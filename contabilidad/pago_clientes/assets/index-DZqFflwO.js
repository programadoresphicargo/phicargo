var __defProp = Object.defineProperty;
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg2) => member.has(obj) || __typeError("Cannot " + msg2);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _i, _client2, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _j;
function _mergeNamespaces(n2, m4) {
  for (var i2 = 0; i2 < m4.length; i2++) {
    const e3 = m4[i2];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k3 in e3) {
        if (k3 !== "default" && !(k3 in n2)) {
          const d4 = Object.getOwnPropertyDescriptor(e3, k3);
          if (d4) {
            Object.defineProperty(n2, k3, d4.get ? d4 : {
              enumerable: true,
              get: () => e3[k3]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a3 = function a4() {
      if (this instanceof a4) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a3.prototype = f2.prototype;
  } else a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k3) {
    var d4 = Object.getOwnPropertyDescriptor(n2, k3);
    Object.defineProperty(a3, k3, d4.get ? d4 : {
      enumerable: true,
      get: function() {
        return n2[k3];
      }
    });
  });
  return a3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a3) {
  if (null === a3 || "object" !== typeof a3) return null;
  a3 = z$2 && a3[z$2] || a3["@@iterator"];
  return "function" === typeof a3 ? a3 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a3, b3, e3) {
  this.props = a3;
  this.context = b3;
  this.refs = D$1;
  this.updater = e3 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a3, b3) {
  if ("object" !== typeof a3 && "function" !== typeof a3 && null != a3) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a3, b3, "setState");
};
E$1.prototype.forceUpdate = function(a3) {
  this.updater.enqueueForceUpdate(this, a3, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a3, b3, e3) {
  this.props = a3;
  this.context = b3;
  this.refs = D$1;
  this.updater = e3 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a3, b3, e3) {
  var d4, c3 = {}, k3 = null, h4 = null;
  if (null != b3) for (d4 in void 0 !== b3.ref && (h4 = b3.ref), void 0 !== b3.key && (k3 = "" + b3.key), b3) J.call(b3, d4) && !L$1.hasOwnProperty(d4) && (c3[d4] = b3[d4]);
  var g2 = arguments.length - 2;
  if (1 === g2) c3.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m4 = 0; m4 < g2; m4++) f2[m4] = arguments[m4 + 2];
    c3.children = f2;
  }
  if (a3 && a3.defaultProps) for (d4 in g2 = a3.defaultProps, g2) void 0 === c3[d4] && (c3[d4] = g2[d4]);
  return { $$typeof: l$3, type: a3, key: k3, ref: h4, props: c3, _owner: K$1.current };
}
function N$1(a3, b3) {
  return { $$typeof: l$3, type: a3.type, key: b3, ref: a3.ref, props: a3.props, _owner: a3._owner };
}
function O$1(a3) {
  return "object" === typeof a3 && null !== a3 && a3.$$typeof === l$3;
}
function escape(a3) {
  var b3 = { "=": "=0", ":": "=2" };
  return "$" + a3.replace(/[=:]/g, function(a4) {
    return b3[a4];
  });
}
var P$1 = /\/+/g;
function Q$1(a3, b3) {
  return "object" === typeof a3 && null !== a3 && null != a3.key ? escape("" + a3.key) : b3.toString(36);
}
function R$1(a3, b3, e3, d4, c3) {
  var k3 = typeof a3;
  if ("undefined" === k3 || "boolean" === k3) a3 = null;
  var h4 = false;
  if (null === a3) h4 = true;
  else switch (k3) {
    case "string":
    case "number":
      h4 = true;
      break;
    case "object":
      switch (a3.$$typeof) {
        case l$3:
        case n$3:
          h4 = true;
      }
  }
  if (h4) return h4 = a3, c3 = c3(h4), a3 = "" === d4 ? "." + Q$1(h4, 0) : d4, I$1(c3) ? (e3 = "", null != a3 && (e3 = a3.replace(P$1, "$&/") + "/"), R$1(c3, b3, e3, "", function(a4) {
    return a4;
  })) : null != c3 && (O$1(c3) && (c3 = N$1(c3, e3 + (!c3.key || h4 && h4.key === c3.key ? "" : ("" + c3.key).replace(P$1, "$&/") + "/") + a3)), b3.push(c3)), 1;
  h4 = 0;
  d4 = "" === d4 ? "." : d4 + ":";
  if (I$1(a3)) for (var g2 = 0; g2 < a3.length; g2++) {
    k3 = a3[g2];
    var f2 = d4 + Q$1(k3, g2);
    h4 += R$1(k3, b3, e3, f2, c3);
  }
  else if (f2 = A$2(a3), "function" === typeof f2) for (a3 = f2.call(a3), g2 = 0; !(k3 = a3.next()).done; ) k3 = k3.value, f2 = d4 + Q$1(k3, g2++), h4 += R$1(k3, b3, e3, f2, c3);
  else if ("object" === k3) throw b3 = String(a3), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b3 ? "object with keys {" + Object.keys(a3).join(", ") + "}" : b3) + "). If you meant to render a collection of children, use an array instead.");
  return h4;
}
function S$1(a3, b3, e3) {
  if (null == a3) return a3;
  var d4 = [], c3 = 0;
  R$1(a3, d4, "", "", function(a4) {
    return b3.call(e3, a4, c3++);
  });
  return d4;
}
function T$1(a3) {
  if (-1 === a3._status) {
    var b3 = a3._result;
    b3 = b3();
    b3.then(function(b4) {
      if (0 === a3._status || -1 === a3._status) a3._status = 1, a3._result = b4;
    }, function(b4) {
      if (0 === a3._status || -1 === a3._status) a3._status = 2, a3._result = b4;
    });
    -1 === a3._status && (a3._status = 0, a3._result = b3);
  }
  if (1 === a3._status) return a3._result.default;
  throw a3._result;
}
var U$2 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a3, b3, e3) {
  S$1(a3, function() {
    b3.apply(this, arguments);
  }, e3);
}, count: function(a3) {
  var b3 = 0;
  S$1(a3, function() {
    b3++;
  });
  return b3;
}, toArray: function(a3) {
  return S$1(a3, function(a4) {
    return a4;
  }) || [];
}, only: function(a3) {
  if (!O$1(a3)) throw Error("React.Children.only expected to receive a single React element child.");
  return a3;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a3, b3, e3) {
  if (null === a3 || void 0 === a3) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a3 + ".");
  var d4 = C$1({}, a3.props), c3 = a3.key, k3 = a3.ref, h4 = a3._owner;
  if (null != b3) {
    void 0 !== b3.ref && (k3 = b3.ref, h4 = K$1.current);
    void 0 !== b3.key && (c3 = "" + b3.key);
    if (a3.type && a3.type.defaultProps) var g2 = a3.type.defaultProps;
    for (f2 in b3) J.call(b3, f2) && !L$1.hasOwnProperty(f2) && (d4[f2] = void 0 === b3[f2] && void 0 !== g2 ? g2[f2] : b3[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d4.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m4 = 0; m4 < f2; m4++) g2[m4] = arguments[m4 + 2];
    d4.children = g2;
  }
  return { $$typeof: l$3, type: a3.type, key: c3, ref: k3, props: d4, _owner: h4 };
};
react_production_min.createContext = function(a3) {
  a3 = { $$typeof: u$1, _currentValue: a3, _currentValue2: a3, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a3.Provider = { $$typeof: t$2, _context: a3 };
  return a3.Consumer = a3;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a3) {
  var b3 = M$1.bind(null, a3);
  b3.type = a3;
  return b3;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a3) {
  return { $$typeof: v$4, render: a3 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a3) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a3 }, _init: T$1 };
};
react_production_min.memo = function(a3, b3) {
  return { $$typeof: x$1, type: a3, compare: void 0 === b3 ? null : b3 };
};
react_production_min.startTransition = function(a3) {
  var b3 = V$1.transition;
  V$1.transition = {};
  try {
    a3();
  } finally {
    V$1.transition = b3;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a3, b3) {
  return U$2.current.useCallback(a3, b3);
};
react_production_min.useContext = function(a3) {
  return U$2.current.useContext(a3);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a3) {
  return U$2.current.useDeferredValue(a3);
};
react_production_min.useEffect = function(a3, b3) {
  return U$2.current.useEffect(a3, b3);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a3, b3, e3) {
  return U$2.current.useImperativeHandle(a3, b3, e3);
};
react_production_min.useInsertionEffect = function(a3, b3) {
  return U$2.current.useInsertionEffect(a3, b3);
};
react_production_min.useLayoutEffect = function(a3, b3) {
  return U$2.current.useLayoutEffect(a3, b3);
};
react_production_min.useMemo = function(a3, b3) {
  return U$2.current.useMemo(a3, b3);
};
react_production_min.useReducer = function(a3, b3, e3) {
  return U$2.current.useReducer(a3, b3, e3);
};
react_production_min.useRef = function(a3) {
  return U$2.current.useRef(a3);
};
react_production_min.useState = function(a3) {
  return U$2.current.useState(a3);
};
react_production_min.useSyncExternalStore = function(a3, b3, e3) {
  return U$2.current.useSyncExternalStore(a3, b3, e3);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$2 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$2(c3, a3, g2) {
  var b3, d4 = {}, e3 = null, h4 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a3.key && (e3 = "" + a3.key);
  void 0 !== a3.ref && (h4 = a3.ref);
  for (b3 in a3) m$3.call(a3, b3) && !p$3.hasOwnProperty(b3) && (d4[b3] = a3[b3]);
  if (c3 && c3.defaultProps) for (b3 in a3 = c3.defaultProps, a3) void 0 === d4[b3] && (d4[b3] = a3[b3]);
  return { $$typeof: k$2, type: c3, key: e3, ref: h4, props: d4, _owner: n$2.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$5() {
  return void 0;
}
function functionalUpdate$1(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject$6(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (typeof a3 !== typeof b3) {
    return false;
  }
  if (a3 && b3 && typeof a3 === "object" && typeof b3 === "object") {
    return !Object.keys(b3).some((key) => !partialMatchKey(a3[key], b3[key]));
  }
  return false;
}
function replaceEqualDeep(a3, b3) {
  if (a3 === b3) {
    return a3;
  }
  const array = isPlainArray(a3) && isPlainArray(b3);
  if (array || isPlainObject$6(a3) && isPlainObject$6(b3)) {
    const aItems = array ? a3 : Object.keys(a3);
    const aSize = aItems.length;
    const bItems = array ? b3 : Object.keys(b3);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < bSize; i2++) {
      const key = array ? i2 : bItems[i2];
      if ((!array && aItems.includes(key) || array) && a3[key] === void 0 && b3[key] === void 0) {
        copy2[key] = void 0;
        equalItems++;
      } else {
        copy2[key] = replaceEqualDeep(a3[key], b3[key]);
        if (copy2[key] === a3[key] && a3[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a3 : copy2;
  }
  return b3;
}
function shallowEqualObjects(a3, b3) {
  if (!b3 || Object.keys(a3).length !== Object.keys(b3).length) {
    return false;
  }
  for (const key in a3) {
    if (a3[key] !== b3[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$6(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup, setup);
    (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a2;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();
var OnlineManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a2;
    __privateSet(this, _setup2, setup);
    (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    var _a2;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a2 = config2.abort) == null ? void 0 : _a2.call(config2);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onSuccess) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    var _a2;
    if (!isResolved) {
      isResolved = true;
      (_a2 = config2.onError) == null ? void 0 : _a2.call(config2, value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a2;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a2 = config2.onPause) == null ? void 0 : _a2.call(config2);
    }).then(() => {
      var _a2;
      continueFn = void 0;
      if (!isResolved) {
        (_a2 = config2.onContinue) == null ? void 0 : _a2.call(config2);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a2;
      if (isResolved) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a2 = config2.onFail) == null ? void 0 : _a2.call(config2, failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return promise;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return promise;
    }
  };
}
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb2) => setTimeout(cb2, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn2) => {
      notifyFn = fn2;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn2) => {
      batchNotifyFn = fn2;
    },
    setScheduler: (fn2) => {
      scheduleFn = fn2;
    }
  };
}
var notifyManager = createNotifyManager();
var Removable = (_c = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _c);
var Query = (_d = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _cache, config2.cache);
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a2;
    return (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a2, _b2;
    const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options);
    return promise ? promise.then(noop$5).catch(noop$5) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a2;
    const observer = this.observers.find((x3) => x3.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  onOnline() {
    var _a2;
    const observer = this.observers.find((x3) => x3.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x3) => x3 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a2, _b2, _c2;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x3) => x3.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context.fetchOptions) == null ? void 0 : _b2.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context.fetchOptions) == null ? void 0 : _c2.meta });
    }
    const onError = (error) => {
      var _a3, _b3, _c3, _d2;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
          _a3,
          error,
          this
        );
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          this.state.data,
          error,
          this
        );
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a3, _b3, _c3, _d2;
        if (data === void 0) {
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data, this);
        (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
          _c3,
          data,
          this.state.error,
          this
        );
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer3 = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer3(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _d);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryCache = (_e = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _e);
var Mutation = (_f = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x3) => x3 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a2;
    return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t2;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
          _a2,
          variables,
          this
        ));
        const context = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
        _e2,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
      await ((_j2 = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j2.call(
        _i2,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l = (_k = this.options).onSettled) == null ? void 0 : _l.call(_k, data, null, variables, this.state.context));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t2 = (_s = this.options).onSettled) == null ? void 0 : _t2.call(
          _s,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer3 = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer3(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _mutationId);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a2;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a2 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a2.filter((x3) => x3 !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a2;
    const firstPendingMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m4) => m4.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a2;
    const foundMutation = (_a2 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a2.find((m4) => m4 !== mutation && m4.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x3) => x3.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$5))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  var _a2;
  return ((_a2 = mutation.options.scope) == null ? void 0 : _a2.id) ?? String(mutation.mutationId);
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const fetchFn = async () => {
        var _a2, _b2, _c2, _d2, _e2;
        const options = context.options;
        const direction = (_c2 = (_b2 = (_a2 = context.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
        const oldPages = ((_d2 = context.state.data) == null ? void 0 : _d2.pages) || [];
        const oldPageParams = ((_e2 = context.state.data) == null ? void 0 : _e2.pageParams) || [];
        const empty2 = { pages: [], pageParams: [] };
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        let result;
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          result = await fetchPage(
            empty2,
            oldPageParams[0] ?? options.initialPageParam
          );
          const remainingPages = pages ?? oldPages.length;
          for (let i2 = 1; i2 < remainingPages; i2++) {
            const param = getNextPageParam(options, result);
            if (param == null) {
              break;
            }
            result = await fetchPage(result, param);
          }
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a2, _b2;
          return (_b2 = (_a2 = context.options).persister) == null ? void 0 : _b2.call(
            _a2,
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a2;
  return pages.length > 0 ? (_a2 = options.getPreviousPageParam) == null ? void 0 : _a2.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
var QueryClient = (_h = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a2, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate$1(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a2;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a2 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a2.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$5).catch(noop$5);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: (options == null ? void 0 : options.cancelRefetch) ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$5);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$5);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$5).catch(noop$5);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$5).catch(noop$5);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
var QueryObserver = (_i = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client, client);
    __privateSet(this, _selectError, null);
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a2;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(newState.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data = newState.data;
    }
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop$5);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time2 = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time2 + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _i);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
var MutationObserver$1 = (_j = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client2, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a2;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a2;
    if (!this.hasListeners()) {
      (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a2;
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a2;
    __privateSet(this, _mutateOptions, options);
    (_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a2;
  const state = ((_a2 = __privateGet(this, _currentMutation)) == null ? void 0 : _a2.state) ?? getDefaultState();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b2 = (_a2 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b2.call(_a2, action.data, variables, context);
        (_d2 = (_c2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d2.call(_c2, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f2 = (_e2 = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f2.call(_e2, action.error, variables, context);
        (_h2 = (_g2 = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h2.call(
          _g2,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _j);
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client = reactExports.useContext(QueryClientContext);
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  reactExports.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client, children });
};
var IsRestoringContext = reactExports.createContext(false);
var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop$4() {
}
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
};
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});
function useBaseQuery(options, Observer, queryClient2) {
  var _a2, _b2, _c2, _d2;
  const client = useQueryClient();
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b2 = (_a2 = client.getDefaultOptions().queries) == null ? void 0 : _a2._experimental_beforeQuery) == null ? void 0 : _b2.call(
    _a2,
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      },
      [observer, isRestoring]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash)
  })) {
    throw result.error;
  }
  (_d2 = (_c2 = client.getDefaultOptions().queries) == null ? void 0 : _c2._experimental_afterQuery) == null ? void 0 : _d2.call(
    _c2,
    defaultedOptions,
    result
  );
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver);
}
function useMutation(options, queryClient2) {
  const client = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$4);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler$1 = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a3, b3) {
    var c3 = a3.length;
    a3.push(b3);
    a: for (; 0 < c3; ) {
      var d4 = c3 - 1 >>> 1, e3 = a3[d4];
      if (0 < g2(e3, b3)) a3[d4] = b3, a3[c3] = e3, c3 = d4;
      else break a;
    }
  }
  function h4(a3) {
    return 0 === a3.length ? null : a3[0];
  }
  function k3(a3) {
    if (0 === a3.length) return null;
    var b3 = a3[0], c3 = a3.pop();
    if (c3 !== b3) {
      a3[0] = c3;
      a: for (var d4 = 0, e3 = a3.length, w3 = e3 >>> 1; d4 < w3; ) {
        var m4 = 2 * (d4 + 1) - 1, C2 = a3[m4], n2 = m4 + 1, x3 = a3[n2];
        if (0 > g2(C2, c3)) n2 < e3 && 0 > g2(x3, C2) ? (a3[d4] = x3, a3[n2] = c3, d4 = n2) : (a3[d4] = C2, a3[m4] = c3, d4 = m4);
        else if (n2 < e3 && 0 > g2(x3, c3)) a3[d4] = x3, a3[n2] = c3, d4 = n2;
        else break a;
      }
    }
    return b3;
  }
  function g2(a3, b3) {
    var c3 = a3.sortIndex - b3.sortIndex;
    return 0 !== c3 ? c3 : a3.id - b3.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q3 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q3;
    };
  }
  var r2 = [], t3 = [], u3 = 1, v2 = null, y4 = 3, z3 = false, A2 = false, B3 = false, D3 = "function" === typeof setTimeout ? setTimeout : null, E3 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G3(a3) {
    for (var b3 = h4(t3); null !== b3; ) {
      if (null === b3.callback) k3(t3);
      else if (b3.startTime <= a3) k3(t3), b3.sortIndex = b3.expirationTime, f2(r2, b3);
      else break;
      b3 = h4(t3);
    }
  }
  function H4(a3) {
    B3 = false;
    G3(a3);
    if (!A2) if (null !== h4(r2)) A2 = true, I3(J2);
    else {
      var b3 = h4(t3);
      null !== b3 && K3(H4, b3.startTime - a3);
    }
  }
  function J2(a3, b3) {
    A2 = false;
    B3 && (B3 = false, E3(L3), L3 = -1);
    z3 = true;
    var c3 = y4;
    try {
      G3(b3);
      for (v2 = h4(r2); null !== v2 && (!(v2.expirationTime > b3) || a3 && !M4()); ) {
        var d4 = v2.callback;
        if ("function" === typeof d4) {
          v2.callback = null;
          y4 = v2.priorityLevel;
          var e3 = d4(v2.expirationTime <= b3);
          b3 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h4(r2) && k3(r2);
          G3(b3);
        } else k3(r2);
        v2 = h4(r2);
      }
      if (null !== v2) var w3 = true;
      else {
        var m4 = h4(t3);
        null !== m4 && K3(H4, m4.startTime - b3);
        w3 = false;
      }
      return w3;
    } finally {
      v2 = null, y4 = c3, z3 = false;
    }
  }
  var N2 = false, O3 = null, L3 = -1, P2 = 5, Q3 = -1;
  function M4() {
    return exports.unstable_now() - Q3 < P2 ? false : true;
  }
  function R3() {
    if (null !== O3) {
      var a3 = exports.unstable_now();
      Q3 = a3;
      var b3 = true;
      try {
        b3 = O3(true, a3);
      } finally {
        b3 ? S4() : (N2 = false, O3 = null);
      }
    } else N2 = false;
  }
  var S4;
  if ("function" === typeof F2) S4 = function() {
    F2(R3);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T3 = new MessageChannel(), U2 = T3.port2;
    T3.port1.onmessage = R3;
    S4 = function() {
      U2.postMessage(null);
    };
  } else S4 = function() {
    D3(R3, 0);
  };
  function I3(a3) {
    O3 = a3;
    N2 || (N2 = true, S4());
  }
  function K3(a3, b3) {
    L3 = D3(function() {
      a3(exports.unstable_now());
    }, b3);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a3) {
    a3.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z3 || (A2 = true, I3(J2));
  };
  exports.unstable_forceFrameRate = function(a3) {
    0 > a3 || 125 < a3 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a3 ? Math.floor(1e3 / a3) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y4;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h4(r2);
  };
  exports.unstable_next = function(a3) {
    switch (y4) {
      case 1:
      case 2:
      case 3:
        var b3 = 3;
        break;
      default:
        b3 = y4;
    }
    var c3 = y4;
    y4 = b3;
    try {
      return a3();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a3, b3) {
    switch (a3) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a3 = 3;
    }
    var c3 = y4;
    y4 = a3;
    try {
      return b3();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_scheduleCallback = function(a3, b3, c3) {
    var d4 = exports.unstable_now();
    "object" === typeof c3 && null !== c3 ? (c3 = c3.delay, c3 = "number" === typeof c3 && 0 < c3 ? d4 + c3 : d4) : c3 = d4;
    switch (a3) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c3 + e3;
    a3 = { id: u3++, callback: b3, priorityLevel: a3, startTime: c3, expirationTime: e3, sortIndex: -1 };
    c3 > d4 ? (a3.sortIndex = c3, f2(t3, a3), null === h4(r2) && a3 === h4(t3) && (B3 ? (E3(L3), L3 = -1) : B3 = true, K3(H4, c3 - d4))) : (a3.sortIndex = e3, f2(r2, a3), A2 || z3 || (A2 = true, I3(J2)));
    return a3;
  };
  exports.unstable_shouldYield = M4;
  exports.unstable_wrapCallback = function(a3) {
    var b3 = y4;
    return function() {
      var c3 = y4;
      y4 = b3;
      try {
        return a3.apply(this, arguments);
      } finally {
        y4 = c3;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler$1.exports = scheduler_production_min;
}
var schedulerExports = scheduler$1.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$2(a3) {
  for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a3, c3 = 1; c3 < arguments.length; c3++) b3 += "&args[]=" + encodeURIComponent(arguments[c3]);
  return "Minified React error #" + a3 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a3, b3) {
  ha(a3, b3);
  ha(a3 + "Capture", b3);
}
function ha(a3, b3) {
  ea[a3] = b3;
  for (a3 = 0; a3 < b3.length; a3++) da.add(b3[a3]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a3) {
  if (ja.call(ma, a3)) return true;
  if (ja.call(la, a3)) return false;
  if (ka.test(a3)) return ma[a3] = true;
  la[a3] = true;
  return false;
}
function pa(a3, b3, c3, d4) {
  if (null !== c3 && 0 === c3.type) return false;
  switch (typeof b3) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d4) return false;
      if (null !== c3) return !c3.acceptsBooleans;
      a3 = a3.toLowerCase().slice(0, 5);
      return "data-" !== a3 && "aria-" !== a3;
    default:
      return false;
  }
}
function qa(a3, b3, c3, d4) {
  if (null === b3 || "undefined" === typeof b3 || pa(a3, b3, c3, d4)) return true;
  if (d4) return false;
  if (null !== c3) switch (c3.type) {
    case 3:
      return !b3;
    case 4:
      return false === b3;
    case 5:
      return isNaN(b3);
    case 6:
      return isNaN(b3) || 1 > b3;
  }
  return false;
}
function v$3(a3, b3, c3, d4, e3, f2, g2) {
  this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
  this.attributeName = d4;
  this.attributeNamespace = e3;
  this.mustUseProperty = c3;
  this.propertyName = a3;
  this.type = b3;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a3) {
  z$1[a3] = new v$3(a3, 0, false, a3, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a3) {
  var b3 = a3[0];
  z$1[b3] = new v$3(b3, 1, false, a3[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 2, false, a3.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 2, false, a3, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a3) {
  z$1[a3] = new v$3(a3, 3, false, a3.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 3, true, a3, null, false, false);
});
["capture", "download"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 4, false, a3, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 6, false, a3, null, false, false);
});
["rowSpan", "start"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 5, false, a3.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a3) {
  return a3[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a3) {
  var b3 = a3.replace(
    ra,
    sa
  );
  z$1[b3] = new v$3(b3, 1, false, a3, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a3) {
  var b3 = a3.replace(ra, sa);
  z$1[b3] = new v$3(b3, 1, false, a3, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a3) {
  var b3 = a3.replace(ra, sa);
  z$1[b3] = new v$3(b3, 1, false, a3, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 1, false, a3.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a3) {
  z$1[a3] = new v$3(a3, 1, false, a3.toLowerCase(), null, true, true);
});
function ta(a3, b3, c3, d4) {
  var e3 = z$1.hasOwnProperty(b3) ? z$1[b3] : null;
  if (null !== e3 ? 0 !== e3.type : d4 || !(2 < b3.length) || "o" !== b3[0] && "O" !== b3[0] || "n" !== b3[1] && "N" !== b3[1]) qa(b3, c3, e3, d4) && (c3 = null), d4 || null === e3 ? oa(b3) && (null === c3 ? a3.removeAttribute(b3) : a3.setAttribute(b3, "" + c3)) : e3.mustUseProperty ? a3[e3.propertyName] = null === c3 ? 3 === e3.type ? false : "" : c3 : (b3 = e3.attributeName, d4 = e3.attributeNamespace, null === c3 ? a3.removeAttribute(b3) : (e3 = e3.type, c3 = 3 === e3 || 4 === e3 && true === c3 ? "" : "" + c3, d4 ? a3.setAttributeNS(d4, b3, c3) : a3.setAttribute(b3, c3)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a3) {
  if (null === a3 || "object" !== typeof a3) return null;
  a3 = Ja && a3[Ja] || a3["@@iterator"];
  return "function" === typeof a3 ? a3 : null;
}
var A$1 = Object.assign, La;
function Ma(a3) {
  if (void 0 === La) try {
    throw Error();
  } catch (c3) {
    var b3 = c3.stack.trim().match(/\n( *(at )?)/);
    La = b3 && b3[1] || "";
  }
  return "\n" + La + a3;
}
var Na = false;
function Oa(a3, b3) {
  if (!a3 || Na) return "";
  Na = true;
  var c3 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b3) if (b3 = function() {
      throw Error();
    }, Object.defineProperty(b3.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b3, []);
      } catch (l2) {
        var d4 = l2;
      }
      Reflect.construct(a3, [], b3);
    } else {
      try {
        b3.call();
      } catch (l2) {
        d4 = l2;
      }
      a3.call(b3.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d4 = l2;
      }
      a3();
    }
  } catch (l2) {
    if (l2 && d4 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d4.stack.split("\n"), g2 = e3.length - 1, h4 = f2.length - 1; 1 <= g2 && 0 <= h4 && e3[g2] !== f2[h4]; ) h4--;
      for (; 1 <= g2 && 0 <= h4; g2--, h4--) if (e3[g2] !== f2[h4]) {
        if (1 !== g2 || 1 !== h4) {
          do
            if (g2--, h4--, 0 > h4 || e3[g2] !== f2[h4]) {
              var k3 = "\n" + e3[g2].replace(" at new ", " at ");
              a3.displayName && k3.includes("<anonymous>") && (k3 = k3.replace("<anonymous>", a3.displayName));
              return k3;
            }
          while (1 <= g2 && 0 <= h4);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c3;
  }
  return (a3 = a3 ? a3.displayName || a3.name : "") ? Ma(a3) : "";
}
function Pa(a3) {
  switch (a3.tag) {
    case 5:
      return Ma(a3.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a3 = Oa(a3.type, false), a3;
    case 11:
      return a3 = Oa(a3.type.render, false), a3;
    case 1:
      return a3 = Oa(a3.type, true), a3;
    default:
      return "";
  }
}
function Qa(a3) {
  if (null == a3) return null;
  if ("function" === typeof a3) return a3.displayName || a3.name || null;
  if ("string" === typeof a3) return a3;
  switch (a3) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a3) switch (a3.$$typeof) {
    case Ca:
      return (a3.displayName || "Context") + ".Consumer";
    case Ba:
      return (a3._context.displayName || "Context") + ".Provider";
    case Da:
      var b3 = a3.render;
      a3 = a3.displayName;
      a3 || (a3 = b3.displayName || b3.name || "", a3 = "" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
      return a3;
    case Ga:
      return b3 = a3.displayName || null, null !== b3 ? b3 : Qa(a3.type) || "Memo";
    case Ha:
      b3 = a3._payload;
      a3 = a3._init;
      try {
        return Qa(a3(b3));
      } catch (c3) {
      }
  }
  return null;
}
function Ra(a3) {
  var b3 = a3.type;
  switch (a3.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b3.displayName || "Context") + ".Consumer";
    case 10:
      return (b3._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a3 = b3.render, a3 = a3.displayName || a3.name || "", b3.displayName || ("" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b3;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b3);
    case 8:
      return b3 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b3) return b3.displayName || b3.name || null;
      if ("string" === typeof b3) return b3;
  }
  return null;
}
function Sa(a3) {
  switch (typeof a3) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a3;
    case "object":
      return a3;
    default:
      return "";
  }
}
function Ta(a3) {
  var b3 = a3.type;
  return (a3 = a3.nodeName) && "input" === a3.toLowerCase() && ("checkbox" === b3 || "radio" === b3);
}
function Ua(a3) {
  var b3 = Ta(a3) ? "checked" : "value", c3 = Object.getOwnPropertyDescriptor(a3.constructor.prototype, b3), d4 = "" + a3[b3];
  if (!a3.hasOwnProperty(b3) && "undefined" !== typeof c3 && "function" === typeof c3.get && "function" === typeof c3.set) {
    var e3 = c3.get, f2 = c3.set;
    Object.defineProperty(a3, b3, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a4) {
      d4 = "" + a4;
      f2.call(this, a4);
    } });
    Object.defineProperty(a3, b3, { enumerable: c3.enumerable });
    return { getValue: function() {
      return d4;
    }, setValue: function(a4) {
      d4 = "" + a4;
    }, stopTracking: function() {
      a3._valueTracker = null;
      delete a3[b3];
    } };
  }
}
function Va(a3) {
  a3._valueTracker || (a3._valueTracker = Ua(a3));
}
function Wa(a3) {
  if (!a3) return false;
  var b3 = a3._valueTracker;
  if (!b3) return true;
  var c3 = b3.getValue();
  var d4 = "";
  a3 && (d4 = Ta(a3) ? a3.checked ? "true" : "false" : a3.value);
  a3 = d4;
  return a3 !== c3 ? (b3.setValue(a3), true) : false;
}
function Xa(a3) {
  a3 = a3 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a3) return null;
  try {
    return a3.activeElement || a3.body;
  } catch (b3) {
    return a3.body;
  }
}
function Ya(a3, b3) {
  var c3 = b3.checked;
  return A$1({}, b3, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c3 ? c3 : a3._wrapperState.initialChecked });
}
function Za(a3, b3) {
  var c3 = null == b3.defaultValue ? "" : b3.defaultValue, d4 = null != b3.checked ? b3.checked : b3.defaultChecked;
  c3 = Sa(null != b3.value ? b3.value : c3);
  a3._wrapperState = { initialChecked: d4, initialValue: c3, controlled: "checkbox" === b3.type || "radio" === b3.type ? null != b3.checked : null != b3.value };
}
function ab(a3, b3) {
  b3 = b3.checked;
  null != b3 && ta(a3, "checked", b3, false);
}
function bb(a3, b3) {
  ab(a3, b3);
  var c3 = Sa(b3.value), d4 = b3.type;
  if (null != c3) if ("number" === d4) {
    if (0 === c3 && "" === a3.value || a3.value != c3) a3.value = "" + c3;
  } else a3.value !== "" + c3 && (a3.value = "" + c3);
  else if ("submit" === d4 || "reset" === d4) {
    a3.removeAttribute("value");
    return;
  }
  b3.hasOwnProperty("value") ? cb(a3, b3.type, c3) : b3.hasOwnProperty("defaultValue") && cb(a3, b3.type, Sa(b3.defaultValue));
  null == b3.checked && null != b3.defaultChecked && (a3.defaultChecked = !!b3.defaultChecked);
}
function db(a3, b3, c3) {
  if (b3.hasOwnProperty("value") || b3.hasOwnProperty("defaultValue")) {
    var d4 = b3.type;
    if (!("submit" !== d4 && "reset" !== d4 || void 0 !== b3.value && null !== b3.value)) return;
    b3 = "" + a3._wrapperState.initialValue;
    c3 || b3 === a3.value || (a3.value = b3);
    a3.defaultValue = b3;
  }
  c3 = a3.name;
  "" !== c3 && (a3.name = "");
  a3.defaultChecked = !!a3._wrapperState.initialChecked;
  "" !== c3 && (a3.name = c3);
}
function cb(a3, b3, c3) {
  if ("number" !== b3 || Xa(a3.ownerDocument) !== a3) null == c3 ? a3.defaultValue = "" + a3._wrapperState.initialValue : a3.defaultValue !== "" + c3 && (a3.defaultValue = "" + c3);
}
var eb = Array.isArray;
function fb(a3, b3, c3, d4) {
  a3 = a3.options;
  if (b3) {
    b3 = {};
    for (var e3 = 0; e3 < c3.length; e3++) b3["$" + c3[e3]] = true;
    for (c3 = 0; c3 < a3.length; c3++) e3 = b3.hasOwnProperty("$" + a3[c3].value), a3[c3].selected !== e3 && (a3[c3].selected = e3), e3 && d4 && (a3[c3].defaultSelected = true);
  } else {
    c3 = "" + Sa(c3);
    b3 = null;
    for (e3 = 0; e3 < a3.length; e3++) {
      if (a3[e3].value === c3) {
        a3[e3].selected = true;
        d4 && (a3[e3].defaultSelected = true);
        return;
      }
      null !== b3 || a3[e3].disabled || (b3 = a3[e3]);
    }
    null !== b3 && (b3.selected = true);
  }
}
function gb(a3, b3) {
  if (null != b3.dangerouslySetInnerHTML) throw Error(p$2(91));
  return A$1({}, b3, { value: void 0, defaultValue: void 0, children: "" + a3._wrapperState.initialValue });
}
function hb(a3, b3) {
  var c3 = b3.value;
  if (null == c3) {
    c3 = b3.children;
    b3 = b3.defaultValue;
    if (null != c3) {
      if (null != b3) throw Error(p$2(92));
      if (eb(c3)) {
        if (1 < c3.length) throw Error(p$2(93));
        c3 = c3[0];
      }
      b3 = c3;
    }
    null == b3 && (b3 = "");
    c3 = b3;
  }
  a3._wrapperState = { initialValue: Sa(c3) };
}
function ib(a3, b3) {
  var c3 = Sa(b3.value), d4 = Sa(b3.defaultValue);
  null != c3 && (c3 = "" + c3, c3 !== a3.value && (a3.value = c3), null == b3.defaultValue && a3.defaultValue !== c3 && (a3.defaultValue = c3));
  null != d4 && (a3.defaultValue = "" + d4);
}
function jb(a3) {
  var b3 = a3.textContent;
  b3 === a3._wrapperState.initialValue && "" !== b3 && null !== b3 && (a3.value = b3);
}
function kb(a3) {
  switch (a3) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a3, b3) {
  return null == a3 || "http://www.w3.org/1999/xhtml" === a3 ? kb(b3) : "http://www.w3.org/2000/svg" === a3 && "foreignObject" === b3 ? "http://www.w3.org/1999/xhtml" : a3;
}
var mb, nb = function(a3) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b3, c3, d4, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a3(b3, c3, d4, e3);
    });
  } : a3;
}(function(a3, b3) {
  if ("http://www.w3.org/2000/svg" !== a3.namespaceURI || "innerHTML" in a3) a3.innerHTML = b3;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b3.valueOf().toString() + "</svg>";
    for (b3 = mb.firstChild; a3.firstChild; ) a3.removeChild(a3.firstChild);
    for (; b3.firstChild; ) a3.appendChild(b3.firstChild);
  }
});
function ob(a3, b3) {
  if (b3) {
    var c3 = a3.firstChild;
    if (c3 && c3 === a3.lastChild && 3 === c3.nodeType) {
      c3.nodeValue = b3;
      return;
    }
  }
  a3.textContent = b3;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a3) {
  qb.forEach(function(b3) {
    b3 = b3 + a3.charAt(0).toUpperCase() + a3.substring(1);
    pb[b3] = pb[a3];
  });
});
function rb(a3, b3, c3) {
  return null == b3 || "boolean" === typeof b3 || "" === b3 ? "" : c3 || "number" !== typeof b3 || 0 === b3 || pb.hasOwnProperty(a3) && pb[a3] ? ("" + b3).trim() : b3 + "px";
}
function sb(a3, b3) {
  a3 = a3.style;
  for (var c3 in b3) if (b3.hasOwnProperty(c3)) {
    var d4 = 0 === c3.indexOf("--"), e3 = rb(c3, b3[c3], d4);
    "float" === c3 && (c3 = "cssFloat");
    d4 ? a3.setProperty(c3, e3) : a3[c3] = e3;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a3, b3) {
  if (b3) {
    if (tb[a3] && (null != b3.children || null != b3.dangerouslySetInnerHTML)) throw Error(p$2(137, a3));
    if (null != b3.dangerouslySetInnerHTML) {
      if (null != b3.children) throw Error(p$2(60));
      if ("object" !== typeof b3.dangerouslySetInnerHTML || !("__html" in b3.dangerouslySetInnerHTML)) throw Error(p$2(61));
    }
    if (null != b3.style && "object" !== typeof b3.style) throw Error(p$2(62));
  }
}
function vb(a3, b3) {
  if (-1 === a3.indexOf("-")) return "string" === typeof b3.is;
  switch (a3) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a3) {
  a3 = a3.target || a3.srcElement || window;
  a3.correspondingUseElement && (a3 = a3.correspondingUseElement);
  return 3 === a3.nodeType ? a3.parentNode : a3;
}
var yb = null, zb = null, Ab = null;
function Bb(a3) {
  if (a3 = Cb(a3)) {
    if ("function" !== typeof yb) throw Error(p$2(280));
    var b3 = a3.stateNode;
    b3 && (b3 = Db(b3), yb(a3.stateNode, a3.type, b3));
  }
}
function Eb(a3) {
  zb ? Ab ? Ab.push(a3) : Ab = [a3] : zb = a3;
}
function Fb() {
  if (zb) {
    var a3 = zb, b3 = Ab;
    Ab = zb = null;
    Bb(a3);
    if (b3) for (a3 = 0; a3 < b3.length; a3++) Bb(b3[a3]);
  }
}
function Gb(a3, b3) {
  return a3(b3);
}
function Hb() {
}
var Ib = false;
function Jb(a3, b3, c3) {
  if (Ib) return a3(b3, c3);
  Ib = true;
  try {
    return Gb(a3, b3, c3);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a3, b3) {
  var c3 = a3.stateNode;
  if (null === c3) return null;
  var d4 = Db(c3);
  if (null === d4) return null;
  c3 = d4[b3];
  a: switch (b3) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d4 = !d4.disabled) || (a3 = a3.type, d4 = !("button" === a3 || "input" === a3 || "select" === a3 || "textarea" === a3));
      a3 = !d4;
      break a;
    default:
      a3 = false;
  }
  if (a3) return null;
  if (c3 && "function" !== typeof c3) throw Error(p$2(231, b3, typeof c3));
  return c3;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a3) {
  Lb = false;
}
function Nb(a3, b3, c3, d4, e3, f2, g2, h4, k3) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b3.apply(c3, l2);
  } catch (m4) {
    this.onError(m4);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a3) {
  Ob = true;
  Pb = a3;
} };
function Tb(a3, b3, c3, d4, e3, f2, g2, h4, k3) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a3, b3, c3, d4, e3, f2, g2, h4, k3) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$2(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a3) {
  var b3 = a3, c3 = a3;
  if (a3.alternate) for (; b3.return; ) b3 = b3.return;
  else {
    a3 = b3;
    do
      b3 = a3, 0 !== (b3.flags & 4098) && (c3 = b3.return), a3 = b3.return;
    while (a3);
  }
  return 3 === b3.tag ? c3 : null;
}
function Wb(a3) {
  if (13 === a3.tag) {
    var b3 = a3.memoizedState;
    null === b3 && (a3 = a3.alternate, null !== a3 && (b3 = a3.memoizedState));
    if (null !== b3) return b3.dehydrated;
  }
  return null;
}
function Xb(a3) {
  if (Vb(a3) !== a3) throw Error(p$2(188));
}
function Yb(a3) {
  var b3 = a3.alternate;
  if (!b3) {
    b3 = Vb(a3);
    if (null === b3) throw Error(p$2(188));
    return b3 !== a3 ? null : a3;
  }
  for (var c3 = a3, d4 = b3; ; ) {
    var e3 = c3.return;
    if (null === e3) break;
    var f2 = e3.alternate;
    if (null === f2) {
      d4 = e3.return;
      if (null !== d4) {
        c3 = d4;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c3) return Xb(e3), a3;
        if (f2 === d4) return Xb(e3), b3;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c3.return !== d4.return) c3 = e3, d4 = f2;
    else {
      for (var g2 = false, h4 = e3.child; h4; ) {
        if (h4 === c3) {
          g2 = true;
          c3 = e3;
          d4 = f2;
          break;
        }
        if (h4 === d4) {
          g2 = true;
          d4 = e3;
          c3 = f2;
          break;
        }
        h4 = h4.sibling;
      }
      if (!g2) {
        for (h4 = f2.child; h4; ) {
          if (h4 === c3) {
            g2 = true;
            c3 = f2;
            d4 = e3;
            break;
          }
          if (h4 === d4) {
            g2 = true;
            d4 = f2;
            c3 = e3;
            break;
          }
          h4 = h4.sibling;
        }
        if (!g2) throw Error(p$2(189));
      }
    }
    if (c3.alternate !== d4) throw Error(p$2(190));
  }
  if (3 !== c3.tag) throw Error(p$2(188));
  return c3.stateNode.current === c3 ? a3 : b3;
}
function Zb(a3) {
  a3 = Yb(a3);
  return null !== a3 ? $b(a3) : null;
}
function $b(a3) {
  if (5 === a3.tag || 6 === a3.tag) return a3;
  for (a3 = a3.child; null !== a3; ) {
    var b3 = $b(a3);
    if (null !== b3) return b3;
    a3 = a3.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a3) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a3, void 0, 128 === (a3.current.flags & 128));
  } catch (b3) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a3) {
  a3 >>>= 0;
  return 0 === a3 ? 32 : 31 - (pc(a3) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a3) {
  switch (a3 & -a3) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a3 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a3 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a3;
  }
}
function uc(a3, b3) {
  var c3 = a3.pendingLanes;
  if (0 === c3) return 0;
  var d4 = 0, e3 = a3.suspendedLanes, f2 = a3.pingedLanes, g2 = c3 & 268435455;
  if (0 !== g2) {
    var h4 = g2 & ~e3;
    0 !== h4 ? d4 = tc(h4) : (f2 &= g2, 0 !== f2 && (d4 = tc(f2)));
  } else g2 = c3 & ~e3, 0 !== g2 ? d4 = tc(g2) : 0 !== f2 && (d4 = tc(f2));
  if (0 === d4) return 0;
  if (0 !== b3 && b3 !== d4 && 0 === (b3 & e3) && (e3 = d4 & -d4, f2 = b3 & -b3, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240))) return b3;
  0 !== (d4 & 4) && (d4 |= c3 & 16);
  b3 = a3.entangledLanes;
  if (0 !== b3) for (a3 = a3.entanglements, b3 &= d4; 0 < b3; ) c3 = 31 - oc(b3), e3 = 1 << c3, d4 |= a3[c3], b3 &= ~e3;
  return d4;
}
function vc(a3, b3) {
  switch (a3) {
    case 1:
    case 2:
    case 4:
      return b3 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b3 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a3, b3) {
  for (var c3 = a3.suspendedLanes, d4 = a3.pingedLanes, e3 = a3.expirationTimes, f2 = a3.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h4 = 1 << g2, k3 = e3[g2];
    if (-1 === k3) {
      if (0 === (h4 & c3) || 0 !== (h4 & d4)) e3[g2] = vc(h4, b3);
    } else k3 <= b3 && (a3.expiredLanes |= h4);
    f2 &= ~h4;
  }
}
function xc(a3) {
  a3 = a3.pendingLanes & -1073741825;
  return 0 !== a3 ? a3 : a3 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a3 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a3;
}
function zc(a3) {
  for (var b3 = [], c3 = 0; 31 > c3; c3++) b3.push(a3);
  return b3;
}
function Ac(a3, b3, c3) {
  a3.pendingLanes |= b3;
  536870912 !== b3 && (a3.suspendedLanes = 0, a3.pingedLanes = 0);
  a3 = a3.eventTimes;
  b3 = 31 - oc(b3);
  a3[b3] = c3;
}
function Bc(a3, b3) {
  var c3 = a3.pendingLanes & ~b3;
  a3.pendingLanes = b3;
  a3.suspendedLanes = 0;
  a3.pingedLanes = 0;
  a3.expiredLanes &= b3;
  a3.mutableReadLanes &= b3;
  a3.entangledLanes &= b3;
  b3 = a3.entanglements;
  var d4 = a3.eventTimes;
  for (a3 = a3.expirationTimes; 0 < c3; ) {
    var e3 = 31 - oc(c3), f2 = 1 << e3;
    b3[e3] = 0;
    d4[e3] = -1;
    a3[e3] = -1;
    c3 &= ~f2;
  }
}
function Cc(a3, b3) {
  var c3 = a3.entangledLanes |= b3;
  for (a3 = a3.entanglements; c3; ) {
    var d4 = 31 - oc(c3), e3 = 1 << d4;
    e3 & b3 | a3[d4] & b3 && (a3[d4] |= b3);
    c3 &= ~e3;
  }
}
var C = 0;
function Dc(a3) {
  a3 &= -a3;
  return 1 < a3 ? 4 < a3 ? 0 !== (a3 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a3, b3) {
  switch (a3) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b3.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b3.pointerId);
  }
}
function Tc(a3, b3, c3, d4, e3, f2) {
  if (null === a3 || a3.nativeEvent !== f2) return a3 = { blockedOn: b3, domEventName: c3, eventSystemFlags: d4, nativeEvent: f2, targetContainers: [e3] }, null !== b3 && (b3 = Cb(b3), null !== b3 && Fc(b3)), a3;
  a3.eventSystemFlags |= d4;
  b3 = a3.targetContainers;
  null !== e3 && -1 === b3.indexOf(e3) && b3.push(e3);
  return a3;
}
function Uc(a3, b3, c3, d4, e3) {
  switch (b3) {
    case "focusin":
      return Lc = Tc(Lc, a3, b3, c3, d4, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a3, b3, c3, d4, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a3, b3, c3, d4, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a3, b3, c3, d4, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a3, b3, c3, d4, e3)), true;
  }
  return false;
}
function Vc(a3) {
  var b3 = Wc(a3.target);
  if (null !== b3) {
    var c3 = Vb(b3);
    if (null !== c3) {
      if (b3 = c3.tag, 13 === b3) {
        if (b3 = Wb(c3), null !== b3) {
          a3.blockedOn = b3;
          Ic(a3.priority, function() {
            Gc(c3);
          });
          return;
        }
      } else if (3 === b3 && c3.stateNode.current.memoizedState.isDehydrated) {
        a3.blockedOn = 3 === c3.tag ? c3.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a3.blockedOn = null;
}
function Xc(a3) {
  if (null !== a3.blockedOn) return false;
  for (var b3 = a3.targetContainers; 0 < b3.length; ) {
    var c3 = Yc(a3.domEventName, a3.eventSystemFlags, b3[0], a3.nativeEvent);
    if (null === c3) {
      c3 = a3.nativeEvent;
      var d4 = new c3.constructor(c3.type, c3);
      wb = d4;
      c3.target.dispatchEvent(d4);
      wb = null;
    } else return b3 = Cb(c3), null !== b3 && Fc(b3), a3.blockedOn = c3, false;
    b3.shift();
  }
  return true;
}
function Zc(a3, b3, c3) {
  Xc(a3) && c3.delete(b3);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a3, b3) {
  a3.blockedOn === b3 && (a3.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a3) {
  function b3(b4) {
    return ad(b4, a3);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a3);
    for (var c3 = 1; c3 < Kc.length; c3++) {
      var d4 = Kc[c3];
      d4.blockedOn === a3 && (d4.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a3);
  null !== Mc && ad(Mc, a3);
  null !== Nc && ad(Nc, a3);
  Oc.forEach(b3);
  Pc.forEach(b3);
  for (c3 = 0; c3 < Qc.length; c3++) d4 = Qc[c3], d4.blockedOn === a3 && (d4.blockedOn = null);
  for (; 0 < Qc.length && (c3 = Qc[0], null === c3.blockedOn); ) Vc(c3), null === c3.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a3, b3, c3, d4) {
  var e3 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a3, b3, c3, d4);
  } finally {
    C = e3, cd.transition = f2;
  }
}
function gd(a3, b3, c3, d4) {
  var e3 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a3, b3, c3, d4);
  } finally {
    C = e3, cd.transition = f2;
  }
}
function fd(a3, b3, c3, d4) {
  if (dd) {
    var e3 = Yc(a3, b3, c3, d4);
    if (null === e3) hd(a3, b3, d4, id, c3), Sc(a3, d4);
    else if (Uc(e3, a3, b3, c3, d4)) d4.stopPropagation();
    else if (Sc(a3, d4), b3 & 4 && -1 < Rc.indexOf(a3)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a3, b3, c3, d4);
        null === f2 && hd(a3, b3, d4, id, c3);
        if (f2 === e3) break;
        e3 = f2;
      }
      null !== e3 && d4.stopPropagation();
    } else hd(a3, b3, d4, null, c3);
  }
}
var id = null;
function Yc(a3, b3, c3, d4) {
  id = null;
  a3 = xb(d4);
  a3 = Wc(a3);
  if (null !== a3) if (b3 = Vb(a3), null === b3) a3 = null;
  else if (c3 = b3.tag, 13 === c3) {
    a3 = Wb(b3);
    if (null !== a3) return a3;
    a3 = null;
  } else if (3 === c3) {
    if (b3.stateNode.current.memoizedState.isDehydrated) return 3 === b3.tag ? b3.stateNode.containerInfo : null;
    a3 = null;
  } else b3 !== a3 && (a3 = null);
  id = a3;
  return null;
}
function jd(a3) {
  switch (a3) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a3, b3 = ld, c3 = b3.length, d4, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a3 = 0; a3 < c3 && b3[a3] === e3[a3]; a3++) ;
  var g2 = c3 - a3;
  for (d4 = 1; d4 <= g2 && b3[c3 - d4] === e3[f2 - d4]; d4++) ;
  return md = e3.slice(a3, 1 < d4 ? 1 - d4 : void 0);
}
function od(a3) {
  var b3 = a3.keyCode;
  "charCode" in a3 ? (a3 = a3.charCode, 0 === a3 && 13 === b3 && (a3 = 13)) : a3 = b3;
  10 === a3 && (a3 = 13);
  return 32 <= a3 || 13 === a3 ? a3 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a3) {
  function b3(b4, d4, e3, f2, g2) {
    this._reactName = b4;
    this._targetInst = e3;
    this.type = d4;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c3 in a3) a3.hasOwnProperty(c3) && (b4 = a3[c3], this[c3] = b4 ? b4(f2) : f2[c3]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b3.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a4 = this.nativeEvent;
    a4 && (a4.preventDefault ? a4.preventDefault() : "unknown" !== typeof a4.returnValue && (a4.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a4 = this.nativeEvent;
    a4 && (a4.stopPropagation ? a4.stopPropagation() : "unknown" !== typeof a4.cancelBubble && (a4.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b3;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a3) {
  return a3.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a3) {
  return void 0 === a3.relatedTarget ? a3.fromElement === a3.srcElement ? a3.toElement : a3.fromElement : a3.relatedTarget;
}, movementX: function(a3) {
  if ("movementX" in a3) return a3.movementX;
  a3 !== yd && (yd && "mousemove" === a3.type ? (wd = a3.screenX - yd.screenX, xd = a3.screenY - yd.screenY) : xd = wd = 0, yd = a3);
  return wd;
}, movementY: function(a3) {
  return "movementY" in a3 ? a3.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a3) {
  return "clipboardData" in a3 ? a3.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a3) {
  var b3 = this.nativeEvent;
  return b3.getModifierState ? b3.getModifierState(a3) : (a3 = Od[a3]) ? !!b3[a3] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a3) {
  if (a3.key) {
    var b3 = Md[a3.key] || a3.key;
    if ("Unidentified" !== b3) return b3;
  }
  return "keypress" === a3.type ? (a3 = od(a3), 13 === a3 ? "Enter" : String.fromCharCode(a3)) : "keydown" === a3.type || "keyup" === a3.type ? Nd[a3.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a3) {
  return "keypress" === a3.type ? od(a3) : 0;
}, keyCode: function(a3) {
  return "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
}, which: function(a3) {
  return "keypress" === a3.type ? od(a3) : "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a3) {
    return "deltaX" in a3 ? a3.deltaX : "wheelDeltaX" in a3 ? -a3.wheelDeltaX : 0;
  },
  deltaY: function(a3) {
    return "deltaY" in a3 ? a3.deltaY : "wheelDeltaY" in a3 ? -a3.wheelDeltaY : "wheelDelta" in a3 ? -a3.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae$1 || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe = false;
function ge(a3, b3) {
  switch (a3) {
    case "keyup":
      return -1 !== $d.indexOf(b3.keyCode);
    case "keydown":
      return 229 !== b3.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a3) {
  a3 = a3.detail;
  return "object" === typeof a3 && "data" in a3 ? a3.data : null;
}
var ie = false;
function je(a3, b3) {
  switch (a3) {
    case "compositionend":
      return he(b3);
    case "keypress":
      if (32 !== b3.which) return null;
      fe = true;
      return ee$1;
    case "textInput":
      return a3 = b3.data, a3 === ee$1 && fe ? null : a3;
    default:
      return null;
  }
}
function ke(a3, b3) {
  if (ie) return "compositionend" === a3 || !ae$1 && ge(a3, b3) ? (a3 = nd(), md = ld = kd = null, ie = false, a3) : null;
  switch (a3) {
    case "paste":
      return null;
    case "keypress":
      if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || b3.ctrlKey && b3.altKey) {
        if (b3.char && 1 < b3.char.length) return b3.char;
        if (b3.which) return String.fromCharCode(b3.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b3.locale ? null : b3.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a3) {
  var b3 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
  return "input" === b3 ? !!le[a3.type] : "textarea" === b3 ? true : false;
}
function ne$1(a3, b3, c3, d4) {
  Eb(d4);
  b3 = oe$1(b3, "onChange");
  0 < b3.length && (c3 = new td("onChange", "change", null, c3, d4), a3.push({ event: c3, listeners: b3 }));
}
var pe = null, qe = null;
function re(a3) {
  se$1(a3, 0);
}
function te$1(a3) {
  var b3 = ue(a3);
  if (Wa(b3)) return a3;
}
function ve(a3, b3) {
  if ("change" === a3) return b3;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a3) {
  if ("value" === a3.propertyName && te$1(qe)) {
    var b3 = [];
    ne$1(b3, qe, a3, xb(a3));
    Jb(re, b3);
  }
}
function Ce(a3, b3, c3) {
  "focusin" === a3 ? (Ae(), pe = b3, qe = c3, pe.attachEvent("onpropertychange", Be)) : "focusout" === a3 && Ae();
}
function De(a3) {
  if ("selectionchange" === a3 || "keyup" === a3 || "keydown" === a3) return te$1(qe);
}
function Ee(a3, b3) {
  if ("click" === a3) return te$1(b3);
}
function Fe(a3, b3) {
  if ("input" === a3 || "change" === a3) return te$1(b3);
}
function Ge(a3, b3) {
  return a3 === b3 && (0 !== a3 || 1 / a3 === 1 / b3) || a3 !== a3 && b3 !== b3;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a3, b3) {
  if (He(a3, b3)) return true;
  if ("object" !== typeof a3 || null === a3 || "object" !== typeof b3 || null === b3) return false;
  var c3 = Object.keys(a3), d4 = Object.keys(b3);
  if (c3.length !== d4.length) return false;
  for (d4 = 0; d4 < c3.length; d4++) {
    var e3 = c3[d4];
    if (!ja.call(b3, e3) || !He(a3[e3], b3[e3])) return false;
  }
  return true;
}
function Je(a3) {
  for (; a3 && a3.firstChild; ) a3 = a3.firstChild;
  return a3;
}
function Ke(a3, b3) {
  var c3 = Je(a3);
  a3 = 0;
  for (var d4; c3; ) {
    if (3 === c3.nodeType) {
      d4 = a3 + c3.textContent.length;
      if (a3 <= b3 && d4 >= b3) return { node: c3, offset: b3 - a3 };
      a3 = d4;
    }
    a: {
      for (; c3; ) {
        if (c3.nextSibling) {
          c3 = c3.nextSibling;
          break a;
        }
        c3 = c3.parentNode;
      }
      c3 = void 0;
    }
    c3 = Je(c3);
  }
}
function Le(a3, b3) {
  return a3 && b3 ? a3 === b3 ? true : a3 && 3 === a3.nodeType ? false : b3 && 3 === b3.nodeType ? Le(a3, b3.parentNode) : "contains" in a3 ? a3.contains(b3) : a3.compareDocumentPosition ? !!(a3.compareDocumentPosition(b3) & 16) : false : false;
}
function Me() {
  for (var a3 = window, b3 = Xa(); b3 instanceof a3.HTMLIFrameElement; ) {
    try {
      var c3 = "string" === typeof b3.contentWindow.location.href;
    } catch (d4) {
      c3 = false;
    }
    if (c3) a3 = b3.contentWindow;
    else break;
    b3 = Xa(a3.document);
  }
  return b3;
}
function Ne(a3) {
  var b3 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
  return b3 && ("input" === b3 && ("text" === a3.type || "search" === a3.type || "tel" === a3.type || "url" === a3.type || "password" === a3.type) || "textarea" === b3 || "true" === a3.contentEditable);
}
function Oe(a3) {
  var b3 = Me(), c3 = a3.focusedElem, d4 = a3.selectionRange;
  if (b3 !== c3 && c3 && c3.ownerDocument && Le(c3.ownerDocument.documentElement, c3)) {
    if (null !== d4 && Ne(c3)) {
      if (b3 = d4.start, a3 = d4.end, void 0 === a3 && (a3 = b3), "selectionStart" in c3) c3.selectionStart = b3, c3.selectionEnd = Math.min(a3, c3.value.length);
      else if (a3 = (b3 = c3.ownerDocument || document) && b3.defaultView || window, a3.getSelection) {
        a3 = a3.getSelection();
        var e3 = c3.textContent.length, f2 = Math.min(d4.start, e3);
        d4 = void 0 === d4.end ? f2 : Math.min(d4.end, e3);
        !a3.extend && f2 > d4 && (e3 = d4, d4 = f2, f2 = e3);
        e3 = Ke(c3, f2);
        var g2 = Ke(
          c3,
          d4
        );
        e3 && g2 && (1 !== a3.rangeCount || a3.anchorNode !== e3.node || a3.anchorOffset !== e3.offset || a3.focusNode !== g2.node || a3.focusOffset !== g2.offset) && (b3 = b3.createRange(), b3.setStart(e3.node, e3.offset), a3.removeAllRanges(), f2 > d4 ? (a3.addRange(b3), a3.extend(g2.node, g2.offset)) : (b3.setEnd(g2.node, g2.offset), a3.addRange(b3)));
      }
    }
    b3 = [];
    for (a3 = c3; a3 = a3.parentNode; ) 1 === a3.nodeType && b3.push({ element: a3, left: a3.scrollLeft, top: a3.scrollTop });
    "function" === typeof c3.focus && c3.focus();
    for (c3 = 0; c3 < b3.length; c3++) a3 = b3[c3], a3.element.scrollLeft = a3.left, a3.element.scrollTop = a3.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te$1 = false;
function Ue(a3, b3, c3) {
  var d4 = c3.window === c3 ? c3.document : 9 === c3.nodeType ? c3 : c3.ownerDocument;
  Te$1 || null == Qe || Qe !== Xa(d4) || (d4 = Qe, "selectionStart" in d4 && Ne(d4) ? d4 = { start: d4.selectionStart, end: d4.selectionEnd } : (d4 = (d4.ownerDocument && d4.ownerDocument.defaultView || window).getSelection(), d4 = { anchorNode: d4.anchorNode, anchorOffset: d4.anchorOffset, focusNode: d4.focusNode, focusOffset: d4.focusOffset }), Se && Ie(Se, d4) || (Se = d4, d4 = oe$1(Re, "onSelect"), 0 < d4.length && (b3 = new td("onSelect", "select", null, b3, c3), a3.push({ event: b3, listeners: d4 }), b3.target = Qe)));
}
function Ve(a3, b3) {
  var c3 = {};
  c3[a3.toLowerCase()] = b3.toLowerCase();
  c3["Webkit" + a3] = "webkit" + b3;
  c3["Moz" + a3] = "moz" + b3;
  return c3;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a3) {
  if (Xe[a3]) return Xe[a3];
  if (!We[a3]) return a3;
  var b3 = We[a3], c3;
  for (c3 in b3) if (b3.hasOwnProperty(c3) && c3 in Ye) return Xe[a3] = b3[c3];
  return a3;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a3, b3) {
  df.set(a3, b3);
  fa(b3, [a3]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a3, b3, c3) {
  var d4 = a3.type || "unknown-event";
  a3.currentTarget = c3;
  Ub(d4, b3, void 0, a3);
  a3.currentTarget = null;
}
function se$1(a3, b3) {
  b3 = 0 !== (b3 & 4);
  for (var c3 = 0; c3 < a3.length; c3++) {
    var d4 = a3[c3], e3 = d4.event;
    d4 = d4.listeners;
    a: {
      var f2 = void 0;
      if (b3) for (var g2 = d4.length - 1; 0 <= g2; g2--) {
        var h4 = d4[g2], k3 = h4.instance, l2 = h4.currentTarget;
        h4 = h4.listener;
        if (k3 !== f2 && e3.isPropagationStopped()) break a;
        nf(e3, h4, l2);
        f2 = k3;
      }
      else for (g2 = 0; g2 < d4.length; g2++) {
        h4 = d4[g2];
        k3 = h4.instance;
        l2 = h4.currentTarget;
        h4 = h4.listener;
        if (k3 !== f2 && e3.isPropagationStopped()) break a;
        nf(e3, h4, l2);
        f2 = k3;
      }
    }
  }
  if (Qb) throw a3 = Rb, Qb = false, Rb = null, a3;
}
function D(a3, b3) {
  var c3 = b3[of];
  void 0 === c3 && (c3 = b3[of] = /* @__PURE__ */ new Set());
  var d4 = a3 + "__bubble";
  c3.has(d4) || (pf(b3, a3, 2, false), c3.add(d4));
}
function qf(a3, b3, c3) {
  var d4 = 0;
  b3 && (d4 |= 4);
  pf(c3, a3, d4, b3);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a3) {
  if (!a3[rf]) {
    a3[rf] = true;
    da.forEach(function(b4) {
      "selectionchange" !== b4 && (mf.has(b4) || qf(b4, false, a3), qf(b4, true, a3));
    });
    var b3 = 9 === a3.nodeType ? a3 : a3.ownerDocument;
    null === b3 || b3[rf] || (b3[rf] = true, qf("selectionchange", false, b3));
  }
}
function pf(a3, b3, c3, d4) {
  switch (jd(b3)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c3 = e3.bind(null, b3, c3, a3);
  e3 = void 0;
  !Lb || "touchstart" !== b3 && "touchmove" !== b3 && "wheel" !== b3 || (e3 = true);
  d4 ? void 0 !== e3 ? a3.addEventListener(b3, c3, { capture: true, passive: e3 }) : a3.addEventListener(b3, c3, true) : void 0 !== e3 ? a3.addEventListener(b3, c3, { passive: e3 }) : a3.addEventListener(b3, c3, false);
}
function hd(a3, b3, c3, d4, e3) {
  var f2 = d4;
  if (0 === (b3 & 1) && 0 === (b3 & 2) && null !== d4) a: for (; ; ) {
    if (null === d4) return;
    var g2 = d4.tag;
    if (3 === g2 || 4 === g2) {
      var h4 = d4.stateNode.containerInfo;
      if (h4 === e3 || 8 === h4.nodeType && h4.parentNode === e3) break;
      if (4 === g2) for (g2 = d4.return; null !== g2; ) {
        var k3 = g2.tag;
        if (3 === k3 || 4 === k3) {
          if (k3 = g2.stateNode.containerInfo, k3 === e3 || 8 === k3.nodeType && k3.parentNode === e3) return;
        }
        g2 = g2.return;
      }
      for (; null !== h4; ) {
        g2 = Wc(h4);
        if (null === g2) return;
        k3 = g2.tag;
        if (5 === k3 || 6 === k3) {
          d4 = f2 = g2;
          continue a;
        }
        h4 = h4.parentNode;
      }
    }
    d4 = d4.return;
  }
  Jb(function() {
    var d5 = f2, e4 = xb(c3), g3 = [];
    a: {
      var h5 = df.get(a3);
      if (void 0 !== h5) {
        var k4 = td, n2 = a3;
        switch (a3) {
          case "keypress":
            if (0 === od(c3)) break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (2 === c3.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k4 = Hd;
            break;
          case cf:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var t3 = 0 !== (b3 & 4), J2 = !t3 && "scroll" === a3, x3 = t3 ? null !== h5 ? h5 + "Capture" : null : h5;
        t3 = [];
        for (var w3 = d5, u3; null !== w3; ) {
          u3 = w3;
          var F2 = u3.stateNode;
          5 === u3.tag && null !== F2 && (u3 = F2, null !== x3 && (F2 = Kb(w3, x3), null != F2 && t3.push(tf(w3, F2, u3))));
          if (J2) break;
          w3 = w3.return;
        }
        0 < t3.length && (h5 = new k4(h5, n2, null, c3, e4), g3.push({ event: h5, listeners: t3 }));
      }
    }
    if (0 === (b3 & 7)) {
      a: {
        h5 = "mouseover" === a3 || "pointerover" === a3;
        k4 = "mouseout" === a3 || "pointerout" === a3;
        if (h5 && c3 !== wb && (n2 = c3.relatedTarget || c3.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k4 || h5) {
          h5 = e4.window === e4 ? e4 : (h5 = e4.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
          if (k4) {
            if (n2 = c3.relatedTarget || c3.toElement, k4 = d5, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k4 = null, n2 = d5;
          if (k4 !== n2) {
            t3 = Bd;
            F2 = "onMouseLeave";
            x3 = "onMouseEnter";
            w3 = "mouse";
            if ("pointerout" === a3 || "pointerover" === a3) t3 = Td, F2 = "onPointerLeave", x3 = "onPointerEnter", w3 = "pointer";
            J2 = null == k4 ? h5 : ue(k4);
            u3 = null == n2 ? h5 : ue(n2);
            h5 = new t3(F2, w3 + "leave", k4, c3, e4);
            h5.target = J2;
            h5.relatedTarget = u3;
            F2 = null;
            Wc(e4) === d5 && (t3 = new t3(x3, w3 + "enter", n2, c3, e4), t3.target = u3, t3.relatedTarget = J2, F2 = t3);
            J2 = F2;
            if (k4 && n2) b: {
              t3 = k4;
              x3 = n2;
              w3 = 0;
              for (u3 = t3; u3; u3 = vf(u3)) w3++;
              u3 = 0;
              for (F2 = x3; F2; F2 = vf(F2)) u3++;
              for (; 0 < w3 - u3; ) t3 = vf(t3), w3--;
              for (; 0 < u3 - w3; ) x3 = vf(x3), u3--;
              for (; w3--; ) {
                if (t3 === x3 || null !== x3 && t3 === x3.alternate) break b;
                t3 = vf(t3);
                x3 = vf(x3);
              }
              t3 = null;
            }
            else t3 = null;
            null !== k4 && wf(g3, h5, k4, t3, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t3, true);
          }
        }
      }
      a: {
        h5 = d5 ? ue(d5) : window;
        k4 = h5.nodeName && h5.nodeName.toLowerCase();
        if ("select" === k4 || "input" === k4 && "file" === h5.type) var na = ve;
        else if (me(h5)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k4 = h5.nodeName) && "input" === k4.toLowerCase() && ("checkbox" === h5.type || "radio" === h5.type) && (na = Ee);
        if (na && (na = na(a3, d5))) {
          ne$1(g3, na, c3, e4);
          break a;
        }
        xa && xa(a3, h5, d5);
        "focusout" === a3 && (xa = h5._wrapperState) && xa.controlled && "number" === h5.type && cb(h5, "number", h5.value);
      }
      xa = d5 ? ue(d5) : window;
      switch (a3) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d5, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue(g3, c3, e4);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c3, e4);
      }
      var $a;
      if (ae$1) b: {
        switch (a3) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a3, c3) && (ba = "onCompositionEnd") : "keydown" === a3 && 229 === c3.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c3.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe$1(d5, ba), 0 < xa.length && (ba = new Ld(ba, a3, null, c3, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c3), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a3, c3) : ke(a3, c3)) d5 = oe$1(d5, "onBeforeInput"), 0 < d5.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c3, e4), g3.push({ event: e4, listeners: d5 }), e4.data = $a);
    }
    se$1(g3, b3);
  });
}
function tf(a3, b3, c3) {
  return { instance: a3, listener: b3, currentTarget: c3 };
}
function oe$1(a3, b3) {
  for (var c3 = b3 + "Capture", d4 = []; null !== a3; ) {
    var e3 = a3, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a3, c3), null != f2 && d4.unshift(tf(a3, f2, e3)), f2 = Kb(a3, b3), null != f2 && d4.push(tf(a3, f2, e3)));
    a3 = a3.return;
  }
  return d4;
}
function vf(a3) {
  if (null === a3) return null;
  do
    a3 = a3.return;
  while (a3 && 5 !== a3.tag);
  return a3 ? a3 : null;
}
function wf(a3, b3, c3, d4, e3) {
  for (var f2 = b3._reactName, g2 = []; null !== c3 && c3 !== d4; ) {
    var h4 = c3, k3 = h4.alternate, l2 = h4.stateNode;
    if (null !== k3 && k3 === d4) break;
    5 === h4.tag && null !== l2 && (h4 = l2, e3 ? (k3 = Kb(c3, f2), null != k3 && g2.unshift(tf(c3, k3, h4))) : e3 || (k3 = Kb(c3, f2), null != k3 && g2.push(tf(c3, k3, h4))));
    c3 = c3.return;
  }
  0 !== g2.length && a3.push({ event: b3, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a3) {
  return ("string" === typeof a3 ? a3 : "" + a3).replace(xf, "\n").replace(yf, "");
}
function Af(a3, b3, c3) {
  b3 = zf(b3);
  if (zf(a3) !== b3 && c3) throw Error(p$2(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a3, b3) {
  return "textarea" === a3 || "noscript" === a3 || "string" === typeof b3.children || "number" === typeof b3.children || "object" === typeof b3.dangerouslySetInnerHTML && null !== b3.dangerouslySetInnerHTML && null != b3.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a3) {
  return Hf.resolve(null).then(a3).catch(If);
} : Ff;
function If(a3) {
  setTimeout(function() {
    throw a3;
  });
}
function Kf(a3, b3) {
  var c3 = b3, d4 = 0;
  do {
    var e3 = c3.nextSibling;
    a3.removeChild(c3);
    if (e3 && 8 === e3.nodeType) if (c3 = e3.data, "/$" === c3) {
      if (0 === d4) {
        a3.removeChild(e3);
        bd(b3);
        return;
      }
      d4--;
    } else "$" !== c3 && "$?" !== c3 && "$!" !== c3 || d4++;
    c3 = e3;
  } while (c3);
  bd(b3);
}
function Lf(a3) {
  for (; null != a3; a3 = a3.nextSibling) {
    var b3 = a3.nodeType;
    if (1 === b3 || 3 === b3) break;
    if (8 === b3) {
      b3 = a3.data;
      if ("$" === b3 || "$!" === b3 || "$?" === b3) break;
      if ("/$" === b3) return null;
    }
  }
  return a3;
}
function Mf(a3) {
  a3 = a3.previousSibling;
  for (var b3 = 0; a3; ) {
    if (8 === a3.nodeType) {
      var c3 = a3.data;
      if ("$" === c3 || "$!" === c3 || "$?" === c3) {
        if (0 === b3) return a3;
        b3--;
      } else "/$" === c3 && b3++;
    }
    a3 = a3.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a3) {
  var b3 = a3[Of];
  if (b3) return b3;
  for (var c3 = a3.parentNode; c3; ) {
    if (b3 = c3[uf] || c3[Of]) {
      c3 = b3.alternate;
      if (null !== b3.child || null !== c3 && null !== c3.child) for (a3 = Mf(a3); null !== a3; ) {
        if (c3 = a3[Of]) return c3;
        a3 = Mf(a3);
      }
      return b3;
    }
    a3 = c3;
    c3 = a3.parentNode;
  }
  return null;
}
function Cb(a3) {
  a3 = a3[Of] || a3[uf];
  return !a3 || 5 !== a3.tag && 6 !== a3.tag && 13 !== a3.tag && 3 !== a3.tag ? null : a3;
}
function ue(a3) {
  if (5 === a3.tag || 6 === a3.tag) return a3.stateNode;
  throw Error(p$2(33));
}
function Db(a3) {
  return a3[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a3) {
  return { current: a3 };
}
function E(a3) {
  0 > Tf || (a3.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a3, b3) {
  Tf++;
  Sf[Tf] = a3.current;
  a3.current = b3;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a3, b3) {
  var c3 = a3.type.contextTypes;
  if (!c3) return Vf;
  var d4 = a3.stateNode;
  if (d4 && d4.__reactInternalMemoizedUnmaskedChildContext === b3) return d4.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c3) e3[f2] = b3[f2];
  d4 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = b3, a3.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a3) {
  a3 = a3.childContextTypes;
  return null !== a3 && void 0 !== a3;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a3, b3, c3) {
  if (H.current !== Vf) throw Error(p$2(168));
  G(H, b3);
  G(Wf, c3);
}
function bg(a3, b3, c3) {
  var d4 = a3.stateNode;
  b3 = b3.childContextTypes;
  if ("function" !== typeof d4.getChildContext) return c3;
  d4 = d4.getChildContext();
  for (var e3 in d4) if (!(e3 in b3)) throw Error(p$2(108, Ra(a3) || "Unknown", e3));
  return A$1({}, c3, d4);
}
function cg(a3) {
  a3 = (a3 = a3.stateNode) && a3.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a3);
  G(Wf, Wf.current);
  return true;
}
function dg(a3, b3, c3) {
  var d4 = a3.stateNode;
  if (!d4) throw Error(p$2(169));
  c3 ? (a3 = bg(a3, b3, Xf), d4.__reactInternalMemoizedMergedChildContext = a3, E(Wf), E(H), G(H, a3)) : E(Wf);
  G(Wf, c3);
}
var eg = null, fg = false, gg = false;
function hg(a3) {
  null === eg ? eg = [a3] : eg.push(a3);
}
function ig(a3) {
  fg = true;
  hg(a3);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a3 = 0, b3 = C;
    try {
      var c3 = eg;
      for (C = 1; a3 < c3.length; a3++) {
        var d4 = c3[a3];
        do
          d4 = d4(true);
        while (null !== d4);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a3 + 1)), ac(fc, jg), e3;
    } finally {
      C = b3, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a3, b3) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a3;
  ng = b3;
}
function ug(a3, b3, c3) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a3;
  var d4 = rg;
  a3 = sg;
  var e3 = 32 - oc(d4) - 1;
  d4 &= ~(1 << e3);
  c3 += 1;
  var f2 = 32 - oc(b3) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d4 & (1 << g2) - 1).toString(32);
    d4 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b3) + e3 | c3 << e3 | d4;
    sg = f2 + a3;
  } else rg = 1 << f2 | c3 << e3 | d4, sg = a3;
}
function vg(a3) {
  null !== a3.return && (tg(a3, 1), ug(a3, 1, 0));
}
function wg(a3) {
  for (; a3 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a3 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a3, b3) {
  var c3 = Bg(5, null, null, 0);
  c3.elementType = "DELETED";
  c3.stateNode = b3;
  c3.return = a3;
  b3 = a3.deletions;
  null === b3 ? (a3.deletions = [c3], a3.flags |= 16) : b3.push(c3);
}
function Cg(a3, b3) {
  switch (a3.tag) {
    case 5:
      var c3 = a3.type;
      b3 = 1 !== b3.nodeType || c3.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3;
      return null !== b3 ? (a3.stateNode = b3, xg = a3, yg = Lf(b3.firstChild), true) : false;
    case 6:
      return b3 = "" === a3.pendingProps || 3 !== b3.nodeType ? null : b3, null !== b3 ? (a3.stateNode = b3, xg = a3, yg = null, true) : false;
    case 13:
      return b3 = 8 !== b3.nodeType ? null : b3, null !== b3 ? (c3 = null !== qg ? { id: rg, overflow: sg } : null, a3.memoizedState = { dehydrated: b3, treeContext: c3, retryLane: 1073741824 }, c3 = Bg(18, null, null, 0), c3.stateNode = b3, c3.return = a3, a3.child = c3, xg = a3, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a3) {
  return 0 !== (a3.mode & 1) && 0 === (a3.flags & 128);
}
function Eg(a3) {
  if (I) {
    var b3 = yg;
    if (b3) {
      var c3 = b3;
      if (!Cg(a3, b3)) {
        if (Dg(a3)) throw Error(p$2(418));
        b3 = Lf(c3.nextSibling);
        var d4 = xg;
        b3 && Cg(a3, b3) ? Ag(d4, c3) : (a3.flags = a3.flags & -4097 | 2, I = false, xg = a3);
      }
    } else {
      if (Dg(a3)) throw Error(p$2(418));
      a3.flags = a3.flags & -4097 | 2;
      I = false;
      xg = a3;
    }
  }
}
function Fg(a3) {
  for (a3 = a3.return; null !== a3 && 5 !== a3.tag && 3 !== a3.tag && 13 !== a3.tag; ) a3 = a3.return;
  xg = a3;
}
function Gg(a3) {
  if (a3 !== xg) return false;
  if (!I) return Fg(a3), I = true, false;
  var b3;
  (b3 = 3 !== a3.tag) && !(b3 = 5 !== a3.tag) && (b3 = a3.type, b3 = "head" !== b3 && "body" !== b3 && !Ef(a3.type, a3.memoizedProps));
  if (b3 && (b3 = yg)) {
    if (Dg(a3)) throw Hg(), Error(p$2(418));
    for (; b3; ) Ag(a3, b3), b3 = Lf(b3.nextSibling);
  }
  Fg(a3);
  if (13 === a3.tag) {
    a3 = a3.memoizedState;
    a3 = null !== a3 ? a3.dehydrated : null;
    if (!a3) throw Error(p$2(317));
    a: {
      a3 = a3.nextSibling;
      for (b3 = 0; a3; ) {
        if (8 === a3.nodeType) {
          var c3 = a3.data;
          if ("/$" === c3) {
            if (0 === b3) {
              yg = Lf(a3.nextSibling);
              break a;
            }
            b3--;
          } else "$" !== c3 && "$!" !== c3 && "$?" !== c3 || b3++;
        }
        a3 = a3.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a3.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a3 = yg; a3; ) a3 = Lf(a3.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a3) {
  null === zg ? zg = [a3] : zg.push(a3);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a3, b3, c3) {
  a3 = c3.ref;
  if (null !== a3 && "function" !== typeof a3 && "object" !== typeof a3) {
    if (c3._owner) {
      c3 = c3._owner;
      if (c3) {
        if (1 !== c3.tag) throw Error(p$2(309));
        var d4 = c3.stateNode;
      }
      if (!d4) throw Error(p$2(147, a3));
      var e3 = d4, f2 = "" + a3;
      if (null !== b3 && null !== b3.ref && "function" === typeof b3.ref && b3.ref._stringRef === f2) return b3.ref;
      b3 = function(a4) {
        var b4 = e3.refs;
        null === a4 ? delete b4[f2] : b4[f2] = a4;
      };
      b3._stringRef = f2;
      return b3;
    }
    if ("string" !== typeof a3) throw Error(p$2(284));
    if (!c3._owner) throw Error(p$2(290, a3));
  }
  return a3;
}
function Mg(a3, b3) {
  a3 = Object.prototype.toString.call(b3);
  throw Error(p$2(31, "[object Object]" === a3 ? "object with keys {" + Object.keys(b3).join(", ") + "}" : a3));
}
function Ng(a3) {
  var b3 = a3._init;
  return b3(a3._payload);
}
function Og(a3) {
  function b3(b4, c4) {
    if (a3) {
      var d5 = b4.deletions;
      null === d5 ? (b4.deletions = [c4], b4.flags |= 16) : d5.push(c4);
    }
  }
  function c3(c4, d5) {
    if (!a3) return null;
    for (; null !== d5; ) b3(c4, d5), d5 = d5.sibling;
    return null;
  }
  function d4(a4, b4) {
    for (a4 = /* @__PURE__ */ new Map(); null !== b4; ) null !== b4.key ? a4.set(b4.key, b4) : a4.set(b4.index, b4), b4 = b4.sibling;
    return a4;
  }
  function e3(a4, b4) {
    a4 = Pg(a4, b4);
    a4.index = 0;
    a4.sibling = null;
    return a4;
  }
  function f2(b4, c4, d5) {
    b4.index = d5;
    if (!a3) return b4.flags |= 1048576, c4;
    d5 = b4.alternate;
    if (null !== d5) return d5 = d5.index, d5 < c4 ? (b4.flags |= 2, c4) : d5;
    b4.flags |= 2;
    return c4;
  }
  function g2(b4) {
    a3 && null === b4.alternate && (b4.flags |= 2);
    return b4;
  }
  function h4(a4, b4, c4, d5) {
    if (null === b4 || 6 !== b4.tag) return b4 = Qg(c4, a4.mode, d5), b4.return = a4, b4;
    b4 = e3(b4, c4);
    b4.return = a4;
    return b4;
  }
  function k3(a4, b4, c4, d5) {
    var f3 = c4.type;
    if (f3 === ya) return m4(a4, b4, c4.props.children, d5, c4.key);
    if (null !== b4 && (b4.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b4.type)) return d5 = e3(b4, c4.props), d5.ref = Lg(a4, b4, c4), d5.return = a4, d5;
    d5 = Rg(c4.type, c4.key, c4.props, null, a4.mode, d5);
    d5.ref = Lg(a4, b4, c4);
    d5.return = a4;
    return d5;
  }
  function l2(a4, b4, c4, d5) {
    if (null === b4 || 4 !== b4.tag || b4.stateNode.containerInfo !== c4.containerInfo || b4.stateNode.implementation !== c4.implementation) return b4 = Sg(c4, a4.mode, d5), b4.return = a4, b4;
    b4 = e3(b4, c4.children || []);
    b4.return = a4;
    return b4;
  }
  function m4(a4, b4, c4, d5, f3) {
    if (null === b4 || 7 !== b4.tag) return b4 = Tg(c4, a4.mode, d5, f3), b4.return = a4, b4;
    b4 = e3(b4, c4);
    b4.return = a4;
    return b4;
  }
  function q3(a4, b4, c4) {
    if ("string" === typeof b4 && "" !== b4 || "number" === typeof b4) return b4 = Qg("" + b4, a4.mode, c4), b4.return = a4, b4;
    if ("object" === typeof b4 && null !== b4) {
      switch (b4.$$typeof) {
        case va:
          return c4 = Rg(b4.type, b4.key, b4.props, null, a4.mode, c4), c4.ref = Lg(a4, null, b4), c4.return = a4, c4;
        case wa:
          return b4 = Sg(b4, a4.mode, c4), b4.return = a4, b4;
        case Ha:
          var d5 = b4._init;
          return q3(a4, d5(b4._payload), c4);
      }
      if (eb(b4) || Ka(b4)) return b4 = Tg(b4, a4.mode, c4, null), b4.return = a4, b4;
      Mg(a4, b4);
    }
    return null;
  }
  function r2(a4, b4, c4, d5) {
    var e4 = null !== b4 ? b4.key : null;
    if ("string" === typeof c4 && "" !== c4 || "number" === typeof c4) return null !== e4 ? null : h4(a4, b4, "" + c4, d5);
    if ("object" === typeof c4 && null !== c4) {
      switch (c4.$$typeof) {
        case va:
          return c4.key === e4 ? k3(a4, b4, c4, d5) : null;
        case wa:
          return c4.key === e4 ? l2(a4, b4, c4, d5) : null;
        case Ha:
          return e4 = c4._init, r2(
            a4,
            b4,
            e4(c4._payload),
            d5
          );
      }
      if (eb(c4) || Ka(c4)) return null !== e4 ? null : m4(a4, b4, c4, d5, null);
      Mg(a4, c4);
    }
    return null;
  }
  function y4(a4, b4, c4, d5, e4) {
    if ("string" === typeof d5 && "" !== d5 || "number" === typeof d5) return a4 = a4.get(c4) || null, h4(b4, a4, "" + d5, e4);
    if ("object" === typeof d5 && null !== d5) {
      switch (d5.$$typeof) {
        case va:
          return a4 = a4.get(null === d5.key ? c4 : d5.key) || null, k3(b4, a4, d5, e4);
        case wa:
          return a4 = a4.get(null === d5.key ? c4 : d5.key) || null, l2(b4, a4, d5, e4);
        case Ha:
          var f3 = d5._init;
          return y4(a4, b4, c4, f3(d5._payload), e4);
      }
      if (eb(d5) || Ka(d5)) return a4 = a4.get(c4) || null, m4(b4, a4, d5, e4, null);
      Mg(b4, d5);
    }
    return null;
  }
  function n2(e4, g3, h5, k4) {
    for (var l3 = null, m5 = null, u3 = g3, w3 = g3 = 0, x3 = null; null !== u3 && w3 < h5.length; w3++) {
      u3.index > w3 ? (x3 = u3, u3 = null) : x3 = u3.sibling;
      var n3 = r2(e4, u3, h5[w3], k4);
      if (null === n3) {
        null === u3 && (u3 = x3);
        break;
      }
      a3 && u3 && null === n3.alternate && b3(e4, u3);
      g3 = f2(n3, g3, w3);
      null === m5 ? l3 = n3 : m5.sibling = n3;
      m5 = n3;
      u3 = x3;
    }
    if (w3 === h5.length) return c3(e4, u3), I && tg(e4, w3), l3;
    if (null === u3) {
      for (; w3 < h5.length; w3++) u3 = q3(e4, h5[w3], k4), null !== u3 && (g3 = f2(u3, g3, w3), null === m5 ? l3 = u3 : m5.sibling = u3, m5 = u3);
      I && tg(e4, w3);
      return l3;
    }
    for (u3 = d4(e4, u3); w3 < h5.length; w3++) x3 = y4(u3, e4, w3, h5[w3], k4), null !== x3 && (a3 && null !== x3.alternate && u3.delete(null === x3.key ? w3 : x3.key), g3 = f2(x3, g3, w3), null === m5 ? l3 = x3 : m5.sibling = x3, m5 = x3);
    a3 && u3.forEach(function(a4) {
      return b3(e4, a4);
    });
    I && tg(e4, w3);
    return l3;
  }
  function t3(e4, g3, h5, k4) {
    var l3 = Ka(h5);
    if ("function" !== typeof l3) throw Error(p$2(150));
    h5 = l3.call(h5);
    if (null == h5) throw Error(p$2(151));
    for (var u3 = l3 = null, m5 = g3, w3 = g3 = 0, x3 = null, n3 = h5.next(); null !== m5 && !n3.done; w3++, n3 = h5.next()) {
      m5.index > w3 ? (x3 = m5, m5 = null) : x3 = m5.sibling;
      var t4 = r2(e4, m5, n3.value, k4);
      if (null === t4) {
        null === m5 && (m5 = x3);
        break;
      }
      a3 && m5 && null === t4.alternate && b3(e4, m5);
      g3 = f2(t4, g3, w3);
      null === u3 ? l3 = t4 : u3.sibling = t4;
      u3 = t4;
      m5 = x3;
    }
    if (n3.done) return c3(
      e4,
      m5
    ), I && tg(e4, w3), l3;
    if (null === m5) {
      for (; !n3.done; w3++, n3 = h5.next()) n3 = q3(e4, n3.value, k4), null !== n3 && (g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
      I && tg(e4, w3);
      return l3;
    }
    for (m5 = d4(e4, m5); !n3.done; w3++, n3 = h5.next()) n3 = y4(m5, e4, w3, n3.value, k4), null !== n3 && (a3 && null !== n3.alternate && m5.delete(null === n3.key ? w3 : n3.key), g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
    a3 && m5.forEach(function(a4) {
      return b3(e4, a4);
    });
    I && tg(e4, w3);
    return l3;
  }
  function J2(a4, d5, f3, h5) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k4 = f3.key, l3 = d5; null !== l3; ) {
              if (l3.key === k4) {
                k4 = f3.type;
                if (k4 === ya) {
                  if (7 === l3.tag) {
                    c3(a4, l3.sibling);
                    d5 = e3(l3, f3.props.children);
                    d5.return = a4;
                    a4 = d5;
                    break a;
                  }
                } else if (l3.elementType === k4 || "object" === typeof k4 && null !== k4 && k4.$$typeof === Ha && Ng(k4) === l3.type) {
                  c3(a4, l3.sibling);
                  d5 = e3(l3, f3.props);
                  d5.ref = Lg(a4, l3, f3);
                  d5.return = a4;
                  a4 = d5;
                  break a;
                }
                c3(a4, l3);
                break;
              } else b3(a4, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d5 = Tg(f3.props.children, a4.mode, h5, f3.key), d5.return = a4, a4 = d5) : (h5 = Rg(f3.type, f3.key, f3.props, null, a4.mode, h5), h5.ref = Lg(a4, d5, f3), h5.return = a4, a4 = h5);
          }
          return g2(a4);
        case wa:
          a: {
            for (l3 = f3.key; null !== d5; ) {
              if (d5.key === l3) if (4 === d5.tag && d5.stateNode.containerInfo === f3.containerInfo && d5.stateNode.implementation === f3.implementation) {
                c3(a4, d5.sibling);
                d5 = e3(d5, f3.children || []);
                d5.return = a4;
                a4 = d5;
                break a;
              } else {
                c3(a4, d5);
                break;
              }
              else b3(a4, d5);
              d5 = d5.sibling;
            }
            d5 = Sg(f3, a4.mode, h5);
            d5.return = a4;
            a4 = d5;
          }
          return g2(a4);
        case Ha:
          return l3 = f3._init, J2(a4, d5, l3(f3._payload), h5);
      }
      if (eb(f3)) return n2(a4, d5, f3, h5);
      if (Ka(f3)) return t3(a4, d5, f3, h5);
      Mg(a4, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d5 && 6 === d5.tag ? (c3(a4, d5.sibling), d5 = e3(d5, f3), d5.return = a4, a4 = d5) : (c3(a4, d5), d5 = Qg(f3, a4.mode, h5), d5.return = a4, a4 = d5), g2(a4)) : c3(a4, d5);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a3) {
  var b3 = Wg.current;
  E(Wg);
  a3._currentValue = b3;
}
function bh(a3, b3, c3) {
  for (; null !== a3; ) {
    var d4 = a3.alternate;
    (a3.childLanes & b3) !== b3 ? (a3.childLanes |= b3, null !== d4 && (d4.childLanes |= b3)) : null !== d4 && (d4.childLanes & b3) !== b3 && (d4.childLanes |= b3);
    if (a3 === c3) break;
    a3 = a3.return;
  }
}
function ch(a3, b3) {
  Xg = a3;
  Zg = Yg = null;
  a3 = a3.dependencies;
  null !== a3 && null !== a3.firstContext && (0 !== (a3.lanes & b3) && (dh = true), a3.firstContext = null);
}
function eh(a3) {
  var b3 = a3._currentValue;
  if (Zg !== a3) if (a3 = { context: a3, memoizedValue: b3, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$2(308));
    Yg = a3;
    Xg.dependencies = { lanes: 0, firstContext: a3 };
  } else Yg = Yg.next = a3;
  return b3;
}
var fh = null;
function gh(a3) {
  null === fh ? fh = [a3] : fh.push(a3);
}
function hh(a3, b3, c3, d4) {
  var e3 = b3.interleaved;
  null === e3 ? (c3.next = c3, gh(b3)) : (c3.next = e3.next, e3.next = c3);
  b3.interleaved = c3;
  return ih(a3, d4);
}
function ih(a3, b3) {
  a3.lanes |= b3;
  var c3 = a3.alternate;
  null !== c3 && (c3.lanes |= b3);
  c3 = a3;
  for (a3 = a3.return; null !== a3; ) a3.childLanes |= b3, c3 = a3.alternate, null !== c3 && (c3.childLanes |= b3), c3 = a3, a3 = a3.return;
  return 3 === c3.tag ? c3.stateNode : null;
}
var jh = false;
function kh(a3) {
  a3.updateQueue = { baseState: a3.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a3, b3) {
  a3 = a3.updateQueue;
  b3.updateQueue === a3 && (b3.updateQueue = { baseState: a3.baseState, firstBaseUpdate: a3.firstBaseUpdate, lastBaseUpdate: a3.lastBaseUpdate, shared: a3.shared, effects: a3.effects });
}
function mh(a3, b3) {
  return { eventTime: a3, lane: b3, tag: 0, payload: null, callback: null, next: null };
}
function nh(a3, b3, c3) {
  var d4 = a3.updateQueue;
  if (null === d4) return null;
  d4 = d4.shared;
  if (0 !== (K & 2)) {
    var e3 = d4.pending;
    null === e3 ? b3.next = b3 : (b3.next = e3.next, e3.next = b3);
    d4.pending = b3;
    return ih(a3, c3);
  }
  e3 = d4.interleaved;
  null === e3 ? (b3.next = b3, gh(d4)) : (b3.next = e3.next, e3.next = b3);
  d4.interleaved = b3;
  return ih(a3, c3);
}
function oh(a3, b3, c3) {
  b3 = b3.updateQueue;
  if (null !== b3 && (b3 = b3.shared, 0 !== (c3 & 4194240))) {
    var d4 = b3.lanes;
    d4 &= a3.pendingLanes;
    c3 |= d4;
    b3.lanes = c3;
    Cc(a3, c3);
  }
}
function ph(a3, b3) {
  var c3 = a3.updateQueue, d4 = a3.alternate;
  if (null !== d4 && (d4 = d4.updateQueue, c3 === d4)) {
    var e3 = null, f2 = null;
    c3 = c3.firstBaseUpdate;
    if (null !== c3) {
      do {
        var g2 = { eventTime: c3.eventTime, lane: c3.lane, tag: c3.tag, payload: c3.payload, callback: c3.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c3 = c3.next;
      } while (null !== c3);
      null === f2 ? e3 = f2 = b3 : f2 = f2.next = b3;
    } else e3 = f2 = b3;
    c3 = { baseState: d4.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d4.shared, effects: d4.effects };
    a3.updateQueue = c3;
    return;
  }
  a3 = c3.lastBaseUpdate;
  null === a3 ? c3.firstBaseUpdate = b3 : a3.next = b3;
  c3.lastBaseUpdate = b3;
}
function qh(a3, b3, c3, d4) {
  var e3 = a3.updateQueue;
  jh = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h4 = e3.shared.pending;
  if (null !== h4) {
    e3.shared.pending = null;
    var k3 = h4, l2 = k3.next;
    k3.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k3;
    var m4 = a3.alternate;
    null !== m4 && (m4 = m4.updateQueue, h4 = m4.lastBaseUpdate, h4 !== g2 && (null === h4 ? m4.firstBaseUpdate = l2 : h4.next = l2, m4.lastBaseUpdate = k3));
  }
  if (null !== f2) {
    var q3 = e3.baseState;
    g2 = 0;
    m4 = l2 = k3 = null;
    h4 = f2;
    do {
      var r2 = h4.lane, y4 = h4.eventTime;
      if ((d4 & r2) === r2) {
        null !== m4 && (m4 = m4.next = {
          eventTime: y4,
          lane: 0,
          tag: h4.tag,
          payload: h4.payload,
          callback: h4.callback,
          next: null
        });
        a: {
          var n2 = a3, t3 = h4;
          r2 = b3;
          y4 = c3;
          switch (t3.tag) {
            case 1:
              n2 = t3.payload;
              if ("function" === typeof n2) {
                q3 = n2.call(y4, q3, r2);
                break a;
              }
              q3 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t3.payload;
              r2 = "function" === typeof n2 ? n2.call(y4, q3, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q3 = A$1({}, q3, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h4.callback && 0 !== h4.lane && (a3.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h4] : r2.push(h4));
      } else y4 = { eventTime: y4, lane: r2, tag: h4.tag, payload: h4.payload, callback: h4.callback, next: null }, null === m4 ? (l2 = m4 = y4, k3 = q3) : m4 = m4.next = y4, g2 |= r2;
      h4 = h4.next;
      if (null === h4) if (h4 = e3.shared.pending, null === h4) break;
      else r2 = h4, h4 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m4 && (k3 = q3);
    e3.baseState = k3;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m4;
    b3 = e3.shared.interleaved;
    if (null !== b3) {
      e3 = b3;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b3);
    } else null === f2 && (e3.shared.lanes = 0);
    rh |= g2;
    a3.lanes = g2;
    a3.memoizedState = q3;
  }
}
function sh(a3, b3, c3) {
  a3 = b3.effects;
  b3.effects = null;
  if (null !== a3) for (b3 = 0; b3 < a3.length; b3++) {
    var d4 = a3[b3], e3 = d4.callback;
    if (null !== e3) {
      d4.callback = null;
      d4 = c3;
      if ("function" !== typeof e3) throw Error(p$2(191, e3));
      e3.call(d4);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a3) {
  if (a3 === th) throw Error(p$2(174));
  return a3;
}
function yh(a3, b3) {
  G(wh, b3);
  G(vh, a3);
  G(uh, th);
  a3 = b3.nodeType;
  switch (a3) {
    case 9:
    case 11:
      b3 = (b3 = b3.documentElement) ? b3.namespaceURI : lb(null, "");
      break;
    default:
      a3 = 8 === a3 ? b3.parentNode : b3, b3 = a3.namespaceURI || null, a3 = a3.tagName, b3 = lb(b3, a3);
  }
  E(uh);
  G(uh, b3);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a3) {
  xh(wh.current);
  var b3 = xh(uh.current);
  var c3 = lb(b3, a3.type);
  b3 !== c3 && (G(vh, a3), G(uh, c3));
}
function Bh(a3) {
  vh.current === a3 && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a3) {
  for (var b3 = a3; null !== b3; ) {
    if (13 === b3.tag) {
      var c3 = b3.memoizedState;
      if (null !== c3 && (c3 = c3.dehydrated, null === c3 || "$?" === c3.data || "$!" === c3.data)) return b3;
    } else if (19 === b3.tag && void 0 !== b3.memoizedProps.revealOrder) {
      if (0 !== (b3.flags & 128)) return b3;
    } else if (null !== b3.child) {
      b3.child.return = b3;
      b3 = b3.child;
      continue;
    }
    if (b3 === a3) break;
    for (; null === b3.sibling; ) {
      if (null === b3.return || b3.return === a3) return null;
      b3 = b3.return;
    }
    b3.sibling.return = b3.return;
    b3 = b3.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a3 = 0; a3 < Dh.length; a3++) Dh[a3]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p$2(321));
}
function Mh(a3, b3) {
  if (null === b3) return false;
  for (var c3 = 0; c3 < b3.length && c3 < a3.length; c3++) if (!He(a3[c3], b3[c3])) return false;
  return true;
}
function Nh(a3, b3, c3, d4, e3, f2) {
  Hh = f2;
  M = b3;
  b3.memoizedState = null;
  b3.updateQueue = null;
  b3.lanes = 0;
  Fh.current = null === a3 || null === a3.memoizedState ? Oh : Ph;
  a3 = c3(d4, e3);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$2(301));
      f2 += 1;
      O = N = null;
      b3.updateQueue = null;
      Fh.current = Qh;
      a3 = c3(d4, e3);
    } while (Jh);
  }
  Fh.current = Rh;
  b3 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b3) throw Error(p$2(300));
  return a3;
}
function Sh() {
  var a3 = 0 !== Kh;
  Kh = 0;
  return a3;
}
function Th() {
  var a3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a3 : O = O.next = a3;
  return O;
}
function Uh() {
  if (null === N) {
    var a3 = M.alternate;
    a3 = null !== a3 ? a3.memoizedState : null;
  } else a3 = N.next;
  var b3 = null === O ? M.memoizedState : O.next;
  if (null !== b3) O = b3, N = a3;
  else {
    if (null === a3) throw Error(p$2(310));
    N = a3;
    a3 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a3 : O = O.next = a3;
  }
  return O;
}
function Vh(a3, b3) {
  return "function" === typeof b3 ? b3(a3) : b3;
}
function Wh(a3) {
  var b3 = Uh(), c3 = b3.queue;
  if (null === c3) throw Error(p$2(311));
  c3.lastRenderedReducer = a3;
  var d4 = N, e3 = d4.baseQueue, f2 = c3.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d4.baseQueue = e3 = f2;
    c3.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d4 = d4.baseState;
    var h4 = g2 = null, k3 = null, l2 = f2;
    do {
      var m4 = l2.lane;
      if ((Hh & m4) === m4) null !== k3 && (k3 = k3.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d4 = l2.hasEagerState ? l2.eagerState : a3(d4, l2.action);
      else {
        var q3 = {
          lane: m4,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k3 ? (h4 = k3 = q3, g2 = d4) : k3 = k3.next = q3;
        M.lanes |= m4;
        rh |= m4;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k3 ? g2 = d4 : k3.next = h4;
    He(d4, b3.memoizedState) || (dh = true);
    b3.memoizedState = d4;
    b3.baseState = g2;
    b3.baseQueue = k3;
    c3.lastRenderedState = d4;
  }
  a3 = c3.interleaved;
  if (null !== a3) {
    e3 = a3;
    do
      f2 = e3.lane, M.lanes |= f2, rh |= f2, e3 = e3.next;
    while (e3 !== a3);
  } else null === e3 && (c3.lanes = 0);
  return [b3.memoizedState, c3.dispatch];
}
function Xh(a3) {
  var b3 = Uh(), c3 = b3.queue;
  if (null === c3) throw Error(p$2(311));
  c3.lastRenderedReducer = a3;
  var d4 = c3.dispatch, e3 = c3.pending, f2 = b3.memoizedState;
  if (null !== e3) {
    c3.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a3(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He(f2, b3.memoizedState) || (dh = true);
    b3.memoizedState = f2;
    null === b3.baseQueue && (b3.baseState = f2);
    c3.lastRenderedState = f2;
  }
  return [f2, d4];
}
function Yh() {
}
function Zh(a3, b3) {
  var c3 = M, d4 = Uh(), e3 = b3(), f2 = !He(d4.memoizedState, e3);
  f2 && (d4.memoizedState = e3, dh = true);
  d4 = d4.queue;
  $h(ai.bind(null, c3, d4, a3), [a3]);
  if (d4.getSnapshot !== b3 || f2 || null !== O && O.memoizedState.tag & 1) {
    c3.flags |= 2048;
    bi(9, ci.bind(null, c3, d4, e3, b3), void 0, null);
    if (null === Q) throw Error(p$2(349));
    0 !== (Hh & 30) || di(c3, b3, e3);
  }
  return e3;
}
function di(a3, b3, c3) {
  a3.flags |= 16384;
  a3 = { getSnapshot: b3, value: c3 };
  b3 = M.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, M.updateQueue = b3, b3.stores = [a3]) : (c3 = b3.stores, null === c3 ? b3.stores = [a3] : c3.push(a3));
}
function ci(a3, b3, c3, d4) {
  b3.value = c3;
  b3.getSnapshot = d4;
  ei(b3) && fi(a3);
}
function ai(a3, b3, c3) {
  return c3(function() {
    ei(b3) && fi(a3);
  });
}
function ei(a3) {
  var b3 = a3.getSnapshot;
  a3 = a3.value;
  try {
    var c3 = b3();
    return !He(a3, c3);
  } catch (d4) {
    return true;
  }
}
function fi(a3) {
  var b3 = ih(a3, 1);
  null !== b3 && gi(b3, a3, 1, -1);
}
function hi(a3) {
  var b3 = Th();
  "function" === typeof a3 && (a3 = a3());
  b3.memoizedState = b3.baseState = a3;
  a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a3 };
  b3.queue = a3;
  a3 = a3.dispatch = ii.bind(null, M, a3);
  return [b3.memoizedState, a3];
}
function bi(a3, b3, c3, d4) {
  a3 = { tag: a3, create: b3, destroy: c3, deps: d4, next: null };
  b3 = M.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, M.updateQueue = b3, b3.lastEffect = a3.next = a3) : (c3 = b3.lastEffect, null === c3 ? b3.lastEffect = a3.next = a3 : (d4 = c3.next, c3.next = a3, a3.next = d4, b3.lastEffect = a3));
  return a3;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a3, b3, c3, d4) {
  var e3 = Th();
  M.flags |= a3;
  e3.memoizedState = bi(1 | b3, c3, void 0, void 0 === d4 ? null : d4);
}
function li(a3, b3, c3, d4) {
  var e3 = Uh();
  d4 = void 0 === d4 ? null : d4;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d4 && Mh(d4, g2.deps)) {
      e3.memoizedState = bi(b3, c3, f2, d4);
      return;
    }
  }
  M.flags |= a3;
  e3.memoizedState = bi(1 | b3, c3, f2, d4);
}
function mi(a3, b3) {
  return ki(8390656, 8, a3, b3);
}
function $h(a3, b3) {
  return li(2048, 8, a3, b3);
}
function ni(a3, b3) {
  return li(4, 2, a3, b3);
}
function oi(a3, b3) {
  return li(4, 4, a3, b3);
}
function pi(a3, b3) {
  if ("function" === typeof b3) return a3 = a3(), b3(a3), function() {
    b3(null);
  };
  if (null !== b3 && void 0 !== b3) return a3 = a3(), b3.current = a3, function() {
    b3.current = null;
  };
}
function qi(a3, b3, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a3]) : null;
  return li(4, 4, pi.bind(null, b3, a3), c3);
}
function ri() {
}
function si(a3, b3) {
  var c3 = Uh();
  b3 = void 0 === b3 ? null : b3;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b3 && Mh(b3, d4[1])) return d4[0];
  c3.memoizedState = [a3, b3];
  return a3;
}
function ti(a3, b3) {
  var c3 = Uh();
  b3 = void 0 === b3 ? null : b3;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b3 && Mh(b3, d4[1])) return d4[0];
  a3 = a3();
  c3.memoizedState = [a3, b3];
  return a3;
}
function ui(a3, b3, c3) {
  if (0 === (Hh & 21)) return a3.baseState && (a3.baseState = false, dh = true), a3.memoizedState = c3;
  He(c3, b3) || (c3 = yc(), M.lanes |= c3, rh |= c3, a3.baseState = true);
  return b3;
}
function vi(a3, b3) {
  var c3 = C;
  C = 0 !== c3 && 4 > c3 ? c3 : 4;
  a3(true);
  var d4 = Gh.transition;
  Gh.transition = {};
  try {
    a3(false), b3();
  } finally {
    C = c3, Gh.transition = d4;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a3, b3, c3) {
  var d4 = yi(a3);
  c3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (zi(a3)) Ai(b3, c3);
  else if (c3 = hh(a3, b3, c3, d4), null !== c3) {
    var e3 = R();
    gi(c3, a3, d4, e3);
    Bi(c3, b3, d4);
  }
}
function ii(a3, b3, c3) {
  var d4 = yi(a3), e3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (zi(a3)) Ai(b3, e3);
  else {
    var f2 = a3.alternate;
    if (0 === a3.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b3.lastRenderedReducer, null !== f2)) try {
      var g2 = b3.lastRenderedState, h4 = f2(g2, c3);
      e3.hasEagerState = true;
      e3.eagerState = h4;
      if (He(h4, g2)) {
        var k3 = b3.interleaved;
        null === k3 ? (e3.next = e3, gh(b3)) : (e3.next = k3.next, k3.next = e3);
        b3.interleaved = e3;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c3 = hh(a3, b3, e3, d4);
    null !== c3 && (e3 = R(), gi(c3, a3, d4, e3), Bi(c3, b3, d4));
  }
}
function zi(a3) {
  var b3 = a3.alternate;
  return a3 === M || null !== b3 && b3 === M;
}
function Ai(a3, b3) {
  Jh = Ih = true;
  var c3 = a3.pending;
  null === c3 ? b3.next = b3 : (b3.next = c3.next, c3.next = b3);
  a3.pending = b3;
}
function Bi(a3, b3, c3) {
  if (0 !== (c3 & 4194240)) {
    var d4 = b3.lanes;
    d4 &= a3.pendingLanes;
    c3 |= d4;
    b3.lanes = c3;
    Cc(a3, c3);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a3, b3) {
  Th().memoizedState = [a3, void 0 === b3 ? null : b3];
  return a3;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a3, b3, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a3]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b3, a3),
    c3
  );
}, useLayoutEffect: function(a3, b3) {
  return ki(4194308, 4, a3, b3);
}, useInsertionEffect: function(a3, b3) {
  return ki(4, 2, a3, b3);
}, useMemo: function(a3, b3) {
  var c3 = Th();
  b3 = void 0 === b3 ? null : b3;
  a3 = a3();
  c3.memoizedState = [a3, b3];
  return a3;
}, useReducer: function(a3, b3, c3) {
  var d4 = Th();
  b3 = void 0 !== c3 ? c3(b3) : b3;
  d4.memoizedState = d4.baseState = b3;
  a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a3, lastRenderedState: b3 };
  d4.queue = a3;
  a3 = a3.dispatch = xi.bind(null, M, a3);
  return [d4.memoizedState, a3];
}, useRef: function(a3) {
  var b3 = Th();
  a3 = { current: a3 };
  return b3.memoizedState = a3;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a3) {
  return Th().memoizedState = a3;
}, useTransition: function() {
  var a3 = hi(false), b3 = a3[0];
  a3 = vi.bind(null, a3[1]);
  Th().memoizedState = a3;
  return [b3, a3];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a3, b3, c3) {
  var d4 = M, e3 = Th();
  if (I) {
    if (void 0 === c3) throw Error(p$2(407));
    c3 = c3();
  } else {
    c3 = b3();
    if (null === Q) throw Error(p$2(349));
    0 !== (Hh & 30) || di(d4, b3, c3);
  }
  e3.memoizedState = c3;
  var f2 = { value: c3, getSnapshot: b3 };
  e3.queue = f2;
  mi(ai.bind(
    null,
    d4,
    f2,
    a3
  ), [a3]);
  d4.flags |= 2048;
  bi(9, ci.bind(null, d4, f2, c3, b3), void 0, null);
  return c3;
}, useId: function() {
  var a3 = Th(), b3 = Q.identifierPrefix;
  if (I) {
    var c3 = sg;
    var d4 = rg;
    c3 = (d4 & ~(1 << 32 - oc(d4) - 1)).toString(32) + c3;
    b3 = ":" + b3 + "R" + c3;
    c3 = Kh++;
    0 < c3 && (b3 += "H" + c3.toString(32));
    b3 += ":";
  } else c3 = Lh++, b3 = ":" + b3 + "r" + c3.toString(32) + ":";
  return a3.memoizedState = b3;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a3) {
    var b3 = Uh();
    return ui(b3, N.memoizedState, a3);
  },
  useTransition: function() {
    var a3 = Wh(Vh)[0], b3 = Uh().memoizedState;
    return [a3, b3];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a3) {
  var b3 = Uh();
  return null === N ? b3.memoizedState = a3 : ui(b3, N.memoizedState, a3);
}, useTransition: function() {
  var a3 = Xh(Vh)[0], b3 = Uh().memoizedState;
  return [a3, b3];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a3, b3) {
  if (a3 && a3.defaultProps) {
    b3 = A$1({}, b3);
    a3 = a3.defaultProps;
    for (var c3 in a3) void 0 === b3[c3] && (b3[c3] = a3[c3]);
    return b3;
  }
  return b3;
}
function Di(a3, b3, c3, d4) {
  b3 = a3.memoizedState;
  c3 = c3(d4, b3);
  c3 = null === c3 || void 0 === c3 ? b3 : A$1({}, b3, c3);
  a3.memoizedState = c3;
  0 === a3.lanes && (a3.updateQueue.baseState = c3);
}
var Ei = { isMounted: function(a3) {
  return (a3 = a3._reactInternals) ? Vb(a3) === a3 : false;
}, enqueueSetState: function(a3, b3, c3) {
  a3 = a3._reactInternals;
  var d4 = R(), e3 = yi(a3), f2 = mh(d4, e3);
  f2.payload = b3;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b3 = nh(a3, f2, e3);
  null !== b3 && (gi(b3, a3, e3, d4), oh(b3, a3, e3));
}, enqueueReplaceState: function(a3, b3, c3) {
  a3 = a3._reactInternals;
  var d4 = R(), e3 = yi(a3), f2 = mh(d4, e3);
  f2.tag = 1;
  f2.payload = b3;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b3 = nh(a3, f2, e3);
  null !== b3 && (gi(b3, a3, e3, d4), oh(b3, a3, e3));
}, enqueueForceUpdate: function(a3, b3) {
  a3 = a3._reactInternals;
  var c3 = R(), d4 = yi(a3), e3 = mh(c3, d4);
  e3.tag = 2;
  void 0 !== b3 && null !== b3 && (e3.callback = b3);
  b3 = nh(a3, e3, d4);
  null !== b3 && (gi(b3, a3, d4, c3), oh(b3, a3, d4));
} };
function Fi(a3, b3, c3, d4, e3, f2, g2) {
  a3 = a3.stateNode;
  return "function" === typeof a3.shouldComponentUpdate ? a3.shouldComponentUpdate(d4, f2, g2) : b3.prototype && b3.prototype.isPureReactComponent ? !Ie(c3, d4) || !Ie(e3, f2) : true;
}
function Gi(a3, b3, c3) {
  var d4 = false, e3 = Vf;
  var f2 = b3.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e3 = Zf(b3) ? Xf : H.current, d4 = b3.contextTypes, f2 = (d4 = null !== d4 && void 0 !== d4) ? Yf(a3, e3) : Vf);
  b3 = new b3(c3, f2);
  a3.memoizedState = null !== b3.state && void 0 !== b3.state ? b3.state : null;
  b3.updater = Ei;
  a3.stateNode = b3;
  b3._reactInternals = a3;
  d4 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = e3, a3.__reactInternalMemoizedMaskedChildContext = f2);
  return b3;
}
function Hi(a3, b3, c3, d4) {
  a3 = b3.state;
  "function" === typeof b3.componentWillReceiveProps && b3.componentWillReceiveProps(c3, d4);
  "function" === typeof b3.UNSAFE_componentWillReceiveProps && b3.UNSAFE_componentWillReceiveProps(c3, d4);
  b3.state !== a3 && Ei.enqueueReplaceState(b3, b3.state, null);
}
function Ii(a3, b3, c3, d4) {
  var e3 = a3.stateNode;
  e3.props = c3;
  e3.state = a3.memoizedState;
  e3.refs = {};
  kh(a3);
  var f2 = b3.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = eh(f2) : (f2 = Zf(b3) ? Xf : H.current, e3.context = Yf(a3, f2));
  e3.state = a3.memoizedState;
  f2 = b3.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a3, b3, f2, c3), e3.state = a3.memoizedState);
  "function" === typeof b3.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b3 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b3 !== e3.state && Ei.enqueueReplaceState(e3, e3.state, null), qh(a3, c3, e3, d4), e3.state = a3.memoizedState);
  "function" === typeof e3.componentDidMount && (a3.flags |= 4194308);
}
function Ji(a3, b3) {
  try {
    var c3 = "", d4 = b3;
    do
      c3 += Pa(d4), d4 = d4.return;
    while (d4);
    var e3 = c3;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a3, source: b3, stack: e3, digest: null };
}
function Ki(a3, b3, c3) {
  return { value: a3, source: null, stack: null != c3 ? c3 : null, digest: null != b3 ? b3 : null };
}
function Li(a3, b3) {
  try {
    console.error(b3.value);
  } catch (c3) {
    setTimeout(function() {
      throw c3;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a3, b3, c3) {
  c3 = mh(-1, c3);
  c3.tag = 3;
  c3.payload = { element: null };
  var d4 = b3.value;
  c3.callback = function() {
    Oi || (Oi = true, Pi = d4);
    Li(a3, b3);
  };
  return c3;
}
function Qi(a3, b3, c3) {
  c3 = mh(-1, c3);
  c3.tag = 3;
  var d4 = a3.type.getDerivedStateFromError;
  if ("function" === typeof d4) {
    var e3 = b3.value;
    c3.payload = function() {
      return d4(e3);
    };
    c3.callback = function() {
      Li(a3, b3);
    };
  }
  var f2 = a3.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c3.callback = function() {
    Li(a3, b3);
    "function" !== typeof d4 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c4 = b3.stack;
    this.componentDidCatch(b3.value, { componentStack: null !== c4 ? c4 : "" });
  });
  return c3;
}
function Si(a3, b3, c3) {
  var d4 = a3.pingCache;
  if (null === d4) {
    d4 = a3.pingCache = new Mi();
    var e3 = /* @__PURE__ */ new Set();
    d4.set(b3, e3);
  } else e3 = d4.get(b3), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d4.set(b3, e3));
  e3.has(c3) || (e3.add(c3), a3 = Ti.bind(null, a3, b3, c3), b3.then(a3, a3));
}
function Ui(a3) {
  do {
    var b3;
    if (b3 = 13 === a3.tag) b3 = a3.memoizedState, b3 = null !== b3 ? null !== b3.dehydrated ? true : false : true;
    if (b3) return a3;
    a3 = a3.return;
  } while (null !== a3);
  return null;
}
function Vi(a3, b3, c3, d4, e3) {
  if (0 === (a3.mode & 1)) return a3 === b3 ? a3.flags |= 65536 : (a3.flags |= 128, c3.flags |= 131072, c3.flags &= -52805, 1 === c3.tag && (null === c3.alternate ? c3.tag = 17 : (b3 = mh(-1, 1), b3.tag = 2, nh(c3, b3, 1))), c3.lanes |= 1), a3;
  a3.flags |= 65536;
  a3.lanes = e3;
  return a3;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a3, b3, c3, d4) {
  b3.child = null === a3 ? Vg(b3, null, c3, d4) : Ug(b3, a3.child, c3, d4);
}
function Yi(a3, b3, c3, d4, e3) {
  c3 = c3.render;
  var f2 = b3.ref;
  ch(b3, e3);
  d4 = Nh(a3, b3, c3, d4, f2, e3);
  c3 = Sh();
  if (null !== a3 && !dh) return b3.updateQueue = a3.updateQueue, b3.flags &= -2053, a3.lanes &= ~e3, Zi(a3, b3, e3);
  I && c3 && vg(b3);
  b3.flags |= 1;
  Xi(a3, b3, d4, e3);
  return b3.child;
}
function $i(a3, b3, c3, d4, e3) {
  if (null === a3) {
    var f2 = c3.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c3.compare && void 0 === c3.defaultProps) return b3.tag = 15, b3.type = f2, bj(a3, b3, f2, d4, e3);
    a3 = Rg(c3.type, null, d4, b3, b3.mode, e3);
    a3.ref = b3.ref;
    a3.return = b3;
    return b3.child = a3;
  }
  f2 = a3.child;
  if (0 === (a3.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c3 = c3.compare;
    c3 = null !== c3 ? c3 : Ie;
    if (c3(g2, d4) && a3.ref === b3.ref) return Zi(a3, b3, e3);
  }
  b3.flags |= 1;
  a3 = Pg(f2, d4);
  a3.ref = b3.ref;
  a3.return = b3;
  return b3.child = a3;
}
function bj(a3, b3, c3, d4, e3) {
  if (null !== a3) {
    var f2 = a3.memoizedProps;
    if (Ie(f2, d4) && a3.ref === b3.ref) if (dh = false, b3.pendingProps = d4 = f2, 0 !== (a3.lanes & e3)) 0 !== (a3.flags & 131072) && (dh = true);
    else return b3.lanes = a3.lanes, Zi(a3, b3, e3);
  }
  return cj(a3, b3, c3, d4, e3);
}
function dj(a3, b3, c3) {
  var d4 = b3.pendingProps, e3 = d4.children, f2 = null !== a3 ? a3.memoizedState : null;
  if ("hidden" === d4.mode) if (0 === (b3.mode & 1)) b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c3;
  else {
    if (0 === (c3 & 1073741824)) return a3 = null !== f2 ? f2.baseLanes | c3 : c3, b3.lanes = b3.childLanes = 1073741824, b3.memoizedState = { baseLanes: a3, cachePool: null, transitions: null }, b3.updateQueue = null, G(ej, fj), fj |= a3, null;
    b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d4 = null !== f2 ? f2.baseLanes : c3;
    G(ej, fj);
    fj |= d4;
  }
  else null !== f2 ? (d4 = f2.baseLanes | c3, b3.memoizedState = null) : d4 = c3, G(ej, fj), fj |= d4;
  Xi(a3, b3, e3, c3);
  return b3.child;
}
function gj(a3, b3) {
  var c3 = b3.ref;
  if (null === a3 && null !== c3 || null !== a3 && a3.ref !== c3) b3.flags |= 512, b3.flags |= 2097152;
}
function cj(a3, b3, c3, d4, e3) {
  var f2 = Zf(c3) ? Xf : H.current;
  f2 = Yf(b3, f2);
  ch(b3, e3);
  c3 = Nh(a3, b3, c3, d4, f2, e3);
  d4 = Sh();
  if (null !== a3 && !dh) return b3.updateQueue = a3.updateQueue, b3.flags &= -2053, a3.lanes &= ~e3, Zi(a3, b3, e3);
  I && d4 && vg(b3);
  b3.flags |= 1;
  Xi(a3, b3, c3, e3);
  return b3.child;
}
function hj(a3, b3, c3, d4, e3) {
  if (Zf(c3)) {
    var f2 = true;
    cg(b3);
  } else f2 = false;
  ch(b3, e3);
  if (null === b3.stateNode) ij(a3, b3), Gi(b3, c3, d4), Ii(b3, c3, d4, e3), d4 = true;
  else if (null === a3) {
    var g2 = b3.stateNode, h4 = b3.memoizedProps;
    g2.props = h4;
    var k3 = g2.context, l2 = c3.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c3) ? Xf : H.current, l2 = Yf(b3, l2));
    var m4 = c3.getDerivedStateFromProps, q3 = "function" === typeof m4 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q3 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== d4 || k3 !== l2) && Hi(b3, g2, d4, l2);
    jh = false;
    var r2 = b3.memoizedState;
    g2.state = r2;
    qh(b3, d4, g2, e3);
    k3 = b3.memoizedState;
    h4 !== d4 || r2 !== k3 || Wf.current || jh ? ("function" === typeof m4 && (Di(b3, c3, m4, d4), k3 = b3.memoizedState), (h4 = jh || Fi(b3, c3, h4, d4, r2, k3, l2)) ? (q3 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b3.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), b3.memoizedProps = d4, b3.memoizedState = k3), g2.props = d4, g2.state = k3, g2.context = l2, d4 = h4) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), d4 = false);
  } else {
    g2 = b3.stateNode;
    lh(a3, b3);
    h4 = b3.memoizedProps;
    l2 = b3.type === b3.elementType ? h4 : Ci(b3.type, h4);
    g2.props = l2;
    q3 = b3.pendingProps;
    r2 = g2.context;
    k3 = c3.contextType;
    "object" === typeof k3 && null !== k3 ? k3 = eh(k3) : (k3 = Zf(c3) ? Xf : H.current, k3 = Yf(b3, k3));
    var y4 = c3.getDerivedStateFromProps;
    (m4 = "function" === typeof y4 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== q3 || r2 !== k3) && Hi(b3, g2, d4, k3);
    jh = false;
    r2 = b3.memoizedState;
    g2.state = r2;
    qh(b3, d4, g2, e3);
    var n2 = b3.memoizedState;
    h4 !== q3 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y4 && (Di(b3, c3, y4, d4), n2 = b3.memoizedState), (l2 = jh || Fi(b3, c3, l2, d4, r2, n2, k3) || false) ? (m4 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d4, n2, k3), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d4, n2, k3)), "function" === typeof g2.componentDidUpdate && (b3.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b3.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h4 === a3.memoizedProps && r2 === a3.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a3.memoizedProps && r2 === a3.memoizedState || (b3.flags |= 1024), b3.memoizedProps = d4, b3.memoizedState = n2), g2.props = d4, g2.state = n2, g2.context = k3, d4 = l2) : ("function" !== typeof g2.componentDidUpdate || h4 === a3.memoizedProps && r2 === a3.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a3.memoizedProps && r2 === a3.memoizedState || (b3.flags |= 1024), d4 = false);
  }
  return jj(a3, b3, c3, d4, f2, e3);
}
function jj(a3, b3, c3, d4, e3, f2) {
  gj(a3, b3);
  var g2 = 0 !== (b3.flags & 128);
  if (!d4 && !g2) return e3 && dg(b3, c3, false), Zi(a3, b3, f2);
  d4 = b3.stateNode;
  Wi.current = b3;
  var h4 = g2 && "function" !== typeof c3.getDerivedStateFromError ? null : d4.render();
  b3.flags |= 1;
  null !== a3 && g2 ? (b3.child = Ug(b3, a3.child, null, f2), b3.child = Ug(b3, null, h4, f2)) : Xi(a3, b3, h4, f2);
  b3.memoizedState = d4.state;
  e3 && dg(b3, c3, true);
  return b3.child;
}
function kj(a3) {
  var b3 = a3.stateNode;
  b3.pendingContext ? ag(a3, b3.pendingContext, b3.pendingContext !== b3.context) : b3.context && ag(a3, b3.context, false);
  yh(a3, b3.containerInfo);
}
function lj(a3, b3, c3, d4, e3) {
  Ig();
  Jg(e3);
  b3.flags |= 256;
  Xi(a3, b3, c3, d4);
  return b3.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a3) {
  return { baseLanes: a3, cachePool: null, transitions: null };
}
function oj(a3, b3, c3) {
  var d4 = b3.pendingProps, e3 = L.current, f2 = false, g2 = 0 !== (b3.flags & 128), h4;
  (h4 = g2) || (h4 = null !== a3 && null === a3.memoizedState ? false : 0 !== (e3 & 2));
  if (h4) f2 = true, b3.flags &= -129;
  else if (null === a3 || null !== a3.memoizedState) e3 |= 1;
  G(L, e3 & 1);
  if (null === a3) {
    Eg(b3);
    a3 = b3.memoizedState;
    if (null !== a3 && (a3 = a3.dehydrated, null !== a3)) return 0 === (b3.mode & 1) ? b3.lanes = 1 : "$!" === a3.data ? b3.lanes = 8 : b3.lanes = 1073741824, null;
    g2 = d4.children;
    a3 = d4.fallback;
    return f2 ? (d4 = b3.mode, f2 = b3.child, g2 = { mode: "hidden", children: g2 }, 0 === (d4 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d4, 0, null), a3 = Tg(a3, d4, c3, null), f2.return = b3, a3.return = b3, f2.sibling = a3, b3.child = f2, b3.child.memoizedState = nj(c3), b3.memoizedState = mj, a3) : qj(b3, g2);
  }
  e3 = a3.memoizedState;
  if (null !== e3 && (h4 = e3.dehydrated, null !== h4)) return rj(a3, b3, g2, d4, h4, e3, c3);
  if (f2) {
    f2 = d4.fallback;
    g2 = b3.mode;
    e3 = a3.child;
    h4 = e3.sibling;
    var k3 = { mode: "hidden", children: d4.children };
    0 === (g2 & 1) && b3.child !== e3 ? (d4 = b3.child, d4.childLanes = 0, d4.pendingProps = k3, b3.deletions = null) : (d4 = Pg(e3, k3), d4.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h4 ? f2 = Pg(h4, f2) : (f2 = Tg(f2, g2, c3, null), f2.flags |= 2);
    f2.return = b3;
    d4.return = b3;
    d4.sibling = f2;
    b3.child = d4;
    d4 = f2;
    f2 = b3.child;
    g2 = a3.child.memoizedState;
    g2 = null === g2 ? nj(c3) : { baseLanes: g2.baseLanes | c3, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a3.childLanes & ~c3;
    b3.memoizedState = mj;
    return d4;
  }
  f2 = a3.child;
  a3 = f2.sibling;
  d4 = Pg(f2, { mode: "visible", children: d4.children });
  0 === (b3.mode & 1) && (d4.lanes = c3);
  d4.return = b3;
  d4.sibling = null;
  null !== a3 && (c3 = b3.deletions, null === c3 ? (b3.deletions = [a3], b3.flags |= 16) : c3.push(a3));
  b3.child = d4;
  b3.memoizedState = null;
  return d4;
}
function qj(a3, b3) {
  b3 = pj({ mode: "visible", children: b3 }, a3.mode, 0, null);
  b3.return = a3;
  return a3.child = b3;
}
function sj(a3, b3, c3, d4) {
  null !== d4 && Jg(d4);
  Ug(b3, a3.child, null, c3);
  a3 = qj(b3, b3.pendingProps.children);
  a3.flags |= 2;
  b3.memoizedState = null;
  return a3;
}
function rj(a3, b3, c3, d4, e3, f2, g2) {
  if (c3) {
    if (b3.flags & 256) return b3.flags &= -257, d4 = Ki(Error(p$2(422))), sj(a3, b3, g2, d4);
    if (null !== b3.memoizedState) return b3.child = a3.child, b3.flags |= 128, null;
    f2 = d4.fallback;
    e3 = b3.mode;
    d4 = pj({ mode: "visible", children: d4.children }, e3, 0, null);
    f2 = Tg(f2, e3, g2, null);
    f2.flags |= 2;
    d4.return = b3;
    f2.return = b3;
    d4.sibling = f2;
    b3.child = d4;
    0 !== (b3.mode & 1) && Ug(b3, a3.child, null, g2);
    b3.child.memoizedState = nj(g2);
    b3.memoizedState = mj;
    return f2;
  }
  if (0 === (b3.mode & 1)) return sj(a3, b3, g2, null);
  if ("$!" === e3.data) {
    d4 = e3.nextSibling && e3.nextSibling.dataset;
    if (d4) var h4 = d4.dgst;
    d4 = h4;
    f2 = Error(p$2(419));
    d4 = Ki(f2, d4, void 0);
    return sj(a3, b3, g2, d4);
  }
  h4 = 0 !== (g2 & a3.childLanes);
  if (dh || h4) {
    d4 = Q;
    if (null !== d4) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d4.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, ih(a3, e3), gi(d4, a3, e3, -1));
    }
    tj();
    d4 = Ki(Error(p$2(421)));
    return sj(a3, b3, g2, d4);
  }
  if ("$?" === e3.data) return b3.flags |= 128, b3.child = a3.child, b3 = uj.bind(null, a3), e3._reactRetry = b3, null;
  a3 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b3;
  I = true;
  zg = null;
  null !== a3 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a3.id, sg = a3.overflow, qg = b3);
  b3 = qj(b3, d4.children);
  b3.flags |= 4096;
  return b3;
}
function vj(a3, b3, c3) {
  a3.lanes |= b3;
  var d4 = a3.alternate;
  null !== d4 && (d4.lanes |= b3);
  bh(a3.return, b3, c3);
}
function wj(a3, b3, c3, d4, e3) {
  var f2 = a3.memoizedState;
  null === f2 ? a3.memoizedState = { isBackwards: b3, rendering: null, renderingStartTime: 0, last: d4, tail: c3, tailMode: e3 } : (f2.isBackwards = b3, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d4, f2.tail = c3, f2.tailMode = e3);
}
function xj(a3, b3, c3) {
  var d4 = b3.pendingProps, e3 = d4.revealOrder, f2 = d4.tail;
  Xi(a3, b3, d4.children, c3);
  d4 = L.current;
  if (0 !== (d4 & 2)) d4 = d4 & 1 | 2, b3.flags |= 128;
  else {
    if (null !== a3 && 0 !== (a3.flags & 128)) a: for (a3 = b3.child; null !== a3; ) {
      if (13 === a3.tag) null !== a3.memoizedState && vj(a3, c3, b3);
      else if (19 === a3.tag) vj(a3, c3, b3);
      else if (null !== a3.child) {
        a3.child.return = a3;
        a3 = a3.child;
        continue;
      }
      if (a3 === b3) break a;
      for (; null === a3.sibling; ) {
        if (null === a3.return || a3.return === b3) break a;
        a3 = a3.return;
      }
      a3.sibling.return = a3.return;
      a3 = a3.sibling;
    }
    d4 &= 1;
  }
  G(L, d4);
  if (0 === (b3.mode & 1)) b3.memoizedState = null;
  else switch (e3) {
    case "forwards":
      c3 = b3.child;
      for (e3 = null; null !== c3; ) a3 = c3.alternate, null !== a3 && null === Ch(a3) && (e3 = c3), c3 = c3.sibling;
      c3 = e3;
      null === c3 ? (e3 = b3.child, b3.child = null) : (e3 = c3.sibling, c3.sibling = null);
      wj(b3, false, e3, c3, f2);
      break;
    case "backwards":
      c3 = null;
      e3 = b3.child;
      for (b3.child = null; null !== e3; ) {
        a3 = e3.alternate;
        if (null !== a3 && null === Ch(a3)) {
          b3.child = e3;
          break;
        }
        a3 = e3.sibling;
        e3.sibling = c3;
        c3 = e3;
        e3 = a3;
      }
      wj(b3, true, c3, null, f2);
      break;
    case "together":
      wj(b3, false, null, null, void 0);
      break;
    default:
      b3.memoizedState = null;
  }
  return b3.child;
}
function ij(a3, b3) {
  0 === (b3.mode & 1) && null !== a3 && (a3.alternate = null, b3.alternate = null, b3.flags |= 2);
}
function Zi(a3, b3, c3) {
  null !== a3 && (b3.dependencies = a3.dependencies);
  rh |= b3.lanes;
  if (0 === (c3 & b3.childLanes)) return null;
  if (null !== a3 && b3.child !== a3.child) throw Error(p$2(153));
  if (null !== b3.child) {
    a3 = b3.child;
    c3 = Pg(a3, a3.pendingProps);
    b3.child = c3;
    for (c3.return = b3; null !== a3.sibling; ) a3 = a3.sibling, c3 = c3.sibling = Pg(a3, a3.pendingProps), c3.return = b3;
    c3.sibling = null;
  }
  return b3.child;
}
function yj(a3, b3, c3) {
  switch (b3.tag) {
    case 3:
      kj(b3);
      Ig();
      break;
    case 5:
      Ah(b3);
      break;
    case 1:
      Zf(b3.type) && cg(b3);
      break;
    case 4:
      yh(b3, b3.stateNode.containerInfo);
      break;
    case 10:
      var d4 = b3.type._context, e3 = b3.memoizedProps.value;
      G(Wg, d4._currentValue);
      d4._currentValue = e3;
      break;
    case 13:
      d4 = b3.memoizedState;
      if (null !== d4) {
        if (null !== d4.dehydrated) return G(L, L.current & 1), b3.flags |= 128, null;
        if (0 !== (c3 & b3.child.childLanes)) return oj(a3, b3, c3);
        G(L, L.current & 1);
        a3 = Zi(a3, b3, c3);
        return null !== a3 ? a3.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d4 = 0 !== (c3 & b3.childLanes);
      if (0 !== (a3.flags & 128)) {
        if (d4) return xj(a3, b3, c3);
        b3.flags |= 128;
      }
      e3 = b3.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G(L, L.current);
      if (d4) break;
      else return null;
    case 22:
    case 23:
      return b3.lanes = 0, dj(a3, b3, c3);
  }
  return Zi(a3, b3, c3);
}
var zj, Aj, Bj, Cj;
zj = function(a3, b3) {
  for (var c3 = b3.child; null !== c3; ) {
    if (5 === c3.tag || 6 === c3.tag) a3.appendChild(c3.stateNode);
    else if (4 !== c3.tag && null !== c3.child) {
      c3.child.return = c3;
      c3 = c3.child;
      continue;
    }
    if (c3 === b3) break;
    for (; null === c3.sibling; ) {
      if (null === c3.return || c3.return === b3) return;
      c3 = c3.return;
    }
    c3.sibling.return = c3.return;
    c3 = c3.sibling;
  }
};
Aj = function() {
};
Bj = function(a3, b3, c3, d4) {
  var e3 = a3.memoizedProps;
  if (e3 !== d4) {
    a3 = b3.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c3) {
      case "input":
        e3 = Ya(a3, e3);
        d4 = Ya(a3, d4);
        f2 = [];
        break;
      case "select":
        e3 = A$1({}, e3, { value: void 0 });
        d4 = A$1({}, d4, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a3, e3);
        d4 = gb(a3, d4);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d4.onClick && (a3.onclick = Bf);
    }
    ub(c3, d4);
    var g2;
    c3 = null;
    for (l2 in e3) if (!d4.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2]) if ("style" === l2) {
      var h4 = e3[l2];
      for (g2 in h4) h4.hasOwnProperty(g2) && (c3 || (c3 = {}), c3[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d4) {
      var k3 = d4[l2];
      h4 = null != e3 ? e3[l2] : void 0;
      if (d4.hasOwnProperty(l2) && k3 !== h4 && (null != k3 || null != h4)) if ("style" === l2) if (h4) {
        for (g2 in h4) !h4.hasOwnProperty(g2) || k3 && k3.hasOwnProperty(g2) || (c3 || (c3 = {}), c3[g2] = "");
        for (g2 in k3) k3.hasOwnProperty(g2) && h4[g2] !== k3[g2] && (c3 || (c3 = {}), c3[g2] = k3[g2]);
      } else c3 || (f2 || (f2 = []), f2.push(
        l2,
        c3
      )), c3 = k3;
      else "dangerouslySetInnerHTML" === l2 ? (k3 = k3 ? k3.__html : void 0, h4 = h4 ? h4.__html : void 0, null != k3 && h4 !== k3 && (f2 = f2 || []).push(l2, k3)) : "children" === l2 ? "string" !== typeof k3 && "number" !== typeof k3 || (f2 = f2 || []).push(l2, "" + k3) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k3 && "onScroll" === l2 && D("scroll", a3), f2 || h4 === k3 || (f2 = [])) : (f2 = f2 || []).push(l2, k3));
    }
    c3 && (f2 = f2 || []).push("style", c3);
    var l2 = f2;
    if (b3.updateQueue = l2) b3.flags |= 4;
  }
};
Cj = function(a3, b3, c3, d4) {
  c3 !== d4 && (b3.flags |= 4);
};
function Dj(a3, b3) {
  if (!I) switch (a3.tailMode) {
    case "hidden":
      b3 = a3.tail;
      for (var c3 = null; null !== b3; ) null !== b3.alternate && (c3 = b3), b3 = b3.sibling;
      null === c3 ? a3.tail = null : c3.sibling = null;
      break;
    case "collapsed":
      c3 = a3.tail;
      for (var d4 = null; null !== c3; ) null !== c3.alternate && (d4 = c3), c3 = c3.sibling;
      null === d4 ? b3 || null === a3.tail ? a3.tail = null : a3.tail.sibling = null : d4.sibling = null;
  }
}
function S(a3) {
  var b3 = null !== a3.alternate && a3.alternate.child === a3.child, c3 = 0, d4 = 0;
  if (b3) for (var e3 = a3.child; null !== e3; ) c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags & 14680064, d4 |= e3.flags & 14680064, e3.return = a3, e3 = e3.sibling;
  else for (e3 = a3.child; null !== e3; ) c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags, d4 |= e3.flags, e3.return = a3, e3 = e3.sibling;
  a3.subtreeFlags |= d4;
  a3.childLanes = c3;
  return b3;
}
function Ej(a3, b3, c3) {
  var d4 = b3.pendingProps;
  wg(b3);
  switch (b3.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b3), null;
    case 1:
      return Zf(b3.type) && $f(), S(b3), null;
    case 3:
      d4 = b3.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d4.pendingContext && (d4.context = d4.pendingContext, d4.pendingContext = null);
      if (null === a3 || null === a3.child) Gg(b3) ? b3.flags |= 4 : null === a3 || a3.memoizedState.isDehydrated && 0 === (b3.flags & 256) || (b3.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a3, b3);
      S(b3);
      return null;
    case 5:
      Bh(b3);
      var e3 = xh(wh.current);
      c3 = b3.type;
      if (null !== a3 && null != b3.stateNode) Bj(a3, b3, c3, d4, e3), a3.ref !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      else {
        if (!d4) {
          if (null === b3.stateNode) throw Error(p$2(166));
          S(b3);
          return null;
        }
        a3 = xh(uh.current);
        if (Gg(b3)) {
          d4 = b3.stateNode;
          c3 = b3.type;
          var f2 = b3.memoizedProps;
          d4[Of] = b3;
          d4[Pf] = f2;
          a3 = 0 !== (b3.mode & 1);
          switch (c3) {
            case "dialog":
              D("cancel", d4);
              D("close", d4);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d4);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++) D(lf[e3], d4);
              break;
            case "source":
              D("error", d4);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d4
              );
              D("load", d4);
              break;
            case "details":
              D("toggle", d4);
              break;
            case "input":
              Za(d4, f2);
              D("invalid", d4);
              break;
            case "select":
              d4._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d4);
              break;
            case "textarea":
              hb(d4, f2), D("invalid", d4);
          }
          ub(c3, f2);
          e3 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h4 = f2[g2];
            "children" === g2 ? "string" === typeof h4 ? d4.textContent !== h4 && (true !== f2.suppressHydrationWarning && Af(d4.textContent, h4, a3), e3 = ["children", h4]) : "number" === typeof h4 && d4.textContent !== "" + h4 && (true !== f2.suppressHydrationWarning && Af(
              d4.textContent,
              h4,
              a3
            ), e3 = ["children", "" + h4]) : ea.hasOwnProperty(g2) && null != h4 && "onScroll" === g2 && D("scroll", d4);
          }
          switch (c3) {
            case "input":
              Va(d4);
              db(d4, f2, true);
              break;
            case "textarea":
              Va(d4);
              jb(d4);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d4.onclick = Bf);
          }
          d4 = e3;
          b3.updateQueue = d4;
          null !== d4 && (b3.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a3 && (a3 = kb(c3));
          "http://www.w3.org/1999/xhtml" === a3 ? "script" === c3 ? (a3 = g2.createElement("div"), a3.innerHTML = "<script><\/script>", a3 = a3.removeChild(a3.firstChild)) : "string" === typeof d4.is ? a3 = g2.createElement(c3, { is: d4.is }) : (a3 = g2.createElement(c3), "select" === c3 && (g2 = a3, d4.multiple ? g2.multiple = true : d4.size && (g2.size = d4.size))) : a3 = g2.createElementNS(a3, c3);
          a3[Of] = b3;
          a3[Pf] = d4;
          zj(a3, b3, false, false);
          b3.stateNode = a3;
          a: {
            g2 = vb(c3, d4);
            switch (c3) {
              case "dialog":
                D("cancel", a3);
                D("close", a3);
                e3 = d4;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a3);
                e3 = d4;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++) D(lf[e3], a3);
                e3 = d4;
                break;
              case "source":
                D("error", a3);
                e3 = d4;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a3
                );
                D("load", a3);
                e3 = d4;
                break;
              case "details":
                D("toggle", a3);
                e3 = d4;
                break;
              case "input":
                Za(a3, d4);
                e3 = Ya(a3, d4);
                D("invalid", a3);
                break;
              case "option":
                e3 = d4;
                break;
              case "select":
                a3._wrapperState = { wasMultiple: !!d4.multiple };
                e3 = A$1({}, d4, { value: void 0 });
                D("invalid", a3);
                break;
              case "textarea":
                hb(a3, d4);
                e3 = gb(a3, d4);
                D("invalid", a3);
                break;
              default:
                e3 = d4;
            }
            ub(c3, e3);
            h4 = e3;
            for (f2 in h4) if (h4.hasOwnProperty(f2)) {
              var k3 = h4[f2];
              "style" === f2 ? sb(a3, k3) : "dangerouslySetInnerHTML" === f2 ? (k3 = k3 ? k3.__html : void 0, null != k3 && nb(a3, k3)) : "children" === f2 ? "string" === typeof k3 ? ("textarea" !== c3 || "" !== k3) && ob(a3, k3) : "number" === typeof k3 && ob(a3, "" + k3) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k3 && "onScroll" === f2 && D("scroll", a3) : null != k3 && ta(a3, f2, k3, g2));
            }
            switch (c3) {
              case "input":
                Va(a3);
                db(a3, d4, false);
                break;
              case "textarea":
                Va(a3);
                jb(a3);
                break;
              case "option":
                null != d4.value && a3.setAttribute("value", "" + Sa(d4.value));
                break;
              case "select":
                a3.multiple = !!d4.multiple;
                f2 = d4.value;
                null != f2 ? fb(a3, !!d4.multiple, f2, false) : null != d4.defaultValue && fb(
                  a3,
                  !!d4.multiple,
                  d4.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a3.onclick = Bf);
            }
            switch (c3) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d4 = !!d4.autoFocus;
                break a;
              case "img":
                d4 = true;
                break a;
              default:
                d4 = false;
            }
          }
          d4 && (b3.flags |= 4);
        }
        null !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      }
      S(b3);
      return null;
    case 6:
      if (a3 && null != b3.stateNode) Cj(a3, b3, a3.memoizedProps, d4);
      else {
        if ("string" !== typeof d4 && null === b3.stateNode) throw Error(p$2(166));
        c3 = xh(wh.current);
        xh(uh.current);
        if (Gg(b3)) {
          d4 = b3.stateNode;
          c3 = b3.memoizedProps;
          d4[Of] = b3;
          if (f2 = d4.nodeValue !== c3) {
            if (a3 = xg, null !== a3) switch (a3.tag) {
              case 3:
                Af(d4.nodeValue, c3, 0 !== (a3.mode & 1));
                break;
              case 5:
                true !== a3.memoizedProps.suppressHydrationWarning && Af(d4.nodeValue, c3, 0 !== (a3.mode & 1));
            }
          }
          f2 && (b3.flags |= 4);
        } else d4 = (9 === c3.nodeType ? c3 : c3.ownerDocument).createTextNode(d4), d4[Of] = b3, b3.stateNode = d4;
      }
      S(b3);
      return null;
    case 13:
      E(L);
      d4 = b3.memoizedState;
      if (null === a3 || null !== a3.memoizedState && null !== a3.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b3.mode & 1) && 0 === (b3.flags & 128)) Hg(), Ig(), b3.flags |= 98560, f2 = false;
        else if (f2 = Gg(b3), null !== d4 && null !== d4.dehydrated) {
          if (null === a3) {
            if (!f2) throw Error(p$2(318));
            f2 = b3.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$2(317));
            f2[Of] = b3;
          } else Ig(), 0 === (b3.flags & 128) && (b3.memoizedState = null), b3.flags |= 4;
          S(b3);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b3.flags & 65536 ? b3 : null;
      }
      if (0 !== (b3.flags & 128)) return b3.lanes = c3, b3;
      d4 = null !== d4;
      d4 !== (null !== a3 && null !== a3.memoizedState) && d4 && (b3.child.flags |= 8192, 0 !== (b3.mode & 1) && (null === a3 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b3.updateQueue && (b3.flags |= 4);
      S(b3);
      return null;
    case 4:
      return zh(), Aj(a3, b3), null === a3 && sf(b3.stateNode.containerInfo), S(b3), null;
    case 10:
      return ah(b3.type._context), S(b3), null;
    case 17:
      return Zf(b3.type) && $f(), S(b3), null;
    case 19:
      E(L);
      f2 = b3.memoizedState;
      if (null === f2) return S(b3), null;
      d4 = 0 !== (b3.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d4) Dj(f2, false);
      else {
        if (0 !== T || null !== a3 && 0 !== (a3.flags & 128)) for (a3 = b3.child; null !== a3; ) {
          g2 = Ch(a3);
          if (null !== g2) {
            b3.flags |= 128;
            Dj(f2, false);
            d4 = g2.updateQueue;
            null !== d4 && (b3.updateQueue = d4, b3.flags |= 4);
            b3.subtreeFlags = 0;
            d4 = c3;
            for (c3 = b3.child; null !== c3; ) f2 = c3, a3 = d4, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a3, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a3 = g2.dependencies, f2.dependencies = null === a3 ? null : { lanes: a3.lanes, firstContext: a3.firstContext }), c3 = c3.sibling;
            G(L, L.current & 1 | 2);
            return b3.child;
          }
          a3 = a3.sibling;
        }
        null !== f2.tail && B() > Gj && (b3.flags |= 128, d4 = true, Dj(f2, false), b3.lanes = 4194304);
      }
      else {
        if (!d4) if (a3 = Ch(g2), null !== a3) {
          if (b3.flags |= 128, d4 = true, c3 = a3.updateQueue, null !== c3 && (b3.updateQueue = c3, b3.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b3), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c3 && (b3.flags |= 128, d4 = true, Dj(f2, false), b3.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b3.child, b3.child = g2) : (c3 = f2.last, null !== c3 ? c3.sibling = g2 : b3.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b3 = f2.tail, f2.rendering = b3, f2.tail = b3.sibling, f2.renderingStartTime = B(), b3.sibling = null, c3 = L.current, G(L, d4 ? c3 & 1 | 2 : c3 & 1), b3;
      S(b3);
      return null;
    case 22:
    case 23:
      return Hj(), d4 = null !== b3.memoizedState, null !== a3 && null !== a3.memoizedState !== d4 && (b3.flags |= 8192), d4 && 0 !== (b3.mode & 1) ? 0 !== (fj & 1073741824) && (S(b3), b3.subtreeFlags & 6 && (b3.flags |= 8192)) : S(b3), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b3.tag));
}
function Ij(a3, b3) {
  wg(b3);
  switch (b3.tag) {
    case 1:
      return Zf(b3.type) && $f(), a3 = b3.flags, a3 & 65536 ? (b3.flags = a3 & -65537 | 128, b3) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a3 = b3.flags, 0 !== (a3 & 65536) && 0 === (a3 & 128) ? (b3.flags = a3 & -65537 | 128, b3) : null;
    case 5:
      return Bh(b3), null;
    case 13:
      E(L);
      a3 = b3.memoizedState;
      if (null !== a3 && null !== a3.dehydrated) {
        if (null === b3.alternate) throw Error(p$2(340));
        Ig();
      }
      a3 = b3.flags;
      return a3 & 65536 ? (b3.flags = a3 & -65537 | 128, b3) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b3.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$1 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a3, b3) {
  var c3 = a3.ref;
  if (null !== c3) if ("function" === typeof c3) try {
    c3(null);
  } catch (d4) {
    W(a3, b3, d4);
  }
  else c3.current = null;
}
function Mj(a3, b3, c3) {
  try {
    c3();
  } catch (d4) {
    W(a3, b3, d4);
  }
}
var Nj = false;
function Oj(a3, b3) {
  Cf = dd;
  a3 = Me();
  if (Ne(a3)) {
    if ("selectionStart" in a3) var c3 = { start: a3.selectionStart, end: a3.selectionEnd };
    else a: {
      c3 = (c3 = a3.ownerDocument) && c3.defaultView || window;
      var d4 = c3.getSelection && c3.getSelection();
      if (d4 && 0 !== d4.rangeCount) {
        c3 = d4.anchorNode;
        var e3 = d4.anchorOffset, f2 = d4.focusNode;
        d4 = d4.focusOffset;
        try {
          c3.nodeType, f2.nodeType;
        } catch (F2) {
          c3 = null;
          break a;
        }
        var g2 = 0, h4 = -1, k3 = -1, l2 = 0, m4 = 0, q3 = a3, r2 = null;
        b: for (; ; ) {
          for (var y4; ; ) {
            q3 !== c3 || 0 !== e3 && 3 !== q3.nodeType || (h4 = g2 + e3);
            q3 !== f2 || 0 !== d4 && 3 !== q3.nodeType || (k3 = g2 + d4);
            3 === q3.nodeType && (g2 += q3.nodeValue.length);
            if (null === (y4 = q3.firstChild)) break;
            r2 = q3;
            q3 = y4;
          }
          for (; ; ) {
            if (q3 === a3) break b;
            r2 === c3 && ++l2 === e3 && (h4 = g2);
            r2 === f2 && ++m4 === d4 && (k3 = g2);
            if (null !== (y4 = q3.nextSibling)) break;
            q3 = r2;
            r2 = q3.parentNode;
          }
          q3 = y4;
        }
        c3 = -1 === h4 || -1 === k3 ? null : { start: h4, end: k3 };
      } else c3 = null;
    }
    c3 = c3 || { start: 0, end: 0 };
  } else c3 = null;
  Df = { focusedElem: a3, selectionRange: c3 };
  dd = false;
  for (V = b3; null !== V; ) if (b3 = V, a3 = b3.child, 0 !== (b3.subtreeFlags & 1028) && null !== a3) a3.return = b3, V = a3;
  else for (; null !== V; ) {
    b3 = V;
    try {
      var n2 = b3.alternate;
      if (0 !== (b3.flags & 1024)) switch (b3.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t3 = n2.memoizedProps, J2 = n2.memoizedState, x3 = b3.stateNode, w3 = x3.getSnapshotBeforeUpdate(b3.elementType === b3.type ? t3 : Ci(b3.type, t3), J2);
            x3.__reactInternalSnapshotBeforeUpdate = w3;
          }
          break;
        case 3:
          var u3 = b3.stateNode.containerInfo;
          1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$2(163));
      }
    } catch (F2) {
      W(b3, b3.return, F2);
    }
    a3 = b3.sibling;
    if (null !== a3) {
      a3.return = b3.return;
      V = a3;
      break;
    }
    V = b3.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a3, b3, c3) {
  var d4 = b3.updateQueue;
  d4 = null !== d4 ? d4.lastEffect : null;
  if (null !== d4) {
    var e3 = d4 = d4.next;
    do {
      if ((e3.tag & a3) === a3) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Mj(b3, c3, f2);
      }
      e3 = e3.next;
    } while (e3 !== d4);
  }
}
function Qj(a3, b3) {
  b3 = b3.updateQueue;
  b3 = null !== b3 ? b3.lastEffect : null;
  if (null !== b3) {
    var c3 = b3 = b3.next;
    do {
      if ((c3.tag & a3) === a3) {
        var d4 = c3.create;
        c3.destroy = d4();
      }
      c3 = c3.next;
    } while (c3 !== b3);
  }
}
function Rj(a3) {
  var b3 = a3.ref;
  if (null !== b3) {
    var c3 = a3.stateNode;
    switch (a3.tag) {
      case 5:
        a3 = c3;
        break;
      default:
        a3 = c3;
    }
    "function" === typeof b3 ? b3(a3) : b3.current = a3;
  }
}
function Sj(a3) {
  var b3 = a3.alternate;
  null !== b3 && (a3.alternate = null, Sj(b3));
  a3.child = null;
  a3.deletions = null;
  a3.sibling = null;
  5 === a3.tag && (b3 = a3.stateNode, null !== b3 && (delete b3[Of], delete b3[Pf], delete b3[of], delete b3[Qf], delete b3[Rf]));
  a3.stateNode = null;
  a3.return = null;
  a3.dependencies = null;
  a3.memoizedProps = null;
  a3.memoizedState = null;
  a3.pendingProps = null;
  a3.stateNode = null;
  a3.updateQueue = null;
}
function Tj(a3) {
  return 5 === a3.tag || 3 === a3.tag || 4 === a3.tag;
}
function Uj(a3) {
  a: for (; ; ) {
    for (; null === a3.sibling; ) {
      if (null === a3.return || Tj(a3.return)) return null;
      a3 = a3.return;
    }
    a3.sibling.return = a3.return;
    for (a3 = a3.sibling; 5 !== a3.tag && 6 !== a3.tag && 18 !== a3.tag; ) {
      if (a3.flags & 2) continue a;
      if (null === a3.child || 4 === a3.tag) continue a;
      else a3.child.return = a3, a3 = a3.child;
    }
    if (!(a3.flags & 2)) return a3.stateNode;
  }
}
function Vj(a3, b3, c3) {
  var d4 = a3.tag;
  if (5 === d4 || 6 === d4) a3 = a3.stateNode, b3 ? 8 === c3.nodeType ? c3.parentNode.insertBefore(a3, b3) : c3.insertBefore(a3, b3) : (8 === c3.nodeType ? (b3 = c3.parentNode, b3.insertBefore(a3, c3)) : (b3 = c3, b3.appendChild(a3)), c3 = c3._reactRootContainer, null !== c3 && void 0 !== c3 || null !== b3.onclick || (b3.onclick = Bf));
  else if (4 !== d4 && (a3 = a3.child, null !== a3)) for (Vj(a3, b3, c3), a3 = a3.sibling; null !== a3; ) Vj(a3, b3, c3), a3 = a3.sibling;
}
function Wj(a3, b3, c3) {
  var d4 = a3.tag;
  if (5 === d4 || 6 === d4) a3 = a3.stateNode, b3 ? c3.insertBefore(a3, b3) : c3.appendChild(a3);
  else if (4 !== d4 && (a3 = a3.child, null !== a3)) for (Wj(a3, b3, c3), a3 = a3.sibling; null !== a3; ) Wj(a3, b3, c3), a3 = a3.sibling;
}
var X = null, Xj = false;
function Yj(a3, b3, c3) {
  for (c3 = c3.child; null !== c3; ) Zj(a3, b3, c3), c3 = c3.sibling;
}
function Zj(a3, b3, c3) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c3);
  } catch (h4) {
  }
  switch (c3.tag) {
    case 5:
      U$1 || Lj(c3, b3);
    case 6:
      var d4 = X, e3 = Xj;
      X = null;
      Yj(a3, b3, c3);
      X = d4;
      Xj = e3;
      null !== X && (Xj ? (a3 = X, c3 = c3.stateNode, 8 === a3.nodeType ? a3.parentNode.removeChild(c3) : a3.removeChild(c3)) : X.removeChild(c3.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a3 = X, c3 = c3.stateNode, 8 === a3.nodeType ? Kf(a3.parentNode, c3) : 1 === a3.nodeType && Kf(a3, c3), bd(a3)) : Kf(X, c3.stateNode));
      break;
    case 4:
      d4 = X;
      e3 = Xj;
      X = c3.stateNode.containerInfo;
      Xj = true;
      Yj(a3, b3, c3);
      X = d4;
      Xj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d4 = c3.updateQueue, null !== d4 && (d4 = d4.lastEffect, null !== d4))) {
        e3 = d4 = d4.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c3, b3, g2) : 0 !== (f2 & 4) && Mj(c3, b3, g2));
          e3 = e3.next;
        } while (e3 !== d4);
      }
      Yj(a3, b3, c3);
      break;
    case 1:
      if (!U$1 && (Lj(c3, b3), d4 = c3.stateNode, "function" === typeof d4.componentWillUnmount)) try {
        d4.props = c3.memoizedProps, d4.state = c3.memoizedState, d4.componentWillUnmount();
      } catch (h4) {
        W(c3, b3, h4);
      }
      Yj(a3, b3, c3);
      break;
    case 21:
      Yj(a3, b3, c3);
      break;
    case 22:
      c3.mode & 1 ? (U$1 = (d4 = U$1) || null !== c3.memoizedState, Yj(a3, b3, c3), U$1 = d4) : Yj(a3, b3, c3);
      break;
    default:
      Yj(a3, b3, c3);
  }
}
function ak(a3) {
  var b3 = a3.updateQueue;
  if (null !== b3) {
    a3.updateQueue = null;
    var c3 = a3.stateNode;
    null === c3 && (c3 = a3.stateNode = new Kj());
    b3.forEach(function(b4) {
      var d4 = bk.bind(null, a3, b4);
      c3.has(b4) || (c3.add(b4), b4.then(d4, d4));
    });
  }
}
function ck(a3, b3) {
  var c3 = b3.deletions;
  if (null !== c3) for (var d4 = 0; d4 < c3.length; d4++) {
    var e3 = c3[d4];
    try {
      var f2 = a3, g2 = b3, h4 = g2;
      a: for (; null !== h4; ) {
        switch (h4.tag) {
          case 5:
            X = h4.stateNode;
            Xj = false;
            break a;
          case 3:
            X = h4.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X = h4.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h4 = h4.return;
      }
      if (null === X) throw Error(p$2(160));
      Zj(f2, g2, e3);
      X = null;
      Xj = false;
      var k3 = e3.alternate;
      null !== k3 && (k3.return = null);
      e3.return = null;
    } catch (l2) {
      W(e3, b3, l2);
    }
  }
  if (b3.subtreeFlags & 12854) for (b3 = b3.child; null !== b3; ) dk(b3, a3), b3 = b3.sibling;
}
function dk(a3, b3) {
  var c3 = a3.alternate, d4 = a3.flags;
  switch (a3.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b3, a3);
      ek(a3);
      if (d4 & 4) {
        try {
          Pj(3, a3, a3.return), Qj(3, a3);
        } catch (t3) {
          W(a3, a3.return, t3);
        }
        try {
          Pj(5, a3, a3.return);
        } catch (t3) {
          W(a3, a3.return, t3);
        }
      }
      break;
    case 1:
      ck(b3, a3);
      ek(a3);
      d4 & 512 && null !== c3 && Lj(c3, c3.return);
      break;
    case 5:
      ck(b3, a3);
      ek(a3);
      d4 & 512 && null !== c3 && Lj(c3, c3.return);
      if (a3.flags & 32) {
        var e3 = a3.stateNode;
        try {
          ob(e3, "");
        } catch (t3) {
          W(a3, a3.return, t3);
        }
      }
      if (d4 & 4 && (e3 = a3.stateNode, null != e3)) {
        var f2 = a3.memoizedProps, g2 = null !== c3 ? c3.memoizedProps : f2, h4 = a3.type, k3 = a3.updateQueue;
        a3.updateQueue = null;
        if (null !== k3) try {
          "input" === h4 && "radio" === f2.type && null != f2.name && ab(e3, f2);
          vb(h4, g2);
          var l2 = vb(h4, f2);
          for (g2 = 0; g2 < k3.length; g2 += 2) {
            var m4 = k3[g2], q3 = k3[g2 + 1];
            "style" === m4 ? sb(e3, q3) : "dangerouslySetInnerHTML" === m4 ? nb(e3, q3) : "children" === m4 ? ob(e3, q3) : ta(e3, m4, q3, l2);
          }
          switch (h4) {
            case "input":
              bb(e3, f2);
              break;
            case "textarea":
              ib(e3, f2);
              break;
            case "select":
              var r2 = e3._wrapperState.wasMultiple;
              e3._wrapperState.wasMultiple = !!f2.multiple;
              var y4 = f2.value;
              null != y4 ? fb(e3, !!f2.multiple, y4, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e3,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e3[Pf] = f2;
        } catch (t3) {
          W(a3, a3.return, t3);
        }
      }
      break;
    case 6:
      ck(b3, a3);
      ek(a3);
      if (d4 & 4) {
        if (null === a3.stateNode) throw Error(p$2(162));
        e3 = a3.stateNode;
        f2 = a3.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t3) {
          W(a3, a3.return, t3);
        }
      }
      break;
    case 3:
      ck(b3, a3);
      ek(a3);
      if (d4 & 4 && null !== c3 && c3.memoizedState.isDehydrated) try {
        bd(b3.containerInfo);
      } catch (t3) {
        W(a3, a3.return, t3);
      }
      break;
    case 4:
      ck(b3, a3);
      ek(a3);
      break;
    case 13:
      ck(b3, a3);
      ek(a3);
      e3 = a3.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (fk = B()));
      d4 & 4 && ak(a3);
      break;
    case 22:
      m4 = null !== c3 && null !== c3.memoizedState;
      a3.mode & 1 ? (U$1 = (l2 = U$1) || m4, ck(b3, a3), U$1 = l2) : ck(b3, a3);
      ek(a3);
      if (d4 & 8192) {
        l2 = null !== a3.memoizedState;
        if ((a3.stateNode.isHidden = l2) && !m4 && 0 !== (a3.mode & 1)) for (V = a3, m4 = a3.child; null !== m4; ) {
          for (q3 = V = m4; null !== V; ) {
            r2 = V;
            y4 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d4 = r2;
                  c3 = r2.return;
                  try {
                    b3 = d4, n2.props = b3.memoizedProps, n2.state = b3.memoizedState, n2.componentWillUnmount();
                  } catch (t3) {
                    W(d4, c3, t3);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q3);
                  continue;
                }
            }
            null !== y4 ? (y4.return = r2, V = y4) : gk(q3);
          }
          m4 = m4.sibling;
        }
        a: for (m4 = null, q3 = a3; ; ) {
          if (5 === q3.tag) {
            if (null === m4) {
              m4 = q3;
              try {
                e3 = q3.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h4 = q3.stateNode, k3 = q3.memoizedProps.style, g2 = void 0 !== k3 && null !== k3 && k3.hasOwnProperty("display") ? k3.display : null, h4.style.display = rb("display", g2));
              } catch (t3) {
                W(a3, a3.return, t3);
              }
            }
          } else if (6 === q3.tag) {
            if (null === m4) try {
              q3.stateNode.nodeValue = l2 ? "" : q3.memoizedProps;
            } catch (t3) {
              W(a3, a3.return, t3);
            }
          } else if ((22 !== q3.tag && 23 !== q3.tag || null === q3.memoizedState || q3 === a3) && null !== q3.child) {
            q3.child.return = q3;
            q3 = q3.child;
            continue;
          }
          if (q3 === a3) break a;
          for (; null === q3.sibling; ) {
            if (null === q3.return || q3.return === a3) break a;
            m4 === q3 && (m4 = null);
            q3 = q3.return;
          }
          m4 === q3 && (m4 = null);
          q3.sibling.return = q3.return;
          q3 = q3.sibling;
        }
      }
      break;
    case 19:
      ck(b3, a3);
      ek(a3);
      d4 & 4 && ak(a3);
      break;
    case 21:
      break;
    default:
      ck(
        b3,
        a3
      ), ek(a3);
  }
}
function ek(a3) {
  var b3 = a3.flags;
  if (b3 & 2) {
    try {
      a: {
        for (var c3 = a3.return; null !== c3; ) {
          if (Tj(c3)) {
            var d4 = c3;
            break a;
          }
          c3 = c3.return;
        }
        throw Error(p$2(160));
      }
      switch (d4.tag) {
        case 5:
          var e3 = d4.stateNode;
          d4.flags & 32 && (ob(e3, ""), d4.flags &= -33);
          var f2 = Uj(a3);
          Wj(a3, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d4.stateNode.containerInfo, h4 = Uj(a3);
          Vj(a3, h4, g2);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k3) {
      W(a3, a3.return, k3);
    }
    a3.flags &= -3;
  }
  b3 & 4096 && (a3.flags &= -4097);
}
function hk(a3, b3, c3) {
  V = a3;
  ik(a3);
}
function ik(a3, b3, c3) {
  for (var d4 = 0 !== (a3.mode & 1); null !== V; ) {
    var e3 = V, f2 = e3.child;
    if (22 === e3.tag && d4) {
      var g2 = null !== e3.memoizedState || Jj;
      if (!g2) {
        var h4 = e3.alternate, k3 = null !== h4 && null !== h4.memoizedState || U$1;
        h4 = Jj;
        var l2 = U$1;
        Jj = g2;
        if ((U$1 = k3) && !l2) for (V = e3; null !== V; ) g2 = V, k3 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e3) : null !== k3 ? (k3.return = g2, V = k3) : jk(e3);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e3;
        Jj = h4;
        U$1 = l2;
      }
      kk(a3);
    } else 0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V = f2) : kk(a3);
  }
}
function kk(a3) {
  for (; null !== V; ) {
    var b3 = V;
    if (0 !== (b3.flags & 8772)) {
      var c3 = b3.alternate;
      try {
        if (0 !== (b3.flags & 8772)) switch (b3.tag) {
          case 0:
          case 11:
          case 15:
            U$1 || Qj(5, b3);
            break;
          case 1:
            var d4 = b3.stateNode;
            if (b3.flags & 4 && !U$1) if (null === c3) d4.componentDidMount();
            else {
              var e3 = b3.elementType === b3.type ? c3.memoizedProps : Ci(b3.type, c3.memoizedProps);
              d4.componentDidUpdate(e3, c3.memoizedState, d4.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b3.updateQueue;
            null !== f2 && sh(b3, f2, d4);
            break;
          case 3:
            var g2 = b3.updateQueue;
            if (null !== g2) {
              c3 = null;
              if (null !== b3.child) switch (b3.child.tag) {
                case 5:
                  c3 = b3.child.stateNode;
                  break;
                case 1:
                  c3 = b3.child.stateNode;
              }
              sh(b3, g2, c3);
            }
            break;
          case 5:
            var h4 = b3.stateNode;
            if (null === c3 && b3.flags & 4) {
              c3 = h4;
              var k3 = b3.memoizedProps;
              switch (b3.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k3.autoFocus && c3.focus();
                  break;
                case "img":
                  k3.src && (c3.src = k3.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b3.memoizedState) {
              var l2 = b3.alternate;
              if (null !== l2) {
                var m4 = l2.memoizedState;
                if (null !== m4) {
                  var q3 = m4.dehydrated;
                  null !== q3 && bd(q3);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$2(163));
        }
        U$1 || b3.flags & 512 && Rj(b3);
      } catch (r2) {
        W(b3, b3.return, r2);
      }
    }
    if (b3 === a3) {
      V = null;
      break;
    }
    c3 = b3.sibling;
    if (null !== c3) {
      c3.return = b3.return;
      V = c3;
      break;
    }
    V = b3.return;
  }
}
function gk(a3) {
  for (; null !== V; ) {
    var b3 = V;
    if (b3 === a3) {
      V = null;
      break;
    }
    var c3 = b3.sibling;
    if (null !== c3) {
      c3.return = b3.return;
      V = c3;
      break;
    }
    V = b3.return;
  }
}
function jk(a3) {
  for (; null !== V; ) {
    var b3 = V;
    try {
      switch (b3.tag) {
        case 0:
        case 11:
        case 15:
          var c3 = b3.return;
          try {
            Qj(4, b3);
          } catch (k3) {
            W(b3, c3, k3);
          }
          break;
        case 1:
          var d4 = b3.stateNode;
          if ("function" === typeof d4.componentDidMount) {
            var e3 = b3.return;
            try {
              d4.componentDidMount();
            } catch (k3) {
              W(b3, e3, k3);
            }
          }
          var f2 = b3.return;
          try {
            Rj(b3);
          } catch (k3) {
            W(b3, f2, k3);
          }
          break;
        case 5:
          var g2 = b3.return;
          try {
            Rj(b3);
          } catch (k3) {
            W(b3, g2, k3);
          }
      }
    } catch (k3) {
      W(b3, b3.return, k3);
    }
    if (b3 === a3) {
      V = null;
      break;
    }
    var h4 = b3.sibling;
    if (null !== h4) {
      h4.return = b3.return;
      V = h4;
      break;
    }
    V = b3.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a3) {
  if (0 === (a3.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a3 = C;
  if (0 !== a3) return a3;
  a3 = window.event;
  a3 = void 0 === a3 ? 16 : jd(a3.type);
  return a3;
}
function gi(a3, b3, c3, d4) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$2(185));
  Ac(a3, c3, d4);
  if (0 === (K & 2) || a3 !== Q) a3 === Q && (0 === (K & 2) && (qk |= c3), 4 === T && Ck(a3, Z)), Dk(a3, d4), 1 === c3 && 0 === K && 0 === (b3.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a3, b3) {
  var c3 = a3.callbackNode;
  wc(a3, b3);
  var d4 = uc(a3, a3 === Q ? Z : 0);
  if (0 === d4) null !== c3 && bc(c3), a3.callbackNode = null, a3.callbackPriority = 0;
  else if (b3 = d4 & -d4, a3.callbackPriority !== b3) {
    null != c3 && bc(c3);
    if (1 === b3) 0 === a3.tag ? ig(Ek.bind(null, a3)) : hg(Ek.bind(null, a3)), Jf(function() {
      0 === (K & 6) && jg();
    }), c3 = null;
    else {
      switch (Dc(d4)) {
        case 1:
          c3 = fc;
          break;
        case 4:
          c3 = gc;
          break;
        case 16:
          c3 = hc;
          break;
        case 536870912:
          c3 = jc;
          break;
        default:
          c3 = hc;
      }
      c3 = Fk(c3, Gk.bind(null, a3));
    }
    a3.callbackPriority = b3;
    a3.callbackNode = c3;
  }
}
function Gk(a3, b3) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$2(327));
  var c3 = a3.callbackNode;
  if (Hk() && a3.callbackNode !== c3) return null;
  var d4 = uc(a3, a3 === Q ? Z : 0);
  if (0 === d4) return null;
  if (0 !== (d4 & 30) || 0 !== (d4 & a3.expiredLanes) || b3) b3 = Ik(a3, d4);
  else {
    b3 = d4;
    var e3 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a3 || Z !== b3) uk = null, Gj = B() + 500, Kk(a3, b3);
    do
      try {
        Lk();
        break;
      } catch (h4) {
        Mk(a3, h4);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e3;
    null !== Y ? b3 = 0 : (Q = null, Z = 0, b3 = T);
  }
  if (0 !== b3) {
    2 === b3 && (e3 = xc(a3), 0 !== e3 && (d4 = e3, b3 = Nk(a3, e3)));
    if (1 === b3) throw c3 = pk, Kk(a3, 0), Ck(a3, d4), Dk(a3, B()), c3;
    if (6 === b3) Ck(a3, d4);
    else {
      e3 = a3.current.alternate;
      if (0 === (d4 & 30) && !Ok(e3) && (b3 = Ik(a3, d4), 2 === b3 && (f2 = xc(a3), 0 !== f2 && (d4 = f2, b3 = Nk(a3, f2))), 1 === b3)) throw c3 = pk, Kk(a3, 0), Ck(a3, d4), Dk(a3, B()), c3;
      a3.finishedWork = e3;
      a3.finishedLanes = d4;
      switch (b3) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Pk(a3, tk, uk);
          break;
        case 3:
          Ck(a3, d4);
          if ((d4 & 130023424) === d4 && (b3 = fk + 500 - B(), 10 < b3)) {
            if (0 !== uc(a3, 0)) break;
            e3 = a3.suspendedLanes;
            if ((e3 & d4) !== d4) {
              R();
              a3.pingedLanes |= a3.suspendedLanes & e3;
              break;
            }
            a3.timeoutHandle = Ff(Pk.bind(null, a3, tk, uk), b3);
            break;
          }
          Pk(a3, tk, uk);
          break;
        case 4:
          Ck(a3, d4);
          if ((d4 & 4194240) === d4) break;
          b3 = a3.eventTimes;
          for (e3 = -1; 0 < d4; ) {
            var g2 = 31 - oc(d4);
            f2 = 1 << g2;
            g2 = b3[g2];
            g2 > e3 && (e3 = g2);
            d4 &= ~f2;
          }
          d4 = e3;
          d4 = B() - d4;
          d4 = (120 > d4 ? 120 : 480 > d4 ? 480 : 1080 > d4 ? 1080 : 1920 > d4 ? 1920 : 3e3 > d4 ? 3e3 : 4320 > d4 ? 4320 : 1960 * lk(d4 / 1960)) - d4;
          if (10 < d4) {
            a3.timeoutHandle = Ff(Pk.bind(null, a3, tk, uk), d4);
            break;
          }
          Pk(a3, tk, uk);
          break;
        case 5:
          Pk(a3, tk, uk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Dk(a3, B());
  return a3.callbackNode === c3 ? Gk.bind(null, a3) : null;
}
function Nk(a3, b3) {
  var c3 = sk;
  a3.current.memoizedState.isDehydrated && (Kk(a3, b3).flags |= 256);
  a3 = Ik(a3, b3);
  2 !== a3 && (b3 = tk, tk = c3, null !== b3 && Fj(b3));
  return a3;
}
function Fj(a3) {
  null === tk ? tk = a3 : tk.push.apply(tk, a3);
}
function Ok(a3) {
  for (var b3 = a3; ; ) {
    if (b3.flags & 16384) {
      var c3 = b3.updateQueue;
      if (null !== c3 && (c3 = c3.stores, null !== c3)) for (var d4 = 0; d4 < c3.length; d4++) {
        var e3 = c3[d4], f2 = e3.getSnapshot;
        e3 = e3.value;
        try {
          if (!He(f2(), e3)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c3 = b3.child;
    if (b3.subtreeFlags & 16384 && null !== c3) c3.return = b3, b3 = c3;
    else {
      if (b3 === a3) break;
      for (; null === b3.sibling; ) {
        if (null === b3.return || b3.return === a3) return true;
        b3 = b3.return;
      }
      b3.sibling.return = b3.return;
      b3 = b3.sibling;
    }
  }
  return true;
}
function Ck(a3, b3) {
  b3 &= ~rk;
  b3 &= ~qk;
  a3.suspendedLanes |= b3;
  a3.pingedLanes &= ~b3;
  for (a3 = a3.expirationTimes; 0 < b3; ) {
    var c3 = 31 - oc(b3), d4 = 1 << c3;
    a3[c3] = -1;
    b3 &= ~d4;
  }
}
function Ek(a3) {
  if (0 !== (K & 6)) throw Error(p$2(327));
  Hk();
  var b3 = uc(a3, 0);
  if (0 === (b3 & 1)) return Dk(a3, B()), null;
  var c3 = Ik(a3, b3);
  if (0 !== a3.tag && 2 === c3) {
    var d4 = xc(a3);
    0 !== d4 && (b3 = d4, c3 = Nk(a3, d4));
  }
  if (1 === c3) throw c3 = pk, Kk(a3, 0), Ck(a3, b3), Dk(a3, B()), c3;
  if (6 === c3) throw Error(p$2(345));
  a3.finishedWork = a3.current.alternate;
  a3.finishedLanes = b3;
  Pk(a3, tk, uk);
  Dk(a3, B());
  return null;
}
function Qk(a3, b3) {
  var c3 = K;
  K |= 1;
  try {
    return a3(b3);
  } finally {
    K = c3, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a3) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b3 = K;
  K |= 1;
  var c3 = ok.transition, d4 = C;
  try {
    if (ok.transition = null, C = 1, a3) return a3();
  } finally {
    C = d4, ok.transition = c3, K = b3, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a3, b3) {
  a3.finishedWork = null;
  a3.finishedLanes = 0;
  var c3 = a3.timeoutHandle;
  -1 !== c3 && (a3.timeoutHandle = -1, Gf(c3));
  if (null !== Y) for (c3 = Y.return; null !== c3; ) {
    var d4 = c3;
    wg(d4);
    switch (d4.tag) {
      case 1:
        d4 = d4.type.childContextTypes;
        null !== d4 && void 0 !== d4 && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d4);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d4.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c3 = c3.return;
  }
  Q = a3;
  Y = a3 = Pg(a3.current, null);
  Z = fj = b3;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b3 = 0; b3 < fh.length; b3++) if (c3 = fh[b3], d4 = c3.interleaved, null !== d4) {
      c3.interleaved = null;
      var e3 = d4.next, f2 = c3.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e3;
        d4.next = g2;
      }
      c3.pending = d4;
    }
    fh = null;
  }
  return a3;
}
function Mk(a3, b3) {
  do {
    var c3 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d4 = M.memoizedState; null !== d4; ) {
          var e3 = d4.queue;
          null !== e3 && (e3.pending = null);
          d4 = d4.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c3 || null === c3.return) {
        T = 1;
        pk = b3;
        Y = null;
        break;
      }
      a: {
        var f2 = a3, g2 = c3.return, h4 = c3, k3 = b3;
        b3 = Z;
        h4.flags |= 32768;
        if (null !== k3 && "object" === typeof k3 && "function" === typeof k3.then) {
          var l2 = k3, m4 = h4, q3 = m4.tag;
          if (0 === (m4.mode & 1) && (0 === q3 || 11 === q3 || 15 === q3)) {
            var r2 = m4.alternate;
            r2 ? (m4.updateQueue = r2.updateQueue, m4.memoizedState = r2.memoizedState, m4.lanes = r2.lanes) : (m4.updateQueue = null, m4.memoizedState = null);
          }
          var y4 = Ui(g2);
          if (null !== y4) {
            y4.flags &= -257;
            Vi(y4, g2, h4, f2, b3);
            y4.mode & 1 && Si(f2, l2, b3);
            b3 = y4;
            k3 = l2;
            var n2 = b3.updateQueue;
            if (null === n2) {
              var t3 = /* @__PURE__ */ new Set();
              t3.add(k3);
              b3.updateQueue = t3;
            } else n2.add(k3);
            break a;
          } else {
            if (0 === (b3 & 1)) {
              Si(f2, l2, b3);
              tj();
              break a;
            }
            k3 = Error(p$2(426));
          }
        } else if (I && h4.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h4, f2, b3);
            Jg(Ji(k3, h4));
            break a;
          }
        }
        f2 = k3 = Ji(k3, h4);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b3 &= -b3;
              f2.lanes |= b3;
              var x3 = Ni(f2, k3, b3);
              ph(f2, x3);
              break a;
            case 1:
              h4 = k3;
              var w3 = f2.type, u3 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Ri || !Ri.has(u3)))) {
                f2.flags |= 65536;
                b3 &= -b3;
                f2.lanes |= b3;
                var F2 = Qi(f2, h4, b3);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c3);
    } catch (na) {
      b3 = na;
      Y === c3 && null !== c3 && (Y = c3 = c3.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a3 = mk.current;
  mk.current = Rh;
  return null === a3 ? Rh : a3;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a3, b3) {
  var c3 = K;
  K |= 2;
  var d4 = Jk();
  if (Q !== a3 || Z !== b3) uk = null, Kk(a3, b3);
  do
    try {
      Tk();
      break;
    } catch (e3) {
      Mk(a3, e3);
    }
  while (1);
  $g();
  K = c3;
  mk.current = d4;
  if (null !== Y) throw Error(p$2(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a3) {
  var b3 = Vk(a3.alternate, a3, fj);
  a3.memoizedProps = a3.pendingProps;
  null === b3 ? Sk(a3) : Y = b3;
  nk.current = null;
}
function Sk(a3) {
  var b3 = a3;
  do {
    var c3 = b3.alternate;
    a3 = b3.return;
    if (0 === (b3.flags & 32768)) {
      if (c3 = Ej(c3, b3, fj), null !== c3) {
        Y = c3;
        return;
      }
    } else {
      c3 = Ij(c3, b3);
      if (null !== c3) {
        c3.flags &= 32767;
        Y = c3;
        return;
      }
      if (null !== a3) a3.flags |= 32768, a3.subtreeFlags = 0, a3.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b3 = b3.sibling;
    if (null !== b3) {
      Y = b3;
      return;
    }
    Y = b3 = a3;
  } while (null !== b3);
  0 === T && (T = 5);
}
function Pk(a3, b3, c3) {
  var d4 = C, e3 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a3, b3, c3, d4);
  } finally {
    ok.transition = e3, C = d4;
  }
  return null;
}
function Wk(a3, b3, c3, d4) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$2(327));
  c3 = a3.finishedWork;
  var e3 = a3.finishedLanes;
  if (null === c3) return null;
  a3.finishedWork = null;
  a3.finishedLanes = 0;
  if (c3 === a3.current) throw Error(p$2(177));
  a3.callbackNode = null;
  a3.callbackPriority = 0;
  var f2 = c3.lanes | c3.childLanes;
  Bc(a3, f2);
  a3 === Q && (Y = Q = null, Z = 0);
  0 === (c3.subtreeFlags & 2064) && 0 === (c3.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c3.flags & 15990);
  if (0 !== (c3.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h4 = K;
    K |= 4;
    nk.current = null;
    Oj(a3, c3);
    dk(c3, a3);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a3.current = c3;
    hk(c3);
    dc();
    K = h4;
    C = g2;
    ok.transition = f2;
  } else a3.current = c3;
  vk && (vk = false, wk = a3, xk = e3);
  f2 = a3.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c3.stateNode);
  Dk(a3, B());
  if (null !== b3) for (d4 = a3.onRecoverableError, c3 = 0; c3 < b3.length; c3++) e3 = b3[c3], d4(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Oi) throw Oi = false, a3 = Pi, Pi = null, a3;
  0 !== (xk & 1) && 0 !== a3.tag && Hk();
  f2 = a3.pendingLanes;
  0 !== (f2 & 1) ? a3 === zk ? yk++ : (yk = 0, zk = a3) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a3 = Dc(xk), b3 = ok.transition, c3 = C;
    try {
      ok.transition = null;
      C = 16 > a3 ? 16 : a3;
      if (null === wk) var d4 = false;
      else {
        a3 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$2(331));
        var e3 = K;
        K |= 4;
        for (V = a3.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h4 = f2.deletions;
            if (null !== h4) {
              for (var k3 = 0; k3 < h4.length; k3++) {
                var l2 = h4[k3];
                for (V = l2; null !== V; ) {
                  var m4 = V;
                  switch (m4.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m4, f2);
                  }
                  var q3 = m4.child;
                  if (null !== q3) q3.return = m4, V = q3;
                  else for (; null !== V; ) {
                    m4 = V;
                    var r2 = m4.sibling, y4 = m4.return;
                    Sj(m4);
                    if (m4 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y4;
                      V = r2;
                      break;
                    }
                    V = y4;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t3 = n2.child;
                if (null !== t3) {
                  n2.child = null;
                  do {
                    var J2 = t3.sibling;
                    t3.sibling = null;
                    t3 = J2;
                  } while (null !== t3);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x3 = f2.sibling;
            if (null !== x3) {
              x3.return = f2.return;
              V = x3;
              break b;
            }
            V = f2.return;
          }
        }
        var w3 = a3.current;
        for (V = w3; null !== V; ) {
          g2 = V;
          var u3 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u3) u3.return = g2, V = u3;
          else b: for (g2 = w3; null !== V; ) {
            h4 = V;
            if (0 !== (h4.flags & 2048)) try {
              switch (h4.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h4);
              }
            } catch (na) {
              W(h4, h4.return, na);
            }
            if (h4 === g2) {
              V = null;
              break b;
            }
            var F2 = h4.sibling;
            if (null !== F2) {
              F2.return = h4.return;
              V = F2;
              break b;
            }
            V = h4.return;
          }
        }
        K = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a3);
        } catch (na) {
        }
        d4 = true;
      }
      return d4;
    } finally {
      C = c3, ok.transition = b3;
    }
  }
  return false;
}
function Xk(a3, b3, c3) {
  b3 = Ji(c3, b3);
  b3 = Ni(a3, b3, 1);
  a3 = nh(a3, b3, 1);
  b3 = R();
  null !== a3 && (Ac(a3, 1, b3), Dk(a3, b3));
}
function W(a3, b3, c3) {
  if (3 === a3.tag) Xk(a3, a3, c3);
  else for (; null !== b3; ) {
    if (3 === b3.tag) {
      Xk(b3, a3, c3);
      break;
    } else if (1 === b3.tag) {
      var d4 = b3.stateNode;
      if ("function" === typeof b3.type.getDerivedStateFromError || "function" === typeof d4.componentDidCatch && (null === Ri || !Ri.has(d4))) {
        a3 = Ji(c3, a3);
        a3 = Qi(b3, a3, 1);
        b3 = nh(b3, a3, 1);
        a3 = R();
        null !== b3 && (Ac(b3, 1, a3), Dk(b3, a3));
        break;
      }
    }
    b3 = b3.return;
  }
}
function Ti(a3, b3, c3) {
  var d4 = a3.pingCache;
  null !== d4 && d4.delete(b3);
  b3 = R();
  a3.pingedLanes |= a3.suspendedLanes & c3;
  Q === a3 && (Z & c3) === c3 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a3, 0) : rk |= c3);
  Dk(a3, b3);
}
function Yk(a3, b3) {
  0 === b3 && (0 === (a3.mode & 1) ? b3 = 1 : (b3 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c3 = R();
  a3 = ih(a3, b3);
  null !== a3 && (Ac(a3, b3, c3), Dk(a3, c3));
}
function uj(a3) {
  var b3 = a3.memoizedState, c3 = 0;
  null !== b3 && (c3 = b3.retryLane);
  Yk(a3, c3);
}
function bk(a3, b3) {
  var c3 = 0;
  switch (a3.tag) {
    case 13:
      var d4 = a3.stateNode;
      var e3 = a3.memoizedState;
      null !== e3 && (c3 = e3.retryLane);
      break;
    case 19:
      d4 = a3.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  null !== d4 && d4.delete(b3);
  Yk(a3, c3);
}
var Vk;
Vk = function(a3, b3, c3) {
  if (null !== a3) if (a3.memoizedProps !== b3.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a3.lanes & c3) && 0 === (b3.flags & 128)) return dh = false, yj(a3, b3, c3);
    dh = 0 !== (a3.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b3.flags & 1048576) && ug(b3, ng, b3.index);
  b3.lanes = 0;
  switch (b3.tag) {
    case 2:
      var d4 = b3.type;
      ij(a3, b3);
      a3 = b3.pendingProps;
      var e3 = Yf(b3, H.current);
      ch(b3, c3);
      e3 = Nh(null, b3, d4, a3, e3, c3);
      var f2 = Sh();
      b3.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b3.tag = 1, b3.memoizedState = null, b3.updateQueue = null, Zf(d4) ? (f2 = true, cg(b3)) : f2 = false, b3.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, kh(b3), e3.updater = Ei, b3.stateNode = e3, e3._reactInternals = b3, Ii(b3, d4, a3, c3), b3 = jj(null, b3, d4, true, f2, c3)) : (b3.tag = 0, I && f2 && vg(b3), Xi(null, b3, e3, c3), b3 = b3.child);
      return b3;
    case 16:
      d4 = b3.elementType;
      a: {
        ij(a3, b3);
        a3 = b3.pendingProps;
        e3 = d4._init;
        d4 = e3(d4._payload);
        b3.type = d4;
        e3 = b3.tag = Zk(d4);
        a3 = Ci(d4, a3);
        switch (e3) {
          case 0:
            b3 = cj(null, b3, d4, a3, c3);
            break a;
          case 1:
            b3 = hj(null, b3, d4, a3, c3);
            break a;
          case 11:
            b3 = Yi(null, b3, d4, a3, c3);
            break a;
          case 14:
            b3 = $i(null, b3, d4, Ci(d4.type, a3), c3);
            break a;
        }
        throw Error(p$2(
          306,
          d4,
          ""
        ));
      }
      return b3;
    case 0:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Ci(d4, e3), cj(a3, b3, d4, e3, c3);
    case 1:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Ci(d4, e3), hj(a3, b3, d4, e3, c3);
    case 3:
      a: {
        kj(b3);
        if (null === a3) throw Error(p$2(387));
        d4 = b3.pendingProps;
        f2 = b3.memoizedState;
        e3 = f2.element;
        lh(a3, b3);
        qh(b3, d4, null, c3);
        var g2 = b3.memoizedState;
        d4 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d4, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b3.updateQueue.baseState = f2, b3.memoizedState = f2, b3.flags & 256) {
          e3 = Ji(Error(p$2(423)), b3);
          b3 = lj(a3, b3, d4, c3, e3);
          break a;
        } else if (d4 !== e3) {
          e3 = Ji(Error(p$2(424)), b3);
          b3 = lj(a3, b3, d4, c3, e3);
          break a;
        } else for (yg = Lf(b3.stateNode.containerInfo.firstChild), xg = b3, I = true, zg = null, c3 = Vg(b3, null, d4, c3), b3.child = c3; c3; ) c3.flags = c3.flags & -3 | 4096, c3 = c3.sibling;
        else {
          Ig();
          if (d4 === e3) {
            b3 = Zi(a3, b3, c3);
            break a;
          }
          Xi(a3, b3, d4, c3);
        }
        b3 = b3.child;
      }
      return b3;
    case 5:
      return Ah(b3), null === a3 && Eg(b3), d4 = b3.type, e3 = b3.pendingProps, f2 = null !== a3 ? a3.memoizedProps : null, g2 = e3.children, Ef(d4, e3) ? g2 = null : null !== f2 && Ef(d4, f2) && (b3.flags |= 32), gj(a3, b3), Xi(a3, b3, g2, c3), b3.child;
    case 6:
      return null === a3 && Eg(b3), null;
    case 13:
      return oj(a3, b3, c3);
    case 4:
      return yh(b3, b3.stateNode.containerInfo), d4 = b3.pendingProps, null === a3 ? b3.child = Ug(b3, null, d4, c3) : Xi(a3, b3, d4, c3), b3.child;
    case 11:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Ci(d4, e3), Yi(a3, b3, d4, e3, c3);
    case 7:
      return Xi(a3, b3, b3.pendingProps, c3), b3.child;
    case 8:
      return Xi(a3, b3, b3.pendingProps.children, c3), b3.child;
    case 12:
      return Xi(a3, b3, b3.pendingProps.children, c3), b3.child;
    case 10:
      a: {
        d4 = b3.type._context;
        e3 = b3.pendingProps;
        f2 = b3.memoizedProps;
        g2 = e3.value;
        G(Wg, d4._currentValue);
        d4._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e3.children && !Wf.current) {
            b3 = Zi(a3, b3, c3);
            break a;
          }
        } else for (f2 = b3.child, null !== f2 && (f2.return = b3); null !== f2; ) {
          var h4 = f2.dependencies;
          if (null !== h4) {
            g2 = f2.child;
            for (var k3 = h4.firstContext; null !== k3; ) {
              if (k3.context === d4) {
                if (1 === f2.tag) {
                  k3 = mh(-1, c3 & -c3);
                  k3.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m4 = l2.pending;
                    null === m4 ? k3.next = k3 : (k3.next = m4.next, m4.next = k3);
                    l2.pending = k3;
                  }
                }
                f2.lanes |= c3;
                k3 = f2.alternate;
                null !== k3 && (k3.lanes |= c3);
                bh(
                  f2.return,
                  c3,
                  b3
                );
                h4.lanes |= c3;
                break;
              }
              k3 = k3.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b3.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$2(341));
            g2.lanes |= c3;
            h4 = g2.alternate;
            null !== h4 && (h4.lanes |= c3);
            bh(g2, c3, b3);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b3) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a3, b3, e3.children, c3);
        b3 = b3.child;
      }
      return b3;
    case 9:
      return e3 = b3.type, d4 = b3.pendingProps.children, ch(b3, c3), e3 = eh(e3), d4 = d4(e3), b3.flags |= 1, Xi(a3, b3, d4, c3), b3.child;
    case 14:
      return d4 = b3.type, e3 = Ci(d4, b3.pendingProps), e3 = Ci(d4.type, e3), $i(a3, b3, d4, e3, c3);
    case 15:
      return bj(a3, b3, b3.type, b3.pendingProps, c3);
    case 17:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Ci(d4, e3), ij(a3, b3), b3.tag = 1, Zf(d4) ? (a3 = true, cg(b3)) : a3 = false, ch(b3, c3), Gi(b3, d4, e3), Ii(b3, d4, e3, c3), jj(null, b3, d4, true, a3, c3);
    case 19:
      return xj(a3, b3, c3);
    case 22:
      return dj(a3, b3, c3);
  }
  throw Error(p$2(156, b3.tag));
};
function Fk(a3, b3) {
  return ac(a3, b3);
}
function $k(a3, b3, c3, d4) {
  this.tag = a3;
  this.key = c3;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b3;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d4;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a3, b3, c3, d4) {
  return new $k(a3, b3, c3, d4);
}
function aj(a3) {
  a3 = a3.prototype;
  return !(!a3 || !a3.isReactComponent);
}
function Zk(a3) {
  if ("function" === typeof a3) return aj(a3) ? 1 : 0;
  if (void 0 !== a3 && null !== a3) {
    a3 = a3.$$typeof;
    if (a3 === Da) return 11;
    if (a3 === Ga) return 14;
  }
  return 2;
}
function Pg(a3, b3) {
  var c3 = a3.alternate;
  null === c3 ? (c3 = Bg(a3.tag, b3, a3.key, a3.mode), c3.elementType = a3.elementType, c3.type = a3.type, c3.stateNode = a3.stateNode, c3.alternate = a3, a3.alternate = c3) : (c3.pendingProps = b3, c3.type = a3.type, c3.flags = 0, c3.subtreeFlags = 0, c3.deletions = null);
  c3.flags = a3.flags & 14680064;
  c3.childLanes = a3.childLanes;
  c3.lanes = a3.lanes;
  c3.child = a3.child;
  c3.memoizedProps = a3.memoizedProps;
  c3.memoizedState = a3.memoizedState;
  c3.updateQueue = a3.updateQueue;
  b3 = a3.dependencies;
  c3.dependencies = null === b3 ? null : { lanes: b3.lanes, firstContext: b3.firstContext };
  c3.sibling = a3.sibling;
  c3.index = a3.index;
  c3.ref = a3.ref;
  return c3;
}
function Rg(a3, b3, c3, d4, e3, f2) {
  var g2 = 2;
  d4 = a3;
  if ("function" === typeof a3) aj(a3) && (g2 = 1);
  else if ("string" === typeof a3) g2 = 5;
  else a: switch (a3) {
    case ya:
      return Tg(c3.children, e3, f2, b3);
    case za:
      g2 = 8;
      e3 |= 8;
      break;
    case Aa:
      return a3 = Bg(12, c3, b3, e3 | 2), a3.elementType = Aa, a3.lanes = f2, a3;
    case Ea:
      return a3 = Bg(13, c3, b3, e3), a3.elementType = Ea, a3.lanes = f2, a3;
    case Fa:
      return a3 = Bg(19, c3, b3, e3), a3.elementType = Fa, a3.lanes = f2, a3;
    case Ia:
      return pj(c3, e3, f2, b3);
    default:
      if ("object" === typeof a3 && null !== a3) switch (a3.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d4 = null;
          break a;
      }
      throw Error(p$2(130, null == a3 ? a3 : typeof a3, ""));
  }
  b3 = Bg(g2, c3, b3, e3);
  b3.elementType = a3;
  b3.type = d4;
  b3.lanes = f2;
  return b3;
}
function Tg(a3, b3, c3, d4) {
  a3 = Bg(7, a3, d4, b3);
  a3.lanes = c3;
  return a3;
}
function pj(a3, b3, c3, d4) {
  a3 = Bg(22, a3, d4, b3);
  a3.elementType = Ia;
  a3.lanes = c3;
  a3.stateNode = { isHidden: false };
  return a3;
}
function Qg(a3, b3, c3) {
  a3 = Bg(6, a3, null, b3);
  a3.lanes = c3;
  return a3;
}
function Sg(a3, b3, c3) {
  b3 = Bg(4, null !== a3.children ? a3.children : [], a3.key, b3);
  b3.lanes = c3;
  b3.stateNode = { containerInfo: a3.containerInfo, pendingChildren: null, implementation: a3.implementation };
  return b3;
}
function al(a3, b3, c3, d4, e3) {
  this.tag = b3;
  this.containerInfo = a3;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d4;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a3, b3, c3, d4, e3, f2, g2, h4, k3) {
  a3 = new al(a3, b3, c3, h4, k3);
  1 === b3 ? (b3 = 1, true === f2 && (b3 |= 8)) : b3 = 0;
  f2 = Bg(3, null, null, b3);
  a3.current = f2;
  f2.stateNode = a3;
  f2.memoizedState = { element: d4, isDehydrated: c3, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a3;
}
function cl(a3, b3, c3) {
  var d4 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d4 ? null : "" + d4, children: a3, containerInfo: b3, implementation: c3 };
}
function dl(a3) {
  if (!a3) return Vf;
  a3 = a3._reactInternals;
  a: {
    if (Vb(a3) !== a3 || 1 !== a3.tag) throw Error(p$2(170));
    var b3 = a3;
    do {
      switch (b3.tag) {
        case 3:
          b3 = b3.stateNode.context;
          break a;
        case 1:
          if (Zf(b3.type)) {
            b3 = b3.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b3 = b3.return;
    } while (null !== b3);
    throw Error(p$2(171));
  }
  if (1 === a3.tag) {
    var c3 = a3.type;
    if (Zf(c3)) return bg(a3, c3, b3);
  }
  return b3;
}
function el(a3, b3, c3, d4, e3, f2, g2, h4, k3) {
  a3 = bl(c3, d4, true, a3, e3, f2, g2, h4, k3);
  a3.context = dl(null);
  c3 = a3.current;
  d4 = R();
  e3 = yi(c3);
  f2 = mh(d4, e3);
  f2.callback = void 0 !== b3 && null !== b3 ? b3 : null;
  nh(c3, f2, e3);
  a3.current.lanes = e3;
  Ac(a3, e3, d4);
  Dk(a3, d4);
  return a3;
}
function fl(a3, b3, c3, d4) {
  var e3 = b3.current, f2 = R(), g2 = yi(e3);
  c3 = dl(c3);
  null === b3.context ? b3.context = c3 : b3.pendingContext = c3;
  b3 = mh(f2, g2);
  b3.payload = { element: a3 };
  d4 = void 0 === d4 ? null : d4;
  null !== d4 && (b3.callback = d4);
  a3 = nh(e3, b3, g2);
  null !== a3 && (gi(a3, e3, g2, f2), oh(a3, e3, g2));
  return g2;
}
function gl(a3) {
  a3 = a3.current;
  if (!a3.child) return null;
  switch (a3.child.tag) {
    case 5:
      return a3.child.stateNode;
    default:
      return a3.child.stateNode;
  }
}
function hl(a3, b3) {
  a3 = a3.memoizedState;
  if (null !== a3 && null !== a3.dehydrated) {
    var c3 = a3.retryLane;
    a3.retryLane = 0 !== c3 && c3 < b3 ? c3 : b3;
  }
}
function il(a3, b3) {
  hl(a3, b3);
  (a3 = a3.alternate) && hl(a3, b3);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a3) {
  console.error(a3);
};
function ll(a3) {
  this._internalRoot = a3;
}
ml.prototype.render = ll.prototype.render = function(a3) {
  var b3 = this._internalRoot;
  if (null === b3) throw Error(p$2(409));
  fl(a3, b3, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a3 = this._internalRoot;
  if (null !== a3) {
    this._internalRoot = null;
    var b3 = a3.containerInfo;
    Rk(function() {
      fl(null, a3, null, null);
    });
    b3[uf] = null;
  }
};
function ml(a3) {
  this._internalRoot = a3;
}
ml.prototype.unstable_scheduleHydration = function(a3) {
  if (a3) {
    var b3 = Hc();
    a3 = { blockedOn: null, target: a3, priority: b3 };
    for (var c3 = 0; c3 < Qc.length && 0 !== b3 && b3 < Qc[c3].priority; c3++) ;
    Qc.splice(c3, 0, a3);
    0 === c3 && Vc(a3);
  }
};
function nl(a3) {
  return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType);
}
function ol(a3) {
  return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType && (8 !== a3.nodeType || " react-mount-point-unstable " !== a3.nodeValue));
}
function pl() {
}
function ql(a3, b3, c3, d4, e3) {
  if (e3) {
    if ("function" === typeof d4) {
      var f2 = d4;
      d4 = function() {
        var a4 = gl(g2);
        f2.call(a4);
      };
    }
    var g2 = el(b3, d4, a3, 0, null, false, false, "", pl);
    a3._reactRootContainer = g2;
    a3[uf] = g2.current;
    sf(8 === a3.nodeType ? a3.parentNode : a3);
    Rk();
    return g2;
  }
  for (; e3 = a3.lastChild; ) a3.removeChild(e3);
  if ("function" === typeof d4) {
    var h4 = d4;
    d4 = function() {
      var a4 = gl(k3);
      h4.call(a4);
    };
  }
  var k3 = bl(a3, 0, false, null, null, false, false, "", pl);
  a3._reactRootContainer = k3;
  a3[uf] = k3.current;
  sf(8 === a3.nodeType ? a3.parentNode : a3);
  Rk(function() {
    fl(b3, k3, c3, d4);
  });
  return k3;
}
function rl(a3, b3, c3, d4, e3) {
  var f2 = c3._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h4 = e3;
      e3 = function() {
        var a4 = gl(g2);
        h4.call(a4);
      };
    }
    fl(b3, g2, a3, e3);
  } else g2 = ql(c3, b3, a3, e3, d4);
  return gl(g2);
}
Ec = function(a3) {
  switch (a3.tag) {
    case 3:
      var b3 = a3.stateNode;
      if (b3.current.memoizedState.isDehydrated) {
        var c3 = tc(b3.pendingLanes);
        0 !== c3 && (Cc(b3, c3 | 1), Dk(b3, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b4 = ih(a3, 1);
        if (null !== b4) {
          var c4 = R();
          gi(b4, a3, 1, c4);
        }
      }), il(a3, 1);
  }
};
Fc = function(a3) {
  if (13 === a3.tag) {
    var b3 = ih(a3, 134217728);
    if (null !== b3) {
      var c3 = R();
      gi(b3, a3, 134217728, c3);
    }
    il(a3, 134217728);
  }
};
Gc = function(a3) {
  if (13 === a3.tag) {
    var b3 = yi(a3), c3 = ih(a3, b3);
    if (null !== c3) {
      var d4 = R();
      gi(c3, a3, b3, d4);
    }
    il(a3, b3);
  }
};
Hc = function() {
  return C;
};
Ic = function(a3, b3) {
  var c3 = C;
  try {
    return C = a3, b3();
  } finally {
    C = c3;
  }
};
yb = function(a3, b3, c3) {
  switch (b3) {
    case "input":
      bb(a3, c3);
      b3 = c3.name;
      if ("radio" === c3.type && null != b3) {
        for (c3 = a3; c3.parentNode; ) c3 = c3.parentNode;
        c3 = c3.querySelectorAll("input[name=" + JSON.stringify("" + b3) + '][type="radio"]');
        for (b3 = 0; b3 < c3.length; b3++) {
          var d4 = c3[b3];
          if (d4 !== a3 && d4.form === a3.form) {
            var e3 = Db(d4);
            if (!e3) throw Error(p$2(90));
            Wa(d4);
            bb(d4, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a3, c3);
      break;
    case "select":
      b3 = c3.value, null != b3 && fb(a3, !!c3.multiple, b3, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a3) {
  a3 = Zb(a3);
  return null === a3 ? null : a3.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a3) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a3, b3) {
  var c3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b3)) throw Error(p$2(200));
  return cl(a3, b3, null, c3);
};
reactDom_production_min.createRoot = function(a3, b3) {
  if (!nl(a3)) throw Error(p$2(299));
  var c3 = false, d4 = "", e3 = kl;
  null !== b3 && void 0 !== b3 && (true === b3.unstable_strictMode && (c3 = true), void 0 !== b3.identifierPrefix && (d4 = b3.identifierPrefix), void 0 !== b3.onRecoverableError && (e3 = b3.onRecoverableError));
  b3 = bl(a3, 1, false, null, null, c3, false, d4, e3);
  a3[uf] = b3.current;
  sf(8 === a3.nodeType ? a3.parentNode : a3);
  return new ll(b3);
};
reactDom_production_min.findDOMNode = function(a3) {
  if (null == a3) return null;
  if (1 === a3.nodeType) return a3;
  var b3 = a3._reactInternals;
  if (void 0 === b3) {
    if ("function" === typeof a3.render) throw Error(p$2(188));
    a3 = Object.keys(a3).join(",");
    throw Error(p$2(268, a3));
  }
  a3 = Zb(b3);
  a3 = null === a3 ? null : a3.stateNode;
  return a3;
};
reactDom_production_min.flushSync = function(a3) {
  return Rk(a3);
};
reactDom_production_min.hydrate = function(a3, b3, c3) {
  if (!ol(b3)) throw Error(p$2(200));
  return rl(null, a3, b3, true, c3);
};
reactDom_production_min.hydrateRoot = function(a3, b3, c3) {
  if (!nl(a3)) throw Error(p$2(405));
  var d4 = null != c3 && c3.hydratedSources || null, e3 = false, f2 = "", g2 = kl;
  null !== c3 && void 0 !== c3 && (true === c3.unstable_strictMode && (e3 = true), void 0 !== c3.identifierPrefix && (f2 = c3.identifierPrefix), void 0 !== c3.onRecoverableError && (g2 = c3.onRecoverableError));
  b3 = el(b3, null, a3, 1, null != c3 ? c3 : null, e3, false, f2, g2);
  a3[uf] = b3.current;
  sf(a3);
  if (d4) for (a3 = 0; a3 < d4.length; a3++) c3 = d4[a3], e3 = c3._getVersion, e3 = e3(c3._source), null == b3.mutableSourceEagerHydrationData ? b3.mutableSourceEagerHydrationData = [c3, e3] : b3.mutableSourceEagerHydrationData.push(
    c3,
    e3
  );
  return new ml(b3);
};
reactDom_production_min.render = function(a3, b3, c3) {
  if (!ol(b3)) throw Error(p$2(200));
  return rl(null, a3, b3, false, c3);
};
reactDom_production_min.unmountComponentAtNode = function(a3) {
  if (!ol(a3)) throw Error(p$2(40));
  return a3._reactRootContainer ? (Rk(function() {
    rl(null, null, a3, false, function() {
      a3._reactRootContainer = null;
      a3[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a3, b3, c3, d4) {
  if (!ol(c3)) throw Error(p$2(200));
  if (null == a3 || void 0 === a3._reactInternals) throw Error(p$2(38));
  return rl(a3, b3, c3, false, d4);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactDOM
}, [reactDomExports]);
var Ct = (s3) => {
  switch (s3) {
    case "success":
      return $t;
    case "info":
      return _t;
    case "warning":
      return Wt;
    case "error":
      return Ut;
    default:
      return null;
  }
}, Ft = Array(12).fill(0), It = ({ visible: s3 }) => React.createElement("div", { className: "sonner-loading-wrapper", "data-visible": s3 }, React.createElement("div", { className: "sonner-spinner" }, Ft.map((o, t3) => React.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${t3}` })))), $t = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), Wt = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), _t = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), Ut = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" }));
var Dt = () => {
  let [s3, o] = React.useState(document.hidden);
  return React.useEffect(() => {
    let t3 = () => {
      o(document.hidden);
    };
    return document.addEventListener("visibilitychange", t3), () => window.removeEventListener("visibilitychange", t3);
  }, []), s3;
};
var ct = 1, ut = class {
  constructor() {
    this.subscribe = (o) => (this.subscribers.push(o), () => {
      let t3 = this.subscribers.indexOf(o);
      this.subscribers.splice(t3, 1);
    });
    this.publish = (o) => {
      this.subscribers.forEach((t3) => t3(o));
    };
    this.addToast = (o) => {
      this.publish(o), this.toasts = [...this.toasts, o];
    };
    this.create = (o) => {
      var b3;
      let { message: t3, ...n2 } = o, h4 = typeof (o == null ? void 0 : o.id) == "number" || ((b3 = o.id) == null ? void 0 : b3.length) > 0 ? o.id : ct++, u3 = this.toasts.find((d4) => d4.id === h4), g2 = o.dismissible === void 0 ? true : o.dismissible;
      return u3 ? this.toasts = this.toasts.map((d4) => d4.id === h4 ? (this.publish({ ...d4, ...o, id: h4, title: t3 }), { ...d4, ...o, id: h4, dismissible: g2, title: t3 }) : d4) : this.addToast({ title: t3, ...n2, dismissible: g2, id: h4 }), h4;
    };
    this.dismiss = (o) => (o || this.toasts.forEach((t3) => {
      this.subscribers.forEach((n2) => n2({ id: t3.id, dismiss: true }));
    }), this.subscribers.forEach((t3) => t3({ id: o, dismiss: true })), o);
    this.message = (o, t3) => this.create({ ...t3, message: o });
    this.error = (o, t3) => this.create({ ...t3, message: o, type: "error" });
    this.success = (o, t3) => this.create({ ...t3, type: "success", message: o });
    this.info = (o, t3) => this.create({ ...t3, type: "info", message: o });
    this.warning = (o, t3) => this.create({ ...t3, type: "warning", message: o });
    this.loading = (o, t3) => this.create({ ...t3, type: "loading", message: o });
    this.promise = (o, t3) => {
      if (!t3) return;
      let n2;
      t3.loading !== void 0 && (n2 = this.create({ ...t3, promise: o, type: "loading", message: t3.loading, description: typeof t3.description != "function" ? t3.description : void 0 }));
      let h4 = o instanceof Promise ? o : o(), u3 = n2 !== void 0;
      return h4.then(async (g2) => {
        if (Ot(g2) && !g2.ok) {
          u3 = false;
          let b3 = typeof t3.error == "function" ? await t3.error(`HTTP error! status: ${g2.status}`) : t3.error, d4 = typeof t3.description == "function" ? await t3.description(`HTTP error! status: ${g2.status}`) : t3.description;
          this.create({ id: n2, type: "error", message: b3, description: d4 });
        } else if (t3.success !== void 0) {
          u3 = false;
          let b3 = typeof t3.success == "function" ? await t3.success(g2) : t3.success, d4 = typeof t3.description == "function" ? await t3.description(g2) : t3.description;
          this.create({ id: n2, type: "success", message: b3, description: d4 });
        }
      }).catch(async (g2) => {
        if (t3.error !== void 0) {
          u3 = false;
          let b3 = typeof t3.error == "function" ? await t3.error(g2) : t3.error, d4 = typeof t3.description == "function" ? await t3.description(g2) : t3.description;
          this.create({ id: n2, type: "error", message: b3, description: d4 });
        }
      }).finally(() => {
        var g2;
        u3 && (this.dismiss(n2), n2 = void 0), (g2 = t3.finally) == null || g2.call(t3);
      }), n2;
    };
    this.custom = (o, t3) => {
      let n2 = (t3 == null ? void 0 : t3.id) || ct++;
      return this.create({ jsx: o(n2), id: n2, ...t3 }), n2;
    };
    this.subscribers = [], this.toasts = [];
  }
}, v$2 = new ut(), Vt = (s3, o) => {
  let t3 = (o == null ? void 0 : o.id) || ct++;
  return v$2.addToast({ title: s3, ...o, id: t3 }), t3;
}, Ot = (s3) => s3 && typeof s3 == "object" && "ok" in s3 && typeof s3.ok == "boolean" && "status" in s3 && typeof s3.status == "number", Kt = Vt, Xt = () => v$2.toasts, Jt = Object.assign(Kt, { success: v$2.success, info: v$2.info, warning: v$2.warning, error: v$2.error, custom: v$2.custom, message: v$2.message, promise: v$2.promise, dismiss: v$2.dismiss, loading: v$2.loading }, { getHistory: Xt });
function ft(s3, { insertAt: o } = {}) {
  if (typeof document == "undefined") return;
  let t3 = document.head || document.getElementsByTagName("head")[0], n2 = document.createElement("style");
  n2.type = "text/css", o === "top" && t3.firstChild ? t3.insertBefore(n2, t3.firstChild) : t3.appendChild(n2), n2.styleSheet ? n2.styleSheet.cssText = s3 : n2.appendChild(document.createTextNode(s3));
}
ft(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}:where([data-sonner-toaster][data-x-position="right"]){right:max(var(--offset),env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position="left"]){left:max(var(--offset),env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:max(var(--offset),env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:max(var(--offset),env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:0;right:0;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function U(s3) {
  return s3.label !== void 0;
}
var qt = 3, Qt = "32px", Zt = 4e3, te = 356, ee = 14, oe = 20, ae = 200;
function ne(...s3) {
  return s3.filter(Boolean).join(" ");
}
var se = (s3) => {
  var yt, xt, vt, wt, Tt, St, Rt, Et, Nt, Pt;
  let { invert: o, toast: t3, unstyled: n2, interacting: h4, setHeights: u3, visibleToasts: g2, heights: b3, index: d4, toasts: q3, expanded: $, removeToast: V2, defaultRichColors: Q3, closeButton: i2, style: O3, cancelButtonStyle: K3, actionButtonStyle: Z2, className: tt = "", descriptionClassName: et = "", duration: X3, position: ot, gap: w3, loadingIcon: j, expandByDefault: W2, classNames: r2, icons: I3, closeButtonAriaLabel: at = "Close toast", pauseWhenPageIsHidden: k3, cn: T3 } = s3, [z3, nt] = React.useState(false), [D3, H4] = React.useState(false), [st, N2] = React.useState(false), [M4, rt] = React.useState(false), [c3, m4] = React.useState(0), [y4, S4] = React.useState(0), A2 = React.useRef(null), l2 = React.useRef(null), _ = d4 === 0, J2 = d4 + 1 <= g2, x3 = t3.type, P2 = t3.dismissible !== false, Mt = t3.className || "", At = t3.descriptionClassName || "", G3 = React.useMemo(() => b3.findIndex((a3) => a3.toastId === t3.id) || 0, [b3, t3.id]), Lt = React.useMemo(() => {
    var a3;
    return (a3 = t3.closeButton) != null ? a3 : i2;
  }, [t3.closeButton, i2]), mt = React.useMemo(() => t3.duration || X3 || Zt, [t3.duration, X3]), it = React.useRef(0), Y3 = React.useRef(0), pt = React.useRef(0), F2 = React.useRef(null), [gt, zt] = ot.split("-"), ht = React.useMemo(() => b3.reduce((a3, f2, p2) => p2 >= G3 ? a3 : a3 + f2.height, 0), [b3, G3]), bt = Dt(), jt = t3.invert || o, lt = x3 === "loading";
  Y3.current = React.useMemo(() => G3 * w3 + ht, [G3, ht]), React.useEffect(() => {
    nt(true);
  }, []), React.useLayoutEffect(() => {
    if (!z3) return;
    let a3 = l2.current, f2 = a3.style.height;
    a3.style.height = "auto";
    let p2 = a3.getBoundingClientRect().height;
    a3.style.height = f2, S4(p2), u3((B3) => B3.find((R3) => R3.toastId === t3.id) ? B3.map((R3) => R3.toastId === t3.id ? { ...R3, height: p2 } : R3) : [{ toastId: t3.id, height: p2, position: t3.position }, ...B3]);
  }, [z3, t3.title, t3.description, u3, t3.id]);
  let L3 = React.useCallback(() => {
    H4(true), m4(Y3.current), u3((a3) => a3.filter((f2) => f2.toastId !== t3.id)), setTimeout(() => {
      V2(t3);
    }, ae);
  }, [t3, V2, u3, Y3]);
  React.useEffect(() => {
    if (t3.promise && x3 === "loading" || t3.duration === 1 / 0 || t3.type === "loading") return;
    let a3, f2 = mt;
    return $ || h4 || k3 && bt ? (() => {
      if (pt.current < it.current) {
        let C2 = (/* @__PURE__ */ new Date()).getTime() - it.current;
        f2 = f2 - C2;
      }
      pt.current = (/* @__PURE__ */ new Date()).getTime();
    })() : (() => {
      f2 !== 1 / 0 && (it.current = (/* @__PURE__ */ new Date()).getTime(), a3 = setTimeout(() => {
        var C2;
        (C2 = t3.onAutoClose) == null || C2.call(t3, t3), L3();
      }, f2));
    })(), () => clearTimeout(a3);
  }, [$, h4, W2, t3, mt, L3, t3.promise, x3, k3, bt]), React.useEffect(() => {
    let a3 = l2.current;
    if (a3) {
      let f2 = a3.getBoundingClientRect().height;
      return S4(f2), u3((p2) => [{ toastId: t3.id, height: f2, position: t3.position }, ...p2]), () => u3((p2) => p2.filter((B3) => B3.toastId !== t3.id));
    }
  }, [u3, t3.id]), React.useEffect(() => {
    t3.delete && L3();
  }, [L3, t3.delete]);
  function Yt() {
    return I3 != null && I3.loading ? React.createElement("div", { className: "sonner-loader", "data-visible": x3 === "loading" }, I3.loading) : j ? React.createElement("div", { className: "sonner-loader", "data-visible": x3 === "loading" }, j) : React.createElement(It, { visible: x3 === "loading" });
  }
  return React.createElement("li", { "aria-live": t3.important ? "assertive" : "polite", "aria-atomic": "true", role: "status", tabIndex: 0, ref: l2, className: T3(tt, Mt, r2 == null ? void 0 : r2.toast, (yt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : yt.toast, r2 == null ? void 0 : r2.default, r2 == null ? void 0 : r2[x3], (xt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : xt[x3]), "data-sonner-toast": "", "data-rich-colors": (vt = t3.richColors) != null ? vt : Q3, "data-styled": !(t3.jsx || t3.unstyled || n2), "data-mounted": z3, "data-promise": !!t3.promise, "data-removed": D3, "data-visible": J2, "data-y-position": gt, "data-x-position": zt, "data-index": d4, "data-front": _, "data-swiping": st, "data-dismissible": P2, "data-type": x3, "data-invert": jt, "data-swipe-out": M4, "data-expanded": !!($ || W2 && z3), style: { "--index": d4, "--toasts-before": d4, "--z-index": q3.length - d4, "--offset": `${D3 ? c3 : Y3.current}px`, "--initial-height": W2 ? "auto" : `${y4}px`, ...O3, ...t3.style }, onPointerDown: (a3) => {
    lt || !P2 || (A2.current = /* @__PURE__ */ new Date(), m4(Y3.current), a3.target.setPointerCapture(a3.pointerId), a3.target.tagName !== "BUTTON" && (N2(true), F2.current = { x: a3.clientX, y: a3.clientY }));
  }, onPointerUp: () => {
    var B3, C2, R3, dt;
    if (M4 || !P2) return;
    F2.current = null;
    let a3 = Number(((B3 = l2.current) == null ? void 0 : B3.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0), f2 = (/* @__PURE__ */ new Date()).getTime() - ((C2 = A2.current) == null ? void 0 : C2.getTime()), p2 = Math.abs(a3) / f2;
    if (Math.abs(a3) >= oe || p2 > 0.11) {
      m4(Y3.current), (R3 = t3.onDismiss) == null || R3.call(t3, t3), L3(), rt(true);
      return;
    }
    (dt = l2.current) == null || dt.style.setProperty("--swipe-amount", "0px"), N2(false);
  }, onPointerMove: (a3) => {
    var Bt;
    if (!F2.current || !P2) return;
    let f2 = a3.clientY - F2.current.y, p2 = a3.clientX - F2.current.x, C2 = (gt === "top" ? Math.min : Math.max)(0, f2), R3 = a3.pointerType === "touch" ? 10 : 2;
    Math.abs(C2) > R3 ? (Bt = l2.current) == null || Bt.style.setProperty("--swipe-amount", `${f2}px`) : Math.abs(p2) > R3 && (F2.current = null);
  } }, Lt && !t3.jsx ? React.createElement("button", { "aria-label": at, "data-disabled": lt, "data-close-button": true, onClick: lt || !P2 ? () => {
  } : () => {
    var a3;
    L3(), (a3 = t3.onDismiss) == null || a3.call(t3, t3);
  }, className: T3(r2 == null ? void 0 : r2.closeButton, (wt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : wt.closeButton) }, React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), React.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }))) : null, t3.jsx || React.isValidElement(t3.title) ? t3.jsx || t3.title : React.createElement(React.Fragment, null, x3 || t3.icon || t3.promise ? React.createElement("div", { "data-icon": "", className: T3(r2 == null ? void 0 : r2.icon, (Tt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Tt.icon) }, t3.promise || t3.type === "loading" && !t3.icon ? t3.icon || Yt() : null, t3.type !== "loading" ? t3.icon || (I3 == null ? void 0 : I3[x3]) || Ct(x3) : null) : null, React.createElement("div", { "data-content": "", className: T3(r2 == null ? void 0 : r2.content, (St = t3 == null ? void 0 : t3.classNames) == null ? void 0 : St.content) }, React.createElement("div", { "data-title": "", className: T3(r2 == null ? void 0 : r2.title, (Rt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Rt.title) }, t3.title), t3.description ? React.createElement("div", { "data-description": "", className: T3(et, At, r2 == null ? void 0 : r2.description, (Et = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Et.description) }, t3.description) : null), React.isValidElement(t3.cancel) ? t3.cancel : t3.cancel && U(t3.cancel) ? React.createElement("button", { "data-button": true, "data-cancel": true, style: t3.cancelButtonStyle || K3, onClick: (a3) => {
    var f2, p2;
    U(t3.cancel) && P2 && ((p2 = (f2 = t3.cancel).onClick) == null || p2.call(f2, a3), L3());
  }, className: T3(r2 == null ? void 0 : r2.cancelButton, (Nt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Nt.cancelButton) }, t3.cancel.label) : null, React.isValidElement(t3.action) ? t3.action : t3.action && U(t3.action) ? React.createElement("button", { "data-button": true, "data-action": true, style: t3.actionButtonStyle || Z2, onClick: (a3) => {
    var f2, p2;
    U(t3.action) && (a3.defaultPrevented || ((p2 = (f2 = t3.action).onClick) == null || p2.call(f2, a3), L3()));
  }, className: T3(r2 == null ? void 0 : r2.actionButton, (Pt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Pt.actionButton) }, t3.action.label) : null));
};
function Ht() {
  if (typeof window == "undefined" || typeof document == "undefined") return "ltr";
  let s3 = document.documentElement.getAttribute("dir");
  return s3 === "auto" || !s3 ? window.getComputedStyle(document.documentElement).direction : s3;
}
var Te = (s3) => {
  let { invert: o, position: t3 = "bottom-right", hotkey: n2 = ["altKey", "KeyT"], expand: h4, closeButton: u3, className: g2, offset: b3, theme: d4 = "light", richColors: q3, duration: $, style: V2, visibleToasts: Q3 = qt, toastOptions: i2, dir: O3 = Ht(), gap: K3 = ee, loadingIcon: Z2, icons: tt, containerAriaLabel: et = "Notifications", pauseWhenPageIsHidden: X3, cn: ot = ne } = s3, [w3, j] = React.useState([]), W2 = React.useMemo(() => Array.from(new Set([t3].concat(w3.filter((c3) => c3.position).map((c3) => c3.position)))), [w3, t3]), [r2, I3] = React.useState([]), [at, k3] = React.useState(false), [T3, z3] = React.useState(false), [nt, D3] = React.useState(d4 !== "system" ? d4 : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), H4 = React.useRef(null), st = n2.join("+").replace(/Key/g, "").replace(/Digit/g, ""), N2 = React.useRef(null), M4 = React.useRef(false), rt = React.useCallback((c3) => {
    var m4;
    (m4 = w3.find((y4) => y4.id === c3.id)) != null && m4.delete || v$2.dismiss(c3.id), j((y4) => y4.filter(({ id: S4 }) => S4 !== c3.id));
  }, [w3]);
  return React.useEffect(() => v$2.subscribe((c3) => {
    if (c3.dismiss) {
      j((m4) => m4.map((y4) => y4.id === c3.id ? { ...y4, delete: true } : y4));
      return;
    }
    setTimeout(() => {
      ReactDOM.flushSync(() => {
        j((m4) => {
          let y4 = m4.findIndex((S4) => S4.id === c3.id);
          return y4 !== -1 ? [...m4.slice(0, y4), { ...m4[y4], ...c3 }, ...m4.slice(y4 + 1)] : [c3, ...m4];
        });
      });
    });
  }), []), React.useEffect(() => {
    if (d4 !== "system") {
      D3(d4);
      return;
    }
    d4 === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? D3("dark") : D3("light")), typeof window != "undefined" && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches: c3 }) => {
      D3(c3 ? "dark" : "light");
    });
  }, [d4]), React.useEffect(() => {
    w3.length <= 1 && k3(false);
  }, [w3]), React.useEffect(() => {
    let c3 = (m4) => {
      var S4, A2;
      n2.every((l2) => m4[l2] || m4.code === l2) && (k3(true), (S4 = H4.current) == null || S4.focus()), m4.code === "Escape" && (document.activeElement === H4.current || (A2 = H4.current) != null && A2.contains(document.activeElement)) && k3(false);
    };
    return document.addEventListener("keydown", c3), () => document.removeEventListener("keydown", c3);
  }, [n2]), React.useEffect(() => {
    if (H4.current) return () => {
      N2.current && (N2.current.focus({ preventScroll: true }), N2.current = null, M4.current = false);
    };
  }, [H4.current]), w3.length ? React.createElement("section", { "aria-label": `${et} ${st}`, tabIndex: -1 }, W2.map((c3, m4) => {
    var A2;
    let [y4, S4] = c3.split("-");
    return React.createElement("ol", { key: c3, dir: O3 === "auto" ? Ht() : O3, tabIndex: -1, ref: H4, className: g2, "data-sonner-toaster": true, "data-theme": nt, "data-y-position": y4, "data-x-position": S4, style: { "--front-toast-height": `${((A2 = r2[0]) == null ? void 0 : A2.height) || 0}px`, "--offset": typeof b3 == "number" ? `${b3}px` : b3 || Qt, "--width": `${te}px`, "--gap": `${K3}px`, ...V2 }, onBlur: (l2) => {
      M4.current && !l2.currentTarget.contains(l2.relatedTarget) && (M4.current = false, N2.current && (N2.current.focus({ preventScroll: true }), N2.current = null));
    }, onFocus: (l2) => {
      l2.target instanceof HTMLElement && l2.target.dataset.dismissible === "false" || M4.current || (M4.current = true, N2.current = l2.relatedTarget);
    }, onMouseEnter: () => k3(true), onMouseMove: () => k3(true), onMouseLeave: () => {
      T3 || k3(false);
    }, onPointerDown: (l2) => {
      l2.target instanceof HTMLElement && l2.target.dataset.dismissible === "false" || z3(true);
    }, onPointerUp: () => z3(false) }, w3.filter((l2) => !l2.position && m4 === 0 || l2.position === c3).map((l2, _) => {
      var J2, x3;
      return React.createElement(se, { key: l2.id, icons: tt, index: _, toast: l2, defaultRichColors: q3, duration: (J2 = i2 == null ? void 0 : i2.duration) != null ? J2 : $, className: i2 == null ? void 0 : i2.className, descriptionClassName: i2 == null ? void 0 : i2.descriptionClassName, invert: o, visibleToasts: Q3, closeButton: (x3 = i2 == null ? void 0 : i2.closeButton) != null ? x3 : u3, interacting: T3, position: c3, style: i2 == null ? void 0 : i2.style, unstyled: i2 == null ? void 0 : i2.unstyled, classNames: i2 == null ? void 0 : i2.classNames, cancelButtonStyle: i2 == null ? void 0 : i2.cancelButtonStyle, actionButtonStyle: i2 == null ? void 0 : i2.actionButtonStyle, removeToast: rt, toasts: w3.filter((P2) => P2.position == l2.position), heights: r2.filter((P2) => P2.position == l2.position), setHeights: I3, expandByDefault: h4, gap: K3, loadingIcon: Z2, expanded: at, pauseWhenPageIsHidden: X3, cn: ot });
    }));
  })) : null;
};
const BaseLayout = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Te, { position: "bottom-right", richColors: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "main",
      {
        style: {
          backgroundColor: "#BAC1B8",
          color: "#fff",
          padding: "10px",
          height: "100vh"
        },
        children
      }
    )
  ] });
};
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t3 = arguments[e3];
      for (var r2 in t3) ({}).hasOwnProperty.call(t3, r2) && (n2[r2] = t3[r2]);
    }
    return n2;
  }, _extends$1.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r2, e3) {
  if (null == r2) return {};
  var t3 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (e3.includes(n2)) continue;
    t3[n2] = r2[n2];
  }
  return t3;
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction$1() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction$1;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction$1
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg2 = arguments[i2];
        if (arg2) {
          classes = appendClass(classes, parseValue(arg2));
        }
      }
      return classes;
    }
    function parseValue(arg2) {
      if (typeof arg2 === "string" || typeof arg2 === "number") {
        return arg2;
      }
      if (typeof arg2 !== "object") {
        return "";
      }
      if (Array.isArray(arg2)) {
        return classNames2.apply(null, arg2);
      }
      if (arg2.toString !== Object.prototype.toString && !arg2.toString.toString().includes("[native code]")) {
        return arg2.toString();
      }
      var classes = "";
      for (var key in arg2) {
        if (hasOwn.call(arg2, key) && arg2[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$c = freeGlobal || freeSelf || Function("return this")();
var _root = root$c;
var root$b = _root;
var Symbol$7 = root$b.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$i = Object.prototype;
var hasOwnProperty$g = objectProto$i.hasOwnProperty;
var nativeObjectToString$1 = objectProto$i.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$g.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$h = Object.prototype;
var nativeObjectToString = objectProto$h.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$8;
function isObject$d(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$d;
var baseGetTag$7 = _baseGetTag, isObject$c = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$4(value) {
  if (!isObject$c(value)) {
    return false;
  }
  var tag = baseGetTag$7(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
const isFunction$5 = /* @__PURE__ */ getDefaultExportFromCjs(isFunction_1);
var root$a = _root;
var coreJsData$1 = root$a["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$3 = isFunction_1, isMasked = _isMasked, isObject$b = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$g = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$f = objectProto$g.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$f).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$b(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$3(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$3;
var baseIsNative = _baseIsNative, getValue$2 = _getValue;
function getNative$7(object, key) {
  var value = getValue$2(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$9 = _root;
var WeakMap$3 = getNative$6(root$9, "WeakMap");
var _WeakMap = WeakMap$3;
var WeakMap$2 = _WeakMap;
var metaMap$2 = WeakMap$2 && new WeakMap$2();
var _metaMap = metaMap$2;
var identity$4 = identity_1, metaMap$1 = _metaMap;
var baseSetData$2 = !metaMap$1 ? identity$4 : function(func, data) {
  metaMap$1.set(func, data);
  return func;
};
var _baseSetData = baseSetData$2;
var isObject$a = isObject_1;
var objectCreate = Object.create;
var baseCreate$4 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$a(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$4;
var baseCreate$3 = _baseCreate, isObject$9 = isObject_1;
function createCtor$4(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate$3(Ctor.prototype), result = Ctor.apply(thisBinding, args);
    return isObject$9(result) ? result : thisBinding;
  };
}
var _createCtor = createCtor$4;
var createCtor$3 = _createCtor, root$8 = _root;
var WRAP_BIND_FLAG$6 = 1;
function createBind$1(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$6, Ctor = createCtor$3(func);
  function wrapper() {
    var fn2 = this && this !== root$8 && this instanceof wrapper ? Ctor : func;
    return fn2.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var _createBind = createBind$1;
function apply$3(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$3;
var nativeMax$5 = Math.max;
function composeArgs$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$5(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}
var _composeArgs = composeArgs$2;
var nativeMax$4 = Math.max;
function composeArgsRight$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$4(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset2 = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset2 + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset2 + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}
var _composeArgsRight = composeArgsRight$2;
function countHolders$1(array, placeholder) {
  var length2 = array.length, result = 0;
  while (length2--) {
    if (array[length2] === placeholder) {
      ++result;
    }
  }
  return result;
}
var _countHolders = countHolders$1;
function baseLodash$3() {
}
var _baseLodash = baseLodash$3;
var baseCreate$2 = _baseCreate, baseLodash$2 = _baseLodash;
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper$3(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper$3.prototype = baseCreate$2(baseLodash$2.prototype);
LazyWrapper$3.prototype.constructor = LazyWrapper$3;
var _LazyWrapper = LazyWrapper$3;
function noop$3() {
}
var noop_1 = noop$3;
var metaMap = _metaMap, noop$2 = noop_1;
var getData$2 = !metaMap ? noop$2 : function(func) {
  return metaMap.get(func);
};
var _getData = getData$2;
var realNames$1 = {};
var _realNames = realNames$1;
var realNames = _realNames;
var objectProto$f = Object.prototype;
var hasOwnProperty$e = objectProto$f.hasOwnProperty;
function getFuncName$1(func) {
  var result = func.name + "", array = realNames[result], length2 = hasOwnProperty$e.call(realNames, result) ? array.length : 0;
  while (length2--) {
    var data = array[length2], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}
var _getFuncName = getFuncName$1;
var baseCreate$1 = _baseCreate, baseLodash$1 = _baseLodash;
function LodashWrapper$2(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper$2.prototype = baseCreate$1(baseLodash$1.prototype);
LodashWrapper$2.prototype.constructor = LodashWrapper$2;
var _LodashWrapper = LodashWrapper$2;
var isArray$f = Array.isArray;
var isArray_1 = isArray$f;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
function copyArray$3(source, array) {
  var index = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index < length2) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$3;
var LazyWrapper$2 = _LazyWrapper, LodashWrapper$1 = _LodashWrapper, copyArray$2 = _copyArray;
function wrapperClone$1(wrapper) {
  if (wrapper instanceof LazyWrapper$2) {
    return wrapper.clone();
  }
  var result = new LodashWrapper$1(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray$2(wrapper.__actions__);
  result.__index__ = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}
var _wrapperClone = wrapperClone$1;
var LazyWrapper$1 = _LazyWrapper, LodashWrapper = _LodashWrapper, baseLodash = _baseLodash, isArray$e = isArray_1, isObjectLike$a = isObjectLike_1, wrapperClone = _wrapperClone;
var objectProto$e = Object.prototype;
var hasOwnProperty$d = objectProto$e.hasOwnProperty;
function lodash$1(value) {
  if (isObjectLike$a(value) && !isArray$e(value) && !(value instanceof LazyWrapper$1)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$d.call(value, "__wrapped__")) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}
lodash$1.prototype = baseLodash.prototype;
lodash$1.prototype.constructor = lodash$1;
var wrapperLodash = lodash$1;
var LazyWrapper = _LazyWrapper, getData$1 = _getData, getFuncName = _getFuncName, lodash = wrapperLodash;
function isLaziable$1(func) {
  var funcName = getFuncName(func), other = lodash[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData$1(other);
  return !!data && func === data[0];
}
var _isLaziable = isLaziable$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$2(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$2;
var baseSetData$1 = _baseSetData, shortOut$1 = _shortOut;
var setData$2 = shortOut$1(baseSetData$1);
var _setData = setData$2;
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails$1(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
var _getWrapDetails = getWrapDetails$1;
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails$1(source, details) {
  var length2 = details.length;
  if (!length2) {
    return source;
  }
  var lastIndex = length2 - 1;
  details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length2 > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var _insertWrapDetails = insertWrapDetails$1;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var getNative$5 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$5(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
var _defineProperty$1 = defineProperty$2;
var constant = constant_1, defineProperty$1 = _defineProperty$1, identity$3 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$3 : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$3 = shortOut(baseSetToString);
var _setToString = setToString$3;
function arrayEach$3(array, iteratee) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$3;
function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length2) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$2;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array, value, fromIndex) {
  var index = fromIndex - 1, length2 = array.length;
  while (++index < length2) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex$1 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$4(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex$1(array, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$4;
var baseIndexOf$3 = _baseIndexOf;
function arrayIncludes$2(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf$3(array, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$2;
var arrayEach$2 = _arrayEach, arrayIncludes$1 = _arrayIncludes;
var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$5 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_PARTIAL_FLAG$3 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$1 = 256, WRAP_FLIP_FLAG$1 = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG$2],
  ["bind", WRAP_BIND_FLAG$5],
  ["bindKey", WRAP_BIND_KEY_FLAG$4],
  ["curry", WRAP_CURRY_FLAG$5],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG$2],
  ["flip", WRAP_FLIP_FLAG$1],
  ["partial", WRAP_PARTIAL_FLAG$3],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$2],
  ["rearg", WRAP_REARG_FLAG$1]
];
function updateWrapDetails$1(details, bitmask) {
  arrayEach$2(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes$1(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var _updateWrapDetails = updateWrapDetails$1;
var getWrapDetails = _getWrapDetails, insertWrapDetails = _insertWrapDetails, setToString$2 = _setToString, updateWrapDetails = _updateWrapDetails;
function setWrapToString$2(wrapper, reference2, bitmask) {
  var source = reference2 + "";
  return setToString$2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}
var _setWrapToString = setWrapToString$2;
var isLaziable = _isLaziable, setData$1 = _setData, setWrapToString$1 = _setWrapToString;
var WRAP_BIND_FLAG$4 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$4 = 8, WRAP_PARTIAL_FLAG$2 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
function createRecurry$2(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$4, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG$2 : WRAP_PARTIAL_RIGHT_FLAG$1;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$4 | WRAP_BIND_KEY_FLAG$3);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary,
    arity
  ];
  var result = wrapFunc.apply(void 0, newData);
  if (isLaziable(func)) {
    setData$1(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString$1(result, func, bitmask);
}
var _createRecurry = createRecurry$2;
function getHolder$3(func) {
  var object = func;
  return object.placeholder;
}
var _getHolder = getHolder$3;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$5(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$5;
var copyArray$1 = _copyArray, isIndex$4 = _isIndex;
var nativeMin$1 = Math.min;
function reorder$1(array, indexes) {
  var arrLength = array.length, length2 = nativeMin$1(indexes.length, arrLength), oldArray = copyArray$1(array);
  while (length2--) {
    var index = indexes[length2];
    array[length2] = isIndex$4(index, arrLength) ? oldArray[index] : void 0;
  }
  return array;
}
var _reorder = reorder$1;
var PLACEHOLDER$1 = "__lodash_placeholder__";
function replaceHolders$4(array, placeholder) {
  var index = -1, length2 = array.length, resIndex = 0, result = [];
  while (++index < length2) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER$1) {
      array[index] = PLACEHOLDER$1;
      result[resIndex++] = index;
    }
  }
  return result;
}
var _replaceHolders = replaceHolders$4;
var composeArgs$1 = _composeArgs, composeArgsRight$1 = _composeArgsRight, countHolders = _countHolders, createCtor$2 = _createCtor, createRecurry$1 = _createRecurry, getHolder$2 = _getHolder, reorder = _reorder, replaceHolders$3 = _replaceHolders, root$7 = _root;
var WRAP_BIND_FLAG$3 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$3 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_ARY_FLAG$1 = 128, WRAP_FLIP_FLAG = 512;
function createHybrid$2(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$1, isBind = bitmask & WRAP_BIND_FLAG$3, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2, isCurried = bitmask & (WRAP_CURRY_FLAG$3 | WRAP_CURRY_RIGHT_FLAG$1), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor$2(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index = length2;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder$2(wrapper), holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs$1(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight$1(args, partialsRight, holdersRight, isCurried);
    }
    length2 -= holdersCount;
    if (isCurried && length2 < arity) {
      var newHolders = replaceHolders$3(args, placeholder);
      return createRecurry$1(
        func,
        bitmask,
        createHybrid$2,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary,
        arity - length2
      );
    }
    var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
    length2 = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length2 > 1) {
      args.reverse();
    }
    if (isAry && ary < length2) {
      args.length = ary;
    }
    if (this && this !== root$7 && this instanceof wrapper) {
      fn2 = Ctor || createCtor$2(fn2);
    }
    return fn2.apply(thisBinding, args);
  }
  return wrapper;
}
var _createHybrid = createHybrid$2;
var apply$2 = _apply, createCtor$1 = _createCtor, createHybrid$1 = _createHybrid, createRecurry = _createRecurry, getHolder$1 = _getHolder, replaceHolders$2 = _replaceHolders, root$6 = _root;
function createCurry$1(func, bitmask, arity) {
  var Ctor = createCtor$1(func);
  function wrapper() {
    var length2 = arguments.length, args = Array(length2), index = length2, placeholder = getHolder$1(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders$2(args, placeholder);
    length2 -= holders.length;
    if (length2 < arity) {
      return createRecurry(
        func,
        bitmask,
        createHybrid$1,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length2
      );
    }
    var fn2 = this && this !== root$6 && this instanceof wrapper ? Ctor : func;
    return apply$2(fn2, this, args);
  }
  return wrapper;
}
var _createCurry = createCurry$1;
var apply$1 = _apply, createCtor = _createCtor, root$5 = _root;
var WRAP_BIND_FLAG$2 = 1;
function createPartial$1(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$2, Ctor = createCtor(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn2 = this && this !== root$5 && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply$1(fn2, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var _createPartial = createPartial$1;
var composeArgs = _composeArgs, composeArgsRight = _composeArgsRight, replaceHolders$1 = _replaceHolders;
var PLACEHOLDER = "__lodash_placeholder__";
var WRAP_BIND_FLAG$1 = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$2 = 8, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
var nativeMin = Math.min;
function mergeData$1(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$1 | WRAP_BIND_KEY_FLAG$1 | WRAP_ARY_FLAG);
  var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG$2 || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$2;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG$1) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG$1 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders$1(data[3], PLACEHOLDER) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders$1(data[5], PLACEHOLDER) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var _mergeData = mergeData$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$2(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$2;
var baseGetTag$6 = _baseGetTag, isObjectLike$9 = isObjectLike_1;
var symbolTag$3 = "[object Symbol]";
function isSymbol$5(value) {
  return typeof value == "symbol" || isObjectLike$9(value) && baseGetTag$6(value) == symbolTag$3;
}
var isSymbol_1 = isSymbol$5;
var baseTrim$1 = _baseTrim, isObject$8 = isObject_1, isSymbol$4 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$4(value)) {
    return NAN;
  }
  if (isObject$8(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$8(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim$1(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$4(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$4;
var baseSetData = _baseSetData, createBind = _createBind, createCurry = _createCurry, createHybrid = _createHybrid, createPartial = _createPartial, getData = _getData, mergeData = _mergeData, setData = _setData, setWrapToString = _setWrapToString, toInteger$3 = toInteger_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG$1 = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG$1 = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
var nativeMax$3 = Math.max;
function createWrap$2(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var length2 = partials ? partials.length : 0;
  if (!length2) {
    bitmask &= ~(WRAP_PARTIAL_FLAG$1 | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = void 0;
  }
  ary = ary === void 0 ? ary : nativeMax$3(toInteger$3(ary), 0);
  arity = arity === void 0 ? arity : toInteger$3(arity);
  length2 -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary,
    arity
  ];
  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax$3(newData[9] - length2, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG$1 | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG$1 | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG$1 || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG$1 || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG$1)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(void 0, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}
var _createWrap = createWrap$2;
var createWrap$1 = _createWrap;
var WRAP_CURRY_FLAG = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result = createWrap$1(func, WRAP_CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
  result.placeholder = curry.placeholder;
  return result;
}
curry.placeholder = {};
var curry_1 = curry;
const curry$1 = /* @__PURE__ */ getDefaultExportFromCjs(curry_1);
var globalKey$1 = "rs-";
var getClassNamePrefix$1 = function getClassNamePrefix() {
  return globalKey$1;
};
function prefix$4(pre, className) {
  if (!pre || !className) {
    return "";
  }
  if (Array.isArray(className)) {
    return classNames(className.filter(function(name) {
      return !!name;
    }).map(function(name) {
      return pre + "-" + name;
    }));
  }
  if (pre[pre.length - 1] === "-") {
    return "" + pre + className;
  }
  return pre + "-" + className;
}
curry$1(prefix$4);
function on(target, eventType, listener, options) {
  if (options === void 0) {
    options = false;
  }
  target.addEventListener(eventType, listener, options);
  return {
    off: function off() {
      target.removeEventListener(eventType, listener, options);
    }
  };
}
var _this$1 = void 0;
function makeEmptyFunction(arg2) {
  return function() {
    return arg2;
  };
}
function emptyFunction() {
}
emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function() {
  return _this$1;
};
emptyFunction.thatReturnsArgument = function(arg2) {
  return arg2;
};
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
const canUseDOM$1 = canUseDOM;
if (canUseDOM$1) {
  document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature("", "") !== true;
}
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  throw new Error("unable to locate global object");
}
var g$4 = getGlobal();
var lastTime = 0;
function _setTimeout(callback) {
  var currTime = Date.now();
  var timeDelay = Math.max(0, 16 - (currTime - lastTime));
  lastTime = currTime + timeDelay;
  return g$4.setTimeout(function() {
    callback(Date.now());
  }, timeDelay);
}
var requestAnimationFramePolyfill = g$4.requestAnimationFrame || _setTimeout;
requestAnimationFramePolyfill(emptyFunction);
var g$3 = getGlobal();
g$3.cancelAnimationFrame || g$3.clearTimeout;
function hasClass$1(target, className) {
  if (target.classList) {
    return !!className && target.classList.contains(className);
  }
  return (" " + target.className + " ").indexOf(" " + className + " ") !== -1;
}
function addClass$1(target, className) {
  if (className) {
    if (target.classList) {
      target.classList.add(className);
    } else if (!hasClass$1(target, className)) {
      target.className = target.className + " " + className;
    }
  }
  return target;
}
function removeClass$2(target, className) {
  if (className) {
    if (target.classList) {
      target.classList.remove(className);
    } else {
      target.className = target.className.replace(new RegExp("(^|\\s)" + className + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
    }
  }
  return target;
}
var vendorMap = {
  animation: "animationend",
  OAnimation: "oAnimationEnd",
  MozAnimation: "animationend",
  WebkitAnimation: "webkitAnimationEnd"
};
function getAnimationEnd$1() {
  if (!canUseDOM$1) {
    return;
  }
  var tempAnimationEnd;
  var style2 = document.createElement("div").style;
  for (tempAnimationEnd in vendorMap) {
    if (style2[tempAnimationEnd] !== void 0) {
      return vendorMap[tempAnimationEnd];
    }
  }
}
function ownerDocument$2(node2) {
  return node2 && node2.ownerDocument || document;
}
function getWindow$1(node2) {
  if (node2 === (node2 === null || node2 === void 0 ? void 0 : node2.window)) {
    return node2;
  }
  return (node2 === null || node2 === void 0 ? void 0 : node2.nodeType) === 9 ? (node2 === null || node2 === void 0 ? void 0 : node2.defaultView) || (node2 === null || node2 === void 0 ? void 0 : node2.parentWindow) : null;
}
function getContainer$2(container, defaultContainer) {
  container = typeof container === "function" ? container() : container;
  return container || defaultContainer;
}
var fallback = function fallback2(context, node2) {
  if (!node2) return false;
  do {
    if (node2 === context) {
      return true;
    }
  } while (node2.parentNode && (node2 = node2.parentNode));
  return false;
};
var contains$2 = function contains(context, node2) {
  if (!node2) return false;
  if (context.contains) {
    return context.contains(node2);
  } else if (context.compareDocumentPosition) {
    return context === node2 || !!(context.compareDocumentPosition(node2) & 16);
  }
  return fallback(context, node2);
};
const contains$3 = /* @__PURE__ */ function() {
  return canUseDOM$1 ? contains$2 : fallback;
}();
function scrollTop(node2, val) {
  var win = getWindow$1(node2);
  var top2 = node2.scrollTop;
  var left2 = 0;
  if (win) {
    top2 = win.pageYOffset;
    left2 = win.pageXOffset;
  }
  if (val !== void 0) {
    if (win) {
      win.scrollTo(left2, val);
    } else {
      node2.scrollTop = val;
    }
  }
  return top2;
}
function scrollLeft(node2, val) {
  var win = getWindow$1(node2);
  var left2 = node2.scrollLeft;
  if (win) {
    left2 = win.pageXOffset;
    win.pageYOffset;
  }
  return left2;
}
function getOffset(node2) {
  var doc = ownerDocument$2(node2);
  var win = getWindow$1(doc);
  var docElem = doc && doc.documentElement;
  var box = {
    top: 0,
    left: 0,
    height: 0,
    width: 0
  };
  if (!doc) {
    return null;
  }
  if (!contains$3(docElem, node2)) {
    return box;
  }
  if ((node2 === null || node2 === void 0 ? void 0 : node2.getBoundingClientRect) !== void 0) {
    box = node2.getBoundingClientRect();
  }
  if ((box.width || box.height) && docElem && win) {
    box = {
      top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
      left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
      width: (box.width === null ? node2.offsetWidth : box.width) || 0,
      height: (box.height === null ? node2.offsetHeight : box.height) || 0
    };
  }
  return box;
}
function nodeName(node2) {
  var _node$nodeName;
  return (node2 === null || node2 === void 0 ? void 0 : node2.nodeName) && (node2 === null || node2 === void 0 ? void 0 : (_node$nodeName = node2.nodeName) === null || _node$nodeName === void 0 ? void 0 : _node$nodeName.toLowerCase());
}
function camelize(string) {
  return string.replace(/\-(\w)/g, function(_char) {
    return _char.slice(1).toUpperCase();
  });
}
function hyphenate(string) {
  return string.replace(/([A-Z])/g, "-$1").toLowerCase();
}
var msPattern$1 = /^-ms-/;
function camelizeStyleName(name) {
  return camelize(name.replace(msPattern$1, "ms-"));
}
const getComputedStyle$2 = function(node2) {
  if (!node2) {
    throw new TypeError("No Element passed to `getComputedStyle()`");
  }
  var doc = node2.ownerDocument;
  if ("defaultView" in doc) {
    if (doc.defaultView.opener) {
      return node2.ownerDocument.defaultView.getComputedStyle(node2, null);
    }
    return window.getComputedStyle(node2, null);
  }
  return null;
};
var msPattern = /^ms-/;
const hyphenateStyleName = function(string) {
  return hyphenate(string).replace(msPattern, "-ms-");
};
function getStyle(node2, property2) {
  if (property2) {
    var value = node2.style[camelizeStyleName(property2)];
    if (value) {
      return value;
    }
    var styles2 = getComputedStyle$2(node2);
    if (styles2) {
      return styles2.getPropertyValue(hyphenateStyleName(property2));
    }
  }
  return node2.style || getComputedStyle$2(node2);
}
function getOffsetParent$1(node2) {
  var doc = ownerDocument$2(node2);
  var offsetParent = node2 === null || node2 === void 0 ? void 0 : node2.offsetParent;
  while (offsetParent && nodeName(node2) !== "html" && getStyle(offsetParent, "position") === "static") {
    offsetParent = offsetParent.offsetParent;
  }
  return offsetParent || doc.documentElement;
}
function getPosition$1(node2, offsetParent, calcMargin) {
  if (calcMargin === void 0) {
    calcMargin = true;
  }
  var parentOffset = {
    top: 0,
    left: 0
  };
  var offset2 = null;
  if (getStyle(node2, "position") === "fixed") {
    offset2 = node2.getBoundingClientRect();
  } else {
    offsetParent = offsetParent || getOffsetParent$1(node2);
    offset2 = getOffset(node2);
    if (nodeName(offsetParent) !== "html") {
      var nextParentOffset = getOffset(offsetParent);
      if (nextParentOffset) {
        parentOffset.top = nextParentOffset.top;
        parentOffset.left = nextParentOffset.left;
      }
    }
    parentOffset.top += parseInt(getStyle(offsetParent, "borderTopWidth"), 10) - scrollTop(offsetParent) || 0;
    parentOffset.left += parseInt(getStyle(offsetParent, "borderLeftWidth"), 10) - scrollLeft(offsetParent) || 0;
  }
  if (offset2) {
    var marginTop = calcMargin ? parseInt(getStyle(node2, "marginTop"), 10) || 0 : 0;
    var marginLeft = calcMargin ? parseInt(getStyle(node2, "marginLeft"), 10) || 0 : 0;
    return _extends$1({}, offset2, {
      top: offset2.top - parentOffset.top - marginTop,
      left: offset2.left - parentOffset.left - marginLeft
    });
  }
  return null;
}
function bodyIsOverflowing(node2) {
  var doc = ownerDocument$2(node2);
  var win = getWindow$1(doc);
  var fullWidth = win.innerWidth;
  if (doc.body) {
    return doc.body.clientWidth < fullWidth;
  }
  return false;
}
function isOverflowing$1(container) {
  var win = getWindow$1(container);
  var isBody = container && container.tagName.toLowerCase() === "body";
  return win || isBody ? bodyIsOverflowing(container) : container.scrollHeight > container.clientHeight;
}
var size$2;
function getScrollbarSize$2(recalc) {
  if (size$2 === void 0 || recalc) {
    if (canUseDOM$1) {
      var scrollDiv = document.createElement("div");
      var body = document.body;
      scrollDiv.style.position = "absolute";
      scrollDiv.style.top = "-9999px";
      scrollDiv.style.width = "50px";
      scrollDiv.style.height = "50px";
      scrollDiv.style.overflow = "scroll";
      body.appendChild(scrollDiv);
      size$2 = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      body.removeChild(scrollDiv);
    }
  }
  return size$2;
}
function getHeight(node2, client) {
  var win = getWindow$1(node2);
  if (win) {
    return win.innerHeight;
  }
  return client ? node2.clientHeight : getOffset(node2).height;
}
function getWidth(node2, client) {
  var win = getWindow$1(node2);
  if (win) {
    return win.innerWidth;
  }
  var offset2 = getOffset(node2);
  return offset2 ? offset2.width : 0;
}
function _removeStyle(node2, key) {
  var _style, _style$removeProperty;
  (_style = node2.style) === null || _style === void 0 ? void 0 : (_style$removeProperty = _style.removeProperty) === null || _style$removeProperty === void 0 ? void 0 : _style$removeProperty.call(_style, key);
}
function removeStyle(node2, keys2) {
  if (typeof keys2 === "string") {
    _removeStyle(node2, keys2);
  } else if (Array.isArray(keys2)) {
    keys2.forEach(function(key) {
      return _removeStyle(node2, key);
    });
  }
}
function addStyle(node2, property2, value) {
  var css2 = "";
  var props = property2;
  if (typeof property2 === "string") {
    if (value === void 0) {
      throw new Error("value is undefined");
    }
    (props = {})[property2] = value;
  }
  if (typeof props === "object") {
    for (var _key in props) {
      if (Object.prototype.hasOwnProperty.call(props, _key)) {
        if (!props[_key] && props[_key] !== 0) {
          removeStyle(node2, hyphenateStyleName(_key));
        } else {
          css2 += hyphenateStyleName(_key) + ":" + props[_key] + ";";
        }
      }
    }
  }
  node2.style.cssText += ";" + css2;
}
var memoized = {};
var prefixes = ["Webkit", "ms", "Moz", "O"];
var prefixRegex = new RegExp("^(" + prefixes.join("|") + ")");
var testStyle = canUseDOM$1 ? document.createElement("div").style : {};
function getWithPrefix(name) {
  for (var i2 = 0; i2 < prefixes.length; i2 += 1) {
    var prefixedName = prefixes[i2] + name;
    if (prefixedName in testStyle) {
      return prefixedName;
    }
  }
  return null;
}
function getVendorPrefixedName(property2) {
  var name = camelize(property2);
  if (memoized[name] === void 0) {
    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
    if (prefixRegex.test(capitalizedName)) {
      throw new Error("getVendorPrefixedName must only be called with unprefixed\n          CSS property names. It was called with " + property2);
    }
    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
  }
  return memoized[name] || name;
}
const BrowserSupportCore = {
  /**
   * @return {bool} True if browser supports css animations.
   */
  hasCSSAnimations: function hasCSSAnimations() {
    return !!getVendorPrefixedName("animationName");
  },
  /**
   * @return {bool} True if browser supports css transforms.
   */
  hasCSSTransforms: function hasCSSTransforms() {
    return !!getVendorPrefixedName("transform");
  },
  /**
   * @return {bool} True if browser supports css 3d transforms.
   */
  hasCSS3DTransforms: function hasCSS3DTransforms() {
    return !!getVendorPrefixedName("perspective");
  },
  /**
   * @return {bool} True if browser supports css transitions.
   */
  hasCSSTransitions: function hasCSSTransitions() {
    return !!getVendorPrefixedName("transition");
  }
};
var g$2 = getGlobal();
var TRANSFORM = getVendorPrefixedName("transform");
var BACKFACE_VISIBILITY = getVendorPrefixedName("backfaceVisibility");
var appendLeftAndTop = function appendLeftAndTop2(style2, x3, y4) {
  if (x3 === void 0) {
    x3 = 0;
  }
  if (y4 === void 0) {
    y4 = 0;
  }
  style2.left = x3 + "px";
  style2.top = y4 + "px";
  return style2;
};
var appendTranslate = function appendTranslate2(style2, x3, y4) {
  if (x3 === void 0) {
    x3 = 0;
  }
  if (y4 === void 0) {
    y4 = 0;
  }
  style2[TRANSFORM] = "translate(" + x3 + "px," + y4 + "px)";
  return style2;
};
var appendTranslate3d = function appendTranslate3d2(style2, x3, y4) {
  if (x3 === void 0) {
    x3 = 0;
  }
  if (y4 === void 0) {
    y4 = 0;
  }
  style2[TRANSFORM] = "translate3d(" + x3 + "px," + y4 + "px,0)";
  style2[BACKFACE_VISIBILITY] = "hidden";
  return style2;
};
var getTranslateDOMPositionXY = function getTranslateDOMPositionXY2(conf) {
  var _ref = {}, _ref$enableTransform = _ref.enableTransform, enableTransform = _ref$enableTransform === void 0 ? true : _ref$enableTransform, _ref$enable3DTransfor = _ref.enable3DTransform, enable3DTransform = _ref$enable3DTransfor === void 0 ? true : _ref$enable3DTransfor, forceUseTransform = _ref.forceUseTransform;
  if (forceUseTransform) {
    return conf.enable3DTransform ? appendTranslate3d : appendTranslate;
  }
  if (BrowserSupportCore.hasCSSTransforms() && enableTransform) {
    var ua2 = g$2.window ? g$2.window.navigator.userAgent : "UNKNOWN";
    var isSafari = /Safari\//.test(ua2) && !/Chrome\//.test(ua2);
    if (!isSafari && BrowserSupportCore.hasCSS3DTransforms() && enable3DTransform) {
      return appendTranslate3d;
    }
    return appendTranslate;
  }
  return appendLeftAndTop;
};
getTranslateDOMPositionXY();
var isElement$2 = function isElement(value) {
  return (value === null || value === void 0 ? void 0 : value.nodeType) === 1 && typeof (value === null || value === void 0 ? void 0 : value.nodeName) === "string";
};
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index = -1, length2 = array == null ? 0 : array.length;
  if (initAccum && length2) {
    accumulator = array[++index];
  }
  while (++index < length2) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "À": "A",
  "Á": "A",
  "Â": "A",
  "Ã": "A",
  "Ä": "A",
  "Å": "A",
  "à": "a",
  "á": "a",
  "â": "a",
  "ã": "a",
  "ä": "a",
  "å": "a",
  "Ç": "C",
  "ç": "c",
  "Ð": "D",
  "ð": "d",
  "È": "E",
  "É": "E",
  "Ê": "E",
  "Ë": "E",
  "è": "e",
  "é": "e",
  "ê": "e",
  "ë": "e",
  "Ì": "I",
  "Í": "I",
  "Î": "I",
  "Ï": "I",
  "ì": "i",
  "í": "i",
  "î": "i",
  "ï": "i",
  "Ñ": "N",
  "ñ": "n",
  "Ò": "O",
  "Ó": "O",
  "Ô": "O",
  "Õ": "O",
  "Ö": "O",
  "Ø": "O",
  "ò": "o",
  "ó": "o",
  "ô": "o",
  "õ": "o",
  "ö": "o",
  "ø": "o",
  "Ù": "U",
  "Ú": "U",
  "Û": "U",
  "Ü": "U",
  "ù": "u",
  "ú": "u",
  "û": "u",
  "ü": "u",
  "Ý": "Y",
  "ý": "y",
  "ÿ": "y",
  "Æ": "Ae",
  "æ": "ae",
  "Þ": "Th",
  "þ": "th",
  "ß": "ss",
  // Latin Extended-A block.
  "Ā": "A",
  "Ă": "A",
  "Ą": "A",
  "ā": "a",
  "ă": "a",
  "ą": "a",
  "Ć": "C",
  "Ĉ": "C",
  "Ċ": "C",
  "Č": "C",
  "ć": "c",
  "ĉ": "c",
  "ċ": "c",
  "č": "c",
  "Ď": "D",
  "Đ": "D",
  "ď": "d",
  "đ": "d",
  "Ē": "E",
  "Ĕ": "E",
  "Ė": "E",
  "Ę": "E",
  "Ě": "E",
  "ē": "e",
  "ĕ": "e",
  "ė": "e",
  "ę": "e",
  "ě": "e",
  "Ĝ": "G",
  "Ğ": "G",
  "Ġ": "G",
  "Ģ": "G",
  "ĝ": "g",
  "ğ": "g",
  "ġ": "g",
  "ģ": "g",
  "Ĥ": "H",
  "Ħ": "H",
  "ĥ": "h",
  "ħ": "h",
  "Ĩ": "I",
  "Ī": "I",
  "Ĭ": "I",
  "Į": "I",
  "İ": "I",
  "ĩ": "i",
  "ī": "i",
  "ĭ": "i",
  "į": "i",
  "ı": "i",
  "Ĵ": "J",
  "ĵ": "j",
  "Ķ": "K",
  "ķ": "k",
  "ĸ": "k",
  "Ĺ": "L",
  "Ļ": "L",
  "Ľ": "L",
  "Ŀ": "L",
  "Ł": "L",
  "ĺ": "l",
  "ļ": "l",
  "ľ": "l",
  "ŀ": "l",
  "ł": "l",
  "Ń": "N",
  "Ņ": "N",
  "Ň": "N",
  "Ŋ": "N",
  "ń": "n",
  "ņ": "n",
  "ň": "n",
  "ŋ": "n",
  "Ō": "O",
  "Ŏ": "O",
  "Ő": "O",
  "ō": "o",
  "ŏ": "o",
  "ő": "o",
  "Ŕ": "R",
  "Ŗ": "R",
  "Ř": "R",
  "ŕ": "r",
  "ŗ": "r",
  "ř": "r",
  "Ś": "S",
  "Ŝ": "S",
  "Ş": "S",
  "Š": "S",
  "ś": "s",
  "ŝ": "s",
  "ş": "s",
  "š": "s",
  "Ţ": "T",
  "Ť": "T",
  "Ŧ": "T",
  "ţ": "t",
  "ť": "t",
  "ŧ": "t",
  "Ũ": "U",
  "Ū": "U",
  "Ŭ": "U",
  "Ů": "U",
  "Ű": "U",
  "Ų": "U",
  "ũ": "u",
  "ū": "u",
  "ŭ": "u",
  "ů": "u",
  "ű": "u",
  "ų": "u",
  "Ŵ": "W",
  "ŵ": "w",
  "Ŷ": "Y",
  "ŷ": "y",
  "Ÿ": "Y",
  "Ź": "Z",
  "Ż": "Z",
  "Ž": "Z",
  "ź": "z",
  "ż": "z",
  "ž": "z",
  "Ĳ": "IJ",
  "ĳ": "ij",
  "Œ": "Oe",
  "œ": "oe",
  "ŉ": "'n",
  "ſ": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
function arrayMap$4(array, iteratee) {
  var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$4;
var Symbol$4 = _Symbol, arrayMap$3 = _arrayMap, isArray$d = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString$2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$d(value)) {
    return arrayMap$3(value, baseToString$2) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$2;
var baseToString$1 = _baseToString;
function toString$8(value) {
  return value == null ? "" : baseToString$1(value);
}
var toString_1 = toString$8;
var deburrLetter = _deburrLetter, toString$7 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
var rsCombo$2 = "[" + rsComboRange$3 + "]";
var reComboMark = RegExp(rsCombo$2, "g");
function deburr$1(string) {
  string = toString$7(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange$2 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo$1 = "[" + rsComboRange$2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$2 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ$2 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$2 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$6 = toString_1, unicodeWords = _unicodeWords;
function words$1(string, pattern, guard) {
  string = toString$6(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce, deburr = deburr_1, words = words_1;
var rsApos = "['’]";
var reApos = RegExp(rsApos, "g");
function createCompounder$3(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$3;
var createCompounder$2 = _createCompounder;
var kebabCase = createCompounder$2(function(result, word, index) {
  return result + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
const kebabCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(kebabCase_1);
function _setPrototypeOf(t3, e3) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e4) {
    return t4.__proto__ = e4, t4;
  }, _setPrototypeOf(t3, e3);
}
function _inheritsLoose(t3, o) {
  t3.prototype = Object.create(o.prototype), t3.prototype.constructor = t3, _setPrototypeOf(t3, o);
}
function getTransitionProperties() {
  if (!canUseDOM$1) {
    return {};
  }
  var vendorMap2 = {
    O: function O3(e3) {
      return "o" + e3.toLowerCase();
    },
    Moz: function Moz(e3) {
      return e3.toLowerCase();
    },
    Webkit: function Webkit(e3) {
      return "webkit" + e3;
    },
    ms: function ms(e3) {
      return "MS" + e3;
    }
  };
  var vendors = Object.keys(vendorMap2);
  var style2 = document.createElement("div").style;
  var tempTransitionEnd;
  var tempPrefix = "";
  for (var i2 = 0; i2 < vendors.length; i2 += 1) {
    var vendor = vendors[i2];
    if (vendor + "TransitionProperty" in style2) {
      tempPrefix = "-" + vendor.toLowerCase();
      tempTransitionEnd = vendorMap2[vendor]("TransitionEnd");
      break;
    }
  }
  if (!tempTransitionEnd && "transitionProperty" in style2) {
    tempTransitionEnd = "transitionend";
  }
  style2 = null;
  var addPrefix = function addPrefix2(name) {
    return tempPrefix + "-" + name;
  };
  return {
    end: tempTransitionEnd,
    backfaceVisibility: addPrefix("backface-visibility"),
    transform: addPrefix("transform"),
    property: addPrefix("transition-property"),
    timing: addPrefix("transition-timing-function"),
    delay: addPrefix("transition-delay"),
    duration: addPrefix("transition-duration")
  };
}
function getTransitionEnd() {
  return getTransitionProperties().end;
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq$2(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var getNative$4 = _getNative, root$4 = _root;
var Map$4 = getNative$4(root$4, "Map");
var _Map = Map$4;
var getNative$3 = _getNative;
var nativeCreate$4 = getNative$3(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$c.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$b.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$5(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$5.prototype.clear = stackClear;
Stack$5.prototype["delete"] = stackDelete;
Stack$5.prototype.get = stackGet;
Stack$5.prototype.has = stackHas;
Stack$5.prototype.set = stackSet;
var _Stack = Stack$5;
var defineProperty = _defineProperty$1;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$1 = eq_1;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$a.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
function copyObject$5(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length2 = props.length;
  while (++index < length2) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$5;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var baseGetTag$5 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$8(value) && baseGetTag$5(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$7 = isObjectLike_1;
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
var isArguments$3 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$7(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$3;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$3.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var isBufferExports = isBuffer$3.exports;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$4 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$6 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$6(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$4(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$2 = isArguments_1, isArray$c = isArray_1, isBuffer$2 = isBufferExports, isIndex$3 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$c(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$8 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
var _isPrototype = isPrototype$3;
function overArg$2(func, transform) {
  return function(arg2) {
    return func(transform(arg2));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$2(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$7.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$2 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$5(value) {
  return value != null && isLength$1(value.length) && !isFunction$2(value);
}
var isArrayLike_1 = isArrayLike$5;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$7(object) {
  return isArrayLike$4(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$7;
var copyObject$4 = _copyObject, keys$6 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$4(source, keys$6(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$7 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$7(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$3 = isArrayLike_1;
function keysIn$3(object) {
  return isArrayLike$3(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$3;
var copyObject$3 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$3(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
function arrayFilter$1(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length2) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$5 = Object.prototype;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$2 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$2(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values2) {
  var index = -1, length2 = values2.length, offset2 = array.length;
  while (++index < length2) {
    array[offset2 + index] = values2[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush, getPrototype$2 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$1(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush, isArray$b = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$b(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$5 = keys_1;
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$5, getSymbols);
}
var _getAllKeys = getAllKeys$2;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$3(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$3;
var getNative$2 = _getNative, root$3 = _root;
var DataView$1 = getNative$2(root$3, "DataView");
var _DataView = DataView$1;
var getNative$1 = _getNative, root$2 = _root;
var Promise$2 = getNative$1(root$2, "Promise");
var _Promise = Promise$2;
var getNative = _getNative, root$1 = _root;
var Set$2 = getNative(root$1, "Set");
var _Set = Set$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag$3 = _baseGetTag, toSource = _toSource;
var mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$4 = baseGetTag$3;
if (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag$4(new Map$1()) != mapTag$4 || Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag || Set$1 && getTag$4(new Set$1()) != setTag$4 || WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1) {
  getTag$4 = function(value) {
    var result = baseGetTag$3(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$4;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$4;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$4;
var objectProto$4 = Object.prototype;
var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
function initCloneArray$1(array) {
  var length2 = array.length, result = new array.constructor(length2);
  if (length2 && typeof array[0] == "string" && hasOwnProperty$5.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root = _root;
var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$3:
    case stringTag$3:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$3 = _getTag, isObjectLike$5 = isObjectLike_1;
var mapTag$2 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$5(value) && getTag$3(value) == mapTag$2;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$2 = _getTag, isObjectLike$4 = isObjectLike_1;
var setTag$2 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$4(value) && getTag$2(value) == setTag$2;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$4 = _Stack, arrayEach$1 = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn$2 = _getAllKeysIn, getTag$1 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$a = isArray_1, isBuffer$1 = isBufferExports, isMap = isMap_1, isObject$6 = isObject_1, isSet = isSet_1, keys$4 = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$6(value)) {
    return value;
  }
  var isArr = isArray$a(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$2 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$4());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys$1 : isFlat ? keysIn : keys$4;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach$1(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var isArray$9 = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$4(value, object) {
  if (isArray$9(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$4;
var MapCache$1 = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$4(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized2 = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized2.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized2.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized2.cache = new (memoize$4.Cache || MapCache$1)();
  return memoized2;
}
memoize$4.Cache = MapCache$1;
var memoize_1 = memoize$4;
var memoize$3 = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize$3(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$2 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var _stringToPath = stringToPath$2;
var isArray$8 = isArray_1, isKey$3 = _isKey, stringToPath$1 = _stringToPath, toString$5 = toString_1;
function castPath$6(value, object) {
  if (isArray$8(value)) {
    return value;
  }
  return isKey$3(value, object) ? [value] : stringToPath$1(toString$5(value));
}
var _castPath = castPath$6;
function last$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? array[length2 - 1] : void 0;
}
var last_1 = last$1;
var isSymbol$1 = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$6(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$6;
var castPath$5 = _castPath, toKey$5 = _toKey;
function baseGet$5(object, path) {
  path = castPath$5(path, object);
  var index = 0, length2 = path.length;
  while (object != null && index < length2) {
    object = object[toKey$5(path[index++])];
  }
  return index && index == length2 ? object : void 0;
}
var _baseGet = baseGet$5;
function baseSlice$2(array, start2, end2) {
  var index = -1, length2 = array.length;
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end2 = end2 > length2 ? length2 : end2;
  if (end2 < 0) {
    end2 += length2;
  }
  length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length2);
  while (++index < length2) {
    result[index] = array[index + start2];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseGet$4 = _baseGet, baseSlice$1 = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet$4(object, baseSlice$1(path, 0, -1));
}
var _parent = parent$1;
var castPath$4 = _castPath, last = last_1, parent = _parent, toKey$4 = _toKey;
function baseUnset$2(object, path) {
  path = castPath$4(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey$4(last(path))];
}
var _baseUnset = baseUnset$2;
var baseGetTag$2 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$3 = isObjectLike_1;
var objectTag$1 = "[object Object]";
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$5(value) {
  if (!isObjectLike$3(value) || baseGetTag$2(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$4.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$5;
var isPlainObject$4 = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject$4(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var Symbol$2 = _Symbol, isArguments$1 = isArguments_1, isArray$7 = isArray_1;
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$7(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length2) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var apply = _apply;
var nativeMax$2 = Math.max;
function overRest$2(func, start2, transform) {
  start2 = nativeMax$2(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index = -1, length2 = nativeMax$2(args.length - start2, 0), array = Array(length2);
    while (++index < length2) {
      array[index] = args[start2 + index];
    }
    index = -1;
    var otherArgs = Array(start2 + 1);
    while (++index < start2) {
      otherArgs[index] = args[index];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
var flatten = flatten_1, overRest$1 = _overRest, setToString$1 = _setToString;
function flatRest$2(func) {
  return setToString$1(overRest$1(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$2;
var arrayMap$2 = _arrayMap, baseClone = _baseClone, baseUnset$1 = _baseUnset, castPath$3 = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest$1 = _flatRest, getAllKeysIn$1 = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest$1(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$2(paths, function(path) {
    path = castPath$3(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn$1(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length2 = paths.length;
  while (length2--) {
    baseUnset$1(result, paths[length2]);
  }
  return result;
});
var omit_1 = omit;
const omit$1 = /* @__PURE__ */ getDefaultExportFromCjs(omit_1);
var isIE = function isIE2() {
  return canUseDOM$1 && /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent);
};
var isAndroid$1 = function isAndroid() {
  return canUseDOM$1 && /Android/i.test(navigator.userAgent);
};
var getChromeVersion = function getChromeVersion2() {
  if (canUseDOM$1) {
    var match2 = window.navigator.userAgent.match(/Chrom(e|ium)\/([\d\.]+)\./);
    return match2 ? parseFloat(match2[2]) : false;
  }
  return false;
};
var getSafariVersion = function getSafariVersion2() {
  if (canUseDOM$1) {
    var match2 = window.navigator.userAgent.match(/Version\/([\d\.]+).*Safari/);
    return match2 ? parseFloat(match2[1]) : false;
  }
  return false;
};
var isSupportFlexGap = function isSupportFlexGap2() {
  if (typeof CSS !== "undefined" && typeof CSS.supports !== "undefined") {
    return CSS.supports("(gap: 1px)");
  }
  if (isIE()) {
    return false;
  }
  var chromeVersion = getChromeVersion();
  var safariVersion = getSafariVersion();
  if (chromeVersion) {
    return chromeVersion >= 84;
  }
  if (safariVersion) {
    return safariVersion >= 14.1;
  }
  return true;
};
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var baseFor = _baseFor, keys$3 = keys_1;
function baseForOwn$1(object, iteratee) {
  return object && baseFor(object, iteratee, keys$3);
}
var _baseForOwn = baseForOwn$1;
var isArrayLike$2 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$2(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length2) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$2 = createBaseEach(baseForOwn);
var _baseEach = baseEach$2;
var identity$2 = identity_1;
function castFunction$1(value) {
  return typeof value == "function" ? value : identity$2;
}
var _castFunction = castFunction$1;
var arrayEach = _arrayEach, baseEach$1 = _baseEach, castFunction = _castFunction, isArray$6 = isArray_1;
function forEach$1(collection, iteratee) {
  var func = isArray$6(collection) ? arrayEach : baseEach$1;
  return func(collection, castFunction(iteratee));
}
var forEach_1 = forEach$1;
const forEach$2 = /* @__PURE__ */ getDefaultExportFromCjs(forEach_1);
var baseGetTag$1 = _baseGetTag, isArray$5 = isArray_1, isObjectLike$2 = isObjectLike_1;
var stringTag$1 = "[object String]";
function isString$2(value) {
  return typeof value == "string" || !isArray$5(value) && isObjectLike$2(value) && baseGetTag$1(value) == stringTag$1;
}
var isString_1 = isString$2;
const isString$3 = /* @__PURE__ */ getDefaultExportFromCjs(isString_1);
var arrayMap$1 = _arrayMap;
function baseValues$1(object, props) {
  return arrayMap$1(props, function(key) {
    return object[key];
  });
}
var _baseValues = baseValues$1;
var baseValues = _baseValues, keys$2 = keys_1;
function values$3(object) {
  return object == null ? [] : baseValues(object, keys$2(object));
}
var values_1 = values$3;
var baseIndexOf$2 = _baseIndexOf, isArrayLike$1 = isArrayLike_1, isString$1 = isString_1, toInteger$2 = toInteger_1, values$2 = values_1;
var nativeMax$1 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike$1(collection) ? collection : values$2(collection);
  fromIndex = fromIndex && !guard ? toInteger$2(fromIndex) : 0;
  var length2 = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax$1(length2 + fromIndex, 0);
  }
  return isString$1(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf$2(collection, value, fromIndex) > -1;
}
var includes_1 = includes;
const includes$1 = /* @__PURE__ */ getDefaultExportFromCjs(includes_1);
var htmlInputAttrs = [
  // REACT
  "selected",
  "defaultValue",
  "defaultChecked",
  // LIMITED HTML PROPS
  "autoCapitalize",
  "autoComplete",
  "autoCorrect",
  "autoFocus",
  "checked",
  "disabled",
  "form",
  "id",
  "list",
  "max",
  "maxLength",
  "min",
  "minLength",
  "multiple",
  "name",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "step",
  "type",
  "value"
];
var htmlInputEvents = [
  // EVENTS
  // keyboard
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  // focus
  "onFocus",
  "onBlur",
  // form
  "onChange",
  "onInput",
  // mouse
  "onClick",
  "onContextMenu",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  // selection
  "onSelect",
  // touch
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart"
];
var htmlInputProps = [].concat(htmlInputAttrs, htmlInputEvents);
var partitionHTMLProps = function partitionHTMLProps2(props, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$htmlProps = _options.htmlProps, htmlProps = _options$htmlProps === void 0 ? htmlInputProps : _options$htmlProps, _options$includeAria = _options.includeAria, includeAria = _options$includeAria === void 0 ? true : _options$includeAria;
  var inputProps = {};
  var rest = {};
  forEach$2(props, function(val, prop) {
    var possibleAria = includeAria && (/^aria-.*$/.test(prop) || prop === "role");
    var target = includes$1(htmlProps, prop) || possibleAria ? inputProps : rest;
    target[prop] = val;
  });
  return [inputProps, rest];
};
function reactToString(element) {
  var nodes = [];
  var recursion = function recursion2(elmt) {
    React.Children.forEach(elmt.props.children, function(child) {
      if (/* @__PURE__ */ React.isValidElement(child)) {
        recursion2(child);
      } else if (typeof child === "string") {
        nodes.push(child);
      }
    });
  };
  recursion(element);
  return nodes;
}
function stringifyReactNode(node2) {
  if (typeof node2 === "string") {
    return node2;
  } else if (/* @__PURE__ */ React.isValidElement(node2)) {
    var nodes = reactToString(node2);
    return nodes.join("");
  }
  return "";
}
function getSafeRegExpString(str) {
  return str.replace(/([\^\$\.\|\*\+\?\{\\\[\(\)])/g, "\\$1");
}
function safeFindDOMNode(componentOrElement) {
  if (componentOrElement && "setState" in componentOrElement) {
    return ReactDOM.findDOMNode(componentOrElement);
  }
  return componentOrElement !== null && componentOrElement !== void 0 ? componentOrElement : null;
}
var getRefTarget = function getRefTarget2(ref) {
  return ref && ("current" in ref ? ref.current : ref);
};
function getDOMNode(elementOrRef) {
  var element = (elementOrRef === null || elementOrRef === void 0 ? void 0 : elementOrRef.root) || (elementOrRef === null || elementOrRef === void 0 ? void 0 : elementOrRef.child) || getRefTarget(elementOrRef);
  if (element !== null && element !== void 0 && element.nodeType && typeof (element === null || element === void 0 ? void 0 : element.nodeName) === "string") {
    return element;
  }
  return safeFindDOMNode(element);
}
function guid() {
  return "_" + Math.random().toString(36).substring(2, 12);
}
function createChainedFunction$1() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  return funcs.filter(function(f2) {
    return f2 !== null && typeof f2 !== "undefined";
  }).reduce(function(acc, f2) {
    if (typeof f2 !== "function") {
      throw new Error("Invalid Argument Type, must only provide functions, undefined, or null.");
    }
    if (acc === void 0) {
      return f2;
    }
    return function chainedFunction() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      acc.apply(this, args);
      f2.apply(this, args);
    };
  }, void 0);
}
function isOneOf(one, ofTarget) {
  if (Array.isArray(ofTarget)) {
    return ofTarget.indexOf(one) >= 0;
  }
  return one === ofTarget;
}
function typeOf(object) {
  if (typeof object === "object" && object !== null) {
    return object.type || object.$$typeof;
  }
}
function isFragment(children) {
  return React.Children.count(children) === 1 && typeOf(children) === Symbol.for("react.fragment");
}
function flatChildren(children) {
  return React.Children.toArray(React.Children.map(children, function(child) {
    if (isFragment(child)) {
      var _child$props;
      return React.Children.toArray(((_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.children) || []);
    }
    return child;
  }));
}
function find$2(children, func, context) {
  var index = 0;
  var result;
  React.Children.forEach(flatChildren(children), function(child) {
    if (result) {
      return;
    }
    index += 1;
    if (func.call(context, child, index)) {
      result = child;
    }
  });
  return result;
}
function map(children, func, context) {
  var index = 0;
  return React.Children.map(flatChildren(children), function(child) {
    if (!/* @__PURE__ */ React.isValidElement(child)) {
      return child;
    }
    var handle = func.call(context, child, index);
    index += 1;
    return handle;
  });
}
function mapCloneElement(children, func, context) {
  return map(children, function(child, index) {
    return /* @__PURE__ */ React.cloneElement(child, _extends$1({
      key: index
    }, func(child, index)));
  }, context);
}
function forEach(children, func, context) {
  var index = 0;
  React.Children.forEach(flatChildren(children), function(child) {
    if (!/* @__PURE__ */ React.isValidElement(child)) {
      return;
    }
    func.call(context, child, index);
    index += 1;
  });
}
function count$1(children) {
  return React.Children.count(flatChildren(children));
}
function some(children, func, context) {
  var index = 0;
  var result = false;
  React.Children.forEach(flatChildren(children), function(child) {
    if (result) {
      return;
    }
    if (!/* @__PURE__ */ React.isValidElement(child)) {
      return;
    }
    if (func.call(context, child, index += 1)) {
      result = true;
    }
  });
  return result;
}
var ReactChildren = {
  /**
   * Maps over the children and clones each child element with the provided props.
   */
  mapCloneElement,
  /**
   * Returns the number of children.
   */
  count: count$1,
  /**
   * Checks if any child satisfies the given condition.
   */
  some,
  /**
   * Maps over the children and applies the given function to each child.
   */
  map,
  /**
   * Iterates over children that are in flat array form.
   */
  forEach,
  /**
   * Finds the first child that satisfies the given condition.
   */
  find: find$2
};
function placementPolyfill(placement, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  if (typeof placement === "string") {
    if (rtl) {
      placement = placement.replace(/left|right/, function(m4) {
        return m4 === "left" ? "right" : "left";
      });
    }
    return placement.replace(/Left|Top/, "Start").replace(/Right|Bottom/, "End");
  }
  return placement;
}
var toFnRef = function toFnRef2(ref) {
  return !ref || typeof ref === "function" ? ref : function(value) {
    ref.current = value;
  };
};
function mergeRefs(refA, refB) {
  var a3 = toFnRef(refA);
  var b3 = toFnRef(refB);
  return function(value) {
    if (typeof a3 === "function") a3(value);
    if (typeof b3 === "function") b3(value);
  };
}
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
function is(x3, y4) {
  if (x3 === y4) {
    return x3 !== 0 || y4 !== 0 || 1 / x3 === 1 / y4;
  }
  return x3 !== x3 && y4 !== y4;
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (var i2 = 0; i2 < keysA.length; i2 += 1) {
    if (!hasOwnProperty$3.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
function composeFunctions() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(first) {
    return fns.reduce(function(previousValue, fn2) {
      return fn2(previousValue);
    }, first);
  };
}
function scrollTopAnimation(target, nextTop, animation, callback) {
  if (animation === void 0) {
    animation = true;
  }
  var top2 = scrollTop(target);
  var step = function step2() {
    scrollTop(target, top2 > nextTop ? nextTop : top2);
    if (top2 <= nextTop) {
      requestAnimationFramePolyfill(step2);
    }
    top2 += 20;
  };
  if (animation) {
    requestAnimationFramePolyfill(step);
  } else {
    scrollTop(target, nextTop);
  }
}
var majorVersion = parseInt(React.version);
var SuperposedReactDOM = ReactDOM$1;
function render(element, container) {
  var mountElement = document.createElement("div");
  mountElement.className = "rs-mount-element";
  var containerElement = container || document.body;
  containerElement.appendChild(mountElement);
  if (majorVersion >= 18) {
    reactDomExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = true;
    var createRoot2 = SuperposedReactDOM.createRoot;
    var root2 = containerElement.__root || createRoot2(mountElement, {
      identifierPrefix: "rs-root-"
    });
    root2.render(element);
    containerElement.__root = root2;
    return root2;
  }
  SuperposedReactDOM.render(element, mountElement);
  return {
    unmount: function unmount() {
      SuperposedReactDOM.unmountComponentAtNode(mountElement);
      containerElement.removeChild(mountElement);
    }
  };
}
var strNone = "none";
function safeSetSelection(element, selectionStart, selectionEnd) {
  if (document.activeElement === element) {
    if (isAndroid$1()) {
      requestAnimationFrame(function() {
        return element.setSelectionRange(selectionStart, selectionEnd, strNone);
      });
    } else {
      element.setSelectionRange(selectionStart, selectionEnd, strNone);
    }
  }
}
function getStringLength(str) {
  var length2 = 0;
  Array.from(str).forEach(function(char2) {
    if (char2.charCodeAt(0) > 255) {
      length2 += 2;
    } else {
      length2++;
    }
  });
  return length2;
}
function arrayAggregator$1(array, setter, iteratee, accumulator) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}
var _arrayAggregator = arrayAggregator$1;
var baseEach = _baseEach;
function baseAggregator$1(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
var _baseAggregator = baseAggregator$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values2) {
  var index = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index < length2) {
    this.add(values2[index]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache2, key) {
  return cache2.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array2 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag$1:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var Stack$3 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$4 = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$4(object), othIsArr = isArray$4(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$3());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$3());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$3());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$1 = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}
var _baseIsEqual = baseIsEqual$2;
var Stack$2 = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length, length2 = index, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length2) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$2();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$5 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$5(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$1 = keys_1;
function getMatchData$1(object) {
  var result = keys$1(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var baseGet$3 = _baseGet;
function get$3(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$3(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$3;
const get$4 = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath, isArguments = isArguments_1, isArray$3 = isArray_1, isIndex$2 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$2(path, object);
  var index = -1, length2 = path.length, result = false;
  while (++index < length2) {
    var key = toKey$3(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex$2(key, length2) && (isArray$3(object) || isArguments(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$2(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$2;
var baseIsEqual = _baseIsEqual, get$2 = get_1, hasIn$1 = hasIn_1, isKey$2 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$2(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$2(path), srcValue);
  }
  return function(object) {
    var objValue = get$2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$2 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object) {
    return baseGet$2(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;
function property$1(path) {
  return isKey$1(path) ? baseProperty(toKey$1(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$1 = identity_1, isArray$2 = isArray_1, property = property_1;
function baseIteratee$8(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$8;
var arrayAggregator = _arrayAggregator, baseAggregator = _baseAggregator, baseIteratee$7 = _baseIteratee, isArray$1 = isArray_1;
function createAggregator$1(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee$7(iteratee), accumulator);
  };
}
var _createAggregator = createAggregator$1;
var baseAssignValue = _baseAssignValue, createAggregator = _createAggregator;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var groupBy$1 = createAggregator(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});
var groupBy_1 = groupBy$1;
const _groupBy = /* @__PURE__ */ getDefaultExportFromCjs(groupBy_1);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike) {
    if (it) o = it;
    var i2 = 0;
    return function() {
      if (i2 >= o.length) return { done: true };
      return { done: false, value: o[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor) n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
var WalkTreeStrategy = /* @__PURE__ */ function(WalkTreeStrategy2) {
  WalkTreeStrategy2[WalkTreeStrategy2["DFS"] = 0] = "DFS";
  WalkTreeStrategy2[WalkTreeStrategy2["BFS"] = 1] = "BFS";
  return WalkTreeStrategy2;
}({});
function flattenTree(rootNodes, getChildren, walkStrategy) {
  if (walkStrategy === void 0) {
    walkStrategy = WalkTreeStrategy.BFS;
  }
  var result = [];
  if (walkStrategy === WalkTreeStrategy.BFS) {
    walkTreeBfs(rootNodes, getChildren, function(node2) {
      return result.push(node2);
    });
  } else if (walkStrategy === WalkTreeStrategy.DFS) {
    walkTreeDfs(rootNodes, getChildren, function(node2) {
      return result.push(node2);
    });
  }
  return result;
}
function walkTreeBfs(rootNodes, getChildren, callback) {
  for (var queue = [].concat(rootNodes); queue.length > 0; ) {
    var node2 = queue.shift();
    callback(node2);
    var children = getChildren(node2);
    if (children) {
      queue.push.apply(queue, children);
    }
  }
}
function walkTreeDfs(rootNodes, getChildren, callback) {
  for (var _iterator = _createForOfIteratorHelperLoose(rootNodes), _step; !(_step = _iterator()).done; ) {
    var node2 = _step.value;
    callback(node2);
    var children = getChildren(node2);
    if (children) {
      walkTreeDfs(children, getChildren, callback);
    }
  }
}
var RSUITE_PICKER_TYPE = Symbol.for("rsuite.picker");
var RSUITE_PICKER_GROUP_KEY = Symbol.for("rsuite.picker_group_key");
var KEY_GROUP_TITLE = "groupTitle";
function getDataGroupBy(data, key, sort) {
  var groupMap = _groupBy(data, key);
  var isSort = typeof sort === "function";
  var groups = Object.entries(groupMap).map(function(_ref) {
    var _ref2;
    var groupTitle = _ref[0], children = _ref[1];
    return _ref2 = {
      children: isSort ? children.sort(sort(false)) : children
    }, _ref2[KEY_GROUP_TITLE] = groupTitle, _ref2[RSUITE_PICKER_GROUP_KEY] = true, _ref2;
  });
  if (isSort) {
    groups.sort(sort(true));
  }
  return flattenTree(groups, function(group) {
    return group.children;
  }, WalkTreeStrategy.DFS);
}
var warned = {};
function warnOnce(message) {
  if (!warned[message]) {
    console.warn(message);
    warned[message] = true;
  }
}
warnOnce._resetWarned = function() {
  for (var message in warned) {
    delete warned[message];
  }
};
function deprecateComponent(Component, message) {
  var _Component$displayNam;
  var componentDisplayName = (_Component$displayNam = Component.displayName) !== null && _Component$displayNam !== void 0 ? _Component$displayNam : Component.name;
  var Deprecated = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    warnOnce(message);
    return /* @__PURE__ */ React.createElement(Component, _extends$1({
      ref
    }, props));
  });
  Deprecated.displayName = "deprecated(" + componentDisplayName + ")";
  return Deprecated;
}
var _excluded$2c = ["name", "componentAs", "componentClassPrefix"], _excluded2$o = ["as", "classPrefix", "className", "role"];
function createComponent(_ref) {
  var name = _ref.name, componentAs = _ref.componentAs, componentClassPrefix = _ref.componentClassPrefix, defaultProps2 = _objectWithoutPropertiesLoose(_ref, _excluded$2c);
  var Component = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _props$as = props.as, Component2 = _props$as === void 0 ? componentAs || "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? componentClassPrefix || kebabCase$1(name) : _props$classPrefix, className = props.className, role = props.role, rest = _objectWithoutPropertiesLoose(props, _excluded2$o);
    var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
    var classes = merge2(className, withClassPrefix());
    return /* @__PURE__ */ React.createElement(Component2, _extends$1({}, defaultProps2, rest, {
      role,
      ref,
      className: classes
    }));
  });
  Component.displayName = name;
  Component.propTypes = {
    as: PropTypes.elementType,
    className: PropTypes.string,
    classPrefix: PropTypes.string,
    children: PropTypes.node
  };
  return Component;
}
function isFocusEntering(event) {
  return event.type === "focus" && !event.currentTarget.contains(event.relatedTarget);
}
function isFocusLeaving(event) {
  return event.type === "blur" && !event.currentTarget.contains(event.relatedTarget);
}
var focusableSelector = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(function(selector) {
  return selector + ":not([tabindex='-1'])";
}).join(",");
function isFocusableElement(element) {
  if (element === document.body) return false;
  return element.matches(focusableSelector);
}
function getAnimationEnd() {
  var style2 = document.createElement("div").style;
  if ("webkitAnimation" in style2) {
    return "webkitAnimationEnd";
  }
  return "animationend";
}
var animationPropTypes = {
  onEnter: PropTypes.func,
  onEntering: PropTypes.func,
  onEntered: PropTypes.func,
  onExit: PropTypes.func,
  onExiting: PropTypes.func,
  onExited: PropTypes.func
};
var _excluded$2b = ["children", "className", "exitedClassName", "enteringClassName", "enteredClassName", "exitingClassName"];
var STATUS = /* @__PURE__ */ function(STATUS2) {
  STATUS2[STATUS2["UNMOUNTED"] = 0] = "UNMOUNTED";
  STATUS2[STATUS2["EXITED"] = 1] = "EXITED";
  STATUS2[STATUS2["ENTERING"] = 2] = "ENTERING";
  STATUS2[STATUS2["ENTERED"] = 3] = "ENTERED";
  STATUS2[STATUS2["EXITING"] = 4] = "EXITING";
  return STATUS2;
}({});
var transitionPropTypes = _extends$1({}, animationPropTypes, {
  animation: PropTypes.bool,
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  className: PropTypes.string,
  in: PropTypes.bool,
  unmountOnExit: PropTypes.bool,
  transitionAppear: PropTypes.bool,
  timeout: PropTypes.number,
  exitedClassName: PropTypes.string,
  exitingClassName: PropTypes.string,
  enteredClassName: PropTypes.string,
  enteringClassName: PropTypes.string
});
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  function Transition2(props) {
    var _this2;
    _this2 = _React$Component.call(this, props) || this;
    _this2.animationEventListener = null;
    _this2.instanceElement = null;
    _this2.nextCallback = null;
    _this2.needsUpdate = null;
    _this2.childRef = void 0;
    var initialStatus;
    if (props.in) {
      initialStatus = props.transitionAppear ? STATUS.EXITED : STATUS.ENTERED;
    } else {
      initialStatus = props.unmountOnExit ? STATUS.UNMOUNTED : STATUS.EXITED;
    }
    _this2.state = {
      status: initialStatus
    };
    _this2.nextCallback = null;
    _this2.childRef = /* @__PURE__ */ React.createRef();
    return _this2;
  }
  _inheritsLoose(Transition2, _React$Component);
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.in && nextProps.unmountOnExit) {
      if (prevState.status === STATUS.UNMOUNTED) {
        return {
          status: STATUS.EXITED
        };
      }
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate() {
    if (!this.props.in || !this.props.unmountOnExit) {
      this.needsUpdate = true;
    }
    return null;
  };
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.transitionAppear && this.props.in) {
      this.performEnter(this.props);
    }
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    var status = this.state.status;
    var unmountOnExit = this.props.unmountOnExit;
    if (unmountOnExit && status === STATUS.EXITED) {
      if (this.props.in) {
        this.performEnter(this.props);
      } else {
        if (this.instanceElement) {
          this.setState({
            status: STATUS.UNMOUNTED
          });
        }
      }
      return;
    }
    if (this.needsUpdate) {
      this.needsUpdate = false;
      if (this.props.in) {
        if (status === STATUS.EXITING || status === STATUS.EXITED) {
          this.performEnter(this.props);
        }
      } else if (status === STATUS.ENTERING || status === STATUS.ENTERED) {
        this.performExit(this.props);
      }
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
    this.instanceElement = null;
  };
  _proto.onTransitionEnd = function onTransitionEnd(node2, handler) {
    var _this$animationEventL;
    this.setNextCallback(handler);
    (_this$animationEventL = this.animationEventListener) === null || _this$animationEventL === void 0 ? void 0 : _this$animationEventL.off();
    if (!this.nextCallback) {
      return;
    }
    if (node2) {
      var _this$props = this.props, timeout = _this$props.timeout, animation = _this$props.animation;
      this.animationEventListener = on(node2, animation ? getAnimationEnd() : getTransitionEnd(), this.nextCallback);
      if (timeout !== null) {
        setTimeout(this.nextCallback, timeout);
      }
    } else {
      setTimeout(this.nextCallback, 0);
    }
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this2 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (!active) {
        return;
      }
      if (event) {
        if (_this2.instanceElement === event.target) {
          callback(event);
          active = false;
          _this2.nextCallback = null;
        }
        return;
      }
      callback(event);
      active = false;
      _this2.nextCallback = null;
    };
    if (this.nextCallback) {
      this.nextCallback.cancel = function() {
        active = false;
      };
    }
    return this.nextCallback;
  };
  _proto.getChildElement = function getChildElement() {
    if (this.childRef.current) {
      return getDOMNode(this.childRef.current);
    }
    return getDOMNode(this);
  };
  _proto.performEnter = function performEnter(props) {
    var _this3 = this;
    var _ref = props || this.props, onEnter = _ref.onEnter, onEntering = _ref.onEntering, onEntered = _ref.onEntered;
    this.cancelNextCallback();
    var node2 = this.getChildElement();
    this.instanceElement = node2;
    onEnter === null || onEnter === void 0 ? void 0 : onEnter(node2);
    this.safeSetState({
      status: STATUS.ENTERING
    }, function() {
      onEntering === null || onEntering === void 0 ? void 0 : onEntering(node2);
      _this3.onTransitionEnd(node2, function() {
        _this3.safeSetState({
          status: STATUS.ENTERED
        }, function() {
          onEntered === null || onEntered === void 0 ? void 0 : onEntered(node2);
        });
      });
    });
  };
  _proto.performExit = function performExit(props) {
    var _this4 = this;
    var _ref2 = props || this.props, onExit = _ref2.onExit, onExiting = _ref2.onExiting, onExited = _ref2.onExited;
    this.cancelNextCallback();
    var node2 = this.getChildElement();
    this.instanceElement = node2;
    onExit === null || onExit === void 0 ? void 0 : onExit(node2);
    this.safeSetState({
      status: STATUS.EXITING
    }, function() {
      onExiting === null || onExiting === void 0 ? void 0 : onExiting(node2);
      _this4.onTransitionEnd(node2, function() {
        _this4.safeSetState({
          status: STATUS.EXITED
        }, function() {
          onExited === null || onExited === void 0 ? void 0 : onExited(node2);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    if (this.instanceElement) {
      var nextCallback = this.setNextCallback(callback);
      this.setState(nextState, function() {
        return nextCallback === null || nextCallback === void 0 ? void 0 : nextCallback();
      });
    }
  };
  _proto.render = function render2() {
    var _child$props;
    var status = this.state.status;
    if (status === STATUS.UNMOUNTED) {
      return null;
    }
    var _this$props2 = this.props, children = _this$props2.children, className = _this$props2.className, exitedClassName = _this$props2.exitedClassName, enteringClassName = _this$props2.enteringClassName, enteredClassName = _this$props2.enteredClassName, exitingClassName = _this$props2.exitingClassName, rest = _objectWithoutPropertiesLoose(_this$props2, _excluded$2b);
    var childProps = omit$1(rest, Object.keys(transitionPropTypes));
    var transitionClassName;
    if (status === STATUS.EXITED) {
      transitionClassName = exitedClassName;
    } else if (status === STATUS.ENTERING) {
      transitionClassName = enteringClassName;
    } else if (status === STATUS.ENTERED) {
      transitionClassName = enteredClassName;
    } else if (status === STATUS.EXITING) {
      transitionClassName = exitingClassName;
    }
    if (isFunction$5(children)) {
      childProps.className = classNames(className, transitionClassName);
      return children(childProps, this.childRef);
    }
    var child = React.Children.only(children);
    return /* @__PURE__ */ React.cloneElement(child, _extends$1({}, childProps, {
      ref: this.childRef,
      className: classNames(className, (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.className, transitionClassName)
    }));
  };
  return Transition2;
}(React.Component);
Transition$1.propTypes = transitionPropTypes;
Transition$1.displayName = "Transition";
Transition$1.defaultProps = {
  timeout: 1e3
};
var ToastContext = /* @__PURE__ */ React.createContext({
  usedToaster: false
});
ToastContext.displayName = "ToastContext";
var _excluded$2a = ["as", "className", "classPrefix", "placement", "callback"], _excluded2$n = ["className"], _excluded3$8 = ["container"];
var toastPlacements = ["topCenter", "bottomCenter", "topStart", "topEnd", "bottomStart", "bottomEnd"];
var useMessages = function useMessages2() {
  var _useState = reactExports.useState([]), messages = _useState[0], setMessages = _useState[1];
  var getKey = reactExports.useCallback(function(key) {
    if (typeof key === "undefined" && messages.length) {
      return messages[messages.length - 1].key;
    }
    return key;
  }, [messages]);
  var push = reactExports.useCallback(function(message, options) {
    var _ref = options || {}, duration2 = _ref.duration, _ref$mouseReset = _ref.mouseReset, mouseReset = _ref$mouseReset === void 0 ? true : _ref$mouseReset;
    var key = guid();
    setMessages(function(prevMessages) {
      return [].concat(prevMessages, [{
        key,
        visible: true,
        node: message,
        duration: duration2,
        mouseReset
      }]);
    });
    return key;
  }, []);
  var clear = reactExports.useCallback(function() {
    setMessages(messages.map(function(msg2) {
      return _extends$1({}, msg2, {
        visible: false
      });
    }));
    setTimeout(function() {
      setMessages([]);
    }, 400);
  }, [messages]);
  var remove2 = reactExports.useCallback(function(key) {
    setMessages(messages.map(function(n2) {
      if (n2.key === getKey(key)) {
        n2.visible = false;
      }
      return n2;
    }));
    setTimeout(function() {
      setMessages(messages.filter(function(msg2) {
        return msg2.visible;
      }));
    }, 400);
  }, [messages, getKey]);
  return {
    messages,
    push,
    clear,
    remove: remove2
  };
};
var ToastContainer = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var rootRef = reactExports.useRef();
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "toast-container" : _props$classPrefix, _props$placement = props.placement, placement = _props$placement === void 0 ? "topCenter" : _props$placement, callback = props.callback, rest = _objectWithoutPropertiesLoose(props, _excluded$2a);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, rootPrefix = _useClassNames.rootPrefix;
  var classes = merge2(className, withClassPrefix(kebabCase$1(placement)));
  var _useMessages = useMessages(), push = _useMessages.push, clear = _useMessages.clear, remove2 = _useMessages.remove, messages = _useMessages.messages;
  reactExports.useImperativeHandle(ref, function() {
    return {
      root: rootRef.current,
      push,
      clear,
      remove: remove2
    };
  });
  var elements = messages.map(function(item) {
    var mouseReset = item.mouseReset, duration2 = item.duration, node2 = item.node;
    return /* @__PURE__ */ React.createElement(ToastContext.Provider, {
      value: {
        usedToaster: true,
        mouseReset,
        duration: duration2
      },
      key: item.key
    }, /* @__PURE__ */ React.createElement(Transition$1, {
      in: item.visible,
      exitedClassName: rootPrefix("toast-fade-exited"),
      exitingClassName: rootPrefix("toast-fade-exiting"),
      enteringClassName: rootPrefix("toast-fade-entering"),
      enteredClassName: rootPrefix("toast-fade-entered"),
      timeout: 300
    }, function(transitionProps, ref2) {
      var _node$props, _node$props2;
      var transitionClassName = transitionProps.className, rest2 = _objectWithoutPropertiesLoose(transitionProps, _excluded2$n);
      return /* @__PURE__ */ React.cloneElement(node2, _extends$1({}, rest2, {
        ref: ref2,
        duration: duration2,
        onClose: createChainedFunction$1((_node$props = node2.props) === null || _node$props === void 0 ? void 0 : _node$props.onClose, function() {
          return remove2(item.key);
        }),
        className: merge2(rootPrefix("toast"), (_node$props2 = node2.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.className, transitionClassName)
      }));
    }));
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref: function ref2(selfRef) {
      rootRef.current = selfRef;
      callback === null || callback === void 0 ? void 0 : callback(selfRef);
    },
    className: classes
  }), elements);
});
ToastContainer.getInstance = function(props) {
  var container = props.container, rest = _objectWithoutPropertiesLoose(props, _excluded3$8);
  var containerRef = /* @__PURE__ */ React.createRef();
  var containerElement = (typeof container === "function" ? container() : container) || document.body;
  return new Promise(function(resolve) {
    var renderCallback = function renderCallback2() {
      resolve([containerRef, unmount]);
    };
    var _render = render(/* @__PURE__ */ React.createElement(ToastContainer, _extends$1({}, rest, {
      ref: containerRef,
      callback: renderCallback
    })), containerElement), unmount = _render.unmount;
  });
};
ToastContainer.displayName = "ToastContainer";
ToastContainer.propTypes = {
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  placement: PropTypes.elementType,
  container: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  callback: PropTypes.func
};
const ToastContainer$1 = ToastContainer;
var _excluded$29 = ["children", "classPrefix", "theme", "toastContainer", "disableRipple"];
var CustomContext = /* @__PURE__ */ React.createContext({});
var themes = ["light", "dark", "high-contrast"];
var CustomProvider = function CustomProvider2(props) {
  var children = props.children, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? getClassNamePrefix$1() : _props$classPrefix, theme = props.theme, container = props.toastContainer, disableRipple = props.disableRipple, rest = _objectWithoutPropertiesLoose(props, _excluded$29);
  var toasters = React.useRef(/* @__PURE__ */ new Map());
  var _usePortal = usePortal({
    container,
    waitMount: true
  }), Portal3 = _usePortal.Portal;
  var value = React.useMemo(function() {
    return _extends$1({
      classPrefix,
      theme,
      toasters,
      disableRipple
    }, rest);
  }, [classPrefix, theme, disableRipple, rest]);
  useIsomorphicLayoutEffect$2(function() {
    if (canUseDOM$1 && theme) {
      addClass$1(document.body, prefix$4(classPrefix, "theme-" + theme));
      themes.forEach(function(t3) {
        if (t3 !== theme) {
          removeClass$2(document.body, prefix$4(classPrefix, "theme-" + t3));
        }
      });
    }
  }, [classPrefix, theme]);
  return /* @__PURE__ */ React.createElement(CustomContext.Provider, {
    value
  }, children, /* @__PURE__ */ React.createElement(Portal3, null, /* @__PURE__ */ React.createElement("div", {
    className: "rs-toast-provider"
  }, toastPlacements.map(function(placement) {
    return /* @__PURE__ */ React.createElement(ToastContainer$1, {
      key: placement,
      placement,
      ref: function ref(_ref) {
        toasters.current.set(placement, _ref);
      }
    });
  }))));
};
function useClassNames$2(str) {
  var _ref = reactExports.useContext(CustomContext) || {}, _ref$classPrefix = _ref.classPrefix, classPrefix = _ref$classPrefix === void 0 ? "rs" : _ref$classPrefix;
  var componentName = prefix$4(classPrefix, str);
  var prefix2 = reactExports.useCallback(function() {
    var mergeClasses = arguments.length ? classNames.apply(void 0, arguments).split(" ").map(function(item) {
      return prefix$4(componentName, item);
    }) : [];
    return mergeClasses.filter(function(cls) {
      return cls;
    }).join(" ");
  }, [componentName]);
  var withClassPrefix = reactExports.useCallback(function() {
    for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
      classes[_key] = arguments[_key];
    }
    var mergeClasses = prefix2(classes);
    return mergeClasses ? componentName + " " + mergeClasses : componentName;
  }, [componentName, prefix2]);
  var rootPrefix = function rootPrefix2() {
    var mergeClasses = arguments.length ? classNames.apply(void 0, arguments).split(" ").map(function(item) {
      return prefix$4(classPrefix, item);
    }) : [];
    return mergeClasses.filter(function(cls) {
      return cls;
    }).join(" ");
  };
  return {
    withClassPrefix,
    merge: classNames,
    prefix: prefix2,
    rootPrefix
  };
}
function useClickOutside(_ref) {
  var _ref$enabled = _ref.enabled, enabled = _ref$enabled === void 0 ? true : _ref$enabled, isOutside = _ref.isOutside, handle = _ref.handle;
  var isOutsideRef = reactExports.useRef(isOutside);
  var handleRef = reactExports.useRef(handle);
  reactExports.useEffect(function() {
    isOutsideRef.current = isOutside;
    handleRef.current = handle;
  }, [isOutside, handle]);
  reactExports.useEffect(function() {
    if (enabled) {
      var eventHandler = function eventHandler2(event) {
        var _isOutsideRef$current;
        if ((_isOutsideRef$current = isOutsideRef.current) !== null && _isOutsideRef$current !== void 0 && _isOutsideRef$current.call(isOutsideRef, event)) {
          var _handleRef$current;
          (_handleRef$current = handleRef.current) === null || _handleRef$current === void 0 ? void 0 : _handleRef$current.call(handleRef, event);
        }
      };
      window.addEventListener("mousedown", eventHandler);
      return function() {
        window.removeEventListener("mousedown", eventHandler);
      };
    }
  }, [enabled]);
}
function useControlled$2(controlledValue, defaultValue) {
  var controlledRef = reactExports.useRef(false);
  controlledRef.current = controlledValue !== void 0;
  var _useState = reactExports.useState(defaultValue), uncontrolledValue = _useState[0], setUncontrolledValue = _useState[1];
  var value = controlledRef.current ? controlledValue : uncontrolledValue;
  var setValue2 = reactExports.useCallback(function(nextValue) {
    if (!controlledRef.current) {
      setUncontrolledValue(nextValue);
    }
  }, [controlledRef]);
  return [value, setValue2, controlledRef.current];
}
function toInteger$1(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate$1(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var amount = toInteger$1(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var amount = toInteger$1(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate$1(dirtyDate).getTime();
  var amount = toInteger$1(dirtyAmount);
  return new Date(timestamp + amount);
}
function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
var MILLISECONDS_IN_HOUR = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
var defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate$1(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return endOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid$1(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate$1(dirtyDate);
  return !isNaN(Number(date));
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate$1(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate$1(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$1 = {
  // Year
  y: function y(date, token2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  // Month
  M: function M2(date, token2) {
    var month = date.getUTCMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token2) {
    return addLeadingZeros(date.getUTCDate(), token2.length);
  },
  // AM or PM
  a: function a(date, token2) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token2) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token2.length);
  },
  // Hour [0-23]
  H: function H2(date, token2) {
    return addLeadingZeros(date.getUTCHours(), token2.length);
  },
  // Minute
  m: function m(date, token2) {
    return addLeadingZeros(date.getUTCMinutes(), token2.length);
  },
  // Second
  s: function s(date, token2) {
    return addLeadingZeros(date.getUTCSeconds(), token2.length);
  },
  // Fraction of second
  S: function S2(date, token2) {
    var numberOfDigits = token2.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G2(date, token2, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token2, localize2) {
    if (token2 === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$1.y(date, token2);
  },
  // Local week-numbering year
  Y: function Y2(date, token2, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  // ISO week-numbering year
  R: function R2(date, token2) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token2.length);
  },
  // Quarter
  Q: function Q2(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M3(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "M":
      case "MM":
        return formatters$1.M(date, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L2(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token2, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token2.length);
  },
  // ISO week of year
  I: function I2(date, token2, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  // Day of the month
  d: function d2(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$1.d(date, token2);
  },
  // Day of year
  D: function D2(date, token2, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  // Day of week
  E: function E2(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B2(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h2(date, token2, localize2) {
    if (token2 === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$1.h(date, token2);
  },
  // Hour [0-23]
  H: function H3(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$1.H(date, token2);
  },
  // Hour [0-11]
  K: function K2(date, token2, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Hour [1-24]
  k: function k(date, token2, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Minute
  m: function m2(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$1.m(date, token2);
  },
  // Second
  s: function s2(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$1.s(date, token2);
  },
  // Fraction of second
  S: function S3(date, token2) {
    return formatters$1.S(date, token2);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  // Milliseconds timestamp
  T: function T2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset2, dirtyDelimiter) {
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter2 = dirtyDelimiter;
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
  if (offset2 % 60 === 0) {
    var sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, dirtyDelimiter);
}
function formatTimezone(offset2, dirtyDelimiter) {
  var delimiter2 = dirtyDelimiter || "";
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return protectedDayOfYearTokens.indexOf(token2) !== -1;
}
function isProtectedWeekYearToken(token2) {
  return protectedWeekYearTokens.indexOf(token2) !== -1;
}
function throwProtectedError(token2, format2, input) {
  if (token2 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token2, count2, options) {
  var result;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width2 = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width2] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats$1 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats$1 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats$1 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong$1 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: "full"
  })
};
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width2 = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width2] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width2 = options.width;
    var matchPattern = width2 && args.matchPatterns[width2] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width2 && args.parsePatterns[width2] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex$3(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex$3(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match$1 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var locale$1 = {
  code: "en-US",
  formatDistance,
  formatLong: formatLong$1,
  formatRelative,
  localize,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale$1;
  var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate$1(dirtyDate);
  if (!isValid$1(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth2 = /* @__PURE__ */ new Date(0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}
function getHours$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var hours = date.getHours();
  return hours;
}
function getMinutes$1(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var month = date.getMonth();
  return month;
}
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate$1(dirtyDate).getFullYear();
}
function isAfter$1(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var dateToCompare = toDate$1(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var dateToCompare = toDate$1(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
function startOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setMilliseconds(0);
  return date;
}
function isSameSecond(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfSecond = startOfSecond(dirtyDateLeft);
  var dateRightStartOfSecond = startOfSecond(dirtyDateRight);
  return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
}
function _arrayLikeToArray(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r2[e3];
  return n2;
}
function _unsupportedIterableToArray(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a3);
    var t3 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t3 && r2.constructor && (t3 = r2.constructor.name), "Map" === t3 || "Set" === t3 ? Array.from(r2) : "Arguments" === t3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? _arrayLikeToArray(r2, a3) : void 0;
  }
}
function _createForOfIteratorHelper(r2, e3) {
  var t3 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t3) {
    if (Array.isArray(r2) || (t3 = _unsupportedIterableToArray(r2)) || e3) {
      t3 && (r2 = t3);
      var _n = 0, F2 = function F3() {
      };
      return {
        s: F2,
        n: function n2() {
          return _n >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[_n++]
          };
        },
        e: function e4(r3) {
          throw r3;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a3 = true, u3 = false;
  return {
    s: function s3() {
      t3 = t3.call(r2);
    },
    n: function n2() {
      var r3 = t3.next();
      return a3 = r3.done, r3;
    },
    e: function e4(r3) {
      u3 = true, o = r3;
    },
    f: function f2() {
      try {
        a3 || null == t3["return"] || t3["return"]();
      } finally {
        if (u3) throw o;
      }
    }
  };
}
function assign$1(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property2 in object) {
    if (Object.prototype.hasOwnProperty.call(object, property2)) {
      target[property2] = object[property2];
    }
  }
  return target;
}
function _assertThisInitialized(e3) {
  if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}
function _inherits(t3, e3) {
  if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
  t3.prototype = Object.create(e3 && e3.prototype, {
    constructor: {
      value: t3,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t3, "prototype", {
    writable: false
  }), e3 && _setPrototypeOf(t3, e3);
}
function _getPrototypeOf(t3) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf(t3);
}
function _isNativeReflectConstruct() {
  try {
    var t3 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t3;
  })();
}
function _possibleConstructorReturn(t3, e3) {
  if (e3 && ("object" == _typeof(e3) || "function" == typeof e3)) return e3;
  if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t3);
}
function _createSuper(t3) {
  var r2 = _isNativeReflectConstruct();
  return function() {
    var e3, o = _getPrototypeOf(t3);
    if (r2) {
      var s3 = _getPrototypeOf(this).constructor;
      e3 = Reflect.construct(o, arguments, s3);
    } else e3 = o.apply(this, arguments);
    return _possibleConstructorReturn(this, e3);
  };
}
function _classCallCheck(a3, n2) {
  if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function toPrimitive(t3, r2) {
  if ("object" != _typeof(t3) || !t3) return t3;
  var e3 = t3[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t3, r2 || "default");
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t3);
}
function toPropertyKey(t3) {
  var i2 = toPrimitive(t3, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _defineProperties(e3, r2) {
  for (var t3 = 0; t3 < r2.length; t3++) {
    var o = r2[t3];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e3, toPropertyKey(o.key), o);
  }
}
function _createClass(e3, r2, t3) {
  return r2 && _defineProperties(e3.prototype, r2), Object.defineProperty(e3, "prototype", {
    writable: false
  }), e3;
}
function _defineProperty(e3, r2, t3) {
  return (r2 = toPropertyKey(r2)) in e3 ? Object.defineProperty(e3, r2, {
    value: t3,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e3[r2] = t3, e3;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck(this, Setter2);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits(ValueSetter2, _Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue2, priority, subPriority) {
    var _this2;
    _classCallCheck(this, ValueSetter2);
    _this2 = _super.call(this);
    _this2.value = value;
    _this2.validateValue = validateValue;
    _this2.setValue = setValue2;
    _this2.priority = priority;
    if (subPriority) {
      _this2.subPriority = subPriority;
    }
    return _this2;
  }
  _createClass(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
  _inherits(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = /* @__PURE__ */ new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);
var Parser = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck(this, Parser2);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser2, [{
    key: "run",
    value: function run(dateString, token2, match2, options) {
      var result = this.parse(dateString, token2, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits(EraParser2, _Parser);
  var _super = _createSuper(EraParser2);
  function EraParser2() {
    var _this2;
    _classCallCheck(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 140);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this2;
  }
  _createClass(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(YearParser2, _Parser);
  var _super = _createSuper(YearParser2);
  function YearParser2() {
    var _this2;
    _classCallCheck(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 130);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token2 === "yy"
        };
      };
      switch (token2) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalWeekYearParser2, _Parser);
  var _super = _createSuper(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this2;
    _classCallCheck(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 130);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this2;
  }
  _createClass(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token2 === "YY"
        };
      };
      switch (token2) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOWeekYearParser2, _Parser);
  var _super = _createSuper(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this2;
    _classCallCheck(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 130);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      if (token2 === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token2.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ExtendedYearParser2, _Parser);
  var _super = _createSuper(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this2;
    _classCallCheck(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 130);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      if (token2 === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token2.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits(QuarterParser2, _Parser);
  var _super = _createSuper(QuarterParser2);
  function QuarterParser2() {
    var _this2;
    _classCallCheck(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 120);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "Q":
        case "QQ":
          return parseNDigits(token2.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this2;
    _classCallCheck(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 120);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "q":
        case "qq":
          return parseNDigits(token2.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits(MonthParser2, _Parser);
  var _super = _createSuper(MonthParser2);
  function MonthParser2() {
    var _this2;
    _classCallCheck(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty(_assertThisInitialized(_this2), "priority", 110);
    return _this2;
  }
  _createClass(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token2) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneMonthParser2, _Parser);
  var _super = _createSuper(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this2;
    _classCallCheck(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 110);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token2) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var week = toInteger$1(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalWeekParser2, _Parser);
  var _super = _createSuper(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this2;
    _classCallCheck(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 100);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this2;
  }
  _createClass(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var isoWeek = toInteger$1(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOWeekParser2, _Parser);
  var _super = _createSuper(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this2;
    _classCallCheck(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 100);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DateParser2, _Parser);
  var _super = _createSuper(DateParser2);
  function DateParser2() {
    var _this2;
    _classCallCheck(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 90);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayOfYearParser2, _Parser);
  var _super = _createSuper(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this2;
    _classCallCheck(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 90);
    _defineProperty(_assertThisInitialized(_this2), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate$1(dirtyDate);
  var day = toInteger$1(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayParser2, _Parser);
  var _super = _createSuper(DayParser2);
  function DayParser2() {
    var _this2;
    _classCallCheck(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 90);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalDayParser2, _Parser);
  var _super = _createSuper(LocalDayParser2);
  function LocalDayParser2() {
    var _this2;
    _classCallCheck(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 90);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this2;
  }
  _createClass(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this2;
    _classCallCheck(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 90);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this2;
  }
  _createClass(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger$1(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate$1(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISODayParser2, _Parser);
  var _super = _createSuper(ISODayParser2);
  function ISODayParser2() {
    var _this2;
    _classCallCheck(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 90);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this2;
  }
  _createClass(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token2) {
        case "i":
        case "ii":
          return parseNDigits(token2.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits(AMPMParser2, _Parser);
  var _super = _createSuper(AMPMParser2);
  function AMPMParser2() {
    var _this2;
    _classCallCheck(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 80);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this2;
  }
  _createClass(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits(AMPMMidnightParser2, _Parser);
  var _super = _createSuper(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this2;
    _classCallCheck(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 80);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this2;
  }
  _createClass(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayPeriodParser2, _Parser);
  var _super = _createSuper(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this2;
    _classCallCheck(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 80);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this2;
  }
  _createClass(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour1to12Parser2, _Parser);
  var _super = _createSuper(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this2;
    _classCallCheck(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 70);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this2;
  }
  _createClass(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour0to23Parser2, _Parser);
  var _super = _createSuper(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this2;
    _classCallCheck(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 70);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this2;
  }
  _createClass(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour0To11Parser2, _Parser);
  var _super = _createSuper(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this2;
    _classCallCheck(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 70);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this2;
  }
  _createClass(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour1To24Parser2, _Parser);
  var _super = _createSuper(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this2;
    _classCallCheck(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 70);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this2;
  }
  _createClass(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits(MinuteParser2, _Parser);
  var _super = _createSuper(MinuteParser2);
  function MinuteParser2() {
    var _this2;
    _classCallCheck(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 60);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["t", "T"]);
    return _this2;
  }
  _createClass(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits(SecondParser2, _Parser);
  var _super = _createSuper(SecondParser2);
  function SecondParser2() {
    var _this2;
    _classCallCheck(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 50);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["t", "T"]);
    return _this2;
  }
  _createClass(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits(FractionOfSecondParser2, _Parser);
  var _super = _createSuper(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this2;
    _classCallCheck(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 30);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["t", "T"]);
    return _this2;
  }
  _createClass(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token2.length + 3));
      };
      return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this2;
    _classCallCheck(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 10);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["t", "T", "x"]);
    return _this2;
  }
  _createClass(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      switch (token2) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOTimezoneParser2, _Parser);
  var _super = _createSuper(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this2;
    _classCallCheck(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 10);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", ["t", "T", "X"]);
    return _this2;
  }
  _createClass(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      switch (token2) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampSecondsParser2, _Parser);
  var _super = _createSuper(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this2;
    _classCallCheck(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 40);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", "*");
    return _this2;
  }
  _createClass(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this2;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", 20);
    _defineProperty(_assertThisInitialized(_this2), "incompatibleTokens", "*");
    return _this2;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse$1(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale$1;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger$1((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger$1((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate$1(dirtyReferenceDate);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token2 = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token2)) {
        throwProtectedError(token2, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token2)) {
        throwProtectedError(token2, formatString, dirtyDateString);
      }
      var firstCharacter = token2[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token2, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token2, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token2
        });
        var parseResult = parser.run(dateString, token2, locale2.match, subFnOptions);
        if (!parseResult) {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token2 === "''") {
          token2 = "'";
        } else if (firstCharacter === "'") {
          token2 = cleanEscapedString(token2);
        }
        if (dateString.indexOf(token2) === 0) {
          dateString = dateString.slice(token2.length);
        } else {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b3) {
    return b3 - a3;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b3) {
      return b3.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate$1(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign$1(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function setDate(dirtyDate, dirtyDayOfMonth) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var dayOfMonth = toInteger$1(dirtyDayOfMonth);
  date.setDate(dayOfMonth);
  return date;
}
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var hours = toInteger$1(dirtyHours);
  date.setHours(hours);
  return date;
}
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var minutes = toInteger$1(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var month = toInteger$1(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = /* @__PURE__ */ new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var seconds = toInteger$1(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate$1(dirtyDate);
  var year = toInteger$1(dirtyYear);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger$1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate$1(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger$1(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function set$4(dirtyDate, values2) {
  requiredArgs(2, arguments);
  if (_typeof(values2) !== "object" || values2 === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate$1(dirtyDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (values2.year != null) {
    date.setFullYear(values2.year);
  }
  if (values2.month != null) {
    date = setMonth(date, values2.month);
  }
  if (values2.date != null) {
    date.setDate(toInteger$1(values2.date));
  }
  if (values2.hours != null) {
    date.setHours(toInteger$1(values2.hours));
  }
  if (values2.minutes != null) {
    date.setMinutes(toInteger$1(values2.minutes));
  }
  if (values2.seconds != null) {
    date.setSeconds(toInteger$1(values2.seconds));
  }
  if (values2.milliseconds != null) {
    date.setMilliseconds(toInteger$1(values2.milliseconds));
  }
  return date;
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate$1(dirtyDateLeft);
  var dateRight = toDate$1(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  return endOfDay(date).getTime() === endOfMonth(date).getTime();
}
function lastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate$1(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
function getWeekStartDates(firstDayOfMonth, options) {
  var _options$weekStart = options.weekStart, weekStart = _options$weekStart === void 0 ? 0 : _options$weekStart, isoWeek = options.isoWeek, locale2 = options.locale;
  var weekStartsOn = isoWeek ? 1 : weekStart;
  var firstDay = startOfWeek(firstDayOfMonth, {
    weekStartsOn,
    locale: locale2
  });
  var days = [firstDay];
  for (var i2 = 1; i2 < 6; i2++) {
    days.push(addDays(firstDay, i2 * 7));
  }
  return days;
}
function getWeekKeys(weekStart) {
  var weekKeys = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  if (typeof weekStart === "undefined") {
    return weekKeys;
  }
  return weekKeys.slice(weekStart).concat(weekKeys.slice(0, weekStart));
}
var getReversedTimeMeridian = function getReversedTimeMeridian2(date) {
  var clonedDate = new Date(date.valueOf());
  var hours = getHours$1(clonedDate);
  var nextHours = hours >= 12 ? hours - 12 : hours + 12;
  return setHours(clonedDate, nextHours);
};
function copyTime(_ref) {
  var from2 = _ref.from, to = _ref.to;
  if (!isValid$1(from2) || !isValid$1(to)) {
    return to;
  }
  return set$4(to, {
    hours: getHours$1(from2),
    minutes: getMinutes$1(from2),
    seconds: getSeconds(from2)
  });
}
function reverseDateRangeOmitTime(dateRange) {
  var start2 = dateRange[0], end2 = dateRange[1];
  if (start2 && end2) {
    return [copyTime({
      from: start2,
      to: end2
    }), copyTime({
      from: end2,
      to: start2
    })];
  }
  return dateRange;
}
var FUNC_ERROR_TEXT = "Expected a function";
function negate$1(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_1 = negate$1;
var assignValue = _assignValue, castPath$1 = _castPath, isIndex$1 = _isIndex, isObject$4 = isObject_1, toKey = _toKey;
function baseSet$2(object, path, value, customizer) {
  if (!isObject$4(object)) {
    return object;
  }
  path = castPath$1(path, object);
  var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index < length2) {
    var key = toKey(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$4(objValue) ? objValue : isIndex$1(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$2;
var baseGet$1 = _baseGet, baseSet$1 = _baseSet, castPath = _castPath;
function basePickBy$2(object, paths, predicate) {
  var index = -1, length2 = paths.length, result = {};
  while (++index < length2) {
    var path = paths[index], value = baseGet$1(object, path);
    if (predicate(value, path)) {
      baseSet$1(result, castPath(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$2;
var arrayMap = _arrayMap, baseIteratee$6 = _baseIteratee, basePickBy$1 = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy$1(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$6(predicate);
  return basePickBy$1(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_1 = pickBy$1;
const pickBy$2 = /* @__PURE__ */ getDefaultExportFromCjs(pickBy_1);
var baseIteratee$5 = _baseIteratee, negate = negate_1, pickBy = pickBy_1;
function omitBy(object, predicate) {
  return pickBy(object, negate(baseIteratee$5(predicate)));
}
var omitBy_1 = omitBy;
const omitBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(omitBy_1);
var omitHideDisabledProps = function omitHideDisabledProps2(props) {
  return omitBy$1(props, function(_val, key) {
    return key.startsWith("disabled") || key.startsWith("hide") || key.startsWith("shouldDisable");
  });
};
var basePickBy = _basePickBy, hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}
var _basePick = basePick$1;
var basePick = _basePick, flatRest = _flatRest;
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
const pick$1 = /* @__PURE__ */ getDefaultExportFromCjs(pick_1);
var TimeProp = /* @__PURE__ */ function(TimeProp2) {
  TimeProp2["DisabledHours"] = "disabledHours";
  TimeProp2["DisabledMinutes"] = "disabledMinutes";
  TimeProp2["DisabledSeconds"] = "disabledSeconds";
  TimeProp2["ShouldDisableHour"] = "shouldDisableHour";
  TimeProp2["ShouldDisableMinute"] = "shouldDisableMinute";
  TimeProp2["ShouldDisableSecond"] = "shouldDisableSecond";
  TimeProp2["HideHours"] = "hideHours";
  TimeProp2["HideMinutes"] = "hideMinutes";
  TimeProp2["HideSeconds"] = "hideSeconds";
  return TimeProp2;
}({});
var calendarOnlyProps = [TimeProp.DisabledHours, TimeProp.DisabledMinutes, TimeProp.DisabledSeconds, TimeProp.HideHours, TimeProp.HideMinutes, TimeProp.HideSeconds];
var HOURS_PATTERN = /(Hours?)/;
var MINUTES_PATTERN = /(Minutes?)/;
var SECONDS_PATTERN = /(Seconds?)/;
function disableTime(props, date) {
  if (!date) {
    return false;
  }
  var disabledTimeProps = [TimeProp.DisabledHours, TimeProp.DisabledMinutes, TimeProp.DisabledSeconds, TimeProp.ShouldDisableHour, TimeProp.ShouldDisableMinute, TimeProp.ShouldDisableSecond];
  var calendarProps = pick$1(props, disabledTimeProps);
  var mapProps = new Map(Object.entries(calendarProps));
  return Array.from(mapProps.keys()).some(function(key) {
    if (HOURS_PATTERN.test(key)) {
      var _mapProps$get;
      return (_mapProps$get = mapProps.get(key)) === null || _mapProps$get === void 0 ? void 0 : _mapProps$get(getHours$1(date), date);
    }
    if (MINUTES_PATTERN.test(key)) {
      var _mapProps$get2;
      return (_mapProps$get2 = mapProps.get(key)) === null || _mapProps$get2 === void 0 ? void 0 : _mapProps$get2(getMinutes$1(date), date);
    }
    if (SECONDS_PATTERN.test(key)) {
      var _mapProps$get3;
      return (_mapProps$get3 = mapProps.get(key)) === null || _mapProps$get3 === void 0 ? void 0 : _mapProps$get3(getSeconds(date), date);
    }
    return false;
  });
}
var shouldRenderTime = function shouldRenderTime2(format2) {
  return /([Hhms])/.test(format2);
};
var shouldRenderMonth = function shouldRenderMonth2(format2) {
  return /[Yy]/.test(format2) && /[ML]/.test(format2);
};
var shouldRenderDate = function shouldRenderDate2(format2) {
  return /[Yy]/.test(format2) && /[ML]/.test(format2) && /[Dd]/.test(format2);
};
var shouldOnlyRenderTime = function shouldOnlyRenderTime2(format2) {
  return /([Hhms])/.test(format2) && !/([YyMDd])/.test(format2);
};
var dateFormats = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var locale = {
  code: "en-GB",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match: match$1,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
var Calendar$4 = {
  sunday: "Su",
  monday: "Mo",
  tuesday: "Tu",
  wednesday: "We",
  thursday: "Th",
  friday: "Fr",
  saturday: "Sa",
  ok: "OK",
  today: "Today",
  yesterday: "Yesterday",
  hours: "Hours",
  minutes: "Minutes",
  seconds: "Seconds",
  /**
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   **/
  formattedMonthPattern: "MMM yyyy",
  formattedDayPattern: "dd MMM yyyy",
  dateLocale: locale
};
const defaultLocale = {
  common: {
    loading: "Loading...",
    emptyMessage: "No data found",
    remove: "Remove",
    clear: "Clear"
  },
  Plaintext: {
    unfilled: "Unfilled",
    notSelected: "Not selected",
    notUploaded: "Not uploaded"
  },
  Pagination: {
    more: "More",
    prev: "Previous",
    next: "Next",
    first: "First",
    last: "Last",
    limit: "{0} / page",
    total: "Total Rows: {0}",
    skip: "Go to{0}"
  },
  Calendar: Calendar$4,
  DatePicker: _extends$1({}, Calendar$4),
  DateRangePicker: _extends$1({}, Calendar$4, {
    last7Days: "Last 7 Days"
  }),
  Picker: {
    noResultsText: "No results found",
    placeholder: "Select",
    searchPlaceholder: "Search",
    checkAll: "All"
  },
  InputPicker: {
    newItem: "New item",
    createOption: 'Create option "{0}"'
  },
  Uploader: {
    inited: "Initial",
    progress: "Uploading",
    error: "Error",
    complete: "Finished",
    emptyFile: "Empty",
    upload: "Upload",
    removeFile: "Remove file"
  },
  CloseButton: {
    closeLabel: "Close"
  },
  Breadcrumb: {
    expandText: "Show path"
  },
  Toggle: {
    on: "Open",
    off: "Close"
  }
};
var mergeObject = function mergeObject2(list) {
  return list.reduce(function(a3, b3) {
    a3 = _extends$1({}, a3, b3);
    return a3;
  }, {});
};
var getDefaultRTL = function getDefaultRTL2() {
  return typeof document !== "undefined" && (document.body.getAttribute("dir") || document.dir) === "rtl";
};
function useCustom(keys2, overrideLocale) {
  var _locale$Calendar2, _locale$Calendar4;
  var _useContext = reactExports.useContext(CustomContext), _useContext$locale = _useContext.locale, locale2 = _useContext$locale === void 0 ? defaultLocale : _useContext$locale, _useContext$rtl = _useContext.rtl, rtl = _useContext$rtl === void 0 ? getDefaultRTL() : _useContext$rtl, formatDate = _useContext.formatDate, parseDate = _useContext.parseDate, toasters = _useContext.toasters, disableRipple = _useContext.disableRipple;
  var componentLocale = _extends$1({}, locale2 === null || locale2 === void 0 ? void 0 : locale2.common, typeof keys2 === "string" ? locale2 === null || locale2 === void 0 ? void 0 : locale2[keys2] : typeof keys2 === "object" ? mergeObject(keys2.map(function(key) {
    return locale2 === null || locale2 === void 0 ? void 0 : locale2[key];
  })) : {});
  if (overrideLocale) {
    componentLocale = mergeObject([componentLocale, overrideLocale]);
  }
  var _formatDate = reactExports.useCallback(function(date, formatStr, options) {
    try {
      var _locale$Calendar;
      if (formatDate) {
        return formatDate(date, formatStr, options);
      }
      return format(isValid$1(date) ? date : /* @__PURE__ */ new Date(), formatStr, _extends$1({
        locale: locale2 === null || locale2 === void 0 ? void 0 : (_locale$Calendar = locale2.Calendar) === null || _locale$Calendar === void 0 ? void 0 : _locale$Calendar.dateLocale
      }, options));
    } catch (error) {
      return "Error: Invalid date format";
    }
  }, [formatDate, locale2 === null || locale2 === void 0 ? void 0 : (_locale$Calendar2 = locale2.Calendar) === null || _locale$Calendar2 === void 0 ? void 0 : _locale$Calendar2.dateLocale]);
  var _parseDate = reactExports.useCallback(function(dateString, formatString, referenceDate, options) {
    var _locale$Calendar3;
    if (parseDate) {
      return parseDate(dateString, formatString, referenceDate, options);
    }
    return parse$1(dateString, formatString, referenceDate || /* @__PURE__ */ new Date(), _extends$1({
      locale: locale2 === null || locale2 === void 0 ? void 0 : (_locale$Calendar3 = locale2.Calendar) === null || _locale$Calendar3 === void 0 ? void 0 : _locale$Calendar3.dateLocale
    }, options));
  }, [parseDate, locale2 === null || locale2 === void 0 ? void 0 : (_locale$Calendar4 = locale2.Calendar) === null || _locale$Calendar4 === void 0 ? void 0 : _locale$Calendar4.dateLocale]);
  return {
    locale: componentLocale,
    rtl,
    toasters,
    disableRipple,
    formatDate: _formatDate,
    parseDate: _parseDate
  };
}
var resizeObservers = [];
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x3, y4, width2, height2) {
    this.x = x3;
    this.y = y4;
    this.width = width2;
    this.height = height2;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a2 = this, x3 = _a2.x, y4 = _a2.y, top2 = _a2.top, right2 = _a2.right, bottom2 = _a2.bottom, left2 = _a2.left, width2 = _a2.width, height2 = _a2.height;
    return { x: x3, y: y4, top: top2, right: right2, bottom: bottom2, left: left2, width: width2, height: height2 };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a2 = target.getBBox(), width2 = _a2.width, height2 = _a2.height;
    return !width2 && !height2;
  }
  var _b2 = target, offsetWidth = _b2.offsetWidth, offsetHeight = _b2.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement$1 = function(obj) {
  var _a2;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};
var global$1 = typeof window !== "undefined" ? window : {};
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size$1 = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft2 + borderRight2;
  var verticalBorderArea = borderTop2 + borderBottom2;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();
var calculateDepthForNode = function(node2) {
  if (isHidden(node2)) {
    return Infinity;
  }
  var depth = 0;
  var parent2 = node2.parentNode;
  while (parent2) {
    depth += 1;
    parent2 = parent2.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i2 = 0, callbacks_1 = callbacks2; _i2 < callbacks_1.length; _i2++) {
    var callback = callbacks_1[_i2];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb2) {
    return cb2();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config2 = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config2);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function(cb2) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb2);
  });
};
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this2 = this;
    this.stopped = true;
    this.listener = function() {
      return _this2.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this2 = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this2.run(1e3);
        } else if (timeout > 0) {
          _this2.run(timeout);
        } else {
          _this2.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this2 = this;
    var cb2 = function() {
      return _this2.observer && _this2.observer.observe(document.body, observerConfig);
    };
    document.body ? cb2() : global$1.addEventListener("DOMContentLoaded", cb2);
  };
  Scheduler2.prototype.start = function() {
    var _this2 = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global$1.addEventListener(name, _this2.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this2 = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global$1.removeEventListener(name, _this2.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n2) {
  !watching && n2 > 0 && scheduler.start();
  watching += n2;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();
var ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i2 = 0; i2 < observationTargets.length; i2 += 1) {
    if (observationTargets[i2].target === target) {
      return i2;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this2 = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this2.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();
var ResizeObserver$1 = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement$1(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement$1(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
}();
function useElementResize(eventTarget, listener) {
  var resizeObserver = reactExports.useRef();
  reactExports.useEffect(function() {
    if (!resizeObserver.current) {
      var target = typeof eventTarget === "function" ? eventTarget() : eventTarget;
      if (target) {
        resizeObserver.current = new ResizeObserver$1(listener);
        resizeObserver.current.observe(target);
      }
    }
    return function() {
      var _resizeObserver$curre;
      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();
    };
  }, [eventTarget, listener]);
}
function useEnsuredRef(ref) {
  var dumpRef = reactExports.useRef();
  if (ref) {
    return ref;
  }
  return dumpRef;
}
var useIsomorphicLayoutEffect$2 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEventCallback$2(fn2) {
  var ref = reactExports.useRef(fn2);
  useIsomorphicLayoutEffect$2(function() {
    ref.current = fn2;
  });
  return reactExports.useCallback(function() {
    var _ref$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.call.apply(_ref$current, [ref].concat(args));
  }, []);
}
function useFocus(elementRef) {
  var previousActiveElementRef = reactExports.useRef(null);
  var grab = reactExports.useCallback(function() {
    requestAnimationFrame(function() {
      if (document.activeElement !== elementRef.current) {
        var _elementRef$current;
        previousActiveElementRef.current = document.activeElement;
        (_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.focus();
      }
    });
  }, [elementRef]);
  var release = reactExports.useCallback(function(options) {
    requestAnimationFrame(function() {
      var _previousActiveElemen;
      (_previousActiveElemen = previousActiveElementRef.current) === null || _previousActiveElemen === void 0 ? void 0 : _previousActiveElemen.focus(options);
    });
  }, []);
  return {
    grab,
    release
  };
}
var toString$4 = toString_1;
var idCounter = 0;
function uniqueId(prefix2) {
  var id2 = ++idCounter;
  return toString$4(prefix2) + id2;
}
var uniqueId_1 = uniqueId;
const uniqueId$1 = /* @__PURE__ */ getDefaultExportFromCjs(uniqueId_1);
function useInternalId(namespace) {
  var idRef = reactExports.useRef();
  if (!idRef.current) {
    idRef.current = uniqueId$1("internal://" + namespace);
  }
  reactExports.useDebugValue(idRef.current);
  return idRef.current;
}
var useMount = function useMount2(callback) {
  var mountRef = reactExports.useRef(callback);
  mountRef.current = callback;
  reactExports.useEffect(function() {
    var _mountRef$current;
    (_mountRef$current = mountRef.current) === null || _mountRef$current === void 0 ? void 0 : _mountRef$current.call(mountRef);
  }, []);
};
var MountedPortal = /* @__PURE__ */ React.memo(function(_ref) {
  var children = _ref.children, container = _ref.container;
  var _useState = reactExports.useState(false), mounted = _useState[0], setMounted = _useState[1];
  reactExports.useEffect(function() {
    return setMounted(true);
  }, []);
  if (container && mounted) {
    return /* @__PURE__ */ reactDomExports.createPortal(children, container);
  }
  return null;
});
function usePortal(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, container = _props.container, _props$waitMount = _props.waitMount, waitMount = _props$waitMount === void 0 ? false : _props$waitMount;
  var containerElement = typeof container === "function" ? container() : container;
  var rootElement = reactExports.useMemo(function() {
    return canUseDOM$1 ? containerElement || document.body : null;
  }, [containerElement]);
  var Portal3 = reactExports.useCallback(function(_ref2) {
    var children = _ref2.children;
    return rootElement != null ? /* @__PURE__ */ reactDomExports.createPortal(children, rootElement) : null;
  }, [rootElement]);
  var WaitMountPortal = reactExports.useCallback(function(props2) {
    return /* @__PURE__ */ React.createElement(MountedPortal, _extends$1({
      container: rootElement
    }, props2));
  }, [rootElement]);
  return {
    target: rootElement,
    Portal: waitMount ? WaitMountPortal : Portal3
  };
}
var SIZE$1 = ["lg", "md", "sm", "xs"];
var PLACEMENT_4 = ["top", "bottom", "right", "left"];
var PLACEMENT_8 = ["bottomStart", "bottomEnd", "topStart", "topEnd", "leftStart", "rightStart", "leftEnd", "rightEnd"];
var PLACEMENT_AUTO = ["auto", "autoVertical", "autoVerticalStart", "autoVerticalEnd", "autoHorizontal", "autoHorizontalStart", "autoHorizontalEnd"];
var PLACEMENT = [].concat(PLACEMENT_4, PLACEMENT_8, PLACEMENT_AUTO);
var KEY_VALUES = {
  // Navigation Keys
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  END: "End",
  HOME: "Home",
  PAGE_DOWN: "PageDown",
  PAGE_UP: "PageUp",
  // Whitespace Keys
  ENTER: "Enter",
  TAB: "Tab",
  SPACE: " ",
  // Editing Keys
  BACKSPACE: "Backspace",
  DELETE: "Delete",
  COMMA: ",",
  // UI Keys
  ESC: "Escape"
};
var DATERANGE_DISABLED_TARGET = /* @__PURE__ */ function(DATERANGE_DISABLED_TARGET2) {
  DATERANGE_DISABLED_TARGET2["CALENDAR"] = "CALENDAR";
  DATERANGE_DISABLED_TARGET2["TOOLBAR_BUTTON_OK"] = "TOOLBAR_BUTTON_OK";
  DATERANGE_DISABLED_TARGET2["TOOLBAR_SHORTCUT"] = "TOOLBAR_SHORTCUT";
  DATERANGE_DISABLED_TARGET2["INPUT"] = "INPUT";
  return DATERANGE_DISABLED_TARGET2;
}({});
function isLeftClickEvent(event) {
  return (event === null || event === void 0 ? void 0 : event.button) === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event !== null && event !== void 0 && event.shiftKey);
}
function useRootClose(onRootClose, _ref) {
  var disabled = _ref.disabled, triggerTarget = _ref.triggerTarget, overlayTarget = _ref.overlayTarget, _ref$listenEscape = _ref.listenEscape, listenEscape = _ref$listenEscape === void 0 ? true : _ref$listenEscape;
  var handleDocumentKeyUp = reactExports.useCallback(function(event) {
    if (listenEscape && event.key === KEY_VALUES.ESC) {
      onRootClose === null || onRootClose === void 0 ? void 0 : onRootClose(event);
    }
  }, [listenEscape, onRootClose]);
  var handleDocumentMouseDown = reactExports.useCallback(function(event) {
    var triggerElement = getDOMNode(triggerTarget);
    var overlayElement = getDOMNode(overlayTarget);
    if (triggerElement && contains$3(triggerElement, event.target)) {
      return;
    }
    if (overlayElement && contains$3(overlayElement, event.target)) {
      return;
    }
    if (isModifiedEvent(event) || !isLeftClickEvent(event)) {
      return;
    }
    onRootClose === null || onRootClose === void 0 ? void 0 : onRootClose(event);
  }, [onRootClose, triggerTarget, overlayTarget]);
  reactExports.useEffect(function() {
    var currentTarget = getDOMNode(triggerTarget);
    if (disabled || !currentTarget) return;
    var doc = ownerDocument$2(currentTarget);
    var onDocumentMouseDownListener = on(doc, "mousedown", handleDocumentMouseDown, true);
    var onDocumentKeyupListener = on(doc, "keyup", handleDocumentKeyUp);
    return function() {
      onDocumentMouseDownListener === null || onDocumentMouseDownListener === void 0 ? void 0 : onDocumentMouseDownListener.off();
      onDocumentKeyupListener === null || onDocumentKeyupListener === void 0 ? void 0 : onDocumentKeyupListener.off();
    };
  }, [triggerTarget, disabled, onRootClose, handleDocumentMouseDown, handleDocumentKeyUp]);
}
var AngleDown$2 = {};
var AngleDown$1 = { exports: {} };
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(e3) {
    return e3 && e3.__esModule ? e3 : {
      "default": e3
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
var createSvgIcon$2 = { exports: {} };
var _extends = { exports: {} };
var hasRequired_extends;
function require_extends() {
  if (hasRequired_extends) return _extends.exports;
  hasRequired_extends = 1;
  (function(module) {
    function _extends2() {
      return module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n2) {
        for (var e3 = 1; e3 < arguments.length; e3++) {
          var t3 = arguments[e3];
          for (var r2 in t3) ({}).hasOwnProperty.call(t3, r2) && (n2[r2] = t3[r2]);
        }
        return n2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends2.apply(null, arguments);
    }
    module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_extends);
  return _extends.exports;
}
var Icon$1 = { exports: {} };
var objectWithoutPropertiesLoose = { exports: {} };
var hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  if (hasRequiredObjectWithoutPropertiesLoose) return objectWithoutPropertiesLoose.exports;
  hasRequiredObjectWithoutPropertiesLoose = 1;
  (function(module) {
    function _objectWithoutPropertiesLoose2(r2, e3) {
      if (null == r2) return {};
      var t3 = {};
      for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
        if (e3.includes(n2)) continue;
        t3[n2] = r2[n2];
      }
      return t3;
    }
    module.exports = _objectWithoutPropertiesLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutPropertiesLoose);
  return objectWithoutPropertiesLoose.exports;
}
var utils$2 = {};
var prefix$3 = {};
var hasRequiredPrefix;
function requirePrefix() {
  if (hasRequiredPrefix) return prefix$3;
  hasRequiredPrefix = 1;
  var _interopRequireDefault2 = interopRequireDefaultExports;
  prefix$3.__esModule = true;
  prefix$3.prefix = prefix$3.defaultClassPrefix = prefix$3.getClassNamePrefix = prefix$3.globalKey = void 0;
  var _curry = _interopRequireDefault2(curry_1);
  var _classnames = _interopRequireDefault2(classnamesExports);
  var globalKey2 = "rs-";
  prefix$3.globalKey = globalKey2;
  var getClassNamePrefix4 = function getClassNamePrefix5() {
    return globalKey2;
  };
  prefix$3.getClassNamePrefix = getClassNamePrefix4;
  var defaultClassPrefix3 = function defaultClassPrefix4(name) {
    return name ? "" + getClassNamePrefix4() + name : void 0;
  };
  prefix$3.defaultClassPrefix = defaultClassPrefix3;
  var prefix2 = (0, _curry["default"])(function(pre, className) {
    if (!pre || !className) {
      return "";
    }
    if (Array.isArray(className)) {
      return (0, _classnames["default"])(className.filter(function(name) {
        return !!name;
      }).map(function(name) {
        return pre + "-" + name;
      }));
    }
    return pre + "-" + className;
  });
  prefix$3.prefix = prefix2;
  return prefix$3;
}
var useClassNames$1 = { exports: {} };
var hasRequiredUseClassNames;
function requireUseClassNames() {
  if (hasRequiredUseClassNames) return useClassNames$1.exports;
  hasRequiredUseClassNames = 1;
  (function(module, exports) {
    var _interopRequireDefault2 = interopRequireDefaultExports;
    exports.__esModule = true;
    exports["default"] = useClassNames2;
    var _prefix = requirePrefix();
    var _classnames = _interopRequireDefault2(classnamesExports);
    var _react = reactExports;
    function useClassNames2(componentClassName) {
      var className = (0, _prefix.defaultClassPrefix)("icon");
      var addPrefix = (0, _react.useCallback)(function(blockClassName) {
        return (0, _prefix.prefix)(className, blockClassName);
      }, []);
      return [(0, _classnames["default"])(className, (0, _prefix.defaultClassPrefix)(componentClassName)), addPrefix];
    }
    module.exports = exports.default;
  })(useClassNames$1, useClassNames$1.exports);
  return useClassNames$1.exports;
}
var inBrowserEnv = { exports: {} };
var hasRequiredInBrowserEnv;
function requireInBrowserEnv() {
  if (hasRequiredInBrowserEnv) return inBrowserEnv.exports;
  hasRequiredInBrowserEnv = 1;
  (function(module, exports) {
    exports.__esModule = true;
    exports["default"] = _default;
    function _default() {
      return typeof document !== "undefined" && typeof window !== "undefined" && typeof document.createElement === "function";
    }
    module.exports = exports.default;
  })(inBrowserEnv, inBrowserEnv.exports);
  return inBrowserEnv.exports;
}
var useInsertStyles$1 = { exports: {} };
var insertCss = { exports: {} };
var hasRequiredInsertCss;
function requireInsertCss() {
  if (hasRequiredInsertCss) return insertCss.exports;
  hasRequiredInsertCss = 1;
  var containers = [];
  var styleElements = [];
  var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
  function insertCss$1(css2, options) {
    options = options || {};
    if (css2 === void 0) {
      throw new Error(usage);
    }
    var position2 = options.prepend === true ? "prepend" : "append";
    var container = options.container !== void 0 ? options.container : document.querySelector("head");
    var containerId = containers.indexOf(container);
    if (containerId === -1) {
      containerId = containers.push(container) - 1;
      styleElements[containerId] = {};
    }
    var styleElement;
    if (styleElements[containerId] !== void 0 && styleElements[containerId][position2] !== void 0) {
      styleElement = styleElements[containerId][position2];
    } else {
      styleElement = styleElements[containerId][position2] = createStyleElement2();
      if (position2 === "prepend") {
        container.insertBefore(styleElement, container.childNodes[0]);
      } else {
        container.appendChild(styleElement);
      }
    }
    if (css2.charCodeAt(0) === 65279) {
      css2 = css2.substr(1, css2.length);
    }
    if (styleElement.styleSheet) {
      styleElement.styleSheet.cssText += css2;
    } else {
      styleElement.textContent += css2;
    }
    return styleElement;
  }
  function createStyleElement2() {
    var styleElement = document.createElement("style");
    styleElement.setAttribute("type", "text/css");
    return styleElement;
  }
  insertCss.exports = insertCss$1;
  insertCss.exports.insertCss = insertCss$1;
  return insertCss.exports;
}
var hasRequiredUseInsertStyles;
function requireUseInsertStyles() {
  if (hasRequiredUseInsertStyles) return useInsertStyles$1.exports;
  hasRequiredUseInsertStyles = 1;
  (function(module, exports) {
    exports.__esModule = true;
    exports["default"] = void 0;
    var _insertCss = requireInsertCss();
    var _prefix = requirePrefix();
    var _react = reactExports;
    var prefix2 = (0, _prefix.getClassNamePrefix)();
    var styles2 = "." + prefix2 + "icon {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  vertical-align: middle;\n}\n." + prefix2 + "icon[tabindex] {\n  cursor: pointer;\n}\n." + prefix2 + "icon-spin {\n  -webkit-animation: icon-spin 2s infinite linear;\n          animation: icon-spin 2s infinite linear;\n}\n." + prefix2 + "icon-pulse {\n  -webkit-animation: icon-spin 1s infinite steps(8);\n          animation: icon-spin 1s infinite steps(8);\n}\n." + prefix2 + "icon-flip-horizontal {\n  -webkit-transform: scaleX(-1);\n      -ms-transform: scaleX(-1);\n          transform: scaleX(-1);\n}\n." + prefix2 + "icon-flip-vertical {\n  -webkit-transform: scaleY(-1);\n      -ms-transform: scaleY(-1);\n          transform: scaleY(-1);\n}\n@-webkit-keyframes icon-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n            transform: rotate(359deg);\n  }\n}\n@keyframes icon-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n            transform: rotate(359deg);\n  }\n}";
    var cssInjected2 = false;
    var useInsertStyles3 = function useInsertStyles4(styleStr) {
      if (styleStr === void 0) {
        styleStr = styles2;
      }
      (0, _react.useEffect)(function() {
        if (!cssInjected2) {
          (0, _insertCss.insertCss)(styleStr, {
            prepend: true
          });
          cssInjected2 = true;
        }
      }, []);
    };
    var _default = useInsertStyles3;
    exports["default"] = _default;
    module.exports = exports.default;
  })(useInsertStyles$1, useInsertStyles$1.exports);
  return useInsertStyles$1.exports;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$2;
  hasRequiredUtils = 1;
  (function(exports) {
    var _interopRequireDefault2 = interopRequireDefaultExports;
    exports.__esModule = true;
    var _exportNames = {
      useClassNames: true,
      inBrowserEnv: true,
      useInsertStyles: true
    };
    exports.useInsertStyles = exports.inBrowserEnv = exports.useClassNames = void 0;
    var _prefix = requirePrefix();
    Object.keys(_prefix).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _prefix[key]) return;
      exports[key] = _prefix[key];
    });
    var _useClassNames = _interopRequireDefault2(requireUseClassNames());
    exports.useClassNames = _useClassNames["default"];
    var _inBrowserEnv = _interopRequireDefault2(requireInBrowserEnv());
    exports.inBrowserEnv = _inBrowserEnv["default"];
    var _useInsertStyles = _interopRequireDefault2(requireUseInsertStyles());
    exports.useInsertStyles = _useInsertStyles["default"];
  })(utils$2);
  return utils$2;
}
var hasRequiredIcon;
function requireIcon() {
  if (hasRequiredIcon) return Icon$1.exports;
  hasRequiredIcon = 1;
  (function(module, exports) {
    var _interopRequireDefault2 = interopRequireDefaultExports;
    exports.__esModule = true;
    exports["default"] = void 0;
    var _extends2 = _interopRequireDefault2(require_extends());
    var _objectWithoutPropertiesLoose2 = _interopRequireDefault2(requireObjectWithoutPropertiesLoose());
    var _react = _interopRequireDefault2(reactExports);
    var _classnames = _interopRequireDefault2(classnamesExports);
    var _propTypes = _interopRequireDefault2(propTypesExports);
    var _utils = requireUtils();
    var defaultProps2 = {
      as: "svg",
      fill: "currentColor",
      width: "1em",
      height: "1em"
    };
    function filterProps2(props) {
      var nextProps = {};
      Object.entries(props).forEach(function(_ref) {
        var key = _ref[0], value = _ref[1];
        if (typeof value !== "undefined") {
          nextProps[key] = value;
        }
      });
      return nextProps;
    }
    var Icon2 = /* @__PURE__ */ _react["default"].forwardRef(function(props, ref) {
      var _classNames;
      var Component = props.as, spin = props.spin, pulse = props.pulse, flip2 = props.flip, fill = props.fill, className = props.className, rotate = props.rotate, children = props.children, viewBox = props.viewBox, width2 = props.width, height2 = props.height, style2 = props.style, rest = (0, _objectWithoutPropertiesLoose2["default"])(props, ["as", "spin", "pulse", "flip", "fill", "className", "rotate", "children", "viewBox", "width", "height", "style"]);
      var _useClassNames = (0, _utils.useClassNames)(), componentClassName = _useClassNames[0], addPrefix = _useClassNames[1];
      var classes = (0, _classnames["default"])(className, componentClassName, (_classNames = {}, _classNames[addPrefix("spin")] = spin, _classNames[addPrefix("pulse")] = pulse, _classNames[addPrefix("flip-" + flip2)] = !!flip2, _classNames));
      var rotateStyles = {
        msTransform: "rotate(" + rotate + "deg)",
        transform: "rotate(" + rotate + "deg)"
      };
      (0, _utils.useInsertStyles)();
      var svgProps = filterProps2({
        width: width2,
        height: height2,
        fill,
        viewBox,
        className: classes,
        style: rotate ? (0, _extends2["default"])({}, rotateStyles, style2) : style2
      });
      return /* @__PURE__ */ _react["default"].createElement(Component, (0, _extends2["default"])({
        "aria-hidden": true,
        focusable: false,
        ref
      }, svgProps, rest), children);
    });
    Icon2.displayName = "Icon";
    Icon2.defaultProps = defaultProps2;
    Icon2.propTypes = {
      spin: _propTypes["default"].bool,
      pulse: _propTypes["default"].bool,
      rotate: _propTypes["default"].number,
      viewBox: _propTypes["default"].string,
      as: _propTypes["default"].oneOfType([_propTypes["default"].elementType, _propTypes["default"].string]),
      flip: _propTypes["default"].oneOf(["horizontal", "vertical"]),
      fill: _propTypes["default"].string
    };
    var _default = Icon2;
    exports["default"] = _default;
    module.exports = exports.default;
  })(Icon$1, Icon$1.exports);
  return Icon$1.exports;
}
var hasRequiredCreateSvgIcon$1;
function requireCreateSvgIcon$1() {
  if (hasRequiredCreateSvgIcon$1) return createSvgIcon$2.exports;
  hasRequiredCreateSvgIcon$1 = 1;
  (function(module, exports) {
    var _interopRequireDefault2 = interopRequireDefaultExports;
    exports.__esModule = true;
    exports["default"] = void 0;
    var _extends2 = _interopRequireDefault2(require_extends());
    var _react = _interopRequireDefault2(reactExports);
    var _Icon = _interopRequireDefault2(requireIcon());
    function createSvgIcon2(_ref) {
      var as = _ref.as, ariaLabel = _ref.ariaLabel, displayName = _ref.displayName, category = _ref.category;
      var IconComponent = /* @__PURE__ */ _react["default"].forwardRef(function(props, ref) {
        return /* @__PURE__ */ _react["default"].createElement(_Icon["default"], (0, _extends2["default"])({
          "aria-label": ariaLabel,
          "data-category": category,
          ref,
          as
        }, props));
      });
      IconComponent.displayName = displayName;
      return IconComponent;
    }
    var _default = createSvgIcon2;
    exports["default"] = _default;
    module.exports = exports.default;
  })(createSvgIcon$2, createSvgIcon$2.exports);
  return createSvgIcon$2.exports;
}
var AngleDown = {};
var hasRequiredAngleDown;
function requireAngleDown() {
  if (hasRequiredAngleDown) return AngleDown;
  hasRequiredAngleDown = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function AngleDown2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 21 32",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M19.196 13.143a.612.612 0 01-.179.411l-8.321 8.321c-.107.107-.268.179-.411.179s-.304-.071-.411-.179l-8.321-8.321c-.107-.107-.179-.268-.179-.411s.071-.304.179-.411l.893-.893a.582.582 0 01.411-.179c.143 0 .304.071.411.179l7.018 7.018 7.018-7.018c.107-.107.268-.179.411-.179s.304.071.411.179l.893.893a.617.617 0 01.179.411z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(AngleDown2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(AngleDown);
  return AngleDown;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _AngleDown = _interopRequireDefault2(requireAngleDown());
  var AngleDown2 = (0, _createSvgIcon2["default"])({
    as: _AngleDown["default"],
    ariaLabel: "angle down",
    category: "legacy",
    displayName: "AngleDown"
  });
  var _default = AngleDown2;
  exports["default"] = _default;
  module.exports = exports.default;
})(AngleDown$1, AngleDown$1.exports);
var AngleDownExports = AngleDown$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _AngleDown["default"];
    }
  });
  var _AngleDown = _interopRequireDefault2(AngleDownExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(AngleDown$2);
const AngleDownIcon = /* @__PURE__ */ getDefaultExportFromCjs(AngleDown$2);
var AngleUp$2 = {};
var AngleUp$1 = { exports: {} };
var AngleUp = {};
var hasRequiredAngleUp;
function requireAngleUp() {
  if (hasRequiredAngleUp) return AngleUp;
  hasRequiredAngleUp = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function AngleUp2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 21 32",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M19.196 21.143a.612.612 0 01-.179.411l-.893.893a.582.582 0 01-.411.179.612.612 0 01-.411-.179l-7.018-7.018-7.018 7.018c-.107.107-.268.179-.411.179s-.304-.071-.411-.179l-.893-.893c-.107-.107-.179-.268-.179-.411s.071-.304.179-.411l8.321-8.321c.107-.107.268-.179.411-.179s.304.071.411.179l8.321 8.321a.617.617 0 01.179.411z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(AngleUp2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(AngleUp);
  return AngleUp;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _AngleUp = _interopRequireDefault2(requireAngleUp());
  var AngleUp2 = (0, _createSvgIcon2["default"])({
    as: _AngleUp["default"],
    ariaLabel: "angle up",
    category: "legacy",
    displayName: "AngleUp"
  });
  var _default = AngleUp2;
  exports["default"] = _default;
  module.exports = exports.default;
})(AngleUp$1, AngleUp$1.exports);
var AngleUpExports = AngleUp$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _AngleUp["default"];
    }
  });
  var _AngleUp = _interopRequireDefault2(AngleUpExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(AngleUp$2);
const AngleUpIcon = /* @__PURE__ */ getDefaultExportFromCjs(AngleUp$2);
var AngleLeft$2 = {};
var AngleLeft$1 = { exports: {} };
var AngleLeft = {};
var hasRequiredAngleLeft;
function requireAngleLeft() {
  if (hasRequiredAngleLeft) return AngleLeft;
  hasRequiredAngleLeft = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function AngleLeft2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 12 32",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M11.196 9.714a.612.612 0 01-.179.411l-7.018 7.018 7.018 7.018c.107.107.179.268.179.411s-.071.304-.179.411l-.893.893c-.107.107-.268.179-.411.179s-.304-.071-.411-.179L.981 17.555c-.107-.107-.179-.268-.179-.411s.071-.304.179-.411l8.321-8.321c.107-.107.268-.179.411-.179s.304.071.411.179l.893.893c.107.107.179.25.179.411z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(AngleLeft2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(AngleLeft);
  return AngleLeft;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _AngleLeft = _interopRequireDefault2(requireAngleLeft());
  var AngleLeft2 = (0, _createSvgIcon2["default"])({
    as: _AngleLeft["default"],
    ariaLabel: "angle left",
    category: "legacy",
    displayName: "AngleLeft"
  });
  var _default = AngleLeft2;
  exports["default"] = _default;
  module.exports = exports.default;
})(AngleLeft$1, AngleLeft$1.exports);
var AngleLeftExports = AngleLeft$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _AngleLeft["default"];
    }
  });
  var _AngleLeft = _interopRequireDefault2(AngleLeftExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(AngleLeft$2);
const AngleLeftIcon = /* @__PURE__ */ getDefaultExportFromCjs(AngleLeft$2);
var AngleRight$2 = {};
var AngleRight$1 = { exports: {} };
var AngleRight = {};
var hasRequiredAngleRight;
function requireAngleRight() {
  if (hasRequiredAngleRight) return AngleRight;
  hasRequiredAngleRight = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function AngleRight2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 11 32",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M10.625 17.143a.612.612 0 01-.179.411l-8.321 8.321c-.107.107-.268.179-.411.179s-.304-.071-.411-.179l-.893-.893a.582.582 0 01-.179-.411c0-.143.071-.304.179-.411l7.018-7.018L.41 10.124c-.107-.107-.179-.268-.179-.411s.071-.304.179-.411l.893-.893c.107-.107.268-.179.411-.179s.304.071.411.179l8.321 8.321a.617.617 0 01.179.411z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(AngleRight2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(AngleRight);
  return AngleRight;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _AngleRight = _interopRequireDefault2(requireAngleRight());
  var AngleRight2 = (0, _createSvgIcon2["default"])({
    as: _AngleRight["default"],
    ariaLabel: "angle right",
    category: "legacy",
    displayName: "AngleRight"
  });
  var _default = AngleRight2;
  exports["default"] = _default;
  module.exports = exports.default;
})(AngleRight$1, AngleRight$1.exports);
var AngleRightExports = AngleRight$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _AngleRight["default"];
    }
  });
  var _AngleRight = _interopRequireDefault2(AngleRightExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(AngleRight$2);
const AngleRightIcon = /* @__PURE__ */ getDefaultExportFromCjs(AngleRight$2);
function useToggleCaret(placement) {
  var _useCustom = useCustom("Dropdown"), rtl = _useCustom.rtl;
  return reactExports.useMemo(function() {
    switch (true) {
      case /^top/.test(placement):
        return AngleUpIcon;
      case /^right/.test(placement):
        return rtl ? AngleLeftIcon : AngleRightIcon;
      case /^left/.test(placement):
        return rtl ? AngleRightIcon : AngleLeftIcon;
      case /^bottom/.test(placement):
      default:
        return AngleDownIcon;
    }
  }, [placement, rtl]);
}
var reactUseId = React$1["useId".toString()];
function useUniqueId(prefix2, idProp) {
  var idRef = reactExports.useRef();
  if (reactUseId !== void 0) {
    return idProp !== null && idProp !== void 0 ? idProp : "" + prefix2 + reactUseId();
  }
  if (!idRef.current) {
    idRef.current = uniqueId$1(prefix2);
  }
  return idProp !== null && idProp !== void 0 ? idProp : idRef.current;
}
function useUpdatedRef(value) {
  var valueRef = reactExports.useRef(value);
  valueRef.current = value;
  return valueRef;
}
var useUpdateEffect = function useUpdateEffect2(effect2, deps) {
  var isMounting = reactExports.useRef(true);
  reactExports.useEffect(function() {
    if (isMounting.current) {
      isMounting.current = false;
      return;
    }
    effect2();
  }, deps);
};
function useWillUnmount(fn2) {
  var onUnmount = useUpdatedRef(fn2);
  reactExports.useEffect(function() {
    return function() {
      return onUnmount.current();
    };
  }, []);
}
var oneOf = function oneOf2(arr) {
  var checkType = PropTypes.oneOf(arr);
  checkType._argType_ = {
    type: "oneOf",
    value: arr
  };
  return checkType;
};
function deprecatePropType(propType, explanation) {
  return function validate(props, propName, componentName) {
    if (props[propName] != null) {
      var message = '"' + propName + '" property of "' + componentName + '" has been deprecated.\n' + explanation;
      warnOnce(message);
    }
    for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }
    return propType.apply(void 0, [props, propName, componentName].concat(rest));
  };
}
function deprecatePropTypeNew(propType, explanation) {
  return function validate(props, propName, componentName) {
    if (props[propName] != null) {
      var message = '[rsuite] "' + propName + '" property of ' + componentName + " component has been deprecated.\n" + explanation;
      warnOnce(message);
    }
    for (var _len2 = arguments.length, rest = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      rest[_key2 - 3] = arguments[_key2];
    }
    return propType.apply(void 0, [props, propName, componentName].concat(rest));
  };
}
var refType$1 = PropTypes.oneOfType([PropTypes.func, PropTypes.any]);
function highlightText(text2, props) {
  var query = props.query, renderMark = props.renderMark;
  if (!query || !text2) {
    return text2;
  }
  var queries = Array.isArray(query) ? query : [query];
  var regx = new RegExp(queries.map(function(q3) {
    return getSafeRegExpString(q3);
  }).join("|"), "ig");
  var texts = [];
  var strArr = text2.split(regx);
  var highStrArr = text2.match(regx);
  for (var i2 = 0; i2 < strArr.length; i2++) {
    if (strArr[i2]) {
      texts.push(strArr[i2]);
    }
    if (highStrArr !== null && highStrArr !== void 0 && highStrArr[i2]) {
      texts.push(renderMark(highStrArr[i2], i2));
    }
  }
  return texts;
}
var _excluded$28 = ["as", "classPrefix", "className", "children", "query", "renderMark"];
function defaultRenderMark(match2, index) {
  return /* @__PURE__ */ React.createElement("mark", {
    key: index,
    className: "rs-highlight-mark"
  }, match2);
}
var Highlight = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "highlight" : _props$classPrefix, className = props.className, children = props.children, query = props.query, _props$renderMark = props.renderMark, renderMark = _props$renderMark === void 0 ? defaultRenderMark : _props$renderMark, rest = _objectWithoutPropertiesLoose(props, _excluded$28);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  var text2 = stringifyReactNode(children);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    className: classes
  }, rest), highlightText(text2, {
    query,
    renderMark
  }));
});
Highlight.displayName = "Highlight";
Highlight.propTypes = {
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  as: PropTypes.elementType
};
var _excluded$27 = ["as", "href", "disabled", "onClick"];
function isTrivialHref(href) {
  return !href || href.trim() === "#";
}
var SafeAnchor = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "a" : _props$as, href = props.href, disabled = props.disabled, onClick = props.onClick, restProps = _objectWithoutPropertiesLoose(props, _excluded$27);
  var handleClick = reactExports.useCallback(function(event) {
    if (disabled || isTrivialHref(href)) {
      event.preventDefault();
    }
    if (disabled) {
      event.stopPropagation();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
  }, [disabled, href, onClick]);
  var trivialProps = isTrivialHref(href) ? {
    role: "button",
    href: "#"
  } : null;
  if (disabled) {
    restProps.tabIndex = -1;
    restProps["aria-disabled"] = true;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    href
  }, trivialProps, restProps, {
    onClick: handleClick
  }));
});
SafeAnchor.displayName = "SafeAnchor";
SafeAnchor.propTypes = {
  href: PropTypes.string,
  disabled: PropTypes.bool,
  as: PropTypes.elementType
};
function _taggedTemplateLiteralLoose(e3, t3) {
  return t3 || (t3 = e3.slice(0)), e3.raw = t3, e3;
}
var _excluded$26 = ["as", "className", "classPrefix", "onMouseDown"], _excluded2$m = ["className"];
var getPosition = function getPosition2(target, event) {
  var offset2 = getOffset(target);
  var offsetX = (event.pageX || 0) - offset2.left;
  var offsetY = (event.pageY || 0) - offset2.top;
  var radiusX = Math.max(offset2.width - offsetX, offsetX);
  var radiusY = Math.max(offset2.height - offsetY, offsetY);
  var radius = Math.sqrt(Math.pow(radiusX, 2) + Math.pow(radiusY, 2));
  return {
    width: radius * 2,
    height: radius * 2,
    left: offsetX - radius,
    top: offsetY - radius
  };
};
var Ripple$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useCustom = useCustom(), disableRipple = _useCustom.disableRipple;
  var _props$as = props.as, Component = _props$as === void 0 ? "span" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "ripple" : _props$classPrefix, onMouseDown = props.onMouseDown, rest = _objectWithoutPropertiesLoose(props, _excluded$26);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, prefix2("pond"));
  var triggerRef = reactExports.useRef(null);
  var _useState = reactExports.useState(false), rippling = _useState[0], setRippling = _useState[1];
  var _useState2 = reactExports.useState(), position2 = _useState2[0], setPosition = _useState2[1];
  var handleRippled = function handleRippled2() {
    setRippling(false);
  };
  var handleMouseDown = reactExports.useCallback(function(event) {
    if (triggerRef.current) {
      var _position = getPosition(triggerRef.current, event);
      setRippling(true);
      setPosition(_position);
      onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(_position, event);
    }
  }, [onMouseDown]);
  reactExports.useEffect(function() {
    var _triggerRef$current;
    var parentNode = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.parentNode;
    if (parentNode) {
      var mousedownListener = on(parentNode, "mousedown", handleMouseDown);
      return function() {
        mousedownListener === null || mousedownListener === void 0 ? void 0 : mousedownListener.off();
      };
    }
  }, [handleMouseDown]);
  if (disableRipple) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    className: classes,
    ref: mergeRefs(triggerRef, ref)
  }), /* @__PURE__ */ React.createElement(Transition$1, {
    in: rippling,
    enteringClassName: prefix2("rippling"),
    onEntered: handleRippled
  }, function(props2, ref2) {
    var className2 = props2.className, transitionRest = _objectWithoutPropertiesLoose(props2, _excluded2$m);
    return /* @__PURE__ */ React.createElement("span", _extends$1({}, transitionRest, {
      ref: ref2,
      className: merge2(withClassPrefix(), className2),
      style: position2
    }));
  }));
});
Ripple$1.displayName = "Ripple";
Ripple$1.propTypes = {
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  onMouseDown: PropTypes.func
};
var ButtonGroupContext$1 = /* @__PURE__ */ React.createContext(null);
var _templateObject$g, _templateObject2$9, _templateObject3$2;
var _excluded$25 = ["as", "active", "appearance", "block", "className", "children", "classPrefix", "color", "disabled", "loading", "ripple", "size", "startIcon", "endIcon", "type"];
var Button$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var as = props.as, active = props.active, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "default" : _props$appearance, block = props.block, className = props.className, children = props.children, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "btn" : _props$classPrefix, color2 = props.color, disabled = props.disabled, loading = props.loading, _props$ripple = props.ripple, ripple = _props$ripple === void 0 ? true : _props$ripple, sizeProp = props.size, startIcon = props.startIcon, endIcon = props.endIcon, typeProp = props.type, rest = _objectWithoutPropertiesLoose(props, _excluded$25);
  var buttonGroup = reactExports.useContext(ButtonGroupContext$1);
  var size2 = sizeProp !== null && sizeProp !== void 0 ? sizeProp : buttonGroup === null || buttonGroup === void 0 ? void 0 : buttonGroup.size;
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix(appearance, color2, size2, {
    active,
    disabled,
    loading,
    block
  }));
  var buttonContent = reactExports.useMemo(function() {
    var spin = /* @__PURE__ */ React.createElement("span", {
      className: prefix2(_templateObject$g || (_templateObject$g = _taggedTemplateLiteralLoose(["spin"])))
    });
    var rippleElement = ripple && !isOneOf(appearance, ["link", "ghost"]) ? /* @__PURE__ */ React.createElement(Ripple$1, null) : null;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, loading && spin, startIcon ? /* @__PURE__ */ React.createElement("span", {
      className: prefix2(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteralLoose(["start-icon"])))
    }, startIcon) : null, children, endIcon ? /* @__PURE__ */ React.createElement("span", {
      className: prefix2(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteralLoose(["end-icon"])))
    }, endIcon) : null, rippleElement);
  }, [appearance, children, endIcon, loading, prefix2, ripple, startIcon]);
  if (rest.href) {
    return /* @__PURE__ */ React.createElement(SafeAnchor, _extends$1({}, rest, {
      as,
      ref,
      "aria-disabled": disabled,
      disabled,
      className: classes
    }), buttonContent);
  }
  var Component = as || "button";
  var type = typeProp || (Component === "button" ? "button" : void 0);
  var role = rest.role || (Component !== "button" ? "button" : void 0);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    role,
    type,
    ref,
    disabled,
    "aria-disabled": disabled,
    className: classes
  }), buttonContent);
});
Button$1.displayName = "Button";
Button$1.propTypes = {
  as: PropTypes.elementType,
  active: PropTypes.bool,
  appearance: oneOf(["default", "primary", "link", "subtle", "ghost"]),
  block: PropTypes.bool,
  children: PropTypes.node,
  color: oneOf(["red", "orange", "yellow", "green", "cyan", "blue", "violet"]),
  disabled: PropTypes.bool,
  href: PropTypes.string,
  loading: PropTypes.bool,
  ripple: PropTypes.bool,
  size: oneOf(["lg", "md", "sm", "xs"]),
  type: oneOf(["button", "reset", "submit"])
};
var _excluded$24 = ["icon", "placement", "children", "circle", "classPrefix", "className"];
var IconButton$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var icon = props.icon, _props$placement = props.placement, placement = _props$placement === void 0 ? "left" : _props$placement, children = props.children, circle = props.circle, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "btn-icon" : _props$classPrefix, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded$24);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, withClassPrefix("placement-" + placement, {
    circle,
    "with-text": typeof children !== "undefined"
  }));
  return /* @__PURE__ */ React.createElement(Button$1, _extends$1({}, rest, {
    ref,
    className: classes
  }), icon, children);
});
IconButton$1.displayName = "IconButton";
IconButton$1.propTypes = {
  className: PropTypes.string,
  icon: PropTypes.any,
  classPrefix: PropTypes.string,
  circle: PropTypes.bool,
  children: PropTypes.node,
  placement: oneOf(["left", "right"])
};
var _excluded$23 = ["as", "style", "className", "alignSelf", "flex", "grow", "shrink", "order", "basis"];
function StackItem(props) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, style2 = props.style, className = props.className, alignSelf = props.alignSelf, flex = props.flex, grow = props.grow, shrink = props.shrink, order2 = props.order, basis = props.basis, rest = _objectWithoutPropertiesLoose(props, _excluded$23);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    className,
    style: _extends$1({
      alignSelf,
      order: order2
    }, flex ? {
      flex
    } : {
      flexGrow: grow,
      flexShrink: shrink,
      flexBasis: basis
    }, style2)
  }, rest));
}
StackItem.displayName = "StackItem";
StackItem.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  alignSelf: oneOf(["flex-start", "flex-end", "center", "baseline", "stretch"]),
  flex: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  grow: PropTypes.number,
  shrink: PropTypes.number,
  order: PropTypes.number,
  basis: PropTypes.string
};
var _excluded$22 = ["as", "alignItems", "classPrefix", "childrenRenderMode", "className", "children", "direction", "justifyContent", "spacing", "divider", "style", "wrap"];
function isStackItem(child) {
  var _child$type;
  return child.type === StackItem || ((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.displayName) === "StackItem";
}
var Stack$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _itemStyles;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$alignItems = props.alignItems, alignItems = _props$alignItems === void 0 ? "center" : _props$alignItems, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "stack" : _props$classPrefix, _props$childrenRender = props.childrenRenderMode, childrenRenderMode = _props$childrenRender === void 0 ? "wrap" : _props$childrenRender, className = props.className, children = props.children, direction = props.direction, justifyContent = props.justifyContent, spacing = props.spacing, divider = props.divider, style2 = props.style, wrap = props.wrap, rest = _objectWithoutPropertiesLoose(props, _excluded$22);
  var _useCustom = useCustom("Stack"), rtl = _useCustom.rtl;
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix());
  var isSupportGap = isSupportFlexGap();
  var flexGap = Array.isArray(spacing) ? spacing : [spacing, spacing];
  var itemStyles = (_itemStyles = {}, _itemStyles[rtl ? "marginLeft" : "marginRight"] = flexGap[0], _itemStyles.marginBottom = flexGap[1], _itemStyles);
  var styles2 = _extends$1({
    alignItems,
    justifyContent,
    flexDirection: direction,
    flexWrap: wrap ? "wrap" : void 0,
    gap: isSupportGap ? spacing : void 0
  }, style2);
  var filterChildren = React.Children.toArray(children);
  var count2 = ReactChildren.count(filterChildren);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes,
    style: styles2
  }), ReactChildren.map(filterChildren, function(child, index) {
    var childNode = childrenRenderMode === "wrap" && !isStackItem(child) ? /* @__PURE__ */ React.createElement(StackItem, {
      key: index,
      className: prefix2("item"),
      style: !isSupportGap ? itemStyles : void 0
    }, child) : /* @__PURE__ */ React.cloneElement(child, {
      className: merge2(prefix2("item"), child.props.className),
      style: !isSupportGap ? _extends$1({}, itemStyles, child.props.style) : child.props.style
    });
    return [childNode, index < count2 - 1 ? divider : null];
  }));
});
Stack$1.Item = StackItem;
Stack$1.displayName = "Stack";
Stack$1.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  direction: oneOf(["row", "row-reverse", "column", "column-reverse"]),
  alignItems: oneOf(["flex-start", "center", "flex-end", "stretch", "baseline"]),
  justifyContent: oneOf(["flex-start", "center", "flex-end", "space-between", "space-around"]),
  spacing: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.array]),
  divider: PropTypes.node,
  wrap: PropTypes.bool
};
function isUndefined$1(value) {
  return value === void 0;
}
var isUndefined_1 = isUndefined$1;
const isUndefined$2 = /* @__PURE__ */ getDefaultExportFromCjs(isUndefined_1);
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
const isNil$1 = /* @__PURE__ */ getDefaultExportFromCjs(isNil_1);
var isSymbol = isSymbol_1;
function baseExtremum$2(array, iteratee, comparator) {
  var index = -1, length2 = array.length;
  while (++index < length2) {
    var value = array[index], current = iteratee(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
      var computed = current, result = value;
    }
  }
  return result;
}
var _baseExtremum = baseExtremum$2;
function baseGt$1(value, other) {
  return value > other;
}
var _baseGt = baseGt$1;
var baseExtremum$1 = _baseExtremum, baseGt = _baseGt, baseIteratee$4 = _baseIteratee;
function maxBy(array, iteratee) {
  return array && array.length ? baseExtremum$1(array, baseIteratee$4(iteratee), baseGt) : void 0;
}
var maxBy_1 = maxBy;
const maxBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(maxBy_1);
function baseLt$1(value, other) {
  return value < other;
}
var _baseLt = baseLt$1;
var baseExtremum = _baseExtremum, baseIteratee$3 = _baseIteratee, baseLt = _baseLt;
function minBy(array, iteratee) {
  return array && array.length ? baseExtremum(array, baseIteratee$3(iteratee), baseLt) : void 0;
}
var minBy_1 = minBy;
const minBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(minBy_1);
var AutoPlacement = {
  left: "Start",
  right: "End",
  top: "Start",
  bottom: "End"
};
function getContainerDimensions(containerNode) {
  var width2;
  var height2;
  var scrollX;
  var scrollY;
  if (containerNode.tagName === "BODY") {
    width2 = window.innerWidth;
    height2 = window.innerHeight;
    scrollY = scrollTop(ownerDocument$2(containerNode).documentElement) || scrollTop(containerNode);
    scrollX = scrollLeft(ownerDocument$2(containerNode).documentElement) || scrollLeft(containerNode);
  } else {
    var _ref = getOffset(containerNode);
    width2 = _ref.width;
    height2 = _ref.height;
    scrollY = scrollTop(containerNode);
    scrollX = scrollLeft(containerNode);
  }
  return {
    width: width2,
    height: height2,
    scrollX,
    scrollY
  };
}
const positionUtils = function(props) {
  var placement = props.placement, preventOverflow2 = props.preventOverflow, padding2 = props.padding;
  function getTopDelta(top2, overlayHeight, container) {
    if (!preventOverflow2) {
      return 0;
    }
    var containerDimensions = getContainerDimensions(container);
    var containerHeight = containerDimensions.height, scrollY = containerDimensions.scrollY;
    var topEdgeOffset = top2 - padding2 - scrollY;
    var bottomEdgeOffset = top2 + padding2 + overlayHeight - scrollY;
    if (topEdgeOffset < 0) {
      return -topEdgeOffset;
    } else if (bottomEdgeOffset > containerHeight) {
      return containerHeight - bottomEdgeOffset;
    }
    return 0;
  }
  function getLeftDelta(left2, overlayWidth, container) {
    if (!preventOverflow2) {
      return 0;
    }
    var containerDimensions = getContainerDimensions(container);
    var scrollX = containerDimensions.scrollX, containerWidth = containerDimensions.width;
    var leftEdgeOffset = left2 - padding2 - scrollX;
    var rightEdgeOffset = left2 + padding2 + overlayWidth - scrollX;
    if (leftEdgeOffset < 0) {
      return -leftEdgeOffset;
    } else if (rightEdgeOffset > containerWidth) {
      return containerWidth - rightEdgeOffset;
    }
    return 0;
  }
  function getPositionTop(container, overlayHeight, top2) {
    if (!preventOverflow2) {
      return top2;
    }
    var _getContainerDimensio = getContainerDimensions(container), scrollY = _getContainerDimensio.scrollY, containerHeight = _getContainerDimensio.height;
    if (overlayHeight + top2 > containerHeight + scrollY) {
      return containerHeight - overlayHeight + scrollY;
    }
    return Math.max(scrollY, top2);
  }
  function getPositionLeft(container, overlayWidth, left2) {
    if (!preventOverflow2) {
      return left2;
    }
    var _getContainerDimensio2 = getContainerDimensions(container), scrollX = _getContainerDimensio2.scrollX, containerWidth = _getContainerDimensio2.width;
    if (overlayWidth + left2 > containerWidth + scrollX) {
      return containerWidth - overlayWidth + scrollX;
    }
    return Math.max(scrollX, left2);
  }
  return {
    getPosition: function getPosition3(target, container) {
      var offset2 = container.tagName === "BODY" ? getOffset(target) : getPosition$1(target, container, false);
      return offset2;
    },
    getCursorOffsetPosition: function getCursorOffsetPosition(target, container, cursorPosition2) {
      var left2 = cursorPosition2.left, top2 = cursorPosition2.top, clientLeft = cursorPosition2.clientLeft, clientTop = cursorPosition2.clientTop;
      var offset2 = {
        left: left2,
        top: top2,
        width: 10,
        height: 10
      };
      if (getStyle(target, "position") === "fixed") {
        offset2.left = clientLeft;
        offset2.top = clientTop;
        return offset2;
      }
      if (container.tagName === "BODY") {
        return offset2;
      }
      var containerOffset = {
        top: 0,
        left: 0
      };
      if (nodeName(container) !== "html") {
        var nextParentOffset = getOffset(container);
        if (nextParentOffset) {
          containerOffset.top = nextParentOffset.top;
          containerOffset.left = nextParentOffset.left;
        }
      }
      containerOffset.top += parseInt(getStyle(container, "borderTopWidth"), 10) - scrollTop(container) || 0;
      containerOffset.left += parseInt(getStyle(container, "borderLeftWidth"), 10) - scrollLeft(container) || 0;
      offset2.left = left2 - containerOffset.left;
      offset2.top = top2 - containerOffset.top;
      return offset2;
    },
    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {
      var _getContainerDimensio3 = getContainerDimensions(container), width2 = _getContainerDimensio3.width, height2 = _getContainerDimensio3.height, scrollX = _getContainerDimensio3.scrollX, scrollY = _getContainerDimensio3.scrollY;
      var left2 = targetOffset.left - scrollX - overlay.width;
      var top2 = targetOffset.top - scrollY - overlay.height;
      var right2 = width2 - targetOffset.left - targetOffset.width + scrollX - overlay.width;
      var bottom2 = height2 - targetOffset.top - targetOffset.height + scrollY - overlay.height;
      var horizontal = [{
        key: "left",
        value: left2
      }, {
        key: "right",
        value: right2
      }];
      var vertical = [{
        key: "top",
        value: top2
      }, {
        key: "bottom",
        value: bottom2
      }];
      var AV = "autoVertical";
      var AH = "autoHorizontal";
      var direction;
      var align;
      if (placement.indexOf(AV) !== -1) {
        direction = maxBy$1(vertical, function(o) {
          return o.value;
        });
        return placement === AV ? direction.key : "" + direction.key + placement.replace(AV, "");
      } else if (placement.indexOf(AH) !== -1) {
        direction = maxBy$1(horizontal, function(o) {
          return o.value;
        });
        return placement === AH ? direction.key : "" + direction.key + placement.replace(AH, "");
      }
      direction = maxBy$1([].concat(vertical, horizontal), function(o) {
        return o.value;
      });
      if (direction.key === "left" || direction.key === "right") {
        align = minBy$1(vertical, function(o) {
          return o.value;
        });
      } else {
        align = minBy$1(horizontal, function(o) {
          return o.value;
        });
      }
      return "" + direction.key + AutoPlacement[align.key];
    },
    // Calculate the position of the overlay
    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container, cursorPosition2) {
      var childOffset = cursorPosition2 ? this.getCursorOffsetPosition(target, container, cursorPosition2) : this.getPosition(target, container);
      var _ref2 = getOffset(overlayNode), overlayHeight = _ref2.height, overlayWidth = _ref2.width;
      var top2 = childOffset.top, left2 = childOffset.left;
      var nextPlacement = placement;
      if (placement && placement.indexOf("auto") >= 0) {
        nextPlacement = this.calcAutoPlacement(childOffset, container, {
          height: overlayHeight,
          width: overlayWidth
        });
      }
      var positionLeft;
      var positionTop;
      var arrowOffsetLeft;
      var arrowOffsetTop;
      if (nextPlacement === "left" || nextPlacement === "right") {
        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;
        var topDelta = getTopDelta(positionTop, overlayHeight, container);
        positionTop += topDelta;
        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + "%";
        arrowOffsetLeft = void 0;
      } else if (nextPlacement === "top" || nextPlacement === "bottom") {
        positionLeft = left2 + (childOffset.width - overlayWidth) / 2;
        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);
        positionLeft += leftDelta;
        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + "%";
        arrowOffsetTop = void 0;
      }
      if (nextPlacement === "top" || nextPlacement === "topStart" || nextPlacement === "topEnd") {
        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);
      }
      if (nextPlacement === "bottom" || nextPlacement === "bottomStart" || nextPlacement === "bottomEnd") {
        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);
      }
      if (nextPlacement === "left" || nextPlacement === "leftStart" || nextPlacement === "leftEnd") {
        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);
      }
      if (nextPlacement === "right" || nextPlacement === "rightStart" || nextPlacement === "rightEnd") {
        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);
      }
      if (document.dir === "rtl" && (nextPlacement === "left" || nextPlacement === "leftStart" || nextPlacement === "leftEnd" || nextPlacement === "right" || nextPlacement === "rightStart" || nextPlacement === "rightEnd")) {
        var _getContainerDimensio4 = getContainerDimensions(container), containerWidth = _getContainerDimensio4.width;
        if (container.scrollWidth > containerWidth) {
          positionLeft = containerWidth + positionLeft - container.scrollWidth;
        }
      }
      if (nextPlacement === "topStart" || nextPlacement === "bottomStart") {
        if (document.dir === "rtl") {
          var nextLeft = left2 + (childOffset.width - overlayWidth);
          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);
        } else {
          positionLeft = left2 + getLeftDelta(left2, overlayWidth, container);
        }
      }
      if (nextPlacement === "topEnd" || nextPlacement === "bottomEnd") {
        if (document.dir === "rtl") {
          positionLeft = left2 + getLeftDelta(left2, overlayWidth, container);
        } else {
          var _nextLeft = left2 + (childOffset.width - overlayWidth);
          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);
        }
      }
      if (nextPlacement === "leftStart" || nextPlacement === "rightStart") {
        positionTop = top2 + getTopDelta(top2, overlayHeight, container);
      }
      if (nextPlacement === "leftEnd" || nextPlacement === "rightEnd") {
        var nextTop = top2 + (childOffset.height - overlayHeight);
        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);
      }
      return {
        positionLeft,
        positionTop,
        arrowOffsetLeft,
        arrowOffsetTop,
        positionClassName: "placement-" + kebabCase$1(nextPlacement)
      };
    }
  };
};
var usePosition = function usePosition2(props, ref) {
  var _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$preventOverflo = props.preventOverflow, preventOverflow2 = _props$preventOverflo === void 0 ? false : _props$preventOverflo, _props$containerPaddi = props.containerPadding, containerPadding = _props$containerPaddi === void 0 ? 0 : _props$containerPaddi, container = props.container, triggerTarget = props.triggerTarget, followCursor = props.followCursor, cursorPosition2 = props.cursorPosition;
  var containerRef = reactExports.useRef(null);
  var lastTargetRef = reactExports.useRef(null);
  var overlayResizeObserver = reactExports.useRef();
  var defaultPosition = {
    positionLeft: 0,
    positionTop: 0,
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0
  };
  var _useState = reactExports.useState(defaultPosition), position2 = _useState[0], setPosition = _useState[1];
  var utils2 = reactExports.useMemo(function() {
    return positionUtils({
      placement,
      preventOverflow: preventOverflow2,
      padding: containerPadding
    });
  }, [placement, preventOverflow2, containerPadding]);
  var updatePosition = reactExports.useCallback(
    /**
     * @param placementChanged  Whether the placement has changed
     * @param forceUpdateDOM Whether to update the DOM directly
     * @returns void
     */
    function(placementChanged, forceUpdateDOM) {
      if (placementChanged === void 0) {
        placementChanged = true;
      }
      if (!(triggerTarget !== null && triggerTarget !== void 0 && triggerTarget.current)) {
        return;
      }
      var targetElement = getDOMNode(triggerTarget);
      if (!isElement$2(targetElement)) {
        throw new Error("`target` should return an HTMLElement");
      }
      if (targetElement === lastTargetRef.current && !placementChanged) {
        return;
      }
      var overlay = getDOMNode(ref.current);
      var containerElement = getContainer$2(typeof container === "function" ? container() : container !== null && container !== void 0 ? container : null, ownerDocument$2(ref.current).body);
      var posi = utils2.calcOverlayPosition(overlay, targetElement, containerElement, followCursor ? cursorPosition2 : void 0);
      if (forceUpdateDOM && overlay) {
        var _overlay$className, _overlay$className$ma;
        var preClassName = overlay === null || overlay === void 0 ? void 0 : (_overlay$className = overlay.className) === null || _overlay$className === void 0 ? void 0 : (_overlay$className$ma = _overlay$className.match(/(placement-\S+)/)) === null || _overlay$className$ma === void 0 ? void 0 : _overlay$className$ma[0];
        removeClass$2(overlay, preClassName);
        if (posi.positionClassName) {
          addClass$1(overlay, posi.positionClassName);
        }
        addStyle(overlay, {
          left: posi.positionLeft + "px",
          top: posi.positionTop + "px"
        });
      } else {
        setPosition(posi);
      }
      containerRef.current = containerElement;
      lastTargetRef.current = targetElement;
    },
    [container, ref, triggerTarget, utils2, followCursor, cursorPosition2]
  );
  reactExports.useEffect(function() {
    updatePosition(false);
    var overlay = getDOMNode(ref.current);
    var containerScrollListener;
    if (containerRef.current && preventOverflow2) {
      var _containerRef$current;
      containerScrollListener = on(((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.tagName) === "BODY" ? window : containerRef.current, "scroll", function() {
        return updatePosition(true, true);
      });
    }
    var resizeListener = on(window, "resize", function() {
      return updatePosition(true, true);
    });
    if (overlay) {
      overlayResizeObserver.current = new ResizeObserver$1(function() {
        return updatePosition(true, true);
      });
      overlayResizeObserver.current.observe(overlay);
    }
    return function() {
      var _containerScrollListe, _overlayResizeObserve;
      lastTargetRef.current = null;
      (_containerScrollListe = containerScrollListener) === null || _containerScrollListe === void 0 ? void 0 : _containerScrollListe.off();
      resizeListener === null || resizeListener === void 0 ? void 0 : resizeListener.off();
      (_overlayResizeObserve = overlayResizeObserver.current) === null || _overlayResizeObserve === void 0 ? void 0 : _overlayResizeObserve.disconnect();
    };
  }, [preventOverflow2, ref, updatePosition]);
  useUpdateEffect(function() {
    return updatePosition();
  }, [updatePosition, placement]);
  return [position2, updatePosition];
};
var Position = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var children = props.children, className = props.className, followCursor = props.followCursor, cursorPosition2 = props.cursorPosition;
  var childRef = React.useRef(null);
  var _usePosition = usePosition(props, childRef), position2 = _usePosition[0], updatePosition = _usePosition[1];
  var positionClassName = position2.positionClassName, arrowOffsetLeft = position2.arrowOffsetLeft, arrowOffsetTop = position2.arrowOffsetTop, positionLeft = position2.positionLeft, positionTop = position2.positionTop;
  reactExports.useImperativeHandle(ref, function() {
    return {
      get child() {
        return childRef.current;
      },
      updatePosition
    };
  });
  reactExports.useEffect(function() {
    if (!followCursor || !cursorPosition2) return;
    updatePosition();
  }, [followCursor, cursorPosition2, updatePosition]);
  if (typeof children === "function") {
    var childProps = {
      className: classNames(className, positionClassName),
      arrowOffsetLeft,
      arrowOffsetTop,
      left: positionLeft,
      top: positionTop
    };
    return children(childProps, childRef);
  }
  return children;
});
Position.displayName = "Position";
Position.propTypes = {
  className: PropTypes.string,
  children: PropTypes.func.isRequired,
  container: PropTypes.oneOfType([PropTypes.func, PropTypes.any]),
  containerPadding: PropTypes.number,
  placement: PropTypes.any,
  preventOverflow: PropTypes.bool,
  triggerTarget: PropTypes.any
};
var _excluded$21 = ["timeout", "className"];
var Fade$1 = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
  var _ref$timeout = _ref.timeout, timeout = _ref$timeout === void 0 ? 300 : _ref$timeout, className = _ref.className, props = _objectWithoutPropertiesLoose(_ref, _excluded$21);
  var _useClassNames = useClassNames$2("anim"), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  return /* @__PURE__ */ React.createElement(Transition$1, _extends$1({}, props, {
    ref,
    timeout,
    className: merge2(className, prefix2("fade")),
    enteredClassName: prefix2("in"),
    enteringClassName: prefix2("in")
  }));
});
Fade$1.displayName = "Fade";
var OverlayContext = /* @__PURE__ */ React.createContext({});
OverlayContext.displayName = "OverlayContext";
var overlayPropTypes = {
  container: PropTypes.any,
  children: PropTypes.any,
  childrenProps: PropTypes.object,
  className: PropTypes.string,
  containerPadding: PropTypes.number,
  placement: PropTypes.any,
  preventOverflow: PropTypes.bool,
  open: PropTypes.bool,
  rootClose: PropTypes.bool,
  transition: PropTypes.any,
  triggerTarget: PropTypes.any,
  onClose: PropTypes.func,
  onEnter: PropTypes.func,
  onEntering: PropTypes.func,
  onEntered: PropTypes.func,
  onExit: PropTypes.func,
  onExiting: PropTypes.func,
  onExited: PropTypes.func
};
var Overlay = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useContext = reactExports.useContext(OverlayContext), overlayContainer = _useContext.overlayContainer;
  var _props$container = props.container, container = _props$container === void 0 ? overlayContainer : _props$container, containerPadding = props.containerPadding, placement = props.placement, rootClose = props.rootClose, children = props.children, childrenProps = props.childrenProps, _props$transition = props.transition, Transition2 = _props$transition === void 0 ? Fade$1 : _props$transition, open = props.open, preventOverflow2 = props.preventOverflow, triggerTarget = props.triggerTarget, onClose = props.onClose, onExited = props.onExited, onExit = props.onExit, onExiting = props.onExiting, onEnter = props.onEnter, onEntering = props.onEntering, onEntered = props.onEntered, followCursor = props.followCursor, cursorPosition2 = props.cursorPosition;
  var _useState = reactExports.useState(!open), exited = _useState[0], setExited = _useState[1];
  var overlayTarget = reactExports.useRef(null);
  if (open) {
    if (exited) setExited(false);
  } else if (!Transition2 && !exited) {
    setExited(true);
  }
  var mountOverlay = open || Transition2 && !exited;
  var handleExited = reactExports.useCallback(function(args) {
    setExited(true);
    onExited === null || onExited === void 0 ? void 0 : onExited(args);
  }, [onExited]);
  useRootClose(onClose, {
    triggerTarget,
    overlayTarget,
    disabled: !rootClose || !mountOverlay
  });
  if (!mountOverlay) {
    return null;
  }
  var positionProps = {
    container,
    containerPadding,
    triggerTarget,
    placement,
    preventOverflow: preventOverflow2,
    followCursor,
    cursorPosition: cursorPosition2
  };
  var renderChildWithPosition = function renderChildWithPosition2(transitionProps, transitionRef) {
    return /* @__PURE__ */ React.createElement(Position, _extends$1({}, positionProps, transitionProps, {
      ref: mergeRefs(ref, transitionRef)
    }), function(childProps, childRef) {
      if (typeof children === "function") {
        return children(Object.assign(childProps, childrenProps), mergeRefs(childRef, overlayTarget));
      }
      var left2 = childProps.left, top2 = childProps.top, className = childProps.className;
      return /* @__PURE__ */ React.cloneElement(children, _extends$1({}, childrenProps, children.props, {
        className: classNames(className, children.props.className),
        style: _extends$1({
          left: left2,
          top: top2
        }, children.props.style),
        ref: mergeRefs(childRef, overlayTarget)
      }));
    });
  };
  if (Transition2) {
    return /* @__PURE__ */ React.createElement(Transition2, {
      in: open,
      transitionAppear: true,
      onExit,
      onExiting,
      onExited: handleExited,
      onEnter,
      onEntering,
      onEntered
    }, renderChildWithPosition);
  }
  return renderChildWithPosition();
});
Overlay.displayName = "Overlay";
Overlay.propTypes = overlayPropTypes;
var _excluded$20 = ["children", "container", "controlId", "defaultOpen", "trigger", "disabled", "followCursor", "readOnly", "plaintext", "open", "delay", "delayOpen", "delayClose", "enterable", "placement", "speaker", "rootClose", "onClick", "onMouseOver", "onMouseMove", "onMouseOut", "onContextMenu", "onFocus", "onBlur", "onOpen", "onClose", "onExited"];
function mergeEvents(events2, props) {
  if (events2 === void 0) {
    events2 = {};
  }
  if (props === void 0) {
    props = {};
  }
  var nextEvents = {};
  Object.keys(events2).forEach(function(eventName) {
    if (events2[eventName]) {
      var _props;
      nextEvents[eventName] = createChainedFunction$1(events2[eventName], (_props = props) === null || _props === void 0 ? void 0 : _props[eventName]);
    }
  });
  return nextEvents;
}
var OverlayCloseCause = /* @__PURE__ */ function(OverlayCloseCause2) {
  OverlayCloseCause2[OverlayCloseCause2["ClickOutside"] = 0] = "ClickOutside";
  OverlayCloseCause2[OverlayCloseCause2["ImperativeHandle"] = 1] = "ImperativeHandle";
  return OverlayCloseCause2;
}({});
function onMouseEventHandler(handler, event, delay) {
  var target = event.currentTarget;
  var related = event.relatedTarget || get$4(event, ["nativeEvent", "toElement"]);
  if ((!related || related !== target) && !contains$3(target, related)) {
    handler(event, delay);
  }
}
var defaultTrigger = ["hover", "focus"];
var OverlayTrigger = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useContext = reactExports.useContext(OverlayContext), overlayContainer = _useContext.overlayContainer;
  var children = props.children, _props$container = props.container, container = _props$container === void 0 ? overlayContainer : _props$container, controlId = props.controlId, defaultOpen = props.defaultOpen, _props$trigger = props.trigger, trigger2 = _props$trigger === void 0 ? defaultTrigger : _props$trigger, disabled = props.disabled, followCursor = props.followCursor, readOnly = props.readOnly, plaintext = props.plaintext, openProp = props.open, delay = props.delay, delayOpenProp = props.delayOpen, delayCloseProp = props.delayClose, enterable = props.enterable, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, speaker = props.speaker, _props$rootClose = props.rootClose, rootClose = _props$rootClose === void 0 ? true : _props$rootClose, onClick = props.onClick, onMouseOver = props.onMouseOver, onMouseMove = props.onMouseMove, onMouseOut = props.onMouseOut, onContextMenu = props.onContextMenu, onFocus = props.onFocus, onBlur = props.onBlur, onOpen = props.onOpen, onClose = props.onClose, onExited = props.onExited, rest = _objectWithoutPropertiesLoose(props, _excluded$20);
  var _usePortal = usePortal({
    container
  }), Portal3 = _usePortal.Portal, containerElement = _usePortal.target;
  var triggerRef = reactExports.useRef(null);
  var overlayRef = reactExports.useRef();
  var _useControlled = useControlled$2(openProp, defaultOpen), open = _useControlled[0], setOpen = _useControlled[1];
  var _useState = reactExports.useState(null), cursorPosition2 = _useState[0], setCursorPosition = _useState[1];
  var delayOpenTimer = reactExports.useRef(null);
  var delayCloseTimer = reactExports.useRef(null);
  var delayOpen = isNil$1(delayOpenProp) ? delay : delayOpenProp;
  var delayClose = isNil$1(delayCloseProp) ? delay : delayCloseProp;
  var isOnOverlay = reactExports.useRef(false);
  var isOnTrigger = reactExports.useRef(false);
  reactExports.useEffect(function() {
    return function() {
      if (!isNil$1(delayOpenTimer.current)) {
        clearTimeout(delayOpenTimer.current);
      }
      if (!isNil$1(delayCloseTimer.current)) {
        clearTimeout(delayCloseTimer.current);
      }
    };
  }, []);
  var mouseEnter = reactExports.useRef(false);
  var handleOpenChange = reactExports.useCallback(function(nextOpen, closeCause) {
    if (nextOpen === open) return;
    if (nextOpen) {
      onOpen === null || onOpen === void 0 ? void 0 : onOpen();
    } else {
      onClose === null || onClose === void 0 ? void 0 : onClose(closeCause);
    }
    setOpen(nextOpen);
  }, [open, onOpen, onClose, setOpen]);
  var handleOpen = reactExports.useCallback(function(delay2) {
    var ms = isUndefined$2(delay2) ? delayOpen : delay2;
    if (ms && typeof ms === "number") {
      return delayOpenTimer.current = setTimeout(function() {
        delayOpenTimer.current = null;
        if (mouseEnter.current) {
          handleOpenChange(true);
        }
      }, ms);
    }
    handleOpenChange(true);
  }, [delayOpen, handleOpenChange]);
  var handleClose = reactExports.useCallback(function(delay2, closeCause) {
    var ms = isUndefined$2(delay2) ? delayClose : delay2;
    if (ms && typeof ms === "number") {
      return delayCloseTimer.current = setTimeout(function() {
        delayCloseTimer.current = null;
        handleOpenChange(false, closeCause);
      }, ms);
    }
    handleOpenChange(false, closeCause);
  }, [delayClose, handleOpenChange]);
  var handleExited = reactExports.useCallback(function() {
    setCursorPosition(null);
  }, []);
  reactExports.useImperativeHandle(ref, function() {
    return {
      get root() {
        return triggerRef.current;
      },
      get overlay() {
        var _overlayRef$current;
        return (_overlayRef$current = overlayRef.current) === null || _overlayRef$current === void 0 ? void 0 : _overlayRef$current.child;
      },
      getState: function getState() {
        return {
          open
        };
      },
      open: handleOpen,
      close: function close(delay2) {
        return handleClose(delay2, OverlayCloseCause.ImperativeHandle);
      },
      updatePosition: function updatePosition() {
        var _overlayRef$current2, _overlayRef$current2$;
        (_overlayRef$current2 = overlayRef.current) === null || _overlayRef$current2 === void 0 ? void 0 : (_overlayRef$current2$ = _overlayRef$current2.updatePosition) === null || _overlayRef$current2$ === void 0 ? void 0 : _overlayRef$current2$.call(_overlayRef$current2);
      }
    };
  });
  var handleCloseWhenLeave = reactExports.useCallback(function() {
    if (!isOnOverlay.current && !isOnTrigger.current) {
      handleClose(void 0, OverlayCloseCause.ClickOutside);
    }
  }, [handleClose]);
  var handleDelayedOpen = reactExports.useCallback(function() {
    mouseEnter.current = true;
    if (!enterable) {
      return handleOpen();
    }
    isOnTrigger.current = true;
    if (!isNil$1(delayCloseTimer.current)) {
      clearTimeout(delayCloseTimer.current);
      delayCloseTimer.current = null;
      return handleOpen();
    }
    if (open) {
      return;
    }
    handleOpen();
  }, [enterable, open, handleOpen]);
  var handleOpenState = reactExports.useCallback(function() {
    if (open) {
      handleCloseWhenLeave();
    } else {
      handleDelayedOpen();
    }
  }, [open, handleCloseWhenLeave, handleDelayedOpen]);
  var handleDelayedClose = reactExports.useCallback(function() {
    mouseEnter.current = false;
    if (!enterable) {
      return handleClose();
    }
    isOnTrigger.current = false;
    if (!isNil$1(delayOpenTimer.current)) {
      clearTimeout(delayOpenTimer.current);
      delayOpenTimer.current = null;
      return;
    }
    if (!open || !isNil$1(delayCloseTimer.current)) {
      return;
    }
    delayCloseTimer.current = setTimeout(function() {
      if (!isNil$1(delayCloseTimer.current)) {
        clearTimeout(delayCloseTimer.current);
        delayCloseTimer.current = null;
      }
      handleCloseWhenLeave();
    }, 200);
  }, [enterable, open, handleClose, handleCloseWhenLeave]);
  var handleSpeakerMouseEnter = reactExports.useCallback(function() {
    isOnOverlay.current = true;
  }, []);
  var handleSpeakerMouseLeave = reactExports.useCallback(function() {
    isOnOverlay.current = false;
    if (!isOneOf("click", trigger2) && !isOneOf("contextMenu", trigger2) && !isOneOf("active", trigger2)) {
      handleCloseWhenLeave();
    }
  }, [handleCloseWhenLeave, trigger2]);
  var handledMoveOverlay = reactExports.useCallback(function(event) {
    setCursorPosition(function() {
      return {
        top: event.pageY,
        left: event.pageX,
        clientTop: event.clientX,
        clientLeft: event.clientY
      };
    });
  }, []);
  var preventDefault = reactExports.useCallback(function(event) {
    event.preventDefault();
  }, []);
  var triggerEvents = reactExports.useMemo(function() {
    var events2 = {
      onClick,
      onContextMenu,
      onMouseOver,
      onMouseOut,
      onFocus,
      onBlur,
      onMouseMove
    };
    if (disabled || readOnly || plaintext || trigger2 === "none") {
      return events2;
    }
    if (followCursor) {
      events2.onMouseMove = createChainedFunction$1(handledMoveOverlay, onMouseMove);
    }
    if (isOneOf("click", trigger2)) {
      events2.onClick = createChainedFunction$1(handleOpenState, events2.onClick);
      return events2;
    }
    if (isOneOf("active", trigger2)) {
      events2.onClick = createChainedFunction$1(handleDelayedOpen, events2.onClick);
      return events2;
    }
    if (isOneOf("hover", trigger2)) {
      var onMouseOverListener = function onMouseOverListener2(e3) {
        return onMouseEventHandler(handleDelayedOpen, e3);
      };
      var onMouseOutListener = function onMouseOutListener2(e3) {
        return onMouseEventHandler(handleDelayedClose, e3);
      };
      events2.onMouseOver = createChainedFunction$1(onMouseOverListener, events2.onMouseOver);
      events2.onMouseOut = createChainedFunction$1(onMouseOutListener, events2.onMouseOut);
    }
    if (isOneOf("focus", trigger2)) {
      events2.onFocus = createChainedFunction$1(handleDelayedOpen, events2.onFocus);
      events2.onBlur = createChainedFunction$1(handleDelayedClose, events2.onBlur);
    }
    if (isOneOf("contextMenu", trigger2)) {
      events2.onContextMenu = createChainedFunction$1(preventDefault, handleOpenState, events2.onContextMenu);
    }
    return events2;
  }, [disabled, followCursor, handleDelayedClose, handleDelayedOpen, handleOpenState, handledMoveOverlay, onBlur, onClick, onContextMenu, onFocus, onMouseMove, onMouseOut, onMouseOver, plaintext, preventDefault, readOnly, trigger2]);
  var renderOverlay = function renderOverlay2() {
    var overlayProps = _extends$1({}, rest, {
      rootClose,
      triggerTarget: triggerRef,
      onClose: trigger2 !== "none" ? function() {
        return handleClose(void 0, OverlayCloseCause.ClickOutside);
      } : void 0,
      onExited: createChainedFunction$1(followCursor ? handleExited : void 0, onExited),
      placement,
      container: containerElement,
      open
    });
    var speakerProps = {
      id: controlId
    };
    if (trigger2 !== "none" && enterable) {
      speakerProps.onMouseEnter = handleSpeakerMouseEnter;
      speakerProps.onMouseLeave = handleSpeakerMouseLeave;
    }
    return /* @__PURE__ */ React.createElement(Overlay, _extends$1({}, overlayProps, {
      ref: overlayRef,
      childrenProps: speakerProps,
      followCursor,
      cursorPosition: cursorPosition2
    }), typeof speaker === "function" ? function(props2, ref2) {
      return speaker(_extends$1({}, props2, {
        onClose: handleClose
      }), ref2);
    } : speaker);
  };
  var triggerElement = reactExports.useMemo(function() {
    if (typeof children === "function") {
      return children(triggerEvents, triggerRef);
    } else if (isFragment(children) || !/* @__PURE__ */ reactExports.isValidElement(children)) {
      return /* @__PURE__ */ React.createElement("span", _extends$1({
        ref: triggerRef,
        "aria-describedby": controlId
      }, triggerEvents), children);
    }
    return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
      ref: triggerRef,
      "aria-describedby": controlId
    }, mergeEvents(triggerEvents, children.props)));
  }, [children, controlId, triggerEvents]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, triggerElement, /* @__PURE__ */ React.createElement(Portal3, null, renderOverlay()));
});
OverlayTrigger.displayName = "OverlayTrigger";
function FormattedDate(_ref) {
  var date = _ref.date, formatStr = _ref.formatStr;
  var _useCustom = useCustom("Calendar"), formatDate = _useCustom.formatDate;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, formatDate(date, formatStr));
}
var _excluded$1$ = ["onOpen", "onClose", "onEntered", "onExited", "placement", "preventOverflow"];
var Whisper = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var onOpen = props.onOpen, onClose = props.onClose, onEntered = props.onEntered, onExited = props.onExited, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, preventOverflow2 = props.preventOverflow, rest = _objectWithoutPropertiesLoose(props, _excluded$1$);
  var context = reactExports.useContext(CustomContext);
  return /* @__PURE__ */ React.createElement(OverlayTrigger, _extends$1({}, rest, {
    ref,
    preventOverflow: preventOverflow2,
    placement: placementPolyfill(placement, context === null || context === void 0 ? void 0 : context.rtl),
    onEntered: createChainedFunction$1(onOpen, onEntered),
    onExited: createChainedFunction$1(onClose, onExited)
  }));
});
Whisper.displayName = "Whisper";
Whisper.propTypes = {
  onOpen: PropTypes.func,
  onClose: PropTypes.func,
  onEntered: PropTypes.func,
  onExited: PropTypes.func,
  placement: oneOf(PLACEMENT),
  /**
   * Prevent floating element overflow
   */
  preventOverflow: PropTypes.bool,
  /**
   * Whether enable speaker follow cursor
   */
  followCursor: PropTypes.bool
};
var _excluded$1_ = ["as", "className", "classPrefix", "children", "style", "visible", "arrow"];
var Tooltip$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "tooltip" : _props$classPrefix, children = props.children, style2 = props.style, visible = props.visible, _props$arrow = props.arrow, arrow2 = _props$arrow === void 0 ? true : _props$arrow, rest = _objectWithoutPropertiesLoose(props, _excluded$1_);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, withClassPrefix({
    arrow: arrow2
  }));
  var styles2 = _extends$1({
    opacity: visible ? 1 : void 0
  }, style2);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "tooltip"
  }, rest, {
    ref,
    className: classes,
    style: styles2
  }), children);
});
Tooltip$1.displayName = "Tooltip";
Tooltip$1.propTypes = {
  visible: PropTypes.bool,
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node,
  arrow: PropTypes.bool
};
function findIndexOf$1(arr, cb2) {
  var index = -1;
  arr.some(function(d4, i2) {
    if (cb2(d4, i2)) {
      index = i2;
      return true;
    }
    return false;
  });
  return index;
}
function findContainer(data, modal) {
  return findIndexOf$1(data, function(d4) {
    return d4.modals.indexOf(modal) !== -1;
  });
}
var ModalManager$1 = /* @__PURE__ */ function() {
  function ModalManager2() {
    this.modals = [];
    this.containers = [];
    this.data = [];
  }
  var _proto = ModalManager2.prototype;
  _proto.add = function add(modal, container, className) {
    var modalIndex = this.modals.indexOf(modal);
    var containerIndex = this.containers.indexOf(container);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (containerIndex !== -1) {
      this.data[containerIndex].modals.push(modal);
      return modalIndex;
    }
    var containerState = {
      modals: [modal],
      classes: className ? className.split(/\s+/) : [],
      style: {
        overflow: container.style.overflow,
        paddingRight: container.style.paddingRight
      },
      overflowing: isOverflowing$1(container)
    };
    if (containerState.overflowing) {
      var paddingRight = parseInt(getStyle(container, "paddingRight") || 0, 10);
      var barSize = getScrollbarSize$2();
      addStyle(container, {
        paddingRight: (barSize ? paddingRight + barSize : paddingRight) + "px"
      });
    }
    containerState.classes.forEach(addClass$1.bind(null, container));
    this.containers.push(container);
    this.data.push(containerState);
    return modalIndex;
  };
  _proto.remove = function remove2(modal) {
    var modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return;
    }
    var containerIndex = findContainer(this.data, modal);
    var containerState = this.data[containerIndex];
    var container = this.containers[containerIndex];
    containerState.modals.splice(containerState.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerState.modals.length === 0) {
      Object.keys(containerState.style).forEach(function(key) {
        return container.style[key] = containerState.style[key];
      });
      containerState.classes.forEach(removeClass$2.bind(null, container));
      this.containers.splice(containerIndex, 1);
      this.data.splice(containerIndex, 1);
    }
  };
  _proto.isTopModal = function isTopModal(modal) {
    return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
  };
  return ModalManager2;
}();
var _excluded$1Z = ["as", "children", "transition", "dialogTransitionTimeout", "style", "className", "container", "animationProps", "containerClassName", "keyboard", "enforceFocus", "backdrop", "backdropTransitionTimeout", "backdropStyle", "backdropClassName", "open", "autoFocus", "onEsc", "onExit", "onExiting", "onExited", "onEnter", "onEntering", "onEntered", "onClose", "onOpen"], _excluded2$l = ["className"];
var manager;
function getManager() {
  if (!manager) manager = new ModalManager$1();
  return manager;
}
var useModalManager = function useModalManager2() {
  var modalManager = getManager();
  var modal = reactExports.useRef({
    dialog: null,
    backdrop: null
  });
  return {
    get dialog() {
      var _modal$current;
      return (_modal$current = modal.current) === null || _modal$current === void 0 ? void 0 : _modal$current.dialog;
    },
    add: function add(containerElement, containerClassName) {
      return modalManager.add(modal.current, containerElement, containerClassName);
    },
    remove: function remove2() {
      return modalManager.remove(modal.current);
    },
    isTopModal: function isTopModal() {
      return modalManager.isTopModal(modal.current);
    },
    setDialogRef: reactExports.useCallback(function(ref) {
      modal.current.dialog = ref;
    }, []),
    setBackdropRef: reactExports.useCallback(function(ref) {
      modal.current.backdrop = ref;
    }, [])
  };
};
var Modal$2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, children = props.children, Transition2 = props.transition, dialogTransitionTimeout = props.dialogTransitionTimeout, style2 = props.style, className = props.className, container = props.container, animationProps = props.animationProps, containerClassName = props.containerClassName, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$enforceFocus = props.enforceFocus, enforceFocus = _props$enforceFocus === void 0 ? true : _props$enforceFocus, _props$backdrop = props.backdrop, backdrop = _props$backdrop === void 0 ? true : _props$backdrop, backdropTransitionTimeout = props.backdropTransitionTimeout, backdropStyle = props.backdropStyle, backdropClassName = props.backdropClassName, open = props.open, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, onEsc = props.onEsc, onExit = props.onExit, onExiting = props.onExiting, onExited = props.onExited, onEnter = props.onEnter, onEntering = props.onEntering, onEntered = props.onEntered, onClose = props.onClose, onOpen = props.onOpen, rest = _objectWithoutPropertiesLoose(props, _excluded$1Z);
  var _useState = reactExports.useState(!open), exited = _useState[0], setExited = _useState[1];
  var _usePortal = usePortal({
    container
  }), Portal3 = _usePortal.Portal, containerElement = _usePortal.target;
  var modal = useModalManager();
  if (open) {
    if (exited) setExited(false);
  } else if (!Transition2 && !exited) {
    setExited(true);
  }
  var mountModal = open || Transition2 && !exited;
  var lastFocus = reactExports.useRef(null);
  var handleDocumentKeyDown = useEventCallback$2(function(event) {
    if (keyboard && event.key === KEY_VALUES.ESC && modal.isTopModal()) {
      onEsc === null || onEsc === void 0 ? void 0 : onEsc(event);
      onClose === null || onClose === void 0 ? void 0 : onClose(event);
    }
  });
  var restoreLastFocus = reactExports.useCallback(function() {
    if (lastFocus.current) {
      var _lastFocus$current$fo, _lastFocus$current;
      (_lastFocus$current$fo = (_lastFocus$current = lastFocus.current).focus) === null || _lastFocus$current$fo === void 0 ? void 0 : _lastFocus$current$fo.call(_lastFocus$current);
      lastFocus.current = null;
    }
  }, []);
  var handleFocusDialog = useEventCallback$2(function(onBeforeFocusCallback) {
    var currentActiveElement = document.activeElement;
    var dialog = modal.dialog;
    if (dialog && currentActiveElement && !contains$3(dialog, currentActiveElement)) {
      onBeforeFocusCallback === null || onBeforeFocusCallback === void 0 ? void 0 : onBeforeFocusCallback();
      dialog.focus();
    }
  });
  var handleEnforceFocus = useEventCallback$2(function() {
    if (!enforceFocus || !modal.isTopModal()) {
      return;
    }
    handleFocusDialog();
  });
  var documentKeyDownListener = reactExports.useRef();
  var documentFocusListener = reactExports.useRef();
  var handleOpen = useEventCallback$2(function() {
    if (containerElement) {
      modal.add(containerElement, containerClassName);
    }
    if (!documentKeyDownListener.current) {
      documentKeyDownListener.current = on(document, "keydown", handleDocumentKeyDown);
    }
    if (!documentFocusListener.current) {
      documentFocusListener.current = on(document, "focus", handleEnforceFocus, true);
    }
    if (autoFocus) {
      handleFocusDialog(function() {
        lastFocus.current = document.activeElement;
      });
    }
    onOpen === null || onOpen === void 0 ? void 0 : onOpen();
  });
  var handleClose = useEventCallback$2(function() {
    var _documentKeyDownListe, _documentFocusListene;
    modal.remove();
    (_documentKeyDownListe = documentKeyDownListener.current) === null || _documentKeyDownListe === void 0 ? void 0 : _documentKeyDownListe.off();
    documentKeyDownListener.current = null;
    (_documentFocusListene = documentFocusListener.current) === null || _documentFocusListene === void 0 ? void 0 : _documentFocusListene.off();
    documentFocusListener.current = null;
    restoreLastFocus();
  });
  reactExports.useEffect(function() {
    if (!open) {
      return;
    }
    handleOpen();
  }, [open, handleOpen]);
  reactExports.useEffect(function() {
    if (!exited) {
      return;
    }
    handleClose();
  }, [exited, handleClose]);
  useWillUnmount(function() {
    handleClose();
  });
  var handleExited = reactExports.useCallback(function() {
    setExited(true);
  }, []);
  var contextValue = reactExports.useMemo(function() {
    return {
      overlayContainer: function overlayContainer() {
        return modal.dialog;
      }
    };
  }, [modal.dialog]);
  if (!mountModal) {
    return null;
  }
  var renderBackdrop = function renderBackdrop2() {
    if (Transition2) {
      return /* @__PURE__ */ React.createElement(Fade$1, {
        transitionAppear: true,
        in: open,
        timeout: backdropTransitionTimeout
      }, function(fadeProps, ref2) {
        var className2 = fadeProps.className, rest2 = _objectWithoutPropertiesLoose(fadeProps, _excluded2$l);
        return /* @__PURE__ */ React.createElement("div", _extends$1({
          "aria-hidden": true,
          "data-testid": "backdrop"
        }, rest2, {
          style: backdropStyle,
          ref: mergeRefs(modal.setBackdropRef, ref2),
          className: classNames(backdropClassName, className2)
        }));
      });
    }
    return /* @__PURE__ */ React.createElement("div", {
      "aria-hidden": true,
      style: backdropStyle,
      className: backdropClassName
    });
  };
  var dialogElement = Transition2 ? /* @__PURE__ */ React.createElement(Transition2, _extends$1({}, animationProps, {
    transitionAppear: true,
    unmountOnExit: true,
    in: open,
    timeout: dialogTransitionTimeout,
    onExit,
    onExiting,
    onExited: createChainedFunction$1(handleExited, onExited),
    onEnter,
    onEntering,
    onEntered
  }), children) : children;
  return /* @__PURE__ */ React.createElement(OverlayContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Portal3, null, backdrop && renderBackdrop(), /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref: mergeRefs(modal.setDialogRef, ref),
    style: style2,
    className,
    tabIndex: -1
  }), dialogElement)));
});
var modalPropTypes = {
  as: PropTypes.elementType,
  className: PropTypes.string,
  backdropClassName: PropTypes.string,
  style: PropTypes.object,
  backdropStyle: PropTypes.object,
  open: PropTypes.bool,
  backdrop: PropTypes.oneOfType([PropTypes.bool, PropTypes.string]),
  keyboard: PropTypes.bool,
  autoFocus: PropTypes.bool,
  enforceFocus: PropTypes.bool,
  animationProps: PropTypes.object,
  onOpen: PropTypes.func,
  onClose: PropTypes.func
};
Modal$2.displayName = "OverlayModal";
Modal$2.propTypes = _extends$1({}, animationPropTypes, modalPropTypes, {
  children: PropTypes.func,
  container: PropTypes.any,
  containerClassName: PropTypes.string,
  dialogTransitionTimeout: PropTypes.number,
  backdropTransitionTimeout: PropTypes.number,
  transition: PropTypes.any,
  onEsc: PropTypes.func
});
var _excluded$1Y = ["timeout"];
var Bounce = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
  var _ref$timeout = _ref.timeout, timeout = _ref$timeout === void 0 ? 300 : _ref$timeout, props = _objectWithoutPropertiesLoose(_ref, _excluded$1Y);
  var _useClassNames = useClassNames$2("anim"), prefix2 = _useClassNames.prefix;
  return /* @__PURE__ */ React.createElement(Transition$1, _extends$1({}, props, {
    ref,
    animation: true,
    timeout,
    enteringClassName: prefix2("bounce-in"),
    enteredClassName: prefix2("bounce-in"),
    exitingClassName: prefix2("bounce-out"),
    exitedClassName: prefix2("bounce-out")
  }));
});
Bounce.displayName = "Bounce";
var _templateObject$f;
var _excluded$1X = ["as", "style", "children", "dialogClassName", "dialogStyle", "classPrefix", "className", "size"];
var modalDialogPropTypes = {
  size: oneOf(SIZE$1),
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  dialogClassName: PropTypes.string,
  style: PropTypes.object,
  dialogStyle: PropTypes.object,
  children: PropTypes.node
};
var ModalDialog = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, style2 = props.style, children = props.children, dialogClassName = props.dialogClassName, dialogStyle = props.dialogStyle, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "modal" : _props$classPrefix, className = props.className, size2 = props.size, rest = _objectWithoutPropertiesLoose(props, _excluded$1X);
  var modalStyle = _extends$1({
    display: "block"
  }, style2);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix(size2));
  var dialogClasses2 = merge2(dialogClassName, prefix2("dialog"));
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "dialog",
    "aria-modal": true
  }, rest, {
    ref,
    className: classes,
    style: modalStyle
  }), /* @__PURE__ */ React.createElement("div", {
    role: "document",
    className: dialogClasses2,
    style: dialogStyle
  }, /* @__PURE__ */ React.createElement("div", {
    className: prefix2(_templateObject$f || (_templateObject$f = _taggedTemplateLiteralLoose(["content"])))
  }, children)));
});
ModalDialog.displayName = "ModalDialog";
ModalDialog.propTypes = modalDialogPropTypes;
var ModalContext = /* @__PURE__ */ React.createContext(null);
var Close$3 = {};
var Close$2 = { exports: {} };
var Close$1 = {};
var hasRequiredClose;
function requireClose() {
  if (hasRequiredClose) return Close$1;
  hasRequiredClose = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function Close2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 16 16",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M2.784 2.089l.069.058 5.146 5.147 5.146-5.147a.5.5 0 01.765.638l-.058.069L8.705 8l5.147 5.146a.5.5 0 01-.638.765l-.069-.058-5.146-5.147-5.146 5.147a.5.5 0 01-.765-.638l.058-.069L7.293 8 2.146 2.854a.5.5 0 01.638-.765z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(Close2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(Close$1);
  return Close$1;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _Close = _interopRequireDefault2(requireClose());
  var Close2 = (0, _createSvgIcon2["default"])({
    as: _Close["default"],
    ariaLabel: "close",
    category: "application",
    displayName: "Close"
  });
  var _default = Close2;
  exports["default"] = _default;
  module.exports = exports.default;
})(Close$2, Close$2.exports);
var CloseExports = Close$2.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _Close["default"];
    }
  });
  var _Close = _interopRequireDefault2(CloseExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(Close$3);
const CloseIcon$1 = /* @__PURE__ */ getDefaultExportFromCjs(Close$3);
var DrawerContext = /* @__PURE__ */ React.createContext(null);
var _excluded$1W = ["as", "classPrefix", "className", "style", "children"];
var ModalBody = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _context$getBodyStyle, _useContext;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "modal-body" : _props$classPrefix, className = props.className, style2 = props.style, children = props.children, rest = _objectWithoutPropertiesLoose(props, _excluded$1W);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix());
  var context = reactExports.useContext(ModalContext);
  var bodyStyles = context === null || context === void 0 ? void 0 : (_context$getBodyStyle = context.getBodyStyles) === null || _context$getBodyStyle === void 0 ? void 0 : _context$getBodyStyle.call(context);
  var closeButton = (_useContext = reactExports.useContext(DrawerContext)) === null || _useContext === void 0 ? void 0 : _useContext.closeButton;
  var buttonElement = null;
  if (closeButton) {
    buttonElement = typeof closeButton === "boolean" ? /* @__PURE__ */ React.createElement(IconButton$1, {
      icon: /* @__PURE__ */ React.createElement(CloseIcon$1, null),
      appearance: "subtle",
      size: "sm",
      className: prefix2("close"),
      onClick: context === null || context === void 0 ? void 0 : context.onModalClose
    }) : closeButton;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    style: _extends$1({}, bodyStyles, style2),
    className: classes
  }), buttonElement, children);
});
ModalBody.displayName = "ModalBody";
ModalBody.propTypes = {
  as: PropTypes.elementType,
  classPrefix: PropTypes.string,
  className: PropTypes.string
};
var _excluded$1V = ["as", "classPrefix", "className", "locale"];
var CloseButton = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "button" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "btn-close" : _props$classPrefix, className = props.className, overrideLocale = props.locale, rest = _objectWithoutPropertiesLoose(props, _excluded$1V);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var _useCustom = useCustom("CloseButton", overrideLocale), locale2 = _useCustom.locale;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    type: "button",
    ref,
    className: classes,
    "aria-label": locale2 === null || locale2 === void 0 ? void 0 : locale2.closeLabel
  }, rest), /* @__PURE__ */ React.createElement(CloseIcon$1, null));
});
CloseButton.displayName = "CloseButton";
var _excluded$1U = ["as", "classPrefix", "className", "closeButton", "children", "onClose"];
var ModalHeader = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useContext, _useContext2;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "modal-header" : _props$classPrefix, className = props.className, _props$closeButton = props.closeButton, closeButton = _props$closeButton === void 0 ? true : _props$closeButton, children = props.children, onClose = props.onClose, rest = _objectWithoutPropertiesLoose(props, _excluded$1U);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix());
  var onModalClose = (_useContext = reactExports.useContext(ModalContext)) === null || _useContext === void 0 ? void 0 : _useContext.onModalClose;
  var isDrawer = (_useContext2 = reactExports.useContext(DrawerContext)) === null || _useContext2 === void 0 ? void 0 : _useContext2.isDrawer;
  var buttonElement = isDrawer ? /* @__PURE__ */ React.createElement(IconButton$1, {
    icon: /* @__PURE__ */ React.createElement(CloseIcon$1, null),
    appearance: "subtle",
    size: "sm",
    className: prefix2("close"),
    onClick: createChainedFunction$1(onClose, onModalClose)
  }) : /* @__PURE__ */ React.createElement(CloseButton, {
    className: prefix2("close"),
    onClick: createChainedFunction$1(onClose, onModalClose)
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), closeButton && buttonElement, children);
});
ModalHeader.displayName = "ModalHeader";
ModalHeader.propTypes = {
  as: PropTypes.elementType,
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  closeButton: PropTypes.bool,
  children: PropTypes.node
};
var _excluded$1T = ["as", "classPrefix", "className", "role"];
var ModalTitle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "h4" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "modal-title" : _props$classPrefix, className = props.className, role = props.role, rest = _objectWithoutPropertiesLoose(props, _excluded$1T);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  var context = reactExports.useContext(ModalContext);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    id: context ? context.dialogId + "-title" : void 0
  }, rest, {
    role,
    ref,
    className: classes
  }));
});
ModalTitle.displayName = "Modal.Title";
ModalTitle.propTypes = {
  as: PropTypes.elementType,
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  children: PropTypes.node
};
var ModalFooter = createComponent({
  name: "ModalFooter"
});
var useBodyStyles = function useBodyStyles2(ref, options) {
  var _useState = reactExports.useState({}), bodyStyles = _useState[0], setBodyStyles = _useState[1];
  var overflow = options.overflow, prefix2 = options.prefix, size2 = options.size;
  var windowResizeListener = reactExports.useRef();
  var contentElement = reactExports.useRef(null);
  var contentElementResizeObserver = reactExports.useRef();
  var updateBodyStyles = reactExports.useCallback(function(_event, entering) {
    var dialog = ref.current;
    var scrollHeight = dialog ? dialog.scrollHeight : 0;
    var styles2 = {
      overflow: "auto"
    };
    if (dialog) {
      var headerHeight = 46;
      var footerHeight = 46;
      var headerDOM = dialog.querySelector("." + prefix2("header"));
      var footerDOM = dialog.querySelector("." + prefix2("footer"));
      headerHeight = headerDOM ? getHeight(headerDOM) + headerHeight : headerHeight;
      footerHeight = footerDOM ? getHeight(footerDOM) + footerHeight : footerHeight;
      var excludeHeight = headerHeight + footerHeight + (entering ? 70 : 60);
      var bodyHeight = getHeight(window) - excludeHeight;
      var maxHeight2 = scrollHeight >= bodyHeight ? bodyHeight : scrollHeight;
      styles2.maxHeight = maxHeight2;
    }
    setBodyStyles(styles2);
  }, [prefix2, ref]);
  var onDestroyEvents = reactExports.useCallback(function() {
    var _windowResizeListener, _windowResizeListener2, _contentElementResize;
    (_windowResizeListener = windowResizeListener.current) === null || _windowResizeListener === void 0 ? void 0 : (_windowResizeListener2 = _windowResizeListener.off) === null || _windowResizeListener2 === void 0 ? void 0 : _windowResizeListener2.call(_windowResizeListener);
    (_contentElementResize = contentElementResizeObserver.current) === null || _contentElementResize === void 0 ? void 0 : _contentElementResize.disconnect();
    windowResizeListener.current = null;
    contentElementResizeObserver.current = null;
  }, []);
  var onChangeBodyStyles = reactExports.useCallback(function(entering) {
    if (!overflow || size2 === "full") {
      setBodyStyles(null);
      return;
    }
    if (ref.current) {
      updateBodyStyles(void 0, entering);
      contentElement.current = ref.current.querySelector("." + prefix2("content"));
      if (!windowResizeListener.current) {
        windowResizeListener.current = on(window, "resize", updateBodyStyles);
      }
      if (contentElement.current && !contentElementResizeObserver.current) {
        contentElementResizeObserver.current = new ResizeObserver$1(function() {
          return updateBodyStyles();
        });
        contentElementResizeObserver.current.observe(contentElement.current);
      }
    }
  }, [overflow, prefix2, ref, size2, updateBodyStyles]);
  reactExports.useEffect(function() {
    return onDestroyEvents;
  }, []);
  return [overflow ? bodyStyles : null, onChangeBodyStyles, onDestroyEvents];
};
var _templateObject$e, _templateObject2$8, _templateObject3$1;
var _excluded$1S = ["animation", "animationProps", "animationTimeout", "aria-labelledby", "aria-describedby", "backdropClassName", "backdrop", "className", "children", "classPrefix", "dialogClassName", "dialogStyle", "dialogAs", "enforceFocus", "full", "overflow", "open", "onClose", "onEntered", "onEntering", "onExited", "role", "size", "id"], _excluded2$k = ["className"];
var modalSizes = ["xs", "sm", "md", "lg", "full"];
var Modal$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _prefix, _merge;
  var _props$animation = props.animation, animation = _props$animation === void 0 ? Bounce : _props$animation, animationProps = props.animationProps, _props$animationTimeo = props.animationTimeout, animationTimeout = _props$animationTimeo === void 0 ? 300 : _props$animationTimeo, ariaLabelledby = props["aria-labelledby"], ariaDescribedby = props["aria-describedby"], backdropClassName = props.backdropClassName, _props$backdrop = props.backdrop, backdrop = _props$backdrop === void 0 ? true : _props$backdrop, className = props.className, children = props.children, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "modal" : _props$classPrefix, dialogClassName = props.dialogClassName, dialogStyle = props.dialogStyle, _props$dialogAs = props.dialogAs, Dialog3 = _props$dialogAs === void 0 ? ModalDialog : _props$dialogAs, enforceFocusProp = props.enforceFocus, full = props.full, _props$overflow = props.overflow, overflow = _props$overflow === void 0 ? true : _props$overflow, open = props.open, onClose = props.onClose, onEntered = props.onEntered, onEntering = props.onEntering, onExited = props.onExited, _props$role = props.role, role = _props$role === void 0 ? "dialog" : _props$role, _props$size = props.size, size2 = _props$size === void 0 ? "sm" : _props$size, idProp = props.id, rest = _objectWithoutPropertiesLoose(props, _excluded$1S);
  var inClass = {
    in: open && !animation
  };
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var _useState = reactExports.useState(false), shake = _useState[0], setShake = _useState[1];
  var classes = merge2(className, prefix2((_prefix = {
    full
  }, _prefix[size2] = modalSizes.includes(size2), _prefix)));
  var dialogRef = reactExports.useRef(null);
  var transitionEndListener = reactExports.useRef();
  var _ref = reactExports.useContext(DrawerContext) || {}, _ref$isDrawer = _ref.isDrawer, isDrawer = _ref$isDrawer === void 0 ? false : _ref$isDrawer;
  var _useBodyStyles = useBodyStyles(dialogRef, {
    overflow,
    prefix: prefix2,
    size: size2
  }), bodyStyles = _useBodyStyles[0], onChangeBodyStyles = _useBodyStyles[1], onDestroyEvents = _useBodyStyles[2];
  var dialogId = useUniqueId("dialog-", idProp);
  var modalContextValue = reactExports.useMemo(function() {
    return {
      dialogId,
      onModalClose: onClose,
      getBodyStyles: function getBodyStyles() {
        return bodyStyles;
      }
    };
  }, [dialogId, onClose, bodyStyles]);
  var handleExited = reactExports.useCallback(function(node2) {
    var _transitionEndListene;
    onExited === null || onExited === void 0 ? void 0 : onExited(node2);
    onDestroyEvents();
    (_transitionEndListene = transitionEndListener.current) === null || _transitionEndListene === void 0 ? void 0 : _transitionEndListene.off();
    transitionEndListener.current = null;
  }, [onDestroyEvents, onExited]);
  var handleEntered = reactExports.useCallback(function(node2) {
    onEntered === null || onEntered === void 0 ? void 0 : onEntered(node2);
    onChangeBodyStyles();
  }, [onChangeBodyStyles, onEntered]);
  var handleEntering = reactExports.useCallback(function(node2) {
    onEntering === null || onEntering === void 0 ? void 0 : onEntering(node2);
    onChangeBodyStyles(true);
  }, [onChangeBodyStyles, onEntering]);
  var backdropClick = React.useRef();
  var handleMouseDown = reactExports.useCallback(function(event) {
    backdropClick.current = event.target === event.currentTarget;
  }, []);
  var handleBackdropClick = reactExports.useCallback(function(event) {
    if (!backdropClick.current) {
      return;
    }
    if (event.target === dialogRef.current) {
      return;
    }
    if (event.target !== event.currentTarget) {
      return;
    }
    if (backdrop === "static") {
      setShake(true);
      if (!transitionEndListener.current && dialogRef.current) {
        transitionEndListener.current = on(dialogRef.current, getAnimationEnd$1(), function() {
          setShake(false);
        });
      }
      return;
    }
    onClose === null || onClose === void 0 ? void 0 : onClose(event);
  }, [backdrop, onClose]);
  useWillUnmount(function() {
    var _transitionEndListene2;
    (_transitionEndListene2 = transitionEndListener.current) === null || _transitionEndListene2 === void 0 ? void 0 : _transitionEndListene2.off();
  });
  var sizeKey = "width";
  if (isDrawer) {
    var _ref2 = animationProps || {}, placement = _ref2.placement;
    sizeKey = placement === "top" || placement === "bottom" ? "height" : "width";
  }
  var enforceFocus = reactExports.useMemo(function() {
    if (typeof enforceFocusProp === "boolean") {
      return enforceFocusProp;
    }
    if (isDrawer && backdrop === false) {
      return false;
    }
  }, [backdrop, enforceFocusProp, isDrawer]);
  var wrapperClassName = merge2(prefix2(_templateObject$e || (_templateObject$e = _taggedTemplateLiteralLoose(["wrapper"]))), (_merge = {}, _merge[prefix2(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteralLoose(["no-backdrop"])))] = backdrop === false, _merge));
  return /* @__PURE__ */ React.createElement(ModalContext.Provider, {
    value: modalContextValue
  }, /* @__PURE__ */ React.createElement(Modal$2, _extends$1({
    "data-testid": isDrawer ? "drawer-wrapper" : "modal-wrapper"
  }, rest, {
    ref,
    backdrop,
    enforceFocus,
    open,
    onClose,
    className: wrapperClassName,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExited: handleExited,
    backdropClassName: merge2(prefix2(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose(["backdrop"]))), backdropClassName, inClass),
    containerClassName: prefix2({
      open,
      "has-backdrop": backdrop
    }),
    transition: animation ? animation : void 0,
    animationProps,
    dialogTransitionTimeout: animationTimeout,
    backdropTransitionTimeout: 150,
    onClick: backdrop ? handleBackdropClick : void 0,
    onMouseDown: handleMouseDown
  }), function(transitionProps, transitionRef) {
    var _ref3;
    var transitionClassName = transitionProps.className, transitionRest = _objectWithoutPropertiesLoose(transitionProps, _excluded2$k);
    return /* @__PURE__ */ React.createElement(Dialog3, _extends$1({
      role,
      id: dialogId,
      "aria-labelledby": ariaLabelledby !== null && ariaLabelledby !== void 0 ? ariaLabelledby : dialogId + "-title",
      "aria-describedby": ariaDescribedby,
      style: (_ref3 = {}, _ref3[sizeKey] = modalSizes.includes(size2) ? void 0 : size2, _ref3)
    }, transitionRest, pick$1(rest, Object.keys(modalDialogPropTypes)), {
      ref: mergeRefs(dialogRef, transitionRef),
      classPrefix,
      className: merge2(classes, transitionClassName, prefix2({
        shake
      })),
      dialogClassName,
      dialogStyle
    }), children);
  }));
});
Modal$1.Body = ModalBody;
Modal$1.Header = ModalHeader;
Modal$1.Title = ModalTitle;
Modal$1.Footer = ModalFooter;
Modal$1.Dialog = ModalDialog;
Modal$1.displayName = "Modal";
Modal$1.propTypes = _extends$1({}, modalPropTypes, {
  animation: PropTypes.any,
  animationTimeout: PropTypes.number,
  classPrefix: PropTypes.string,
  dialogClassName: PropTypes.string,
  size: PropTypes.oneOfType([oneOf(modalSizes), PropTypes.number, PropTypes.string]),
  dialogStyle: PropTypes.object,
  dialogAs: PropTypes.elementType,
  full: deprecatePropType(PropTypes.bool, 'Use size="full" instead.'),
  overflow: PropTypes.bool
});
var MenuActionTypes = /* @__PURE__ */ function(MenuActionTypes2) {
  MenuActionTypes2[MenuActionTypes2["RegisterItem"] = 0] = "RegisterItem";
  MenuActionTypes2[MenuActionTypes2["UnregisterItem"] = 1] = "UnregisterItem";
  MenuActionTypes2[MenuActionTypes2["OpenMenu"] = 2] = "OpenMenu";
  MenuActionTypes2[MenuActionTypes2["CloseMenu"] = 3] = "CloseMenu";
  MenuActionTypes2[MenuActionTypes2["MoveFocus"] = 4] = "MoveFocus";
  return MenuActionTypes2;
}({});
var MoveFocusTo = /* @__PURE__ */ function(MoveFocusTo2) {
  MoveFocusTo2[MoveFocusTo2["Next"] = 0] = "Next";
  MoveFocusTo2[MoveFocusTo2["Prev"] = 1] = "Prev";
  MoveFocusTo2[MoveFocusTo2["Last"] = 2] = "Last";
  MoveFocusTo2[MoveFocusTo2["First"] = 3] = "First";
  MoveFocusTo2[MoveFocusTo2["Specific"] = 4] = "Specific";
  MoveFocusTo2[MoveFocusTo2["None"] = 5] = "None";
  return MoveFocusTo2;
}({});
var MenuContext = /* @__PURE__ */ React.createContext(null);
MenuContext.displayName = "MenuContext";
const MenuContext$1 = MenuContext;
var initialMenuState = {
  role: "menu",
  open: false,
  items: [],
  activeItemIndex: null
};
function menuReducer(state, action) {
  var items = state.items, activeItemIndex = state.activeItemIndex;
  switch (action.type) {
    case MenuActionTypes.RegisterItem:
      return _extends$1({}, state, {
        items: [].concat(items, [{
          element: action.element,
          props: action.props
        }])
      });
    case MenuActionTypes.UnregisterItem:
      return _extends$1({}, state, {
        items: items.filter(function(item) {
          return item.element.id !== action.id;
        })
      });
    case MenuActionTypes.OpenMenu:
      return _extends$1({}, state, {
        open: true
      });
    case MenuActionTypes.CloseMenu:
      return _extends$1({}, state, {
        open: false
      });
    case MenuActionTypes.MoveFocus:
      var nextActiveItemIndex = activeItemIndex;
      switch (action.to) {
        case MoveFocusTo.Next:
          for (var i2 = activeItemIndex === null ? 0 : activeItemIndex + 1; i2 < items.length; i2++) {
            var _items$i$props;
            if (!((_items$i$props = items[i2].props) !== null && _items$i$props !== void 0 && _items$i$props.disabled)) {
              nextActiveItemIndex = i2;
              break;
            }
          }
          break;
        case MoveFocusTo.Prev:
          for (var _i2 = activeItemIndex === null ? items.length - 1 : activeItemIndex - 1; _i2 >= 0; _i2--) {
            var _items$_i$props;
            if (!((_items$_i$props = items[_i2].props) !== null && _items$_i$props !== void 0 && _items$_i$props.disabled)) {
              nextActiveItemIndex = _i2;
              break;
            }
          }
          break;
        case MoveFocusTo.First:
          for (var _i22 = 0; _i22 < items.length; _i22++) {
            var _items$_i2$props;
            if (!((_items$_i2$props = items[_i22].props) !== null && _items$_i2$props !== void 0 && _items$_i2$props.disabled)) {
              nextActiveItemIndex = _i22;
              break;
            }
          }
          break;
        case MoveFocusTo.Last:
          for (var _i3 = items.length - 1; _i3 >= 0; _i3--) {
            var _items$_i3$props;
            if (!((_items$_i3$props = items[_i3].props) !== null && _items$_i3$props !== void 0 && _items$_i3$props.disabled)) {
              nextActiveItemIndex = _i3;
              break;
            }
          }
          break;
        case MoveFocusTo.Specific:
          for (var _i4 = 0; _i4 < items.length; _i4++) {
            var _items$_i4$props;
            if (items[_i4].element.id === action.id && !((_items$_i4$props = items[_i4].props) !== null && _items$_i4$props !== void 0 && _items$_i4$props.disabled)) {
              nextActiveItemIndex = _i4;
              break;
            }
          }
          break;
        case MoveFocusTo.None:
          nextActiveItemIndex = null;
          break;
      }
      return _extends$1({}, state, {
        activeItemIndex: nextActiveItemIndex
      });
    default:
      return state;
  }
}
function useMenu(initialState2) {
  var _useReducer = reactExports.useReducer(menuReducer, _extends$1({}, initialMenuState, initialState2)), state = _useReducer[0], dispatch = _useReducer[1];
  return [state, dispatch];
}
var defaultOpenMenuOn = ["click"];
function getMenuItemTarget(event) {
  var _event$currentTarget;
  var target = event.target;
  if (target.getAttribute("role") === "menuitem") {
    return target;
  }
  return Array.from((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : _event$currentTarget.querySelectorAll('[role="menuitem"]')).find(function(item) {
    return item.contains(target);
  });
}
function Menu$1(_ref) {
  var _items$activeItemInde;
  var disabled = _ref.disabled, children = _ref.children, _ref$openMenuOn = _ref.openMenuOn, openMenuOn = _ref$openMenuOn === void 0 ? defaultOpenMenuOn : _ref$openMenuOn, _ref$defaultOpen = _ref.defaultOpen, defaultOpen = _ref$defaultOpen === void 0 ? false : _ref$defaultOpen, openProp = _ref.open, menuButtonText = _ref.menuButtonText, renderMenuButton = _ref.renderMenuButton, renderMenuPopup = _ref.renderMenuPopup, onToggleMenu = _ref.onToggleMenu;
  var buttonElementRef = reactExports.useRef(null);
  var menuElementRef = reactExports.useRef(null);
  var parentMenu = reactExports.useContext(MenuContext$1);
  var isSubmenu = !!parentMenu;
  var menu = useMenu({
    open: defaultOpen
  });
  var _menu$ = menu[0], openState = _menu$.open, items = _menu$.items, activeItemIndex = _menu$.activeItemIndex, dispatch = menu[1];
  var openControlled = typeof openProp !== "undefined";
  var open = openControlled ? openProp : openState;
  var _useCustom = useCustom("Menu"), rtl = _useCustom.rtl;
  var activeItem = isNil$1(activeItemIndex) ? null : (_items$activeItemInde = items[activeItemIndex]) === null || _items$activeItemInde === void 0 ? void 0 : _items$activeItemInde.element;
  var _useFocus = useFocus(menuElementRef), grabFocus = _useFocus.grab;
  var openMenu = reactExports.useCallback(function(event) {
    dispatch({
      type: MenuActionTypes.OpenMenu
    });
    if (!event.isTrusted) {
      dispatch({
        type: MenuActionTypes.MoveFocus,
        to: MoveFocusTo.First
      });
    }
    onToggleMenu === null || onToggleMenu === void 0 ? void 0 : onToggleMenu(true, event);
    grabFocus();
  }, [dispatch, onToggleMenu, grabFocus]);
  var closeMenu = reactExports.useCallback(function(event, returnFocusToButton) {
    if (returnFocusToButton === void 0) {
      returnFocusToButton = true;
    }
    dispatch({
      type: MenuActionTypes.CloseMenu
    });
    dispatch({
      type: MenuActionTypes.MoveFocus,
      to: MoveFocusTo.None
    });
    onToggleMenu === null || onToggleMenu === void 0 ? void 0 : onToggleMenu(false, event);
    if (returnFocusToButton) {
      var _buttonElementRef$cur;
      (_buttonElementRef$cur = buttonElementRef.current) === null || _buttonElementRef$cur === void 0 ? void 0 : _buttonElementRef$cur.focus({
        preventScroll: true
      });
    }
  }, [dispatch, onToggleMenu, buttonElementRef]);
  var toggleMenu = reactExports.useCallback(function(event) {
    if (!open) {
      openMenu(event);
    } else {
      closeMenu(event);
    }
  }, [open, openMenu, closeMenu]);
  useClickOutside({
    enabled: open,
    isOutside: function isOutside(event) {
      var _buttonElementRef$cur2, _menuElementRef$curre;
      return !((_buttonElementRef$cur2 = buttonElementRef.current) !== null && _buttonElementRef$cur2 !== void 0 && _buttonElementRef$cur2.contains(event.target)) && !((_menuElementRef$curre = menuElementRef.current) !== null && _menuElementRef$curre !== void 0 && _menuElementRef$curre.contains(event.target));
    },
    // fixme if clicking on a focusable element, don't move focus to menu button
    handle: function handle(event) {
      return closeMenu(event, !isFocusableElement(event.target));
    }
  });
  var handleButtonKeydown = reactExports.useCallback(function(e3) {
    switch (e3.key) {
      case KEY_VALUES.ENTER:
      case KEY_VALUES.SPACE:
        e3.preventDefault();
        e3.stopPropagation();
        if (!open) {
          openMenu(e3);
          dispatch({
            type: MenuActionTypes.MoveFocus,
            to: MoveFocusTo.First
          });
        } else {
          closeMenu(e3);
        }
        break;
      case KEY_VALUES.DOWN:
        e3.preventDefault();
        e3.stopPropagation();
        if (!open) {
          openMenu(e3);
        }
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.First
        });
        break;
    }
  }, [open, openMenu, closeMenu, dispatch]);
  var handleButtonClick = reactExports.useCallback(function(event) {
    if (disabled) {
      return;
    }
    toggleMenu(event);
  }, [disabled, toggleMenu]);
  var handleButtonContextMenu = reactExports.useCallback(function(event) {
    event.preventDefault();
    if (open) return;
    if (disabled) return;
    openMenu(event);
  }, [open, disabled, openMenu]);
  var buttonEventHandlers = reactExports.useMemo(function() {
    var buttonEventHandlers2 = {
      onKeyDown: handleButtonKeydown
    };
    if (openMenuOn !== null && openMenuOn !== void 0 && openMenuOn.includes("click")) {
      buttonEventHandlers2.onClick = handleButtonClick;
    }
    if (openMenuOn !== null && openMenuOn !== void 0 && openMenuOn.includes("contextmenu")) {
      buttonEventHandlers2.onContextMenu = handleButtonContextMenu;
    }
    return buttonEventHandlers2;
  }, [openMenuOn, handleButtonKeydown, handleButtonClick, handleButtonContextMenu]);
  var buttonId = useUniqueId("menubutton-");
  var menuId = useUniqueId("menu-");
  var buttonAriaAttributes = reactExports.useMemo(function() {
    return {
      role: "button",
      "aria-haspopup": "menu",
      "aria-expanded": open || void 0,
      // it's recommend to remove aria-expanded when menu is hidden
      "aria-controls": menuId
    };
  }, [open, menuId]);
  var buttonProps = reactExports.useMemo(function() {
    return _extends$1({
      id: buttonId
    }, buttonAriaAttributes, buttonEventHandlers, {
      // render props
      open
    });
  }, [buttonId, buttonAriaAttributes, buttonEventHandlers, open]);
  var customMenuButton = reactExports.useMemo(function() {
    return renderMenuButton === null || renderMenuButton === void 0 ? void 0 : renderMenuButton(buttonProps, buttonElementRef);
  }, [renderMenuButton, buttonProps, buttonElementRef]);
  var buttonElement = customMenuButton !== null && customMenuButton !== void 0 ? customMenuButton : /* @__PURE__ */ React.createElement("button", _extends$1({
    ref: buttonElementRef
  }, buttonProps), menuButtonText);
  var handleMenuKeydown = reactExports.useCallback(function(e3) {
    switch (e3.key) {
      case KEY_VALUES.UP:
        e3.preventDefault();
        e3.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.Prev
        });
        break;
      case KEY_VALUES.DOWN:
        e3.preventDefault();
        e3.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.Next
        });
        break;
      case KEY_VALUES.RIGHT:
        e3.preventDefault();
        e3.stopPropagation();
        if (!rtl) {
          if ((activeItem === null || activeItem === void 0 ? void 0 : activeItem.getAttribute("aria-haspopup")) === "menu") {
            activeItem.click();
          }
        } else if (isSubmenu) {
          dispatch({
            type: MenuActionTypes.CloseMenu
          });
        }
        break;
      case KEY_VALUES.LEFT:
        e3.preventDefault();
        e3.stopPropagation();
        if (!rtl) {
          if (isSubmenu) {
            closeMenu(e3);
          }
        } else if ((activeItem === null || activeItem === void 0 ? void 0 : activeItem.getAttribute("aria-haspopup")) === "menu") {
          activeItem.click();
        }
        break;
      case KEY_VALUES.HOME:
        e3.preventDefault();
        e3.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.First
        });
        break;
      case KEY_VALUES.END:
        e3.preventDefault();
        e3.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.Last
        });
        break;
      case KEY_VALUES.ENTER:
      case KEY_VALUES.SPACE:
        if (activeItem) {
          e3.preventDefault();
          e3.stopPropagation();
          activeItem.click();
          if (!activeItem.getAttribute("aria-haspopup")) {
            closeMenu(e3);
          }
        }
        break;
      case KEY_VALUES.ESC:
        closeMenu(e3);
        break;
    }
  }, [dispatch, activeItem, isSubmenu, rtl, closeMenu]);
  var handleMenuClick = reactExports.useCallback(function(event) {
    var target = getMenuItemTarget(event);
    if (!target) return;
    if (target.getAttribute("role") !== "menuitem") return;
    if (target.getAttribute("aria-haspopup") === "menu") return;
    if (target.getAttribute("aria-disabled") === "true") return;
    closeMenu(event, !isSubmenu);
  }, [closeMenu, isSubmenu]);
  var menuAriaAttributes = {
    role: "menu",
    "aria-labelledby": buttonId,
    "aria-activedescendant": activeItem === null || activeItem === void 0 ? void 0 : activeItem.id
  };
  var menuEventHandlers = {
    onClick: handleMenuClick,
    onKeyDown: handleMenuKeydown
  };
  var menuProps = _extends$1({
    id: menuId
  }, menuAriaAttributes, menuEventHandlers, {
    tabIndex: 0
  });
  var customMenuPopup = renderMenuPopup === null || renderMenuPopup === void 0 ? void 0 : renderMenuPopup(_extends$1({}, menuProps, {
    open
  }), menuElementRef);
  var menuElement = customMenuPopup !== null && customMenuPopup !== void 0 ? customMenuPopup : /* @__PURE__ */ React.createElement("ul", _extends$1({
    ref: menuElementRef
  }, menuProps, {
    hidden: !open
  }), children);
  var handleMouseEnter = reactExports.useCallback(function(e3) {
    if (!disabled) {
      openMenu(e3);
    }
  }, [disabled, openMenu]);
  var handleMouseLeave = reactExports.useCallback(function(e3) {
    if (!disabled) {
      closeMenu(e3);
    }
  }, [disabled, closeMenu]);
  var rootElementRef = reactExports.useRef(null);
  var handleContainerBlur = reactExports.useCallback(function(event) {
    if (isFocusLeaving(event)) {
      closeMenu(event, false);
    }
  }, [closeMenu]);
  var rootEventHandlers = {
    onBlur: handleContainerBlur
  };
  if (openMenuOn !== null && openMenuOn !== void 0 && openMenuOn.includes("mouseover")) {
    rootEventHandlers.onMouseEnter = handleMouseEnter;
    rootEventHandlers.onMouseLeave = handleMouseLeave;
  }
  var rootProps = _extends$1({}, rootEventHandlers, {
    children: /* @__PURE__ */ React.createElement(React.Fragment, null, buttonElement, /* @__PURE__ */ React.createElement(MenuContext$1.Provider, {
      value: menu
    }, menuElement)),
    // render props
    open
  });
  if (isSubmenu) {
    rootProps.role = "none presentation";
  }
  return children(rootProps, rootElementRef);
}
Menu$1.displayName = "Menu";
Menu$1.propTypes = {
  children: PropTypes.func.isRequired
};
function MenuItem$1(props) {
  var _menuState$items$menu;
  var children = props.children, _props$selected = props.selected, selected = _props$selected === void 0 ? false : _props$selected, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? false : _props$disabled, onActivate = props.onActivate;
  var menuitemRef = reactExports.useRef(null);
  var menuitemId = useUniqueId("menuitem-");
  var menu = reactExports.useContext(MenuContext$1);
  if (!menu) {
    throw new Error("<MenuItem> must be rendered within a <Menu>");
  }
  var menuState = menu[0], dispatch = menu[1];
  var hasFocus = !isNil$1(menuitemRef.current) && !isNil$1(menuState.activeItemIndex) && ((_menuState$items$menu = menuState.items[menuState.activeItemIndex]) === null || _menuState$items$menu === void 0 ? void 0 : _menuState$items$menu.element) === menuitemRef.current;
  var handleClick = reactExports.useCallback(function(event) {
    if (disabled) {
      return;
    }
    onActivate === null || onActivate === void 0 ? void 0 : onActivate(event);
  }, [disabled, onActivate]);
  var handleMouseDown = reactExports.useCallback(function() {
    if (!isNil$1(menuitemRef.current) && !hasFocus) {
      dispatch({
        type: MenuActionTypes.MoveFocus,
        to: MoveFocusTo.Specific,
        id: menuitemRef.current.id
      });
    }
  }, [dispatch, hasFocus]);
  var handleMouseMove = reactExports.useCallback(function() {
    if (!isNil$1(menuitemRef.current) && !hasFocus) {
      dispatch({
        type: MenuActionTypes.MoveFocus,
        to: MoveFocusTo.Specific,
        id: menuitemRef.current.id
      });
    }
  }, [hasFocus, dispatch]);
  var handleMouseLeave = reactExports.useCallback(function() {
    dispatch({
      type: MenuActionTypes.MoveFocus,
      to: MoveFocusTo.None
    });
  }, [dispatch]);
  reactExports.useEffect(function() {
    var menuitemElement = menuitemRef.current;
    if (menuitemElement) {
      dispatch({
        type: MenuActionTypes.RegisterItem,
        element: menuitemElement,
        props: {
          disabled
        }
      });
      return function() {
        dispatch({
          type: MenuActionTypes.UnregisterItem,
          id: menuitemElement.id
        });
      };
    }
  }, [menuitemRef, disabled, dispatch]);
  var menuitemProps = {
    id: menuitemId,
    role: "menuitem",
    // fixme Only use `aria-checked` on menuitemradio and menuitemcheckbox
    "aria-checked": selected || void 0,
    "aria-disabled": disabled,
    tabIndex: -1,
    onClick: handleClick,
    // render props
    selected,
    active: hasFocus
  };
  if ((menuState === null || menuState === void 0 ? void 0 : menuState.role) === "menu") {
    menuitemProps.onMouseMove = handleMouseMove;
    menuitemProps.onMouseLeave = handleMouseLeave;
  }
  if ((menuState === null || menuState === void 0 ? void 0 : menuState.role) === "menubar") {
    menuitemProps.onMouseDown = handleMouseDown;
    menuitemProps.onMouseOver = handleMouseMove;
    menuitemProps.onMouseLeave = handleMouseLeave;
  }
  return children(menuitemProps, menuitemRef);
}
MenuItem$1.displayName = "MenuItem";
MenuItem$1.propTypes = {
  selected: PropTypes.bool,
  disabled: PropTypes.bool,
  children: PropTypes.func.isRequired,
  onActivate: PropTypes.func
};
function Menubar(_ref) {
  var _items$activeItemInde3;
  var _ref$vertical = _ref.vertical, vertical = _ref$vertical === void 0 ? false : _ref$vertical, children = _ref.children, onActivateItem = _ref.onActivateItem;
  var menubar = useMenu({
    role: "menubar"
  });
  var _menubar$ = menubar[0], items = _menubar$.items, activeItemIndex = _menubar$.activeItemIndex, dispatch = menubar[1];
  var menubarElementRef = reactExports.useRef(null);
  var onFocus = reactExports.useCallback(function(event) {
    if (isFocusEntering(event) && // Skip if focus is moving to a focusable element within this menu
    !(event.target !== event.currentTarget && isFocusableElement(event.target))) {
      if (activeItemIndex === null) {
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.First
        });
      }
    }
  }, [activeItemIndex, dispatch]);
  var onBlur = reactExports.useCallback(function(event) {
    if (isFocusLeaving(event)) {
      dispatch({
        type: MenuActionTypes.MoveFocus,
        to: MoveFocusTo.None
      });
    }
  }, [dispatch]);
  var _useCustom = useCustom("Menubar"), rtl = _useCustom.rtl;
  var onKeyDown = reactExports.useCallback(function(event) {
    var _items$activeItemInde, _items$activeItemInde2;
    var activeItemElement = isNil$1(activeItemIndex) ? null : (_items$activeItemInde = (_items$activeItemInde2 = items[activeItemIndex]) === null || _items$activeItemInde2 === void 0 ? void 0 : _items$activeItemInde2.element) !== null && _items$activeItemInde !== void 0 ? _items$activeItemInde : null;
    switch (true) {
      case (!vertical && !rtl && event.key === KEY_VALUES.RIGHT):
      case (!vertical && rtl && event.key === KEY_VALUES.LEFT):
      case (vertical && event.key === KEY_VALUES.DOWN):
        event.preventDefault();
        event.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.Next
        });
        break;
      case (!vertical && !rtl && event.key === KEY_VALUES.LEFT):
      case (!vertical && rtl && event.key === KEY_VALUES.RIGHT):
      case (vertical && event.key === KEY_VALUES.UP):
        event.preventDefault();
        event.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.Prev
        });
        break;
      case event.key === KEY_VALUES.HOME:
        event.preventDefault();
        event.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.First
        });
        break;
      case event.key === KEY_VALUES.END:
        event.preventDefault();
        event.stopPropagation();
        dispatch({
          type: MenuActionTypes.MoveFocus,
          to: MoveFocusTo.Last
        });
        break;
      case (!vertical && event.key === KEY_VALUES.DOWN):
      case (vertical && !rtl && event.key === KEY_VALUES.RIGHT):
      case (vertical && rtl && event.key === KEY_VALUES.LEFT):
        if ((activeItemElement === null || activeItemElement === void 0 ? void 0 : activeItemElement.getAttribute("aria-haspopup")) === "menu") {
          event.preventDefault();
          event.stopPropagation();
          activeItemElement.click();
        }
        break;
      case event.key === KEY_VALUES.ENTER:
      case event.key === KEY_VALUES.SPACE:
        event.preventDefault();
        event.stopPropagation();
        activeItemElement === null || activeItemElement === void 0 ? void 0 : activeItemElement.click();
        break;
    }
  }, [rtl, items, activeItemIndex, dispatch, vertical]);
  var onClick = reactExports.useCallback(function(event) {
    if (items.some(function(item) {
      return item.element === event.target;
    })) {
      onActivateItem === null || onActivateItem === void 0 ? void 0 : onActivateItem(event);
    }
  }, [items, onActivateItem]);
  return /* @__PURE__ */ React.createElement(MenuContext$1.Provider, {
    value: menubar
  }, children({
    role: "menubar",
    tabIndex: 0,
    onFocus,
    onBlur,
    onKeyDown,
    onClick,
    "aria-activedescendant": isNil$1(activeItemIndex) ? void 0 : (_items$activeItemInde3 = items[activeItemIndex]) === null || _items$activeItemInde3 === void 0 ? void 0 : _items$activeItemInde3.element.id,
    "aria-orientation": vertical ? "vertical" : void 0
    // implicitly set 'horizontal'
  }, menubarElementRef));
}
var NavbarBody = createComponent({
  name: "NavbarBody"
});
const NavbarBody$1 = deprecateComponent(NavbarBody, "<Navbar.Body> has been deprecated, you should <Nav> as direct child of <Navbar>");
var NavbarHeader = createComponent({
  name: "NavbarHeader"
});
const NavbarHeader$1 = deprecateComponent(NavbarHeader, "<Navbar.Header> has been deprecated, use <Navbar.Brand> instead.");
var NavbarBrand = createComponent({
  name: "NavbarBrand",
  componentAs: "a",
  componentClassPrefix: "navbar-brand"
});
var _excluded$1R = ["className", "as", "classPrefix", "appearance"];
var NavbarContext = /* @__PURE__ */ React.createContext(false);
var Navbar = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, _props$as = props.as, Component = _props$as === void 0 ? "nav" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "navbar" : _props$classPrefix, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "default" : _props$appearance, rest = _objectWithoutPropertiesLoose(props, _excluded$1R);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix(appearance));
  return /* @__PURE__ */ React.createElement(NavbarContext.Provider, {
    value: true
  }, /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  })));
});
Navbar.Header = NavbarHeader$1;
Navbar.Body = NavbarBody$1;
Navbar.Brand = NavbarBrand;
Navbar.displayName = "Navbar";
var baseUnset = _baseUnset, isIndex = _isIndex;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function basePullAt$1(array, indexes) {
  var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
  while (length2--) {
    var index = indexes[length2];
    if (length2 == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}
var _basePullAt = basePullAt$1;
var baseIteratee$2 = _baseIteratee, basePullAt = _basePullAt;
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1, indexes = [], length2 = array.length;
  predicate = baseIteratee$2(predicate);
  while (++index < length2) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}
var remove_1 = remove;
const remove$1 = /* @__PURE__ */ getDefaultExportFromCjs(remove_1);
var SidenavBody = createComponent({
  name: "SidenavBody"
});
var SidenavHeader = createComponent({
  name: "SidenavHeader"
});
var _excluded$1Q = ["as", "expanded", "className", "classPrefix", "onToggle"];
var SidenavToggle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  if (!sidenav) {
    throw new Error("<Sidenav.Toggle> must be rendered within a <Sidenav>");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, DEPRECATED_expanded = props.expanded, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "sidenav-toggle" : _props$classPrefix, onToggle = props.onToggle, rest = _objectWithoutPropertiesLoose(props, _excluded$1Q);
  var expanded = DEPRECATED_expanded !== null && DEPRECATED_expanded !== void 0 ? DEPRECATED_expanded : sidenav.expanded;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix({
    collapsed: !expanded
  }));
  var Icon2 = expanded ? AngleLeftIcon : AngleRightIcon;
  var handleToggle = function handleToggle2(event) {
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(!expanded, event);
  };
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), /* @__PURE__ */ React.createElement(IconButton$1, {
    icon: /* @__PURE__ */ React.createElement(Icon2, null),
    className: prefix2("button"),
    onClick: handleToggle,
    "aria-label": expanded ? "Collapse" : "Expand"
  }));
});
SidenavToggle.displayName = "Sidenav.Toggle";
SidenavToggle.propTypes = {
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  expanded: deprecatePropType(PropTypes.bool, "Use <Sidenav expanded> instead."),
  onToggle: PropTypes.func
};
var _excluded$1P = ["as", "className", "classPrefix", "appearance", "expanded", "activeKey", "defaultOpenKeys", "openKeys", "onSelect", "onOpenChange"], _excluded2$j = ["className"];
var SidenavContext = /* @__PURE__ */ React.createContext(null);
var emptyArray$1 = [];
var Sidenav = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "nav" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "sidenav" : _props$classPrefix, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "default" : _props$appearance, _props$expanded = props.expanded, expanded = _props$expanded === void 0 ? true : _props$expanded, activeKey = props.activeKey, _props$defaultOpenKey = props.defaultOpenKeys, defaultOpenKeys = _props$defaultOpenKey === void 0 ? emptyArray$1 : _props$defaultOpenKey, openKeysProp = props.openKeys, onSelect = props.onSelect, onOpenChange = props.onOpenChange, rest = _objectWithoutPropertiesLoose(props, _excluded$1P);
  var _useControlled = useControlled$2(openKeysProp, defaultOpenKeys), openKeys = _useControlled[0], setOpenKeys = _useControlled[1];
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, withClassPrefix(appearance));
  var handleOpenChange = reactExports.useCallback(function(eventKey, event) {
    var find2 = function find3(key) {
      return shallowEqual(key, eventKey);
    };
    var nextOpenKeys = [].concat(openKeys);
    if (nextOpenKeys.some(find2)) {
      remove$1(nextOpenKeys, find2);
    } else {
      nextOpenKeys.push(eventKey);
    }
    setOpenKeys(nextOpenKeys);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpenKeys, event);
  }, [onOpenChange, openKeys, setOpenKeys]);
  var contextValue = reactExports.useMemo(function() {
    return {
      expanded,
      activeKey,
      sidenav: true,
      openKeys: openKeys !== null && openKeys !== void 0 ? openKeys : [],
      onOpenChange: handleOpenChange,
      onSelect
    };
  }, [activeKey, expanded, handleOpenChange, onSelect, openKeys]);
  return /* @__PURE__ */ React.createElement(SidenavContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Transition$1, {
    in: expanded,
    timeout: 300,
    exitedClassName: prefix2("collapse-out"),
    exitingClassName: prefix2("collapse-out", "collapsing"),
    enteredClassName: prefix2("collapse-in"),
    enteringClassName: prefix2("collapse-in", "collapsing")
  }, function(transitionProps, transitionRef) {
    var className2 = transitionProps.className, transitionRest = _objectWithoutPropertiesLoose(transitionProps, _excluded2$j);
    return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, transitionRest, {
      ref: mergeRefs(ref, transitionRef),
      className: merge2(classes, className2)
    }));
  }));
});
Sidenav.Header = SidenavHeader;
Sidenav.Body = SidenavBody;
Sidenav.Toggle = SidenavToggle;
Sidenav.displayName = "Sidenav";
Sidenav.propTypes = {
  as: PropTypes.elementType,
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  expanded: PropTypes.bool,
  appearance: oneOf(["default", "inverse", "subtle"]),
  defaultOpenKeys: PropTypes.array,
  openKeys: PropTypes.array,
  onOpenChange: PropTypes.func,
  activeKey: deprecatePropType(PropTypes.any, "Use `activeKey` on <Nav> component instead"),
  onSelect: deprecatePropType(PropTypes.func, "Use `onSelect` on <Nav> component instead")
};
var NavContext = /* @__PURE__ */ React.createContext(null);
var initialState = {
  items: []
};
var DropdownActionType = /* @__PURE__ */ function(DropdownActionType2) {
  DropdownActionType2[DropdownActionType2["RegisterItem"] = 0] = "RegisterItem";
  DropdownActionType2[DropdownActionType2["UnregisterItem"] = 1] = "UnregisterItem";
  DropdownActionType2[DropdownActionType2["UpdateItem"] = 2] = "UpdateItem";
  return DropdownActionType2;
}({});
function reducer$1(state, action) {
  if (state === void 0) {
    state = initialState;
  }
  switch (action.type) {
    case DropdownActionType.RegisterItem:
      if (state.items.find(function(item) {
        return item.id === action.payload.id;
      })) {
        return _extends$1({}, state, {
          items: state.items.map(function(item) {
            if (item.id === action.payload.id) {
              return _extends$1({}, item, {
                props: _extends$1({}, item.props, {
                  selected: action.payload.props.selected
                })
              });
            }
            return item;
          })
        });
      }
      return _extends$1({}, state, {
        items: [].concat(state.items, [{
          id: action.payload.id,
          props: action.payload.props
        }])
      });
    case DropdownActionType.UnregisterItem:
      return _extends$1({}, state, {
        items: state.items.filter(function(item) {
          return item.id !== action.payload.id;
        })
      });
    default:
      return state;
  }
}
function useRenderDropdownItem(Component) {
  return reactExports.useCallback(function(props, OverrideComponent) {
    if (Component === "li") {
      if (OverrideComponent) {
        return /* @__PURE__ */ React.createElement("li", {
          role: "none presentation"
        }, /* @__PURE__ */ React.createElement(OverrideComponent, props));
      }
      return /* @__PURE__ */ React.createElement(Component, props);
    }
    return /* @__PURE__ */ React.createElement("li", {
      role: "none presentation"
    }, /* @__PURE__ */ React.createElement(Component, props));
  }, [Component]);
}
var _excluded$1O = ["classPrefix", "className", "active", "eventKey", "onSelect", "icon", "as", "divider", "panel", "children", "disabled"], _excluded2$i = ["selected", "active"];
var NavDropdownItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var nav = reactExports.useContext(NavContext);
  if (!nav) {
    throw new Error("<Nav.Dropdown.Item> should be used within a <Nav> component.");
  }
  var _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-item" : _props$classPrefix, className = props.className, activeProp = props.active, eventKey = props.eventKey, onSelect = props.onSelect, icon = props.icon, _props$as = props.as, Component = _props$as === void 0 ? "li" : _props$as, divider = props.divider, panel = props.panel, children = props.children, disabled = props.disabled, restProps = _objectWithoutPropertiesLoose(props, _excluded$1O);
  var activeKey = nav.activeKey, onSelectFromNav = nav.onSelect;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var selected = activeProp || !isNil$1(eventKey) && shallowEqual(activeKey, eventKey);
  var handleSelectItem = reactExports.useCallback(function(event) {
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
    onSelectFromNav === null || onSelectFromNav === void 0 ? void 0 : onSelectFromNav(eventKey, event);
  }, [onSelect, eventKey, onSelectFromNav]);
  var renderDropdownItem = useRenderDropdownItem(Component);
  if (divider) {
    return renderDropdownItem(_extends$1({
      ref,
      role: "separator",
      className: merge2(prefix2("divider"), className)
    }, restProps));
  }
  if (panel) {
    return renderDropdownItem(_extends$1({
      ref,
      className: merge2(prefix2("panel"), className),
      children
    }, restProps));
  }
  return /* @__PURE__ */ React.createElement(MenuItem$1, {
    selected,
    disabled,
    onActivate: handleSelectItem
  }, function(_ref, menuitemRef) {
    var selected2 = _ref.selected, active = _ref.active, menuitem = _objectWithoutPropertiesLoose(_ref, _excluded2$i);
    var classes = merge2(className, withClassPrefix({
      "with-icon": icon,
      active: selected2,
      disabled,
      focus: active,
      divider,
      panel
    }));
    var dataAttributes = {
      "data-event-key": eventKey
    };
    if (!isNil$1(eventKey) && typeof eventKey !== "string") {
      dataAttributes["data-event-key-type"] = typeof eventKey;
    }
    return renderDropdownItem(_extends$1({
      ref: mergeRefs(ref, menuitemRef),
      className: classes
    }, menuitem, dataAttributes, restProps, {
      children: /* @__PURE__ */ React.createElement(React.Fragment, null, icon && /* @__PURE__ */ React.cloneElement(icon, {
        className: classNames(prefix2("menu-icon"), icon.props.className)
      }), children)
    }));
  });
});
NavDropdownItem.displayName = "Nav.Dropdown.Item";
NavDropdownItem.propTypes = {
  as: PropTypes.elementType,
  divider: PropTypes.bool,
  panel: PropTypes.bool,
  trigger: PropTypes.oneOfType([PropTypes.array, oneOf(["click", "hover"])]),
  open: deprecatePropType(PropTypes.bool),
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  pullLeft: deprecatePropType(PropTypes.bool),
  onSelect: PropTypes.func,
  onClick: PropTypes.func,
  icon: PropTypes.node,
  eventKey: PropTypes.any,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  tabIndex: PropTypes.number
};
var _templateObject$d, _templateObject2$7;
var _excluded$1N = ["onToggle", "eventKey", "title", "classPrefix", "children", "openDirection", "noCaret"], _excluded2$h = ["icon", "className", "disabled"], _excluded3$7 = ["open"], _excluded4$3 = ["selected", "active"], _excluded5$1 = ["open"], _excluded6$1 = ["open"];
var NavDropdownMenu = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var nav = reactExports.useContext(NavContext);
  if (!nav) {
    throw new Error("<Nav.Dropdown.Menu> should be used within a <Nav> component.");
  }
  var onToggle = props.onToggle, eventKey = props.eventKey, title = props.title, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-menu" : _props$classPrefix, children = props.children, _props$openDirection = props.openDirection, openDirection = _props$openDirection === void 0 ? "end" : _props$openDirection, noCaret = props.noCaret, rest = _objectWithoutPropertiesLoose(props, _excluded$1N);
  var _useCustom = useCustom("DropdownMenu"), rtl = _useCustom.rtl;
  var handleToggleSubmenu = reactExports.useCallback(function(open, event) {
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(open, eventKey, event);
  }, [eventKey, onToggle]);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix;
  var _useClassNames2 = useClassNames$2("dropdown-menu"), withMenuClassPrefix = _useClassNames2.withClassPrefix, mergeMenuClassName = _useClassNames2.merge;
  var _useClassNames3 = useClassNames$2("dropdown-item"), mergeItemClassNames = _useClassNames3.merge, withItemClassPrefix = _useClassNames3.withClassPrefix, prefixItemClassName = _useClassNames3.prefix;
  var _omit = omit$1(rest, ["trigger"]), icon = _omit.icon, className = _omit.className, disabled = _omit.disabled, menuProps = _objectWithoutPropertiesLoose(_omit, _excluded2$h);
  var Icon2 = rtl ? AngleLeftIcon : AngleRightIcon;
  return /* @__PURE__ */ React.createElement(Menu$1, {
    openMenuOn: ["mouseover", "click"],
    renderMenuButton: function renderMenuButton(_ref, buttonRef) {
      var open = _ref.open, menuButtonProps = _objectWithoutPropertiesLoose(_ref, _excluded3$7);
      return /* @__PURE__ */ React.createElement(MenuItem$1, {
        disabled
      }, function(_ref2, menuitemRef) {
        var selected = _ref2.selected, active = _ref2.active, menuitem = _objectWithoutPropertiesLoose(_ref2, _excluded4$3);
        var classes = mergeItemClassNames(className, prefixItemClassName(_templateObject$d || (_templateObject$d = _taggedTemplateLiteralLoose(["toggle"]))), withItemClassPrefix({
          "with-icon": icon,
          open,
          active: selected,
          disabled,
          focus: active
        }));
        return /* @__PURE__ */ React.createElement("div", _extends$1({
          ref: mergeRefs(buttonRef, menuitemRef),
          className: classes,
          "data-event-key": eventKey,
          "data-event-key-type": typeof eventKey
        }, menuitem, omit$1(menuButtonProps, ["role"])), icon && /* @__PURE__ */ React.cloneElement(icon, {
          className: prefix2("menu-icon")
        }), title, !noCaret && /* @__PURE__ */ React.createElement(Icon2, {
          className: prefix2(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteralLoose(["toggle-icon"])))
        }));
      });
    },
    renderMenuPopup: function renderMenuPopup(_ref3, popupRef) {
      var open = _ref3.open, popupProps = _objectWithoutPropertiesLoose(_ref3, _excluded5$1);
      var menuClassName = mergeMenuClassName(className, withMenuClassPrefix());
      return /* @__PURE__ */ React.createElement("ul", _extends$1({
        ref: popupRef,
        className: menuClassName,
        hidden: !open,
        "data-direction": openDirection
      }, popupProps, menuProps), children);
    },
    onToggleMenu: handleToggleSubmenu
  }, function(_ref4, menuContainerRef) {
    var open = _ref4.open, menuContainer = _objectWithoutPropertiesLoose(_ref4, _excluded6$1);
    var classes = mergeItemClassNames(className, withItemClassPrefix({
      disabled,
      open,
      submenu: true
    }));
    return /* @__PURE__ */ React.createElement("li", _extends$1({
      ref: mergeRefs(ref, menuContainerRef),
      className: classes
    }, menuContainer));
  });
});
NavDropdownMenu.displayName = "Nav.Dropdown.Menu";
NavDropdownMenu.propTypes = {
  active: PropTypes.bool,
  className: PropTypes.string,
  children: PropTypes.node,
  icon: PropTypes.any,
  classPrefix: PropTypes.string,
  pullLeft: deprecatePropType(PropTypes.bool, 'Use openDirection="start" instead.'),
  openDirection: oneOf(["start", "end"]),
  noCaret: PropTypes.bool,
  title: PropTypes.node,
  open: PropTypes.bool,
  eventKey: PropTypes.any,
  expanded: PropTypes.bool,
  collapsible: PropTypes.bool,
  onToggle: PropTypes.func
};
var ArrowDownLine$2 = {};
var ArrowDownLine$1 = { exports: {} };
var ArrowDownLine = {};
var hasRequiredArrowDownLine;
function requireArrowDownLine() {
  if (hasRequiredArrowDownLine) return ArrowDownLine;
  hasRequiredArrowDownLine = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function ArrowDownLine2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 16 16",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M8 11a.997.997 0 01-.707-.293l-3-3a.999.999 0 111.414-1.414L8 8.586l2.293-2.293a.999.999 0 111.414 1.414l-3 3A.997.997 0 018 11z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(ArrowDownLine2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(ArrowDownLine);
  return ArrowDownLine;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _ArrowDownLine = _interopRequireDefault2(requireArrowDownLine());
  var ArrowDownLine2 = (0, _createSvgIcon2["default"])({
    as: _ArrowDownLine["default"],
    ariaLabel: "arrow down line",
    category: "direction",
    displayName: "ArrowDownLine"
  });
  var _default = ArrowDownLine2;
  exports["default"] = _default;
  module.exports = exports.default;
})(ArrowDownLine$1, ArrowDownLine$1.exports);
var ArrowDownLineExports = ArrowDownLine$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _ArrowDownLine["default"];
    }
  });
  var _ArrowDownLine = _interopRequireDefault2(ArrowDownLineExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(ArrowDownLine$2);
const ArrowDownLineIcon = /* @__PURE__ */ getDefaultExportFromCjs(ArrowDownLine$2);
var _excluded$1M = ["as", "active", "disabled", "eventKey", "className", "classPrefix", "style", "children", "icon", "divider", "panel", "onClick", "onSelect"];
var NavItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var nav = reactExports.useContext(NavContext);
  if (!nav) {
    throw new Error("<Nav.Item> must be rendered within a <Nav> component.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? SafeAnchor : _props$as, activeProp = props.active, disabled = props.disabled, eventKey = props.eventKey, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "nav-item" : _props$classPrefix, style2 = props.style, children = props.children, icon = props.icon, divider = props.divider, panel = props.panel, onClick = props.onClick, onSelectProp = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$1M);
  var activeKey = nav.activeKey, onSelectFromNav = nav.onSelect;
  var active = activeProp !== null && activeProp !== void 0 ? activeProp : !isNil$1(eventKey) && shallowEqual(eventKey, activeKey);
  var emitSelect = reactExports.useCallback(function(event) {
    onSelectProp === null || onSelectProp === void 0 ? void 0 : onSelectProp(eventKey, event);
    onSelectFromNav === null || onSelectFromNav === void 0 ? void 0 : onSelectFromNav(eventKey, event);
  }, [eventKey, onSelectProp, onSelectFromNav]);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix({
    active,
    disabled
  }));
  var handleClick = reactExports.useCallback(function(event) {
    if (!disabled) {
      emitSelect(event);
      onClick === null || onClick === void 0 ? void 0 : onClick(event);
    }
  }, [disabled, emitSelect, onClick]);
  if (divider) {
    return /* @__PURE__ */ React.createElement("div", _extends$1({
      ref,
      role: "separator",
      style: style2,
      className: merge2(className, prefix2("divider"))
    }, rest));
  }
  if (panel) {
    return /* @__PURE__ */ React.createElement("div", _extends$1({
      ref,
      style: style2,
      className: merge2(className, prefix2("panel"))
    }, rest), children);
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    tabIndex: disabled ? -1 : void 0
  }, rest, {
    className: classes,
    onClick: handleClick,
    style: style2,
    "aria-selected": active || void 0
  }), icon && /* @__PURE__ */ React.cloneElement(icon, {
    className: classNames(prefix2("icon"), icon.props.className)
  }), children, /* @__PURE__ */ React.createElement(Ripple$1, null));
});
NavItem.displayName = "Nav.Item";
NavItem.propTypes = {
  as: PropTypes.elementType,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  divider: PropTypes.bool,
  panel: PropTypes.bool,
  onClick: PropTypes.func,
  style: PropTypes.object,
  icon: PropTypes.node,
  onSelect: PropTypes.func,
  children: PropTypes.node,
  eventKey: PropTypes.any
};
var _excluded$1L = ["as", "className", "classPrefix", "renderToggle", "children", "noCaret"];
var NavDropdownToggle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? NavItem : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-toggle" : _props$classPrefix, renderToggle = props.renderToggle, children = props.children, noCaret = props.noCaret, rest = _objectWithoutPropertiesLoose(props, _excluded$1L);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var _useClassNames2 = useClassNames$2("nav-item"), prefixNavItem = _useClassNames2.prefix;
  var classes = merge2(className, withClassPrefix({
    "no-caret": noCaret
  }));
  var toggle = /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), children, !noCaret && /* @__PURE__ */ React.createElement(ArrowDownLineIcon, {
    className: prefixNavItem("caret")
  }));
  return renderToggle ? renderToggle(rest, ref) : toggle;
});
NavDropdownToggle.displayName = "Nav.Dropdown.Toggle";
NavDropdownToggle.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  noCaret: PropTypes.bool,
  as: PropTypes.elementType,
  renderToggle: PropTypes.func,
  placement: oneOf(["bottomStart", "bottomEnd", "topStart", "topEnd", "leftStart", "rightStart", "leftEnd", "rightEnd"])
};
var _excluded$1K = ["as", "title", "onClose", "onOpen", "onToggle", "eventKey", "trigger", "placement", "toggleAs", "toggleClassName", "classPrefix", "className", "disabled", "children", "menuStyle", "style"], _excluded2$g = ["open"], _excluded3$6 = ["open"];
var NavDropdown = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var nav = reactExports.useContext(NavContext);
  if (!nav) {
    throw new Error("<Nav.Dropdown> must be rendered within a <Nav> component.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, title = props.title, onClose = props.onClose, onOpen = props.onOpen, onToggle = props.onToggle, eventKey = props.eventKey, _props$trigger = props.trigger, trigger2 = _props$trigger === void 0 ? "click" : _props$trigger, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, toggleAs = props.toggleAs, toggleClassName = props.toggleClassName, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown" : _props$classPrefix, className = props.className, disabled = props.disabled, children = props.children, menuStyle = props.menuStyle, style2 = props.style, toggleProps = _objectWithoutPropertiesLoose(props, _excluded$1K);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var _useClassNames2 = useClassNames$2("dropdown-menu"), withMenuClassPrefix = _useClassNames2.withClassPrefix, mergeMenuClassName = _useClassNames2.merge;
  var menuButtonTriggers = reactExports.useMemo(function() {
    if (!trigger2) {
      return void 0;
    }
    var triggerMap = {
      hover: "mouseover",
      click: "click",
      contextMenu: "contextmenu"
    };
    if (!Array.isArray(trigger2)) {
      return [triggerMap[trigger2]];
    }
    return trigger2.map(function(t3) {
      return triggerMap[t3];
    });
  }, [trigger2]);
  var _useReducer = reactExports.useReducer(reducer$1, initialState), items = _useReducer[0].items;
  var hasSelectedItem = reactExports.useMemo(function() {
    return items.some(function(item) {
      return item.props.selected;
    });
  }, [items]);
  var renderMenuButton = function renderMenuButton2(menuButtonProps, menuButtonRef) {
    return /* @__PURE__ */ React.createElement(NavDropdownToggle, _extends$1({
      ref: menuButtonRef,
      as: toggleAs,
      className: toggleClassName,
      placement,
      disabled
    }, omit$1(menuButtonProps, ["open"]), omit$1(toggleProps, ["data-testid"])), title);
  };
  return /* @__PURE__ */ React.createElement(Menu$1, {
    renderMenuButton,
    openMenuOn: menuButtonTriggers,
    renderMenuPopup: function renderMenuPopup(_ref, popupRef) {
      var open = _ref.open, popupProps = _objectWithoutPropertiesLoose(_ref, _excluded2$g);
      var menuClassName = mergeMenuClassName(className, withMenuClassPrefix());
      return /* @__PURE__ */ React.createElement("ul", _extends$1({
        ref: popupRef,
        className: menuClassName,
        style: menuStyle,
        hidden: !open
      }, popupProps), children);
    },
    onToggleMenu: function onToggleMenu(open, event) {
      onToggle === null || onToggle === void 0 ? void 0 : onToggle(open, eventKey, event);
      if (open) {
        onOpen === null || onOpen === void 0 ? void 0 : onOpen();
      } else {
        onClose === null || onClose === void 0 ? void 0 : onClose();
      }
    }
  }, function(_ref2, menuContainerRef) {
    var _withClassPrefix;
    var open = _ref2.open, menuContainer = _objectWithoutPropertiesLoose(_ref2, _excluded3$6);
    var classes = merge2(className, withClassPrefix((_withClassPrefix = {}, _withClassPrefix["placement-" + kebabCase$1(placementPolyfill(placement))] = !!placement, _withClassPrefix.disabled = disabled, _withClassPrefix.open = open, _withClassPrefix["selected-within"] = hasSelectedItem, _withClassPrefix)));
    return /* @__PURE__ */ React.createElement(Component, _extends$1({
      ref: mergeRefs(ref, menuContainerRef),
      className: classes
    }, menuContainer, pick$1(toggleProps, ["data-testid"]), {
      style: style2
    }));
  });
});
NavDropdown.Item = NavDropdownItem;
NavDropdown.Menu = NavDropdownMenu;
NavDropdown.displayName = "Nav.Dropdown";
NavDropdown.propTypes = {
  classPrefix: PropTypes.string,
  trigger: PropTypes.oneOfType([PropTypes.array, oneOf(["click", "hover", "contextMenu"])]),
  placement: oneOf(PLACEMENT_8),
  title: PropTypes.node,
  disabled: PropTypes.bool,
  icon: PropTypes.node,
  menuStyle: PropTypes.object,
  className: PropTypes.string,
  toggleClassName: PropTypes.string,
  children: PropTypes.node,
  open: deprecatePropType(PropTypes.bool),
  eventKey: PropTypes.any,
  as: PropTypes.elementType,
  toggleAs: PropTypes.elementType,
  noCaret: PropTypes.bool,
  style: PropTypes.object,
  onClose: PropTypes.func,
  onOpen: PropTypes.func,
  onToggle: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onContextMenu: PropTypes.func,
  onClick: PropTypes.func,
  renderToggle: PropTypes.func
};
var baseSlice = _baseSlice;
function castSlice$2(array, start2, end2) {
  var length2 = array.length;
  end2 = end2 === void 0 ? length2 : end2;
  return !start2 && end2 >= length2 ? array : baseSlice(array, start2, end2);
}
var _castSlice = castSlice$2;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$2(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$2;
var castSlice$1 = _castSlice, hasUnicode = _hasUnicode, stringToArray$1 = _stringToArray, toString$3 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$3(string);
    var strSymbols = hasUnicode(string) ? stringToArray$1(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice$1(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$2 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$2;
const upperFirst$3 = /* @__PURE__ */ getDefaultExportFromCjs(upperFirst_1);
var toString$2 = toString_1, upperFirst$1 = upperFirst_1;
function capitalize$3(string) {
  return upperFirst$1(toString$2(string).toLowerCase());
}
var capitalize_1 = capitalize$3;
const capitalize$4 = /* @__PURE__ */ getDefaultExportFromCjs(capitalize_1);
var _excluded$1J = ["className", "timeout", "dimension", "exitedClassName", "exitingClassName", "enteredClassName", "enteringClassName", "getDimensionValue", "onEnter", "onEntering", "onEntered", "onExit", "onExiting"];
var DIMENSION = /* @__PURE__ */ function(DIMENSION2) {
  DIMENSION2["HEIGHT"] = "height";
  DIMENSION2["WIDTH"] = "width";
  return DIMENSION2;
}({});
var triggerBrowserReflow = function triggerBrowserReflow2(node2) {
  return get$4(node2, "offsetHeight");
};
var MARGINS = {
  height: ["marginTop", "marginBottom"],
  width: ["marginLeft", "marginRight"]
};
function defaultGetDimensionValue(dimension, elem) {
  var _get;
  var value = (_get = get$4(elem, "offset" + capitalize$4(dimension))) !== null && _get !== void 0 ? _get : 0;
  var margins = MARGINS[dimension];
  return value + parseInt(getStyle(elem, margins[0]), 10) + parseInt(getStyle(elem, margins[1]), 10);
}
function getScrollDimensionValue(elem, dimension) {
  var value = get$4(elem, "scroll" + capitalize$4(dimension));
  return value + "px";
}
var Collapse$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, _props$timeout = props.timeout, timeout = _props$timeout === void 0 ? 300 : _props$timeout, _props$dimension = props.dimension, dimensionProp = _props$dimension === void 0 ? DIMENSION.HEIGHT : _props$dimension, exitedClassName = props.exitedClassName, exitingClassName = props.exitingClassName, enteredClassName = props.enteredClassName, enteringClassName = props.enteringClassName, _props$getDimensionVa = props.getDimensionValue, getDimensionValue = _props$getDimensionVa === void 0 ? defaultGetDimensionValue : _props$getDimensionVa, onEnter = props.onEnter, onEntering = props.onEntering, onEntered = props.onEntered, onExit = props.onExit, onExiting = props.onExiting, rest = _objectWithoutPropertiesLoose(props, _excluded$1J);
  var _useClassNames = useClassNames$2("anim"), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var dimension = typeof dimensionProp === "function" ? dimensionProp() : dimensionProp;
  var handleEnter = reactExports.useCallback(function(elem) {
    addStyle(elem, dimension, 0);
  }, [dimension]);
  var handleEntering = reactExports.useCallback(function(elem) {
    addStyle(elem, dimension, getScrollDimensionValue(elem, dimension));
  }, [dimension]);
  var handleEntered = reactExports.useCallback(function(elem) {
    addStyle(elem, dimension, "auto");
  }, [dimension]);
  var handleExit = reactExports.useCallback(function(elem) {
    var value = getDimensionValue ? getDimensionValue(dimension, elem) : 0;
    addStyle(elem, dimension, value + "px");
  }, [dimension, getDimensionValue]);
  var handleExiting = reactExports.useCallback(function(elem) {
    triggerBrowserReflow(elem);
    addStyle(elem, dimension, 0);
  }, [dimension]);
  return /* @__PURE__ */ React.createElement(Transition$1, _extends$1({}, rest, {
    ref,
    timeout,
    className: merge2(className, prefix2({
      "collapse-horizontal": dimension === "width"
    })),
    exitedClassName: exitedClassName || prefix2("collapse"),
    exitingClassName: exitingClassName || prefix2("collapsing"),
    enteredClassName: enteredClassName || prefix2("collapse", "in"),
    enteringClassName: enteringClassName || prefix2("collapsing"),
    onEnter: createChainedFunction$1(handleEnter, onEnter),
    onEntering: createChainedFunction$1(handleEntering, onEntering),
    onEntered: createChainedFunction$1(handleEntered, onEntered),
    onExit: createChainedFunction$1(handleExit, onExit),
    onExiting: createChainedFunction$1(handleExiting, onExiting)
  }));
});
Collapse$1.displayName = "Collapse";
Collapse$1.propTypes = _extends$1({}, transitionPropTypes, {
  dimension: PropTypes.any,
  getDimensionValue: PropTypes.func
});
var _templateObject$c, _templateObject2$6, _templateObject3, _templateObject4;
var _excluded$1I = ["className", "classPrefix", "open"], _excluded2$f = ["className"];
var SidenavDropdownCollapse = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-menu" : _props$classPrefix, open = props.open, restProps = _objectWithoutPropertiesLoose(props, _excluded$1I);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Collapse$1, {
    in: open,
    exitedClassName: prefix2(_templateObject$c || (_templateObject$c = _taggedTemplateLiteralLoose(["collapse-out"]))),
    exitingClassName: prefix2(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteralLoose(["collapsing"]))),
    enteredClassName: prefix2(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["collapse-in"]))),
    enteringClassName: prefix2(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose(["collapsing"])))
  }, function(transitionProps, transitionRef) {
    var transitionClassName = transitionProps.className, transitionRestProps = _objectWithoutPropertiesLoose(transitionProps, _excluded2$f);
    return /* @__PURE__ */ React.createElement("ul", _extends$1({
      ref: mergeRefs(ref, transitionRef),
      role: "group",
      className: classNames(classes, transitionClassName)
    }, restProps, transitionRestProps));
  });
});
SidenavDropdownCollapse.displayName = "Sidenav.Dropdown.Collapse";
SidenavDropdownCollapse.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  open: PropTypes.bool
};
var DisclosureActionTypes = /* @__PURE__ */ function(DisclosureActionTypes2) {
  DisclosureActionTypes2[DisclosureActionTypes2["Show"] = 0] = "Show";
  DisclosureActionTypes2[DisclosureActionTypes2["Hide"] = 1] = "Hide";
  return DisclosureActionTypes2;
}({});
var DisclosureContext = /* @__PURE__ */ React.createContext(null);
DisclosureContext.displayName = "Disclosure.Context";
function useDisclosureContext(component) {
  var context = reactExports.useContext(DisclosureContext);
  if (!context) {
    throw new Error("<" + component + "> component must be rendered within a <Disclosure>");
  }
  return context;
}
function DisclosureButton(props) {
  var children = props.children;
  var buttonRef = reactExports.useRef(null);
  var _useDisclosureContext = useDisclosureContext(DisclosureButton.displayName), open = _useDisclosureContext[0].open, dispatch = _useDisclosureContext[1], onToggle = _useDisclosureContext[2].onToggle;
  var toggle = reactExports.useCallback(function(event) {
    if (!open) {
      dispatch({
        type: DisclosureActionTypes.Show
      });
      onToggle === null || onToggle === void 0 ? void 0 : onToggle(true, event);
    } else {
      dispatch({
        type: DisclosureActionTypes.Hide
      });
      onToggle === null || onToggle === void 0 ? void 0 : onToggle(false, event);
    }
  }, [open, dispatch, onToggle]);
  var onClick = reactExports.useCallback(function(event) {
    toggle(event);
  }, [toggle]);
  var onKeyDown = reactExports.useCallback(function(event) {
    switch (event.key) {
      case KEY_VALUES.ENTER:
      case KEY_VALUES.SPACE:
        event.preventDefault();
        event.stopPropagation();
        toggle(event);
        break;
    }
  }, [toggle]);
  return children({
    role: "button",
    "aria-expanded": open,
    onClick,
    onKeyDown,
    open
  }, buttonRef);
}
DisclosureButton.displayName = "Disclosure.Button";
function DisclosureContent(props) {
  var children = props.children;
  var elementRef = reactExports.useRef(null);
  var disclosure = useDisclosureContext(DisclosureContent.displayName);
  var open = disclosure[0].open;
  return children({
    open
  }, elementRef);
}
DisclosureContent.displayName = "Disclosure.Content";
var initialDisclosureState = {
  open: false
};
function disclosureReducer(state, action) {
  switch (action.type) {
    case DisclosureActionTypes.Show:
      return _extends$1({}, state, {
        open: true
      });
    case DisclosureActionTypes.Hide:
      return _extends$1({}, state, {
        open: false
      });
  }
  return state;
}
var Disclosure = /* @__PURE__ */ React.memo(function(props) {
  var children = props.children, openProp = props.open, _props$defaultOpen = props.defaultOpen, defaultOpen = _props$defaultOpen === void 0 ? false : _props$defaultOpen, _props$hideOnClickOut = props.hideOnClickOutside, hideOnClickOutside = _props$hideOnClickOut === void 0 ? false : _props$hideOnClickOut, onToggle = props.onToggle, _props$trigger = props.trigger, trigger2 = _props$trigger === void 0 ? ["click"] : _props$trigger;
  var parentDisclosure = reactExports.useContext(DisclosureContext);
  var _useReducer = reactExports.useReducer(disclosureReducer, _extends$1({}, initialDisclosureState, {
    open: defaultOpen
  })), openState = _useReducer[0].open, dispatch = _useReducer[1];
  var containerElementRef = reactExports.useRef(null);
  var open = openProp !== null && openProp !== void 0 ? openProp : openState;
  useClickOutside({
    enabled: hideOnClickOutside,
    isOutside: function isOutside(event) {
      var _containerElementRef$;
      return !((_containerElementRef$ = containerElementRef.current) !== null && _containerElementRef$ !== void 0 && _containerElementRef$.contains(event.target));
    },
    handle: function handle() {
      return dispatch({
        type: DisclosureActionTypes.Hide
      });
    }
  });
  var onMouseEnter = reactExports.useCallback(function(event) {
    if (!open) {
      dispatch({
        type: DisclosureActionTypes.Show
      });
      onToggle === null || onToggle === void 0 ? void 0 : onToggle(true, event);
    }
  }, [open, dispatch, onToggle]);
  var onMouseLeave = reactExports.useCallback(function(event) {
    if (open) {
      dispatch({
        type: DisclosureActionTypes.Hide
      });
      onToggle === null || onToggle === void 0 ? void 0 : onToggle(false, event);
    }
  }, [open, dispatch, onToggle]);
  var contextValue = reactExports.useMemo(function() {
    var cascadeDispatch = function cascadeDispatch2(action) {
      var result = dispatch(action);
      if ("cascade" in action) {
        parentDisclosure === null || parentDisclosure === void 0 ? void 0 : parentDisclosure[1](action);
      }
      return result;
    };
    return [{
      open
    }, cascadeDispatch, {
      onToggle,
      trigger: trigger2
    }];
  }, [parentDisclosure, open, dispatch, onToggle, trigger2]);
  var renderProps = reactExports.useMemo(function() {
    var renderProps2 = {
      open
    };
    if (trigger2.includes("hover")) {
      renderProps2.onMouseEnter = onMouseEnter;
      renderProps2.onMouseLeave = onMouseLeave;
    }
    return renderProps2;
  }, [open, trigger2, onMouseEnter, onMouseLeave]);
  return /* @__PURE__ */ React.createElement(DisclosureContext.Provider, {
    value: contextValue
  }, children(renderProps, containerElementRef));
});
Disclosure.Button = DisclosureButton;
Disclosure.Content = DisclosureContent;
var _excluded$1H = ["as", "active", "children", "className", "disabled", "classPrefix", "icon", "eventKey", "style", "onClick", "onSelect", "divider", "panel", "tooltip"], _excluded2$e = ["selected", "active"];
var SidenavItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  if (!sidenav) {
    throw new Error("<SidenavItem> component is not supposed to be used standalone. Use <Nav.Item> inside <Sidenav> instead.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? SafeAnchor : _props$as, activeProp = props.active, children = props.children, className = props.className, disabled = props.disabled, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "sidenav-item" : _props$classPrefix, icon = props.icon, eventKey = props.eventKey, style2 = props.style, onClick = props.onClick, onSelect = props.onSelect, divider = props.divider, panel = props.panel, _props$tooltip = props.tooltip, tooltip = _props$tooltip === void 0 ? children : _props$tooltip, rest = _objectWithoutPropertiesLoose(props, _excluded$1H);
  var _ref = reactExports.useContext(NavContext), activeKey = _ref.activeKey, onSelectFromNav = _ref.onSelect;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var selected = activeProp !== null && activeProp !== void 0 ? activeProp : !isNil$1(eventKey) && shallowEqual(activeKey, eventKey);
  var whisperRef = React.useRef(null);
  var handleClick = reactExports.useCallback(function(event) {
    var _whisperRef$current;
    if (disabled) return;
    (_whisperRef$current = whisperRef.current) === null || _whisperRef$current === void 0 ? void 0 : _whisperRef$current.close();
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
    onSelectFromNav === null || onSelectFromNav === void 0 ? void 0 : onSelectFromNav(eventKey, event);
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
  }, [disabled, onSelect, onSelectFromNav, eventKey, onClick]);
  var clonedIcon = icon ? /* @__PURE__ */ React.cloneElement(icon, {
    className: classNames(prefix2("icon"), icon.props.className)
  }) : null;
  if (!sidenav.expanded) {
    return /* @__PURE__ */ React.createElement(Whisper, {
      trigger: "hover",
      speaker: /* @__PURE__ */ React.createElement(Tooltip$1, null, tooltip),
      placement: "right",
      ref: whisperRef
    }, function(triggerProps, triggerRef) {
      return /* @__PURE__ */ React.createElement(MenuItem$1, {
        selected,
        disabled,
        onActivate: handleClick
      }, function(_ref2, menuitemRef) {
        var selected2 = _ref2.selected, active = _ref2.active, menuitem = _objectWithoutPropertiesLoose(_ref2, _excluded2$e);
        var classes = merge2(className, withClassPrefix({
          focus: active,
          active: selected2,
          disabled
        }));
        return /* @__PURE__ */ React.createElement(Component, _extends$1({
          ref: mergeRefs(mergeRefs(ref, menuitemRef), triggerRef),
          disabled: Component === SafeAnchor ? disabled : void 0,
          className: classes,
          "data-event-key": eventKey
        }, omit$1(rest, ["divider", "panel"]), triggerProps, menuitem, {
          onMouseOver: createChainedFunction$1(menuitem.onMouseOver, triggerProps.onMouseOver),
          onMouseOut: createChainedFunction$1(menuitem.onMouseOut, triggerProps.onMouseOut)
        }), clonedIcon, children, /* @__PURE__ */ React.createElement(Ripple$1, null));
      });
    });
  }
  if (divider) {
    return /* @__PURE__ */ React.createElement("li", _extends$1({
      ref,
      role: "separator",
      style: style2,
      className: merge2(className, prefix2("divider"))
    }, rest));
  }
  if (panel) {
    return /* @__PURE__ */ React.createElement("li", _extends$1({
      ref,
      role: "none presentation",
      style: style2,
      className: merge2(className, prefix2("panel"))
    }, rest), children);
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    className: merge2(className, withClassPrefix({
      active: selected,
      disabled
    })),
    onClick: handleClick,
    style: style2,
    "aria-selected": selected || void 0,
    "data-event-key": eventKey
  }, rest), clonedIcon, children, /* @__PURE__ */ React.createElement(Ripple$1, null));
});
SidenavItem.displayName = "Sidenav.Item";
SidenavItem.propTypes = {
  classPrefix: PropTypes.string,
  disabled: PropTypes.bool,
  icon: PropTypes.node,
  className: PropTypes.string,
  children: PropTypes.node,
  eventKey: PropTypes.any,
  as: PropTypes.elementType,
  style: PropTypes.object,
  onSelect: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onContextMenu: PropTypes.func,
  onClick: PropTypes.func
};
var _excluded$1G = ["as", "className", "classPrefix", "renderToggle", "children", "noCaret"];
var SidenavDropdownToggle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? SidenavItem : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-toggle" : _props$classPrefix, renderToggle = props.renderToggle, children = props.children, noCaret = props.noCaret, rest = _objectWithoutPropertiesLoose(props, _excluded$1G);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix({
    "no-caret": noCaret
  }));
  var toggle = /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes,
    tooltip: children
  }), children, !noCaret && /* @__PURE__ */ React.createElement(ArrowDownLineIcon, {
    className: prefix2("caret")
  }));
  return renderToggle ? renderToggle(rest, ref) : toggle;
});
SidenavDropdownToggle.displayName = "Sidenav.Dropdown.Toggle";
SidenavDropdownToggle.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  noCaret: PropTypes.bool,
  as: PropTypes.elementType,
  renderToggle: PropTypes.func,
  placement: oneOf(["bottomStart", "bottomEnd", "topStart", "topEnd", "leftStart", "rightStart", "leftEnd", "rightEnd"])
};
var _excluded$1F = ["as", "title", "children", "className", "menuStyle", "disabled", "renderTitle", "renderToggle", "classPrefix", "placement", "toggleClassName", "icon", "eventKey", "toggleAs", "noCaret", "style", "onOpen", "onClose", "open", "onToggle"];
var ExpandedSidenavDropdown = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  var nav = reactExports.useContext(NavContext);
  var navMenu = reactExports.useContext(NavMenuContext);
  if (!sidenav || !nav || !navMenu) {
    throw new Error("<SidenavDropdown> component is not supposed to be used standalone. Use <Nav.Menu> inside <Sidenav> instead.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, title = props.title, children = props.children, className = props.className, menuStyle = props.menuStyle, disabled = props.disabled;
  props.renderTitle;
  var renderToggle = props.renderToggle, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown" : _props$classPrefix, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, toggleClassName = props.toggleClassName, icon = props.icon, eventKey = props.eventKey, toggleAs = props.toggleAs, noCaret = props.noCaret, style2 = props.style, onOpen = props.onOpen, onClose = props.onClose, openProp = props.open, onToggle = props.onToggle, rest = _objectWithoutPropertiesLoose(props, _excluded$1F);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var internalId = useInternalId("SidenavDropdown");
  var uniqueKey = eventKey !== null && eventKey !== void 0 ? eventKey : internalId;
  var _sidenav$openKeys = sidenav.openKeys, openKeys = _sidenav$openKeys === void 0 ? [] : _sidenav$openKeys, onOpenChange = sidenav.onOpenChange;
  var items = navMenu[0].items;
  var hasSelectedItems = (
    // has items that is active indicated by <Nav activeKey>
    nav.activeKey && items.some(function(item) {
      return item.eventKey === nav.activeKey;
    }) || // has items that is active indicated by <Nav.Item active>
    items.some(function(item) {
      return item.active;
    })
  );
  var handleToggleDisclosure = reactExports.useCallback(function(open2, event) {
    if (open2) {
      onClose === null || onClose === void 0 ? void 0 : onClose();
    } else {
      onOpen === null || onOpen === void 0 ? void 0 : onOpen();
    }
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(open2);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(uniqueKey, event);
  }, [onClose, onOpen, onToggle, uniqueKey, onOpenChange]);
  var open = openProp !== null && openProp !== void 0 ? openProp : openKeys.includes(uniqueKey);
  return /* @__PURE__ */ React.createElement(Disclosure, {
    open,
    onToggle: handleToggleDisclosure
  }, function(_ref, containerRef) {
    var _withClassPrefix;
    var open2 = _ref.open;
    var classes = merge2(className, withClassPrefix((_withClassPrefix = {}, _withClassPrefix["placement-" + kebabCase$1(placementPolyfill(placement))] = placement, _withClassPrefix[open2 ? "expand" : "collapse"] = true, _withClassPrefix.disabled = disabled, _withClassPrefix["selected-within"] = hasSelectedItems, _withClassPrefix["no-caret"] = noCaret, _withClassPrefix)));
    return /* @__PURE__ */ React.createElement(Component, _extends$1({
      ref: mergeRefs(ref, containerRef),
      style: style2,
      className: classes
    }, rest, {
      "data-event-key": eventKey
    }), /* @__PURE__ */ React.createElement(Disclosure.Button, null, function(buttonProps, buttonRef) {
      return /* @__PURE__ */ React.createElement(SidenavDropdownToggle, _extends$1({
        ref: buttonRef,
        as: toggleAs,
        noCaret,
        className: toggleClassName,
        renderToggle,
        icon,
        placement
      }, omit$1(buttonProps, ["open"])), title);
    }), /* @__PURE__ */ React.createElement(Disclosure.Content, null, function(_ref2) {
      var open3 = _ref2.open;
      return /* @__PURE__ */ React.createElement(SidenavDropdownCollapse, {
        open: open3,
        style: menuStyle
      }, children);
    }));
  });
});
ExpandedSidenavDropdown.displayName = "Sidenav.Dropdown";
ExpandedSidenavDropdown.propTypes = {
  activeKey: PropTypes.any,
  classPrefix: PropTypes.string,
  placement: oneOf(PLACEMENT_8),
  title: PropTypes.node,
  disabled: PropTypes.bool,
  icon: PropTypes.node,
  menuStyle: PropTypes.object,
  className: PropTypes.string,
  toggleClassName: PropTypes.string,
  children: PropTypes.node,
  tabIndex: PropTypes.number,
  open: deprecatePropType(PropTypes.bool),
  eventKey: PropTypes.any,
  as: PropTypes.elementType,
  toggleAs: PropTypes.elementType,
  noCaret: PropTypes.bool,
  style: PropTypes.object,
  onClose: PropTypes.func,
  onOpen: PropTypes.func,
  onToggle: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onContextMenu: PropTypes.func,
  onClick: PropTypes.func,
  renderTitle: deprecatePropType(PropTypes.func),
  renderToggle: PropTypes.func
};
var _excluded$1E = ["as", "title", "onClose", "onOpen", "onToggle", "eventKey", "trigger", "placement", "toggleAs", "toggleClassName", "classPrefix", "className", "disabled", "children", "menuStyle", "style"], _excluded2$d = ["active"], _excluded3$5 = ["open"], _excluded4$2 = ["open"];
var SidenavDropdown = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  var nav = reactExports.useContext(NavContext);
  var navMenu = reactExports.useContext(NavMenuContext);
  if (!sidenav || !nav || !navMenu) {
    throw new Error("<Sidenav.Dropdown> must be rendered within a <Nav> component within a <Sidenav> component.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, title = props.title, onClose = props.onClose, onOpen = props.onOpen, onToggle = props.onToggle, eventKey = props.eventKey, _props$trigger = props.trigger, trigger2 = _props$trigger === void 0 ? "click" : _props$trigger, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, toggleAs = props.toggleAs, toggleClassName = props.toggleClassName, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown" : _props$classPrefix, className = props.className, disabled = props.disabled, children = props.children, menuStyle = props.menuStyle, style2 = props.style, toggleProps = _objectWithoutPropertiesLoose(props, _excluded$1E);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var _useClassNames2 = useClassNames$2("dropdown-menu"), withMenuClassPrefix = _useClassNames2.withClassPrefix, mergeMenuClassName = _useClassNames2.merge;
  var _useClassNames3 = useClassNames$2("nav-item"), withNavItemClassPrefix = _useClassNames3.withClassPrefix, mergeNavItemClassNames = _useClassNames3.merge;
  var items = navMenu[0].items;
  var hasSelectedItems = (
    // has items that is active indicated by <Nav activeKey>
    nav.activeKey && items.some(function(item) {
      return item.eventKey === nav.activeKey;
    }) || // has items that is active indicated by <Nav.Item active>
    items.some(function(item) {
      return item.active;
    })
  );
  var menuButtonTriggers = reactExports.useMemo(function() {
    if (!trigger2) {
      return void 0;
    }
    var triggerMap = {
      hover: "mouseover",
      click: "click",
      contextMenu: "contextmenu"
    };
    if (!Array.isArray(trigger2)) {
      return [triggerMap[trigger2]];
    }
    return trigger2.map(function(t3) {
      return triggerMap[t3];
    });
  }, [trigger2]);
  if (sidenav.expanded) {
    return /* @__PURE__ */ React.createElement(ExpandedSidenavDropdown, _extends$1({
      ref
    }, props));
  }
  var renderMenuButton = function renderMenuButton2(menuButtonProps, buttonRef) {
    return /* @__PURE__ */ React.createElement(MenuItem$1, {
      disabled
    }, function(_ref, menuitemRef) {
      var active = _ref.active, menuitemProps = _objectWithoutPropertiesLoose(_ref, _excluded2$d);
      return /* @__PURE__ */ React.createElement(SidenavDropdownToggle, _extends$1({
        ref: mergeRefs(buttonRef, menuitemRef),
        as: toggleAs,
        className: mergeNavItemClassNames(toggleClassName, withNavItemClassPrefix({
          focus: active
        }))
      }, menuButtonProps, omit$1(menuitemProps, ["onClick"]), omit$1(toggleProps, "data-testid")), title);
    });
  };
  return /* @__PURE__ */ React.createElement(Menu$1, {
    menuButtonText: title,
    renderMenuButton,
    openMenuOn: menuButtonTriggers,
    renderMenuPopup: function renderMenuPopup(_ref2, popupRef) {
      var open = _ref2.open, popupProps = _objectWithoutPropertiesLoose(_ref2, _excluded3$5);
      var menuClassName = mergeMenuClassName(className, withMenuClassPrefix({}));
      var showHeader = !!sidenav;
      return /* @__PURE__ */ React.createElement("ul", _extends$1({
        ref: popupRef,
        className: menuClassName,
        style: menuStyle,
        hidden: !open
      }, popupProps), showHeader && /* @__PURE__ */ React.createElement("div", {
        className: prefix2("header")
      }, title), children);
    },
    onToggleMenu: function onToggleMenu(open, event) {
      onToggle === null || onToggle === void 0 ? void 0 : onToggle(open, eventKey, event);
      sidenav === null || sidenav === void 0 ? void 0 : sidenav.onOpenChange(eventKey, event);
      if (open) {
        onOpen === null || onOpen === void 0 ? void 0 : onOpen();
      } else {
        onClose === null || onClose === void 0 ? void 0 : onClose();
      }
    }
  }, function(_ref3, menuContainerRef) {
    var _withClassPrefix;
    var open = _ref3.open, menuContainer = _objectWithoutPropertiesLoose(_ref3, _excluded4$2);
    var classes = merge2(className, withClassPrefix((_withClassPrefix = {}, _withClassPrefix["placement-" + kebabCase$1(placementPolyfill(placement))] = !!placement, _withClassPrefix.disabled = disabled, _withClassPrefix.open = open, _withClassPrefix.submenu = true, _withClassPrefix["selected-within"] = hasSelectedItems, _withClassPrefix)));
    return /* @__PURE__ */ React.createElement(Component, _extends$1({
      ref: mergeRefs(ref, menuContainerRef),
      className: classes
    }, menuContainer, pick$1(toggleProps, ["data-testid"]), {
      style: style2
    }));
  });
});
SidenavDropdown.Item = NavDropdownItem;
SidenavDropdown.Menu = NavDropdownMenu;
SidenavDropdown.displayName = "Sidenav.Dropdown";
SidenavDropdown.propTypes = {
  activeKey: PropTypes.any,
  classPrefix: PropTypes.string,
  trigger: PropTypes.oneOfType([PropTypes.array, oneOf(["click", "hover", "contextMenu"])]),
  placement: oneOf(PLACEMENT_8),
  title: PropTypes.node,
  disabled: PropTypes.bool,
  icon: PropTypes.node,
  menuStyle: PropTypes.object,
  className: PropTypes.string,
  toggleClassName: PropTypes.string,
  children: PropTypes.node,
  open: deprecatePropType(PropTypes.bool),
  eventKey: PropTypes.any,
  as: PropTypes.elementType,
  toggleAs: PropTypes.elementType,
  noCaret: PropTypes.bool,
  style: PropTypes.object,
  onClose: PropTypes.func,
  onOpen: PropTypes.func,
  onToggle: PropTypes.func,
  onSelect: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onContextMenu: PropTypes.func,
  onClick: PropTypes.func,
  renderToggle: PropTypes.func
};
var isArray = isArray_1;
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray(value) ? value : [value];
}
var castArray_1 = castArray;
const castArray$1 = /* @__PURE__ */ getDefaultExportFromCjs(castArray_1);
var _excluded$1D = ["as", "active", "disabled", "eventKey", "className", "classPrefix", "style", "children", "icon", "onClick", "onSelect"];
var NavbarItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? SafeAnchor : _props$as, activeProp = props.active, disabled = props.disabled, eventKey = props.eventKey, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "navbar-item" : _props$classPrefix, style2 = props.style, children = props.children, icon = props.icon, onClick = props.onClick, onSelectProp = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$1D);
  var _ref = reactExports.useContext(NavContext), activeKey = _ref.activeKey, onSelectFromNav = _ref.onSelect;
  var active = activeProp !== null && activeProp !== void 0 ? activeProp : !isNil$1(eventKey) && shallowEqual(eventKey, activeKey);
  var emitSelect = reactExports.useCallback(function(event) {
    onSelectProp === null || onSelectProp === void 0 ? void 0 : onSelectProp(eventKey, event);
    onSelectFromNav === null || onSelectFromNav === void 0 ? void 0 : onSelectFromNav(eventKey, event);
  }, [eventKey, onSelectProp, onSelectFromNav]);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix({
    active,
    disabled
  }));
  var handleClick = reactExports.useCallback(function(event) {
    if (!disabled) {
      emitSelect(event);
      onClick === null || onClick === void 0 ? void 0 : onClick(event);
    }
  }, [disabled, emitSelect, onClick]);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    "aria-selected": active || void 0
  }, rest, {
    className: classes,
    onClick: handleClick,
    style: style2
  }), icon && /* @__PURE__ */ React.cloneElement(icon, {
    className: classNames(prefix2("icon"), icon.props.className)
  }), children, /* @__PURE__ */ React.createElement(Ripple$1, null));
});
NavbarItem.displayName = "Navbar.Item";
NavbarItem.propTypes = {
  as: PropTypes.elementType,
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  onClick: PropTypes.func,
  style: PropTypes.object,
  icon: PropTypes.node,
  onSelect: PropTypes.func,
  children: PropTypes.node,
  eventKey: PropTypes.any
};
var _excluded$1C = ["as", "className", "classPrefix", "renderToggle", "children", "noCaret"];
var NavbarDropdownToggle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? NavbarItem : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "navbar-item" : _props$classPrefix, renderToggle = props.renderToggle, children = props.children, noCaret = props.noCaret, rest = _objectWithoutPropertiesLoose(props, _excluded$1C);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix({
    "no-caret": noCaret
  }));
  var toggle = /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), children, !noCaret && /* @__PURE__ */ React.createElement(ArrowDownLineIcon, {
    className: prefix2("caret")
  }));
  return renderToggle ? renderToggle(rest, ref) : toggle;
});
NavbarDropdownToggle.displayName = "Navbar.Dropdown.Toggle";
NavbarDropdownToggle.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  noCaret: PropTypes.bool,
  as: PropTypes.elementType,
  renderToggle: PropTypes.func,
  placement: oneOf(["bottomStart", "bottomEnd", "topStart", "topEnd", "leftStart", "rightStart", "leftEnd", "rightEnd"])
};
var _excluded$1B = ["as", "title", "onClose", "onOpen", "onToggle", "trigger", "placement", "toggleAs", "toggleClassName", "classPrefix", "className", "disabled", "children", "menuStyle", "style"], _excluded2$c = ["open"];
var NavbarDropdown = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var navbar = reactExports.useContext(NavbarContext);
  if (!navbar) {
    throw new Error("<Navbar.Dropdown> should be used within a <Navbar> component.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, title = props.title, onClose = props.onClose, onOpen = props.onOpen, _onToggle = props.onToggle, _props$trigger = props.trigger, trigger2 = _props$trigger === void 0 ? "click" : _props$trigger, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, toggleAs = props.toggleAs, toggleClassName = props.toggleClassName, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown" : _props$classPrefix, className = props.className, disabled = props.disabled, children = props.children, menuStyle = props.menuStyle, style2 = props.style, toggleProps = _objectWithoutPropertiesLoose(props, _excluded$1B);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var _useClassNames2 = useClassNames$2("dropdown-menu"), withMenuClassPrefix = _useClassNames2.withClassPrefix, mergeMenuClassName = _useClassNames2.merge;
  return /* @__PURE__ */ React.createElement(Disclosure, {
    trigger: castArray$1(trigger2),
    hideOnClickOutside: true,
    onToggle: function onToggle(open) {
      _onToggle === null || _onToggle === void 0 ? void 0 : _onToggle(open);
      if (open) {
        onOpen === null || onOpen === void 0 ? void 0 : onOpen();
      } else {
        onClose === null || onClose === void 0 ? void 0 : onClose();
      }
    }
  }, function(_ref, containerRef) {
    var _withClassPrefix;
    var open = _ref.open, props2 = _objectWithoutPropertiesLoose(_ref, _excluded2$c);
    var classes = merge2(className, withClassPrefix((_withClassPrefix = {}, _withClassPrefix["placement-" + kebabCase$1(placementPolyfill(placement))] = !!placement, _withClassPrefix.disabled = disabled, _withClassPrefix.open = open, _withClassPrefix)));
    return /* @__PURE__ */ React.createElement(Component, _extends$1({
      ref: mergeRefs(ref, containerRef),
      className: classes,
      style: style2
    }, props2), /* @__PURE__ */ React.createElement(Disclosure.Button, null, function(buttonProps, buttonRef) {
      return /* @__PURE__ */ React.createElement(NavbarDropdownToggle, _extends$1({
        ref: buttonRef,
        as: toggleAs,
        className: toggleClassName,
        placement,
        disabled
      }, omit$1(buttonProps, ["open"]), toggleProps), title);
    }), /* @__PURE__ */ React.createElement(Disclosure.Content, null, function(_ref2, elementRef) {
      var open2 = _ref2.open;
      var menuClassName = mergeMenuClassName(className, withMenuClassPrefix());
      return /* @__PURE__ */ React.createElement("ul", {
        ref: elementRef,
        className: menuClassName,
        style: menuStyle,
        hidden: !open2
      }, children);
    }));
  });
});
NavbarDropdown.Item = NavDropdownItem;
NavbarDropdown.Menu = NavDropdownMenu;
NavbarDropdown.displayName = "Navbar.Dropdown";
NavbarDropdown.propTypes = {
  classPrefix: PropTypes.string,
  trigger: PropTypes.oneOfType([PropTypes.array, oneOf(["click", "hover", "contextMenu"])]),
  placement: oneOf(PLACEMENT_8),
  title: PropTypes.node,
  disabled: PropTypes.bool,
  icon: PropTypes.node,
  menuStyle: PropTypes.object,
  className: PropTypes.string,
  toggleClassName: PropTypes.string,
  children: PropTypes.node,
  open: deprecatePropType(PropTypes.bool),
  eventKey: PropTypes.any,
  as: PropTypes.elementType,
  toggleAs: PropTypes.elementType,
  noCaret: PropTypes.bool,
  style: PropTypes.object,
  onClose: PropTypes.func,
  onOpen: PropTypes.func,
  onToggle: PropTypes.func,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onContextMenu: PropTypes.func,
  onClick: PropTypes.func,
  renderToggle: PropTypes.func
};
var _templateObject$b, _templateObject2$5;
var _excluded$1A = ["onToggle", "eventKey", "title", "classPrefix", "children", "openDirection"], _excluded2$b = ["icon", "className", "disabled"], _excluded3$4 = ["open"], _excluded4$1 = ["open"];
var NavbarDropdownMenu = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var navbar = reactExports.useContext(NavbarContext);
  var nav = reactExports.useContext(NavContext);
  if (!navbar || !nav) {
    throw new Error("<Navbar.Dropdown.Menu> must be rendered within a <Nav> within a <Navbar> component.");
  }
  var _onToggle = props.onToggle, eventKey = props.eventKey, title = props.title, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-menu" : _props$classPrefix, children = props.children, _props$openDirection = props.openDirection, openDirection = _props$openDirection === void 0 ? "end" : _props$openDirection, rest = _objectWithoutPropertiesLoose(props, _excluded$1A);
  var _useCustom = useCustom("DropdownMenu"), rtl = _useCustom.rtl;
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix;
  var _useClassNames2 = useClassNames$2("dropdown-menu"), withMenuClassPrefix = _useClassNames2.withClassPrefix, mergeMenuClassName = _useClassNames2.merge;
  var _useClassNames3 = useClassNames$2("dropdown-item"), mergeItemClassNames = _useClassNames3.merge, withItemClassPrefix = _useClassNames3.withClassPrefix, prefixItemClassName = _useClassNames3.prefix;
  var _omit = omit$1(rest, ["trigger"]), icon = _omit.icon, className = _omit.className, disabled = _omit.disabled, menuProps = _objectWithoutPropertiesLoose(_omit, _excluded2$b);
  var Icon2 = rtl ? AngleLeftIcon : AngleRightIcon;
  return /* @__PURE__ */ React.createElement(Disclosure, {
    hideOnClickOutside: true,
    trigger: ["click", "hover"],
    onToggle: function onToggle(open, event) {
      return _onToggle === null || _onToggle === void 0 ? void 0 : _onToggle(open, void 0, event);
    }
  }, function(_ref, containerRef) {
    var open = _ref.open, props2 = _objectWithoutPropertiesLoose(_ref, _excluded3$4);
    var classes = mergeItemClassNames(className, withItemClassPrefix({
      disabled,
      open,
      submenu: true
    }));
    return /* @__PURE__ */ React.createElement("li", _extends$1({
      ref: mergeRefs(ref, containerRef),
      className: classes
    }, props2), /* @__PURE__ */ React.createElement(Disclosure.Button, null, function(_ref2, buttonRef) {
      var open2 = _ref2.open, buttonProps = _objectWithoutPropertiesLoose(_ref2, _excluded4$1);
      var classes2 = mergeItemClassNames(className, prefixItemClassName(_templateObject$b || (_templateObject$b = _taggedTemplateLiteralLoose(["toggle"]))), withItemClassPrefix({
        "with-icon": icon,
        open: open2,
        disabled
      }));
      var dataAttributes = {
        "data-event-key": eventKey
      };
      if (!isNil$1(eventKey) && typeof eventKey !== "string") {
        dataAttributes["data-event-key-type"] = typeof eventKey;
      }
      return /* @__PURE__ */ React.createElement("div", _extends$1({
        ref: mergeRefs(buttonRef, buttonRef),
        className: classes2
      }, dataAttributes, buttonProps), icon && /* @__PURE__ */ React.cloneElement(icon, {
        className: prefix2("menu-icon")
      }), title, /* @__PURE__ */ React.createElement(Icon2, {
        className: prefix2(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteralLoose(["toggle-icon"])))
      }));
    }), /* @__PURE__ */ React.createElement(Disclosure.Content, null, function(_ref3, elementRef) {
      var open2 = _ref3.open;
      var menuClassName = mergeMenuClassName(className, withMenuClassPrefix());
      return /* @__PURE__ */ React.createElement("ul", _extends$1({
        ref: elementRef,
        className: menuClassName,
        hidden: !open2,
        "data-direction": openDirection
      }, menuProps), children);
    }));
  });
});
NavbarDropdownMenu.displayName = "Nav.Dropdown.Menu";
NavbarDropdownMenu.propTypes = {
  active: PropTypes.bool,
  activeKey: PropTypes.any,
  className: PropTypes.string,
  children: PropTypes.node,
  icon: PropTypes.any,
  classPrefix: PropTypes.string,
  pullLeft: deprecatePropType(PropTypes.bool, 'Use openDirection="start" instead.'),
  openDirection: oneOf(["start", "end"]),
  title: PropTypes.node,
  open: PropTypes.bool,
  eventKey: PropTypes.any,
  expanded: PropTypes.bool,
  collapsible: PropTypes.bool,
  onToggle: PropTypes.func
};
var ArrowLeftLine$3 = {};
var ArrowLeftLine$2 = { exports: {} };
var ArrowLeftLine$1 = {};
var hasRequiredArrowLeftLine;
function requireArrowLeftLine() {
  if (hasRequiredArrowLeftLine) return ArrowLeftLine$1;
  hasRequiredArrowLeftLine = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function ArrowLeftLine2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 16 16",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M9.707 5.707L7.415 8l2.292 2.293a.999.999 0 11-1.414 1.414l-3-3a.99.99 0 01-.277-.531l-.014-.117v-.118a.997.997 0 01.291-.648l3-3a.999.999 0 111.414 1.414z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(ArrowLeftLine2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(ArrowLeftLine$1);
  return ArrowLeftLine$1;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _ArrowLeftLine = _interopRequireDefault2(requireArrowLeftLine());
  var ArrowLeftLine2 = (0, _createSvgIcon2["default"])({
    as: _ArrowLeftLine["default"],
    ariaLabel: "arrow left line",
    category: "direction",
    displayName: "ArrowLeftLine"
  });
  var _default = ArrowLeftLine2;
  exports["default"] = _default;
  module.exports = exports.default;
})(ArrowLeftLine$2, ArrowLeftLine$2.exports);
var ArrowLeftLineExports = ArrowLeftLine$2.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _ArrowLeftLine["default"];
    }
  });
  var _ArrowLeftLine = _interopRequireDefault2(ArrowLeftLineExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(ArrowLeftLine$3);
const ArrowLeftLine = /* @__PURE__ */ getDefaultExportFromCjs(ArrowLeftLine$3);
var ArrowRightLine$3 = {};
var ArrowRightLine$2 = { exports: {} };
var ArrowRightLine$1 = {};
var hasRequiredArrowRightLine;
function requireArrowRightLine() {
  if (hasRequiredArrowRightLine) return ArrowRightLine$1;
  hasRequiredArrowRightLine = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function ArrowRightLine2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 16 16",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M6.293 10.293L8.585 8 6.293 5.707a.999.999 0 111.414-1.414l3 3a.99.99 0 01.277.531l.014.117v.118a.997.997 0 01-.291.648l-3 3a.999.999 0 11-1.414-1.414z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(ArrowRightLine2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(ArrowRightLine$1);
  return ArrowRightLine$1;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _ArrowRightLine = _interopRequireDefault2(requireArrowRightLine());
  var ArrowRightLine2 = (0, _createSvgIcon2["default"])({
    as: _ArrowRightLine["default"],
    ariaLabel: "arrow right line",
    category: "direction",
    displayName: "ArrowRightLine"
  });
  var _default = ArrowRightLine2;
  exports["default"] = _default;
  module.exports = exports.default;
})(ArrowRightLine$2, ArrowRightLine$2.exports);
var ArrowRightLineExports = ArrowRightLine$2.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _ArrowRightLine["default"];
    }
  });
  var _ArrowRightLine = _interopRequireDefault2(ArrowRightLineExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(ArrowRightLine$3);
const ArrowRightLine = /* @__PURE__ */ getDefaultExportFromCjs(ArrowRightLine$3);
var _templateObject$a;
var _excluded$1z = ["as", "children", "disabled", "className", "style", "classPrefix", "tabIndex", "icon", "title", "eventKey", "onClick", "onSelect"];
var ExpandedSidenavDropdownMenu = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenavContext = reactExports.useContext(SidenavContext);
  if (!sidenavContext) {
    throw new Error("<SidenavDropdownMenu> component is not supposed to be used standalone. Use <Nav.Menu> inside <Sidenav> instead.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "li" : _props$as, children = props.children, disabled = props.disabled, className = props.className, style2 = props.style, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-item" : _props$classPrefix, tabIndex = props.tabIndex, icon = props.icon, title = props.title, eventKey = props.eventKey, onClick = props.onClick, onSelect = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$1z);
  var _useCustom = useCustom("DropdownMenu"), rtl = _useCustom.rtl;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var _sidenavContext$openK = sidenavContext.openKeys, openKeys = _sidenavContext$openK === void 0 ? [] : _sidenavContext$openK, onOpenChange = sidenavContext.onOpenChange, onSidenavSelect = sidenavContext.onSelect;
  var handleClick = reactExports.useCallback(function(event) {
    if (disabled) return;
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
    onSidenavSelect === null || onSidenavSelect === void 0 ? void 0 : onSidenavSelect(eventKey, event);
  }, [disabled, onSelect, onSidenavSelect, eventKey]);
  var menuitemEventHandlers = {
    onClick: createChainedFunction$1(handleClick, onClick)
  };
  var Icon2 = rtl ? ArrowLeftLine : ArrowRightLine;
  return /* @__PURE__ */ React.createElement(Disclosure, {
    open: !isNil$1(eventKey) && openKeys.includes(eventKey),
    onToggle: function onToggle(_, event) {
      return onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(eventKey, event);
    }
  }, function(_ref) {
    var open = _ref.open;
    var classes = merge2(className, prefix2("submenu"), prefix2("pull-" + (rtl ? "left" : "right")), prefix2(open ? "expand" : "collapse"), withClassPrefix({
      "with-icon": icon,
      // open,
      disabled
    }));
    var iconClasses = merge2(className, prefix2("toggle-icon"), prefix2((open ? "expand" : "collapse") + "-icon"));
    return /* @__PURE__ */ React.createElement(Component, _extends$1({
      ref
    }, rest, {
      tabIndex: disabled ? -1 : tabIndex,
      style: style2,
      className: classes
    }, menuitemEventHandlers), /* @__PURE__ */ React.createElement(Disclosure.Button, null, function(buttonProps) {
      return /* @__PURE__ */ React.createElement("button", _extends$1({
        className: prefix2(_templateObject$a || (_templateObject$a = _taggedTemplateLiteralLoose(["toggle"]))),
        onClick: handleClick
      }, omit$1(buttonProps, ["open"])), icon && /* @__PURE__ */ React.cloneElement(icon, {
        className: prefix2("menu-icon")
      }), title, /* @__PURE__ */ React.createElement(Icon2, {
        className: iconClasses
      }), /* @__PURE__ */ React.createElement(Ripple$1, null));
    }), /* @__PURE__ */ React.createElement(Disclosure.Content, null, function(_ref2) {
      var open2 = _ref2.open;
      return /* @__PURE__ */ React.createElement(SidenavDropdownCollapse, {
        open: open2
      }, children);
    }));
  });
});
ExpandedSidenavDropdownMenu.displayName = "Sidenav.Dropdown.Menu";
ExpandedSidenavDropdownMenu.propTypes = {
  as: PropTypes.elementType,
  expanded: PropTypes.bool,
  disabled: PropTypes.bool,
  onSelect: PropTypes.func,
  onClick: PropTypes.func,
  icon: PropTypes.node,
  eventKey: PropTypes.any,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  tabIndex: PropTypes.number,
  title: PropTypes.node,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func
};
var _templateObject$9, _templateObject2$4;
var _excluded$1y = ["onToggle", "eventKey", "title", "classPrefix", "children"], _excluded2$a = ["icon", "className", "disabled"], _excluded3$3 = ["open"], _excluded4 = ["selected", "active"], _excluded5 = ["open"], _excluded6 = ["open"];
var SidenavDropdownMenu = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  var nav = reactExports.useContext(NavContext);
  if (!sidenav || !nav) {
    throw new Error("<Sidenav.Dropdown.Menu> must be rendered within a <Nav> within a <Sidenav> component.");
  }
  var onToggle = props.onToggle, eventKey = props.eventKey, title = props.title, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-menu" : _props$classPrefix, children = props.children, rest = _objectWithoutPropertiesLoose(props, _excluded$1y);
  var _useCustom = useCustom("DropdownMenu"), rtl = _useCustom.rtl;
  var handleToggleSubmenu = reactExports.useCallback(function(open, event) {
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(open, eventKey, event);
  }, [eventKey, onToggle]);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix;
  var _useClassNames2 = useClassNames$2("dropdown-menu"), withMenuClassPrefix = _useClassNames2.withClassPrefix, mergeMenuClassName = _useClassNames2.merge;
  var _useClassNames3 = useClassNames$2("dropdown-item"), mergeItemClassNames = _useClassNames3.merge, withItemClassPrefix = _useClassNames3.withClassPrefix, prefixItemClassName = _useClassNames3.prefix;
  if (sidenav.expanded) {
    return /* @__PURE__ */ React.createElement(ExpandedSidenavDropdownMenu, _extends$1({
      ref
    }, omit$1(props, "classPrefix")));
  }
  var _omit = omit$1(rest, ["trigger"]), icon = _omit.icon, className = _omit.className, disabled = _omit.disabled, menuProps = _objectWithoutPropertiesLoose(_omit, _excluded2$a);
  var Icon2 = rtl ? ArrowLeftLine : ArrowRightLine;
  return /* @__PURE__ */ React.createElement(Menu$1, {
    openMenuOn: ["mouseover", "click"],
    renderMenuButton: function renderMenuButton(_ref, buttonRef) {
      var open = _ref.open, menuButtonProps = _objectWithoutPropertiesLoose(_ref, _excluded3$3);
      return /* @__PURE__ */ React.createElement(MenuItem$1, {
        disabled
      }, function(_ref2, menuitemRef) {
        var selected = _ref2.selected, active = _ref2.active, menuitem = _objectWithoutPropertiesLoose(_ref2, _excluded4);
        var classes = mergeItemClassNames(className, prefixItemClassName(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteralLoose(["toggle"]))), withItemClassPrefix({
          "with-icon": icon,
          open,
          active: selected,
          disabled,
          focus: active
        }));
        return /* @__PURE__ */ React.createElement("div", _extends$1({
          ref: mergeRefs(buttonRef, menuitemRef),
          className: classes,
          "data-event-key": eventKey,
          "data-event-key-type": typeof eventKey
        }, menuitem, omit$1(menuButtonProps, ["role"])), icon && /* @__PURE__ */ React.cloneElement(icon, {
          className: prefix2("menu-icon")
        }), title, /* @__PURE__ */ React.createElement(Icon2, {
          className: prefix2(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteralLoose(["toggle-icon"])))
        }));
      });
    },
    renderMenuPopup: function renderMenuPopup(_ref3, popupRef) {
      var open = _ref3.open, popupProps = _objectWithoutPropertiesLoose(_ref3, _excluded5);
      var menuClassName = mergeMenuClassName(className, withMenuClassPrefix());
      return /* @__PURE__ */ React.createElement("ul", _extends$1({
        ref: popupRef,
        className: menuClassName,
        hidden: !open
      }, popupProps, menuProps), children);
    },
    onToggleMenu: handleToggleSubmenu
  }, function(_ref4, menuContainerRef) {
    var open = _ref4.open, menuContainer = _objectWithoutPropertiesLoose(_ref4, _excluded6);
    var classes = mergeItemClassNames(className, withItemClassPrefix({
      disabled,
      open,
      submenu: true
    }));
    return /* @__PURE__ */ React.createElement("li", _extends$1({
      ref: mergeRefs(ref, menuContainerRef),
      className: classes
    }, menuContainer));
  });
});
SidenavDropdownMenu.displayName = "Sidenav.Dropdown.Menu";
SidenavDropdownMenu.propTypes = {
  active: PropTypes.bool,
  activeKey: PropTypes.any,
  className: PropTypes.string,
  children: PropTypes.node,
  icon: PropTypes.any,
  classPrefix: PropTypes.string,
  pullLeft: PropTypes.bool,
  title: PropTypes.node,
  open: PropTypes.bool,
  eventKey: PropTypes.any,
  expanded: PropTypes.bool,
  collapsible: PropTypes.bool,
  onToggle: PropTypes.func
};
var NavMenuContext = /* @__PURE__ */ React.createContext(null);
NavMenuContext.displayName = "NavMenu.Context";
var NavMenuActionType = /* @__PURE__ */ function(NavMenuActionType2) {
  NavMenuActionType2[NavMenuActionType2["RegisterItem"] = 0] = "RegisterItem";
  NavMenuActionType2[NavMenuActionType2["UnregisterItem"] = 1] = "UnregisterItem";
  return NavMenuActionType2;
}({});
var initilNavMenuState = {
  items: []
};
var reducer = function reducer2(state, action) {
  switch (action.type) {
    case NavMenuActionType.RegisterItem:
      return _extends$1({}, state, {
        items: [].concat(state.items.filter(function(item) {
          return item._id !== action.payload._id;
        }), [action.payload])
      });
    case NavMenuActionType.UnregisterItem:
      return _extends$1({}, state, {
        items: state.items.filter(function(item) {
          return item._id !== action.payload._id;
        })
      });
    default:
      throw new Error("Unrecognizable action type: " + action.type);
  }
};
var NavMenu = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var parentNavMenu = reactExports.useContext(NavMenuContext);
  var navMenuContext = reactExports.useReducer(reducer, initilNavMenuState);
  var navbar = reactExports.useContext(NavbarContext);
  var sidenav = reactExports.useContext(SidenavContext);
  if (!parentNavMenu) {
    if (navbar) {
      return /* @__PURE__ */ React.createElement(NavMenuContext.Provider, {
        value: navMenuContext
      }, /* @__PURE__ */ React.createElement(NavbarDropdown, _extends$1({
        ref
      }, props)));
    }
    if (sidenav) {
      return /* @__PURE__ */ React.createElement(NavMenuContext.Provider, {
        value: navMenuContext
      }, /* @__PURE__ */ React.createElement(SidenavDropdown, _extends$1({
        ref
      }, props)));
    }
    return /* @__PURE__ */ React.createElement(NavMenuContext.Provider, {
      value: navMenuContext
    }, /* @__PURE__ */ React.createElement(NavDropdown, _extends$1({
      ref
    }, props)));
  }
  if (navbar) {
    return /* @__PURE__ */ React.createElement(NavbarDropdownMenu, _extends$1({
      ref
    }, props));
  }
  if (sidenav) {
    return /* @__PURE__ */ React.createElement(SidenavDropdownMenu, _extends$1({
      ref
    }, props));
  }
  return /* @__PURE__ */ React.createElement(NavDropdownMenu, _extends$1({
    ref
  }, props));
});
NavMenu.displayName = "Nav.Menu";
var _excluded$1x = ["classPrefix", "className", "active", "eventKey", "onSelect", "icon", "as", "divider", "panel", "children", "disabled"];
var NavbarDropdownItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var navbar = reactExports.useContext(NavbarContext);
  var nav = reactExports.useContext(NavContext);
  if (!navbar || !nav) {
    throw new Error("<Navbar.Dropdown.Item> must be rendered within a <Nav> component within a <Navbar> component.");
  }
  var _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-item" : _props$classPrefix, className = props.className, activeProp = props.active, eventKey = props.eventKey, onSelect = props.onSelect, icon = props.icon, _props$as = props.as, Component = _props$as === void 0 ? "li" : _props$as, divider = props.divider, panel = props.panel, children = props.children, disabled = props.disabled, restProps = _objectWithoutPropertiesLoose(props, _excluded$1x);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var handleSelectItem = reactExports.useCallback(function(event) {
    var _nav$onSelect;
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
    (_nav$onSelect = nav.onSelect) === null || _nav$onSelect === void 0 ? void 0 : _nav$onSelect.call(nav, eventKey, event);
  }, [onSelect, eventKey, nav]);
  var disclosure = reactExports.useContext(DisclosureContext);
  var _ref = disclosure !== null && disclosure !== void 0 ? disclosure : [], dispatchDisclosure = _ref[1];
  var handleClickNavbarDropdownItem = reactExports.useCallback(function(event) {
    dispatchDisclosure === null || dispatchDisclosure === void 0 ? void 0 : dispatchDisclosure({
      type: DisclosureActionTypes.Hide,
      cascade: true
    });
    handleSelectItem === null || handleSelectItem === void 0 ? void 0 : handleSelectItem(event);
  }, [dispatchDisclosure, handleSelectItem]);
  var selected = activeProp || !isNil$1(eventKey) && shallowEqual(nav.activeKey, eventKey);
  var renderDropdownItem = useRenderDropdownItem(Component);
  if (divider) {
    return renderDropdownItem(_extends$1({
      ref,
      role: "separator",
      className: merge2(prefix2("divider"), className)
    }, restProps));
  }
  if (panel) {
    return renderDropdownItem(_extends$1({
      ref,
      className: merge2(prefix2("panel"), className),
      children
    }, restProps));
  }
  var classes = merge2(className, withClassPrefix({
    "with-icon": icon,
    disabled,
    divider,
    panel,
    active: selected
  }));
  var dataAttributes = {
    "data-event-key": eventKey
  };
  if (!isNil$1(eventKey) && typeof eventKey !== "string") {
    dataAttributes["data-event-key-type"] = typeof eventKey;
  }
  return renderDropdownItem(_extends$1({
    ref,
    className: classes,
    "aria-current": selected || void 0
  }, dataAttributes, restProps, {
    onClick: createChainedFunction$1(handleClickNavbarDropdownItem, restProps.onClick),
    children: /* @__PURE__ */ React.createElement(React.Fragment, null, icon && /* @__PURE__ */ React.cloneElement(icon, {
      className: classNames(prefix2("menu-icon"), icon.props.className)
    }), children)
  }));
});
NavbarDropdownItem.displayName = "Navbar.Dropdown.Item";
NavbarDropdownItem.propTypes = {
  as: PropTypes.elementType,
  divider: PropTypes.bool,
  panel: PropTypes.bool,
  trigger: PropTypes.oneOfType([PropTypes.array, oneOf(["click", "hover"])]),
  open: deprecatePropType(PropTypes.bool),
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  pullLeft: deprecatePropType(PropTypes.bool),
  submenu: PropTypes.element,
  onSelect: PropTypes.func,
  onClick: PropTypes.func,
  icon: PropTypes.node,
  eventKey: PropTypes.any,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  tabIndex: PropTypes.number
};
var _excluded$1w = ["as", "active", "children", "disabled", "divider", "panel", "className", "style", "classPrefix", "icon", "eventKey", "onClick", "onSelect"];
var ExpandedSidenavDropdownItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  var nav = reactExports.useContext(NavContext);
  if (!sidenav || !nav) {
    throw new Error("<SidenavDropdownItem> component is not supposed to be used standalone. Use <Nav.Item> within <Sidenav> instead.");
  }
  var _props$as = props.as, Component = _props$as === void 0 ? "li" : _props$as, activeProp = props.active, children = props.children, disabled = props.disabled, divider = props.divider, panel = props.panel, className = props.className, style2 = props.style, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-item" : _props$classPrefix, icon = props.icon, eventKey = props.eventKey, onClick = props.onClick, onSelect = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$1w);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var selected = activeProp !== null && activeProp !== void 0 ? activeProp : !isNil$1(eventKey) && (shallowEqual(eventKey, sidenav.activeKey) || shallowEqual(nav.activeKey, eventKey));
  var classes = merge2(className, withClassPrefix({
    "with-icon": icon,
    active: selected,
    disabled
  }));
  var handleClick = reactExports.useCallback(function(event) {
    var _nav$onSelect, _sidenav$onSelect;
    if (disabled) return;
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
    (_nav$onSelect = nav.onSelect) === null || _nav$onSelect === void 0 ? void 0 : _nav$onSelect.call(nav, eventKey, event);
    (_sidenav$onSelect = sidenav.onSelect) === null || _sidenav$onSelect === void 0 ? void 0 : _sidenav$onSelect.call(sidenav, eventKey, event);
  }, [disabled, onSelect, sidenav, eventKey, nav]);
  var menuitemEventHandlers = {
    onClick: createChainedFunction$1(handleClick, onClick)
  };
  var renderDropdownItem = useRenderDropdownItem(Component);
  if (divider) {
    return renderDropdownItem(_extends$1({
      ref,
      role: "separator",
      style: style2,
      className: merge2(prefix2("divider"), className)
    }, rest));
  }
  if (panel) {
    return renderDropdownItem(_extends$1({
      ref,
      role: "none presentation",
      style: style2,
      className: merge2(prefix2("panel"), className)
    }, rest, {
      children
    }));
  }
  return renderDropdownItem(_extends$1({
    ref
  }, rest, {
    style: style2,
    className: classes,
    "aria-current": selected || void 0
  }, menuitemEventHandlers, {
    children: /* @__PURE__ */ React.createElement(React.Fragment, null, icon && /* @__PURE__ */ React.cloneElement(icon, {
      className: classNames(prefix2("menu-icon"), icon.props.className)
    }), children, /* @__PURE__ */ React.createElement(Ripple$1, null))
  }), SafeAnchor);
});
ExpandedSidenavDropdownItem.displayName = "Sidenav.Dropdown.Item";
ExpandedSidenavDropdownItem.propTypes = {
  as: PropTypes.elementType,
  expanded: PropTypes.bool,
  active: PropTypes.bool,
  divider: PropTypes.bool,
  panel: PropTypes.bool,
  disabled: PropTypes.bool,
  submenu: PropTypes.element,
  onSelect: PropTypes.func,
  onClick: PropTypes.func,
  icon: PropTypes.node,
  eventKey: PropTypes.any,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  tabIndex: PropTypes.number,
  title: PropTypes.node,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func
};
var _excluded$1v = ["classPrefix", "className", "active", "eventKey", "onSelect", "icon", "as", "divider", "panel", "children", "disabled"], _excluded2$9 = ["selected", "active"];
var SidenavDropdownItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var sidenav = reactExports.useContext(SidenavContext);
  var nav = reactExports.useContext(NavContext);
  if (!sidenav || !nav) {
    throw new Error("<Sidenav.Dropdown.Item> must be used within a <Nav> within a <Sidenav> component.");
  }
  var _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-item" : _props$classPrefix, className = props.className, activeProp = props.active, eventKey = props.eventKey, onSelect = props.onSelect, icon = props.icon, _props$as = props.as, Component = _props$as === void 0 ? "li" : _props$as, divider = props.divider, panel = props.panel, children = props.children, disabled = props.disabled, restProps = _objectWithoutPropertiesLoose(props, _excluded$1v);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var handleSelectItem = reactExports.useCallback(function(event) {
    var _nav$onSelect;
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
    (_nav$onSelect = nav.onSelect) === null || _nav$onSelect === void 0 ? void 0 : _nav$onSelect.call(nav, eventKey, event);
  }, [onSelect, eventKey, nav]);
  var selected = activeProp || !isNil$1(eventKey) && shallowEqual(nav === null || nav === void 0 ? void 0 : nav.activeKey, eventKey);
  var renderDropdownItem = useRenderDropdownItem(Component);
  if (sidenav.expanded) {
    return /* @__PURE__ */ React.createElement(ExpandedSidenavDropdownItem, _extends$1({
      ref
    }, props));
  }
  if (divider) {
    return renderDropdownItem(_extends$1({
      ref,
      role: "separator",
      className: merge2(prefix2("divider"), className)
    }, restProps));
  }
  if (panel) {
    return renderDropdownItem(_extends$1({
      ref,
      className: merge2(prefix2("panel"), className),
      children
    }, restProps));
  }
  return /* @__PURE__ */ React.createElement(MenuItem$1, {
    selected,
    disabled,
    onActivate: handleSelectItem
  }, function(_ref, menuitemRef) {
    var selected2 = _ref.selected, active = _ref.active, menuitem = _objectWithoutPropertiesLoose(_ref, _excluded2$9);
    var classes = merge2(className, withClassPrefix({
      "with-icon": icon,
      active: selected2,
      disabled,
      focus: active,
      divider,
      panel
    }));
    var dataAttributes = {
      "data-event-key": eventKey
    };
    if (!isNil$1(eventKey) && typeof eventKey !== "string") {
      dataAttributes["data-event-key-type"] = typeof eventKey;
    }
    return renderDropdownItem(_extends$1({
      ref: mergeRefs(ref, menuitemRef),
      className: classes
    }, menuitem, dataAttributes, restProps, {
      children: /* @__PURE__ */ React.createElement(React.Fragment, null, icon && /* @__PURE__ */ React.cloneElement(icon, {
        className: classNames(prefix2("menu-icon"), icon.props.className)
      }), children)
    }));
  });
});
SidenavDropdownItem.displayName = "Sidenav.Dropdown.Item";
SidenavDropdownItem.propTypes = {
  as: PropTypes.elementType,
  divider: PropTypes.bool,
  panel: PropTypes.bool,
  trigger: PropTypes.oneOfType([PropTypes.array, oneOf(["click", "hover"])]),
  open: deprecatePropType(PropTypes.bool),
  active: PropTypes.bool,
  disabled: PropTypes.bool,
  pullLeft: deprecatePropType(PropTypes.bool),
  submenu: PropTypes.element,
  onSelect: PropTypes.func,
  onClick: PropTypes.func,
  icon: PropTypes.node,
  eventKey: PropTypes.any,
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node,
  classPrefix: PropTypes.string,
  tabIndex: PropTypes.number
};
var AdaptiveNavItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var nav = reactExports.useContext(NavContext);
  if (!nav) {
    throw new Error("<Nav.Item> must be rendered within a <Nav> component.");
  }
  var parentNavMenu = reactExports.useContext(NavMenuContext);
  var navbar = reactExports.useContext(NavbarContext);
  var sidenav = reactExports.useContext(SidenavContext);
  var _ref = parentNavMenu !== null && parentNavMenu !== void 0 ? parentNavMenu : [], dispatch = _ref[1];
  var _id = useInternalId("Nav.Item");
  reactExports.useEffect(function() {
    if (dispatch) {
      var _props$active;
      dispatch({
        type: NavMenuActionType.RegisterItem,
        payload: {
          _id,
          eventKey: props.eventKey,
          active: (_props$active = props.active) !== null && _props$active !== void 0 ? _props$active : false
        }
      });
      return function() {
        dispatch({
          type: NavMenuActionType.UnregisterItem,
          payload: {
            _id
          }
        });
      };
    }
  }, [dispatch, _id, props.eventKey, props.active]);
  if (parentNavMenu) {
    if (navbar) {
      return /* @__PURE__ */ React.createElement(NavbarDropdownItem, _extends$1({
        ref
      }, props));
    }
    if (sidenav) {
      return /* @__PURE__ */ React.createElement(SidenavDropdownItem, _extends$1({
        ref
      }, props));
    }
    return /* @__PURE__ */ React.createElement(NavDropdownItem, _extends$1({
      ref
    }, props));
  }
  if (navbar) {
    return /* @__PURE__ */ React.createElement(NavbarItem, _extends$1({
      ref
    }, props));
  }
  if (sidenav) {
    return /* @__PURE__ */ React.createElement(SidenavItem, _extends$1({
      ref
    }, props));
  }
  return /* @__PURE__ */ React.createElement(NavItem, _extends$1({
    ref
  }, props));
});
AdaptiveNavItem.displayName = "Nav.Item";
var _excluded$1u = ["as", "classPrefix", "appearance", "vertical", "justified", "reversed", "pullRight", "className", "children", "activeKey", "defaultActiveKey", "onSelect"];
var Nav = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "nav" : _props$classPrefix, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "default" : _props$appearance, vertical = props.vertical, justified = props.justified, reversed = props.reversed, pullRight = props.pullRight, className = props.className, children = props.children, activeKeyProp = props.activeKey, defaultActiveKey = props.defaultActiveKey, onSelectProp = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$1u);
  var sidenav = reactExports.useContext(SidenavContext);
  var navbar = reactExports.useContext(NavbarContext);
  var menubarRef = useEnsuredRef(ref);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, rootPrefix = _useClassNames.rootPrefix, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, rootPrefix({
    "navbar-nav": navbar,
    "navbar-right": pullRight,
    "sidenav-nav": sidenav
  }), withClassPrefix(appearance, {
    horizontal: navbar || !vertical && !sidenav,
    vertical: vertical || sidenav,
    justified,
    reversed
  }));
  var _ref = sidenav || {}, activeKeyFromSidenav = _ref.activeKey, onSelectFromSidenav = _ref.onSelect;
  var _useControlled = useControlled$2(activeKeyProp !== null && activeKeyProp !== void 0 ? activeKeyProp : activeKeyFromSidenav, defaultActiveKey), activeKey = _useControlled[0], setActiveKey = _useControlled[1];
  var contextValue = reactExports.useMemo(function() {
    return {
      activeKey,
      onSelect: function onSelect(eventKey, event) {
        setActiveKey(eventKey);
        onSelectProp === null || onSelectProp === void 0 ? void 0 : onSelectProp(eventKey, event);
        onSelectFromSidenav === null || onSelectFromSidenav === void 0 ? void 0 : onSelectFromSidenav(eventKey, event);
      }
    };
  }, [activeKey, onSelectFromSidenav, onSelectProp, setActiveKey]);
  if (sidenav !== null && sidenav !== void 0 && sidenav.expanded) {
    return /* @__PURE__ */ React.createElement(NavContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement("ul", _extends$1({
      ref,
      className: classes
    }, rest), children));
  }
  var hasWaterline = appearance !== "default";
  if (sidenav) {
    return /* @__PURE__ */ React.createElement(NavContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Menubar, {
      vertical: !!sidenav
    }, function(menubar, ref2) {
      return /* @__PURE__ */ React.createElement(Component, _extends$1({
        ref: ref2
      }, rest, {
        className: classes
      }, menubar), children);
    }));
  }
  return /* @__PURE__ */ React.createElement(NavContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref: menubarRef,
    className: classes
  }), children, hasWaterline && /* @__PURE__ */ React.createElement("div", {
    className: prefix2("bar")
  })));
});
var DeprecatedNavDropdown = deprecateComponent(NavDropdown, "<Nav.Dropdown> is deprecated, use <Nav.Menu> instead.");
DeprecatedNavDropdown.Menu = deprecateComponent(NavDropdownMenu, "<Nav.Dropdown.Menu> is deprecated, use <Nav.Menu> instead");
DeprecatedNavDropdown.Item = deprecateComponent(NavDropdownItem, "<Nav.Dropdown.Item> is deprecated, use <Nav.Item> instead");
Nav.Dropdown = DeprecatedNavDropdown;
Nav.Item = AdaptiveNavItem;
Nav.Menu = NavMenu;
Nav.displayName = "Nav";
Nav.propTypes = {
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  children: PropTypes.node,
  appearance: oneOf(["default", "subtle", "tabs", "pills"]),
  // Reverse Direction of tabs/subtle
  reversed: PropTypes.bool,
  justified: PropTypes.bool,
  vertical: PropTypes.bool,
  pullRight: PropTypes.bool,
  activeKey: PropTypes.any,
  onSelect: PropTypes.func
};
var _excluded$1t = ["as", "classPrefix", "className", "inverse", "backdrop", "speed", "center", "vertical", "content", "size"];
var Loader = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "loader" : _props$classPrefix, className = props.className, inverse = props.inverse, backdrop = props.backdrop, _props$speed = props.speed, speed = _props$speed === void 0 ? "normal" : _props$speed, center = props.center, vertical = props.vertical, content = props.content, size2 = props.size, rest = _objectWithoutPropertiesLoose(props, _excluded$1t);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var labelId = useUniqueId("loader-label-");
  var classes = merge2(className, prefix2("wrapper", "speed-" + speed, size2, {
    "backdrop-wrapper": backdrop,
    vertical,
    inverse,
    center
  }));
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "status",
    "aria-labelledby": content ? labelId : void 0
  }, rest, {
    ref,
    className: classes
  }), backdrop && /* @__PURE__ */ React.createElement("div", {
    className: prefix2("backdrop")
  }), /* @__PURE__ */ React.createElement("div", {
    className: withClassPrefix()
  }, /* @__PURE__ */ React.createElement("span", {
    className: prefix2("spin")
  }), content && /* @__PURE__ */ React.createElement("span", {
    id: labelId,
    className: prefix2("content")
  }, content)));
});
Loader.displayName = "Loader";
Loader.propTypes = {
  as: PropTypes.elementType,
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  center: PropTypes.bool,
  backdrop: PropTypes.bool,
  inverse: PropTypes.bool,
  vertical: PropTypes.bool,
  content: PropTypes.node,
  size: oneOf(["lg", "md", "sm", "xs"]),
  speed: oneOf(["normal", "fast", "slow", "paused"])
};
var _excluded$1s = ["as", "classPrefix", "controlId", "className"];
var FormGroupContext = /* @__PURE__ */ React.createContext({});
var useFormGroup = function useFormGroup2(controlId) {
  var context = React.useContext(FormGroupContext);
  var fallbackId = useUniqueId("rs-");
  var id2 = controlId || context.controlId || fallbackId;
  var helpTextId = id2 + "-help-text";
  var labelId = id2 + "-label";
  var errorMessageId = id2 + "-error-message";
  return {
    /**
     * The `id` of the `<Form.Control>` component.
     */
    controlId: id2,
    /**
     * The `id` of the `<Form.HelpText>` component.
     */
    helpTextId,
    /**
     * The `id` of the `<Form.ControlLabel>` component.
     */
    labelId,
    /**
     * The `id` of the `<Form.ErrorMessage>` component.
     */
    errorMessageId
  };
};
var FormGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "form-group" : _props$classPrefix, controlIdProp = props.controlId, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded$1s);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  var controlId = useUniqueId("rs-", controlIdProp);
  var contextValue = reactExports.useMemo(function() {
    return {
      controlId
    };
  }, [controlId]);
  return /* @__PURE__ */ React.createElement(FormGroupContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes,
    role: "group"
  })));
});
FormGroup.displayName = "FormGroup";
FormGroup.propTypes = {
  controlId: PropTypes.string,
  className: PropTypes.string,
  classPrefix: PropTypes.string
};
var _excluded$1r = ["as", "classPrefix", "className", "disabled"];
var InputGroupAddon = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "span" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "input-group-addon" : _props$classPrefix, className = props.className, disabled = props.disabled, rest = _objectWithoutPropertiesLoose(props, _excluded$1r);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix({
    disabled
  }));
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }));
});
InputGroupAddon.displayName = "InputGroupAddon";
InputGroupAddon.propTypes = {
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  disabled: PropTypes.bool
};
var _excluded$1q = ["classPrefix", "className"];
var InputGroupButton = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "input-group-btn" : _props$classPrefix, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded$1q);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var _useClassNames2 = useClassNames$2("input-group-addon"), withAddOnClassPrefix = _useClassNames2.withClassPrefix;
  var classes = merge2(withAddOnClassPrefix(), className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Button$1, _extends$1({}, rest, {
    ref,
    className: classes
  }));
});
InputGroupButton.displayName = "InputGroupButton";
var _excluded$1p = ["as", "classPrefix", "className", "disabled", "inside", "size", "children"];
var InputGroupContext = /* @__PURE__ */ React.createContext(null);
var InputGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "input-group" : _props$classPrefix, className = props.className, disabled = props.disabled, inside = props.inside, size2 = props.size, children = props.children, rest = _objectWithoutPropertiesLoose(props, _excluded$1p);
  var _useState = reactExports.useState(false), focus = _useState[0], setFocus = _useState[1];
  var handleFocus = reactExports.useCallback(function() {
    setFocus(true);
  }, []);
  var handleBlur = reactExports.useCallback(function() {
    setFocus(false);
  }, []);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix(size2, {
    inside,
    focus,
    disabled
  }));
  var renderChildren = reactExports.useCallback(function() {
    return React.Children.map(children, function(item) {
      if (/* @__PURE__ */ React.isValidElement(item)) {
        if (/* @__PURE__ */ React.isValidElement(item)) {
          return disabled ? /* @__PURE__ */ React.cloneElement(item, {
            disabled
          }) : item;
        }
      }
      return item;
    });
  }, [children, disabled]);
  var contextValue = reactExports.useMemo(function() {
    return {
      onFocus: handleFocus,
      onBlur: handleBlur
    };
  }, [handleFocus, handleBlur]);
  return /* @__PURE__ */ React.createElement(InputGroupContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), renderChildren()));
});
InputGroup.displayName = "InputGroup";
InputGroup.propTypes = {
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  children: PropTypes.node,
  disabled: PropTypes.bool,
  inside: PropTypes.bool,
  size: oneOf(["lg", "md", "sm", "xs"])
};
InputGroup.Addon = InputGroupAddon;
InputGroup.Button = InputGroupButton;
var _excluded$1o = ["as", "classPrefix", "className", "children", "localeKey", "placeholder"];
var Plaintext = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useCustom = useCustom("Plaintext"), locale2 = _useCustom.locale;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "plaintext" : _props$classPrefix, className = props.className, children = props.children, _props$localeKey = props.localeKey, localeKey = _props$localeKey === void 0 ? "" : _props$localeKey, _props$placeholder = props.placeholder, placeholder = _props$placeholder === void 0 ? locale2[localeKey] : _props$placeholder, rest = _objectWithoutPropertiesLoose(props, _excluded$1o);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix({
    empty: !children
  }));
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "text"
  }, rest, {
    ref,
    className: classes
  }), children ? children : placeholder);
});
Plaintext.displayName = "Plaintext";
var _excluded$1n = ["className", "classPrefix", "as", "type", "disabled", "value", "defaultValue", "inputRef", "id", "size", "htmlSize", "plaintext", "placeholder", "readOnly", "onPressEnter", "onFocus", "onBlur", "onKeyDown", "onChange"];
var Input$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "input" : _props$classPrefix, _props$as = props.as, Component = _props$as === void 0 ? "input" : _props$as, _props$type = props.type, type = _props$type === void 0 ? "text" : _props$type, disabled = props.disabled, value = props.value, defaultValue = props.defaultValue, inputRef = props.inputRef, id2 = props.id, size2 = props.size, htmlSize = props.htmlSize, plaintext = props.plaintext, placeholder = props.placeholder, readOnly = props.readOnly, onPressEnter = props.onPressEnter, onFocus = props.onFocus, onBlur = props.onBlur, onKeyDown = props.onKeyDown, onChange = props.onChange, rest = _objectWithoutPropertiesLoose(props, _excluded$1n);
  var handleKeyDown = function handleKeyDown2(event) {
    if (event.key === KEY_VALUES.ENTER) {
      onPressEnter === null || onPressEnter === void 0 ? void 0 : onPressEnter(event);
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
  };
  var handleChange = function handleChange2(event) {
    var _event$target;
    onChange === null || onChange === void 0 ? void 0 : onChange((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.value, event);
  };
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix(size2, {
    plaintext
  }));
  var inputGroupContext = reactExports.useContext(InputGroupContext);
  var _useFormGroup = useFormGroup(), controlId = _useFormGroup.controlId;
  if (plaintext) {
    return /* @__PURE__ */ React.createElement(Plaintext, {
      ref,
      localeKey: "unfilled",
      placeholder
    }, typeof value === "undefined" ? defaultValue : value);
  }
  var inputable = !disabled && !readOnly;
  var eventProps = {};
  if (inputable) {
    eventProps.onChange = handleChange;
    eventProps.onKeyDown = handleKeyDown;
    eventProps.onFocus = createChainedFunction$1(onFocus, inputGroupContext === null || inputGroupContext === void 0 ? void 0 : inputGroupContext.onFocus);
    eventProps.onBlur = createChainedFunction$1(onBlur, inputGroupContext === null || inputGroupContext === void 0 ? void 0 : inputGroupContext.onBlur);
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, eventProps, {
    ref: mergeRefs(ref, inputRef),
    className: classes,
    type,
    id: id2 || controlId,
    value,
    defaultValue,
    disabled,
    readOnly,
    size: htmlSize,
    placeholder
  }));
});
Input$1.displayName = "Input";
Input$1.propTypes = {
  type: PropTypes.string,
  as: PropTypes.elementType,
  id: PropTypes.string,
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  disabled: PropTypes.bool,
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  size: oneOf(["lg", "md", "sm", "xs"]),
  inputRef: refType$1,
  onChange: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onKeyDown: PropTypes.func,
  onPressEnter: PropTypes.func
};
var _excluded$1m = ["pickerProps", "speaker", "placement", "trigger", "id", "multiple", "popupType"];
var omitTriggerPropKeys = ["onEntered", "onExited", "onEnter", "onEntering", "onExit", "onExiting", "open", "onOpen", "defaultOpen", "onClose", "container", "containerPadding", "preventOverflow"];
var pickTriggerPropKeys = [].concat(omitTriggerPropKeys, ["disabled", "plaintext", "readOnly", "loading", "label"]);
var ComboboxContextContext = /* @__PURE__ */ React.createContext({
  popupType: "listbox"
});
var PickerToggleTrigger = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var pickerProps = props.pickerProps, speaker = props.speaker, placement = props.placement, _props$trigger = props.trigger, trigger2 = _props$trigger === void 0 ? "click" : _props$trigger, id2 = props.id, multiple = props.multiple, _props$popupType = props.popupType, popupType = _props$popupType === void 0 ? "listbox" : _props$popupType, rest = _objectWithoutPropertiesLoose(props, _excluded$1m);
  var pickerTriggerProps = pick$1(pickerProps, pickTriggerPropKeys);
  var pickerId = useUniqueId("rs-", id2);
  var _useCustom = useCustom(), rtl = _useCustom.rtl;
  return /* @__PURE__ */ React.createElement(ComboboxContextContext.Provider, {
    value: {
      id: pickerId,
      hasLabel: typeof pickerTriggerProps.label !== "undefined",
      multiple,
      popupType
    }
  }, /* @__PURE__ */ React.createElement(OverlayTrigger, _extends$1({}, pickerTriggerProps, rest, {
    disabled: pickerTriggerProps.disabled || pickerTriggerProps.loading,
    ref,
    trigger: trigger2,
    placement: placementPolyfill(placement, rtl),
    speaker
  })));
});
PickerToggleTrigger.displayName = "PickerToggleTrigger";
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var numberTag = "[object Number]";
function isNumber$1(value) {
  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
}
var isNumber_1 = isNumber$1;
const isNumber$2 = /* @__PURE__ */ getDefaultExportFromCjs(isNumber_1);
var baseFindIndex = _baseFindIndex, baseIteratee$1 = _baseIteratee, toInteger = toInteger_1;
var nativeMax = Math.max;
function findIndex$1(array, predicate, fromIndex) {
  var length2 = array == null ? 0 : array.length;
  if (!length2) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length2 + index, 0);
  }
  return baseFindIndex(array, baseIteratee$1(predicate), index);
}
var findIndex_1 = findIndex$1;
const findIndex$2 = /* @__PURE__ */ getDefaultExportFromCjs(findIndex_1);
var _excluded$1l = ["children", "className", "disableHeight", "disableWidth", "defaultHeight", "defaultWidth", "style", "onResize"];
var AutoSizer = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var children = props.children, className = props.className, disableHeight = props.disableHeight, disableWidth = props.disableWidth, defaultHeight = props.defaultHeight, defaultWidth = props.defaultWidth, style2 = props.style, onResize = props.onResize, rest = _objectWithoutPropertiesLoose(props, _excluded$1l);
  var _useState = reactExports.useState(defaultHeight || 0), height2 = _useState[0], setHeight = _useState[1];
  var _useState2 = reactExports.useState(defaultWidth || 0), width2 = _useState2[0], setWidth = _useState2[1];
  var rootRef = reactExports.useRef(null);
  var getParentNode2 = reactExports.useCallback(function() {
    var _rootRef$current;
    if ((_rootRef$current = rootRef.current) !== null && _rootRef$current !== void 0 && _rootRef$current.parentNode && rootRef.current.parentNode.ownerDocument && rootRef.current.parentNode.ownerDocument.defaultView && rootRef.current.parentNode instanceof rootRef.current.parentNode.ownerDocument.defaultView.HTMLElement) {
      return rootRef.current.parentNode;
    }
    return null;
  }, []);
  var handleResize = reactExports.useCallback(function() {
    var parentNode = getParentNode2();
    if (parentNode) {
      var offsetHeight = parentNode.offsetHeight || 0;
      var offsetWidth = parentNode.offsetWidth || 0;
      var _style = getStyle(parentNode);
      var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;
      var paddingRight = parseInt(_style.paddingRight, 10) || 0;
      var paddingTop = parseInt(_style.paddingTop, 10) || 0;
      var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;
      var newHeight = offsetHeight - paddingTop - paddingBottom;
      var newWidth = offsetWidth - paddingLeft - paddingRight;
      if (!disableHeight && height2 !== newHeight || !disableWidth && width2 !== newWidth) {
        setHeight(offsetHeight - paddingTop - paddingBottom);
        setWidth(offsetWidth - paddingLeft - paddingRight);
        onResize === null || onResize === void 0 ? void 0 : onResize({
          height: offsetHeight,
          width: offsetWidth
        });
      }
    }
  }, [disableHeight, disableWidth, getParentNode2, height2, onResize, width2]);
  useMount(handleResize);
  useElementResize(getParentNode2(), handleResize);
  var outerStyle = {
    overflow: "visible"
  };
  var childParams = {
    width: 0,
    height: 0
  };
  if (!disableHeight) {
    outerStyle.height = 0;
    childParams.height = height2;
  }
  if (!disableWidth) {
    outerStyle.width = 0;
    childParams.width = width2;
  }
  return /* @__PURE__ */ React.createElement("div", _extends$1({
    className,
    ref: mergeRefs(rootRef, ref),
    style: _extends$1({}, outerStyle, style2)
  }, rest), children(childParams));
});
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual$1(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual$1(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized2() {
    var newArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      newArgs[_i2] = arguments[_i2];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized2;
}
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now = hasNativePerformanceNow ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  var start2 = now();
  function tick() {
    if (now() - start2 >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick);
    }
  }
  var timeoutID = {
    id: requestAnimationFrame(tick)
  };
  return timeoutID;
}
var size = -1;
function getScrollbarSize$1(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (size === -1 || recalculate) {
    var div = document.createElement("div");
    var style2 = div.style;
    style2.width = "50px";
    style2.height = "50px";
    style2.overflow = "scroll";
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate) {
  if (recalculate === void 0) {
    recalculate = false;
  }
  if (cachedRTLResult === null || recalculate) {
    var outerDiv = document.createElement("div");
    var outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    var innerDiv = document.createElement("div");
    var innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}
var IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;
var defaultItemKey$1 = function defaultItemKey3(index, data) {
  return index;
};
function createListComponent(_ref) {
  var _class;
  var getItemOffset3 = _ref.getItemOffset, getEstimatedTotalSize4 = _ref.getEstimatedTotalSize, getItemSize3 = _ref.getItemSize, getOffsetForIndexAndAlignment5 = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset3 = _ref.getStartIndexForOffset, getStopIndexForStartIndex3 = _ref.getStopIndexForStartIndex, initInstanceProps5 = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps5 = _ref.validateProps;
  return _class = /* @__PURE__ */ function(_PureComponent) {
    _inheritsLoose(List3, _PureComponent);
    function List3(props) {
      var _this2;
      _this2 = _PureComponent.call(this, props) || this;
      _this2._instanceProps = initInstanceProps5(_this2.props, _assertThisInitialized(_this2));
      _this2._outerRef = void 0;
      _this2._resetIsScrollingTimeoutId = null;
      _this2.state = {
        instance: _assertThisInitialized(_this2),
        isScrolling: false,
        scrollDirection: "forward",
        scrollOffset: typeof _this2.props.initialScrollOffset === "number" ? _this2.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: false
      };
      _this2._callOnItemsRendered = void 0;
      _this2._callOnItemsRendered = memoizeOne(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {
        return _this2.props.onItemsRendered({
          overscanStartIndex,
          overscanStopIndex,
          visibleStartIndex,
          visibleStopIndex
        });
      });
      _this2._callOnScroll = void 0;
      _this2._callOnScroll = memoizeOne(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {
        return _this2.props.onScroll({
          scrollDirection,
          scrollOffset,
          scrollUpdateWasRequested
        });
      });
      _this2._getItemStyle = void 0;
      _this2._getItemStyle = function(index) {
        var _this$props = _this2.props, direction = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;
        var itemStyleCache = _this2._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);
        var style2;
        if (itemStyleCache.hasOwnProperty(index)) {
          style2 = itemStyleCache[index];
        } else {
          var _offset = getItemOffset3(_this2.props, index, _this2._instanceProps);
          var size2 = getItemSize3(_this2.props, index, _this2._instanceProps);
          var isHorizontal = direction === "horizontal" || layout === "horizontal";
          var isRtl = direction === "rtl";
          var offsetHorizontal = isHorizontal ? _offset : 0;
          itemStyleCache[index] = style2 = {
            position: "absolute",
            left: isRtl ? void 0 : offsetHorizontal,
            right: isRtl ? offsetHorizontal : void 0,
            top: !isHorizontal ? _offset : 0,
            height: !isHorizontal ? size2 : "100%",
            width: isHorizontal ? size2 : "100%"
          };
        }
        return style2;
      };
      _this2._getItemStyleCache = void 0;
      _this2._getItemStyleCache = memoizeOne(function(_, __, ___) {
        return {};
      });
      _this2._onScrollHorizontal = function(event) {
        var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft2 = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;
        _this2.setState(function(prevState) {
          if (prevState.scrollOffset === scrollLeft2) {
            return null;
          }
          var direction = _this2.props.direction;
          var scrollOffset = scrollLeft2;
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                scrollOffset = -scrollLeft2;
                break;
              case "positive-descending":
                scrollOffset = scrollWidth - clientWidth - scrollLeft2;
                break;
            }
          }
          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this2._resetIsScrollingDebounced);
      };
      _this2._onScrollVertical = function(event) {
        var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop2 = _event$currentTarget2.scrollTop;
        _this2.setState(function(prevState) {
          if (prevState.scrollOffset === scrollTop2) {
            return null;
          }
          var scrollOffset = Math.max(0, Math.min(scrollTop2, scrollHeight - clientHeight));
          return {
            isScrolling: true,
            scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
            scrollOffset,
            scrollUpdateWasRequested: false
          };
        }, _this2._resetIsScrollingDebounced);
      };
      _this2._outerRefSetter = function(ref) {
        var outerRef = _this2.props.outerRef;
        _this2._outerRef = ref;
        if (typeof outerRef === "function") {
          outerRef(ref);
        } else if (outerRef != null && typeof outerRef === "object" && outerRef.hasOwnProperty("current")) {
          outerRef.current = ref;
        }
      };
      _this2._resetIsScrollingDebounced = function() {
        if (_this2._resetIsScrollingTimeoutId !== null) {
          cancelTimeout(_this2._resetIsScrollingTimeoutId);
        }
        _this2._resetIsScrollingTimeoutId = requestTimeout(_this2._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);
      };
      _this2._resetIsScrolling = function() {
        _this2._resetIsScrollingTimeoutId = null;
        _this2.setState({
          isScrolling: false
        }, function() {
          _this2._getItemStyleCache(-1, null);
        });
      };
      return _this2;
    }
    List3.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      validateSharedProps$1(nextProps, prevState);
      validateProps5(nextProps);
      return null;
    };
    var _proto = List3.prototype;
    _proto.scrollTo = function scrollTo3(scrollOffset) {
      scrollOffset = Math.max(0, scrollOffset);
      this.setState(function(prevState) {
        if (prevState.scrollOffset === scrollOffset) {
          return null;
        }
        return {
          scrollDirection: prevState.scrollOffset < scrollOffset ? "forward" : "backward",
          scrollOffset,
          scrollUpdateWasRequested: true
        };
      }, this._resetIsScrollingDebounced);
    };
    _proto.scrollToItem = function scrollToItem(index, align) {
      if (align === void 0) {
        align = "auto";
      }
      var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;
      var scrollOffset = this.state.scrollOffset;
      index = Math.max(0, Math.min(index, itemCount - 1));
      var scrollbarSize = 0;
      if (this._outerRef) {
        var outerRef = this._outerRef;
        if (layout === "vertical") {
          scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize$1() : 0;
        } else {
          scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize$1() : 0;
        }
      }
      this.scrollTo(getOffsetForIndexAndAlignment5(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this$props3 = this.props, direction = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;
      if (typeof initialScrollOffset === "number" && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout === "horizontal") {
          outerRef.scrollLeft = initialScrollOffset;
        } else {
          outerRef.scrollTop = initialScrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var _this$props4 = this.props, direction = _this$props4.direction, layout = _this$props4.layout;
      var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;
      if (scrollUpdateWasRequested && this._outerRef != null) {
        var outerRef = this._outerRef;
        if (direction === "horizontal" || layout === "horizontal") {
          if (direction === "rtl") {
            switch (getRTLOffsetType()) {
              case "negative":
                outerRef.scrollLeft = -scrollOffset;
                break;
              case "positive-ascending":
                outerRef.scrollLeft = scrollOffset;
                break;
              default:
                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;
                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                break;
            }
          } else {
            outerRef.scrollLeft = scrollOffset;
          }
        } else {
          outerRef.scrollTop = scrollOffset;
        }
      }
      this._callPropsCallbacks();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this._resetIsScrollingTimeoutId !== null) {
        cancelTimeout(this._resetIsScrollingTimeoutId);
      }
    };
    _proto.render = function render2() {
      var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction = _this$props5.direction, height2 = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style2 = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width2 = _this$props5.width;
      var isScrolling = this.state.isScrolling;
      var isHorizontal = direction === "horizontal" || layout === "horizontal";
      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;
      var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];
      var items = [];
      if (itemCount > 0) {
        for (var _index = startIndex; _index <= stopIndex; _index++) {
          items.push(reactExports.createElement(children, {
            data: itemData,
            key: itemKey(_index, itemData),
            index: _index,
            isScrolling: useIsScrolling ? isScrolling : void 0,
            style: this._getItemStyle(_index)
          }));
        }
      }
      var estimatedTotalSize = getEstimatedTotalSize4(this.props, this._instanceProps);
      return reactExports.createElement(outerElementType || outerTagName || "div", {
        className,
        onScroll,
        ref: this._outerRefSetter,
        style: _extends$1({
          position: "relative",
          height: height2,
          width: width2,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction
        }, style2)
      }, reactExports.createElement(innerElementType || innerTagName || "div", {
        children: items,
        ref: innerRef,
        style: {
          height: isHorizontal ? "100%" : estimatedTotalSize,
          pointerEvents: isScrolling ? "none" : void 0,
          width: isHorizontal ? estimatedTotalSize : "100%"
        }
      }));
    };
    _proto._callPropsCallbacks = function _callPropsCallbacks() {
      if (typeof this.props.onItemsRendered === "function") {
        var itemCount = this.props.itemCount;
        if (itemCount > 0) {
          var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];
          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);
        }
      }
      if (typeof this.props.onScroll === "function") {
        var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;
        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);
      }
    };
    _proto._getRangeToRender = function _getRangeToRender() {
      var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;
      var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;
      if (itemCount === 0) {
        return [0, 0, 0, 0];
      }
      var startIndex = getStartIndexForOffset3(this.props, scrollOffset, this._instanceProps);
      var stopIndex = getStopIndexForStartIndex3(this.props, startIndex, scrollOffset, this._instanceProps);
      var overscanBackward = !isScrolling || scrollDirection === "backward" ? Math.max(1, overscanCount) : 1;
      var overscanForward = !isScrolling || scrollDirection === "forward" ? Math.max(1, overscanCount) : 1;
      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];
    };
    return List3;
  }(reactExports.PureComponent), _class.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: false
  }, _class;
}
var validateSharedProps$1 = function validateSharedProps3(_ref2, _ref3) {
  _ref2.children;
  _ref2.direction;
  _ref2.height;
  _ref2.layout;
  _ref2.innerTagName;
  _ref2.outerTagName;
  _ref2.width;
  _ref3.instance;
};
var DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;
var getItemMetadata$1 = function getItemMetadata3(props, index, instanceProps) {
  var _ref = props, itemSize = _ref.itemSize;
  var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  if (index > lastMeasuredIndex) {
    var offset2 = 0;
    if (lastMeasuredIndex >= 0) {
      var itemMetadata = itemMetadataMap[lastMeasuredIndex];
      offset2 = itemMetadata.offset + itemMetadata.size;
    }
    for (var i2 = lastMeasuredIndex + 1; i2 <= index; i2++) {
      var size2 = itemSize(i2);
      itemMetadataMap[i2] = {
        offset: offset2,
        size: size2
      };
      offset2 += size2;
    }
    instanceProps.lastMeasuredIndex = index;
  }
  return itemMetadataMap[index];
};
var findNearestItem$1 = function findNearestItem3(props, instanceProps, offset2) {
  var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;
  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;
  if (lastMeasuredItemOffset >= offset2) {
    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset2);
  } else {
    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset2);
  }
};
var findNearestItemBinarySearch$1 = function findNearestItemBinarySearch3(props, instanceProps, high, low, offset2) {
  while (low <= high) {
    var middle = low + Math.floor((high - low) / 2);
    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;
    if (currentOffset === offset2) {
      return middle;
    } else if (currentOffset < offset2) {
      low = middle + 1;
    } else if (currentOffset > offset2) {
      high = middle - 1;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
var findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch3(props, instanceProps, index, offset2) {
  var itemCount = props.itemCount;
  var interval = 1;
  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset2) {
    index += interval;
    interval *= 2;
  }
  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset2);
};
var getEstimatedTotalSize = function getEstimatedTotalSize2(_ref2, _ref3) {
  var itemCount = _ref2.itemCount;
  var itemMetadataMap = _ref3.itemMetadataMap, estimatedItemSize = _ref3.estimatedItemSize, lastMeasuredIndex = _ref3.lastMeasuredIndex;
  var totalSizeOfMeasuredItems = 0;
  if (lastMeasuredIndex >= itemCount) {
    lastMeasuredIndex = itemCount - 1;
  }
  if (lastMeasuredIndex >= 0) {
    var itemMetadata = itemMetadataMap[lastMeasuredIndex];
    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;
  }
  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;
  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;
  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
};
var VariableSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: function getItemOffset(props, index, instanceProps) {
    return getItemMetadata$1(props, index, instanceProps).offset;
  },
  getItemSize: function getItemSize(props, index, instanceProps) {
    return instanceProps.itemMetadataMap[index].size;
  },
  getEstimatedTotalSize,
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment3(props, index, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction = props.direction, height2 = props.height, layout = props.layout, width2 = props.width;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width2 : height2;
    var itemMetadata = getItemMetadata$1(props, index, instanceProps);
    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);
    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size2, itemMetadata.offset));
    var minOffset = Math.max(0, itemMetadata.offset - size2 + itemMetadata.size + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        return Math.round(minOffset + (maxOffset - minOffset) / 2);
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset(props, offset2, instanceProps) {
    return findNearestItem$1(props, instanceProps, offset2);
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {
    var direction = props.direction, height2 = props.height, itemCount = props.itemCount, layout = props.layout, width2 = props.width;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width2 : height2;
    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);
    var maxOffset = scrollOffset + size2;
    var offset2 = itemMetadata.offset + itemMetadata.size;
    var stopIndex = startIndex;
    while (stopIndex < itemCount - 1 && offset2 < maxOffset) {
      stopIndex++;
      offset2 += getItemMetadata$1(props, stopIndex, instanceProps).size;
    }
    return stopIndex;
  },
  initInstanceProps: function initInstanceProps2(props, instance) {
    var _ref4 = props, estimatedItemSize = _ref4.estimatedItemSize;
    var instanceProps = {
      itemMetadataMap: {},
      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,
      lastMeasuredIndex: -1
    };
    instance.resetAfterIndex = function(index, shouldForceUpdate) {
      if (shouldForceUpdate === void 0) {
        shouldForceUpdate = true;
      }
      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1);
      instance._getItemStyleCache(-1);
      if (shouldForceUpdate) {
        instance.forceUpdate();
      }
    };
    return instanceProps;
  },
  shouldResetStyleCacheOnItemSizeChange: false,
  validateProps: function validateProps2(_ref5) {
    _ref5.itemSize;
  }
});
var FixedSizeList = /* @__PURE__ */ createListComponent({
  getItemOffset: function getItemOffset2(_ref, index) {
    var itemSize = _ref.itemSize;
    return index * itemSize;
  },
  getItemSize: function getItemSize2(_ref2, index) {
    var itemSize = _ref2.itemSize;
    return itemSize;
  },
  getEstimatedTotalSize: function getEstimatedTotalSize3(_ref3) {
    var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;
    return itemSize * itemCount;
  },
  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment4(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {
    var direction = _ref4.direction, height2 = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout = _ref4.layout, width2 = _ref4.width;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var size2 = isHorizontal ? width2 : height2;
    var lastItemOffset = Math.max(0, itemCount * itemSize - size2);
    var maxOffset = Math.min(lastItemOffset, index * itemSize);
    var minOffset = Math.max(0, index * itemSize - size2 + itemSize + scrollbarSize);
    if (align === "smart") {
      if (scrollOffset >= minOffset - size2 && scrollOffset <= maxOffset + size2) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center": {
        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
        if (middleOffset < Math.ceil(size2 / 2)) {
          return 0;
        } else if (middleOffset > lastItemOffset + Math.floor(size2 / 2)) {
          return lastItemOffset;
        } else {
          return middleOffset;
        }
      }
      case "auto":
      default:
        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
          return scrollOffset;
        } else if (scrollOffset < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getStartIndexForOffset: function getStartIndexForOffset2(_ref5, offset2) {
    var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;
    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset2 / itemSize)));
  },
  getStopIndexForStartIndex: function getStopIndexForStartIndex2(_ref6, startIndex, scrollOffset) {
    var direction = _ref6.direction, height2 = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout = _ref6.layout, width2 = _ref6.width;
    var isHorizontal = direction === "horizontal" || layout === "horizontal";
    var offset2 = startIndex * itemSize;
    var size2 = isHorizontal ? width2 : height2;
    var numVisibleItems = Math.ceil((size2 + scrollOffset - offset2) / itemSize);
    return Math.max(0, Math.min(
      itemCount - 1,
      startIndex + numVisibleItems - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function initInstanceProps4(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: function validateProps4(_ref7) {
    _ref7.itemSize;
  }
});
function getScrollState(target) {
  var scrollTop2 = target.scrollTop;
  var scrollHeight = target.scrollHeight;
  var clientHeight = target.clientHeight;
  if (scrollHeight <= clientHeight) {
    return null;
  } else if (scrollTop2 === 0) {
    return "top";
  } else if (scrollTop2 + clientHeight === scrollHeight) {
    return "bottom";
  } else {
    return "middle";
  }
}
function useScrollState(scrollShadow) {
  var bodyRef = reactExports.useRef(null);
  var _useState = reactExports.useState(null), scrollState = _useState[0], setScrollState = _useState[1];
  useMount(function() {
    var observer;
    if (bodyRef.current && scrollShadow) {
      var target = bodyRef.current;
      setScrollState(getScrollState(target));
      var lastScrollHeight = target.scrollHeight;
      observer = new MutationObserver(function() {
        var newScrollHeight = target === null || target === void 0 ? void 0 : target.scrollHeight;
        if (newScrollHeight && newScrollHeight !== lastScrollHeight) {
          setScrollState(getScrollState(target));
          lastScrollHeight = newScrollHeight;
        }
      });
      observer.observe(target, {
        attributes: true,
        childList: true,
        subtree: true
      });
    }
    return function() {
      var _observer;
      (_observer = observer) === null || _observer === void 0 ? void 0 : _observer.disconnect();
    };
  });
  var handleScroll = useEventCallback$2(function(event) {
    var target = event.currentTarget;
    setScrollState(getScrollState(target));
  });
  return {
    scrollState,
    handleScroll: scrollShadow ? handleScroll : void 0,
    bodyRef
  };
}
var _excluded$1k = ["as", "classPrefix", "className", "children", "scrollShadow", "customScrollbar", "height", "width", "style", "onScroll", "data-testid"];
var ScrollView = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "scroll-view" : _props$classPrefix, className = props.className, children = props.children, scrollShadow = props.scrollShadow, customScrollbar = props.customScrollbar, height2 = props.height, width2 = props.width, style2 = props.style, onScroll = props.onScroll, dataTestId = props["data-testid"], rest = _objectWithoutPropertiesLoose(props, _excluded$1k);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var _useScrollState = useScrollState(scrollShadow), scrollState = _useScrollState.scrollState, handleScroll = _useScrollState.handleScroll, bodyRef = _useScrollState.bodyRef;
  var bodyStyles = _extends$1({
    height: height2,
    width: width2
  }, style2);
  var bodyClasses = merge2(className, withClassPrefix({
    shadow: scrollShadow,
    "thumb-top": scrollState === "top",
    "thumb-middle": scrollState === "middle",
    "thumb-bottom": scrollState === "bottom",
    "custom-scrollbar": customScrollbar
  }));
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref: mergeRefs(ref, bodyRef),
    className: bodyClasses,
    style: bodyStyles,
    onScroll: createChainedFunction$1(handleScroll, onScroll),
    "data-testid": dataTestId || "scroll-view"
  }), children);
});
ScrollView.displayName = "ScrollView";
var _excluded$1j = ["rowHeight", "as", "itemSize", "scrollShadow"];
var OuterElementType = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ React.createElement(ScrollView, _extends$1({
    scrollShadow: true,
    ref
  }, props));
});
var List$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var rowHeight = props.rowHeight, _props$as = props.as, Component = _props$as === void 0 ? VariableSizeList : _props$as, itemSizeProp = props.itemSize, scrollShadow = props.scrollShadow, rest = _objectWithoutPropertiesLoose(props, _excluded$1j);
  var listRef = reactExports.useRef(null);
  var _useCustom = useCustom(), rtl = _useCustom.rtl;
  reactExports.useImperativeHandle(ref, function() {
    return {
      resetAfterIndex: function resetAfterIndex(index, shouldForceUpdate) {
        var _listRef$current, _listRef$current$rese;
        (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : (_listRef$current$rese = _listRef$current.resetAfterIndex) === null || _listRef$current$rese === void 0 ? void 0 : _listRef$current$rese.call(_listRef$current, index, shouldForceUpdate);
      },
      scrollTo: function scrollTo3(scrollOffset) {
        var _listRef$current2, _listRef$current2$scr;
        (_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 ? void 0 : (_listRef$current2$scr = _listRef$current2.scrollTo) === null || _listRef$current2$scr === void 0 ? void 0 : _listRef$current2$scr.call(_listRef$current2, scrollOffset);
      },
      scrollToItem: function scrollToItem(index, align) {
        var _listRef$current3, _listRef$current3$scr;
        (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 ? void 0 : (_listRef$current3$scr = _listRef$current3.scrollToItem) === null || _listRef$current3$scr === void 0 ? void 0 : _listRef$current3$scr.call(_listRef$current3, index, align);
      },
      scrollToRow: function scrollToRow(index) {
        var _listRef$current4, _listRef$current4$scr;
        (_listRef$current4 = listRef.current) === null || _listRef$current4 === void 0 ? void 0 : (_listRef$current4$scr = _listRef$current4.scrollToItem) === null || _listRef$current4$scr === void 0 ? void 0 : _listRef$current4$scr.call(_listRef$current4, index);
      }
    };
  });
  var setRowHeight = reactExports.useCallback(function(index) {
    return typeof rowHeight === "function" ? rowHeight({
      index
    }) : rowHeight || 0;
  }, [rowHeight]);
  var itemSize = reactExports.useMemo(function() {
    if (typeof itemSizeProp === "function") return itemSizeProp;
    return function() {
      return itemSizeProp;
    };
  }, [itemSizeProp]);
  var compatibleProps = _extends$1({
    itemSize
  }, rest);
  if (rowHeight) {
    compatibleProps.itemSize = Component === VariableSizeList ? setRowHeight : rowHeight;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref: listRef,
    direction: rtl ? "rtl" : "ltr"
  }, compatibleProps, {
    outerElementType: scrollShadow ? OuterElementType : void 0
  }));
});
var ArrowDown$3 = {};
var ArrowDown$2 = { exports: {} };
var ArrowDown$1 = {};
var hasRequiredArrowDown;
function requireArrowDown() {
  if (hasRequiredArrowDown) return ArrowDown$1;
  hasRequiredArrowDown = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function ArrowDown2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 14 14",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M0 3.5l7 7 7-7z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(ArrowDown2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(ArrowDown$1);
  return ArrowDown$1;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _ArrowDown = _interopRequireDefault2(requireArrowDown());
  var ArrowDown2 = (0, _createSvgIcon2["default"])({
    as: _ArrowDown["default"],
    ariaLabel: "arrow down",
    category: "legacy",
    displayName: "ArrowDown"
  });
  var _default = ArrowDown2;
  exports["default"] = _default;
  module.exports = exports.default;
})(ArrowDown$2, ArrowDown$2.exports);
var ArrowDownExports = ArrowDown$2.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _ArrowDown["default"];
    }
  });
  var _ArrowDown = _interopRequireDefault2(ArrowDownExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(ArrowDown$3);
const ArrowDown = /* @__PURE__ */ getDefaultExportFromCjs(ArrowDown$3);
var _templateObject$8, _templateObject2$3;
var _excluded$1i = ["as", "classPrefix", "children", "className"];
var ListItemGroup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-menu-group" : _props$classPrefix, children = props.children, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded$1i);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "group"
  }, rest, {
    ref,
    className: classes
  }), /* @__PURE__ */ React.createElement("div", {
    className: prefix2(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteralLoose(["title"]))),
    tabIndex: -1
  }, /* @__PURE__ */ React.createElement("span", null, children), /* @__PURE__ */ React.createElement(ArrowDown, {
    "aria-hidden": true,
    className: prefix2(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteralLoose(["caret"])))
  })));
});
ListItemGroup.displayName = "ListItemGroup";
function useCombobox() {
  var _useContext = reactExports.useContext(ComboboxContextContext), id2 = _useContext.id, hasLabel = _useContext.hasLabel, popupType = _useContext.popupType, multiple = _useContext.multiple;
  return {
    id: id2,
    popupType,
    multiple,
    labelId: hasLabel ? id2 + "-label" : void 0
  };
}
var _excluded$1h = ["data", "groupBy", "maxHeight", "activeItemValues", "disabledItemValues", "classPrefix", "valueKey", "labelKey", "virtualized", "listProps", "listRef", "className", "style", "focusItemValue", "listItemClassPrefix", "listItemAs", "listItemProps", "rowHeight", "rowGroupHeight", "query", "renderMenuGroup", "renderMenuItem", "onGroupTitleClick", "onSelect"];
var _this = void 0;
var Listbox = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, groupBy2 = props.groupBy, _props$maxHeight = props.maxHeight, maxHeight2 = _props$maxHeight === void 0 ? 320 : _props$maxHeight, _props$activeItemValu = props.activeItemValues, activeItemValues = _props$activeItemValu === void 0 ? [] : _props$activeItemValu, _props$disabledItemVa = props.disabledItemValues, disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "listbox" : _props$classPrefix, _props$valueKey = props.valueKey, valueKey = _props$valueKey === void 0 ? "value" : _props$valueKey, _props$labelKey = props.labelKey, labelKey = _props$labelKey === void 0 ? "label" : _props$labelKey, virtualized = props.virtualized, listProps = props.listProps, virtualizedListRef = props.listRef, className = props.className, style2 = props.style, focusItemValue = props.focusItemValue, listItemClassPrefix = props.listItemClassPrefix, ListItem3 = props.listItemAs, listItemProps = props.listItemProps, _props$rowHeight = props.rowHeight, rowHeight = _props$rowHeight === void 0 ? 36 : _props$rowHeight, _props$rowGroupHeight = props.rowGroupHeight, rowGroupHeight = _props$rowGroupHeight === void 0 ? 48 : _props$rowGroupHeight, query = props.query, renderMenuGroup = props.renderMenuGroup, renderMenuItem = props.renderMenuItem, onGroupTitleClick = props.onGroupTitleClick, onSelect = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$1h);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var groupable = typeof groupBy2 !== "undefined";
  var classes = merge2(className, withClassPrefix("items", {
    grouped: groupable
  }));
  var _useCombobox = useCombobox(), id2 = _useCombobox.id, labelId = _useCombobox.labelId, popupType = _useCombobox.popupType, multiple = _useCombobox.multiple;
  var menuBodyContainerRef = reactExports.useRef(null);
  var listRef = reactExports.useRef(null);
  var _useState = reactExports.useState([]), foldedGroupKeys = _useState[0], setFoldedGroupKeys = _useState[1];
  var handleGroupTitleClick = useEventCallback$2(function(key, event) {
    var nextGroupKeys = foldedGroupKeys.filter(function(item) {
      return item !== key;
    });
    if (nextGroupKeys.length === foldedGroupKeys.length) {
      nextGroupKeys.push(key);
    }
    setFoldedGroupKeys(nextGroupKeys);
    onGroupTitleClick === null || onGroupTitleClick === void 0 ? void 0 : onGroupTitleClick(event);
  });
  var handleSelect = useEventCallback$2(function(item, value, event, checked) {
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, item, event, checked);
  });
  var getRowHeight = function getRowHeight2(list, index) {
    var item = list[index];
    if (groupable && item[RSUITE_PICKER_GROUP_KEY] && index !== 0) {
      return rowGroupHeight;
    }
    return rowHeight;
  };
  reactExports.useEffect(function() {
    var container = menuBodyContainerRef.current;
    if (!container) {
      return;
    }
    var activeItem = container.querySelector("." + prefix2("item-focus"));
    if (!activeItem) {
      activeItem = container.querySelector("." + prefix2("item-active"));
    }
    if (!activeItem) {
      return;
    }
    var position2 = getPosition$1(activeItem, container);
    var sTop = scrollTop(container);
    var sHeight = getHeight(container);
    if (sTop > position2.top) {
      scrollTop(container, Math.max(0, position2.top - 20));
    } else if (position2.top > sTop + sHeight) {
      scrollTop(container, Math.max(0, position2.top - sHeight + 32));
    }
  }, [focusItemValue, menuBodyContainerRef, prefix2]);
  var filteredItems = groupable ? data.filter(function(item) {
    var _item$parent;
    if (item[RSUITE_PICKER_GROUP_KEY]) return true;
    var groupValue = get$4(item, groupBy2, "") || // FIXME-Doma
    // Usage of `item.parent` is strongly discouraged
    // It's only here for legacy support
    // Remove once `item.parent` is completely removed across related components
    ((_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent[KEY_GROUP_TITLE]);
    return !foldedGroupKeys.includes(groupValue);
  }) : data;
  var rowCount = filteredItems.length;
  var renderItem = function renderItem2(_ref) {
    var _ref$index = _ref.index, index = _ref$index === void 0 ? 0 : _ref$index, style3 = _ref.style, data2 = _ref.data, itemData = _ref.item;
    var item = itemData || data2[index];
    var value = item[valueKey];
    var itemLabel = item[labelKey];
    var label = query ? /* @__PURE__ */ React.createElement(Highlight, {
      query,
      as: "span"
    }, itemLabel) : itemLabel;
    if (isUndefined$2(label) && !item[RSUITE_PICKER_GROUP_KEY]) {
      throw Error('labelKey "' + labelKey + '" is not defined in "data" : ' + index);
    }
    var itemKey = isString$3(value) || isNumber$2(value) ? value : index;
    if (groupable && item[RSUITE_PICKER_GROUP_KEY]) {
      var groupValue = item[KEY_GROUP_TITLE];
      return /* @__PURE__ */ React.createElement(ListItemGroup, {
        style: style3,
        classPrefix: "picker-menu-group",
        className: classNames({
          folded: foldedGroupKeys.some(function(key) {
            return key === groupValue;
          })
        }),
        key: "group-" + groupValue,
        onClick: handleGroupTitleClick.bind(null, groupValue)
      }, renderMenuGroup ? renderMenuGroup(groupValue, item) : groupValue);
    } else if (isUndefined$2(value) && !isUndefined$2(item[RSUITE_PICKER_GROUP_KEY])) {
      throw Error('valueKey "' + valueKey + '" is not defined in "data" : ' + index + " ");
    }
    var disabled = disabledItemValues === null || disabledItemValues === void 0 ? void 0 : disabledItemValues.some(function(disabledValue) {
      return shallowEqual(disabledValue, value);
    });
    var active = activeItemValues === null || activeItemValues === void 0 ? void 0 : activeItemValues.some(function(v2) {
      return shallowEqual(v2, value);
    });
    var focus = !isUndefined$2(focusItemValue) && shallowEqual(focusItemValue, value);
    return /* @__PURE__ */ React.createElement(ListItem3, _extends$1({
      "aria-posinset": index + 1,
      "aria-setsize": rowCount,
      style: style3,
      key: itemKey,
      disabled,
      active,
      focus,
      value,
      classPrefix: listItemClassPrefix,
      onSelect: handleSelect.bind(null, item)
    }, pickBy$2(listItemProps, function(v2) {
      return v2 !== void 0;
    })), renderMenuItem ? renderMenuItem(label, item) : label);
  };
  useMount(function() {
    var _listRef$current, _listRef$current$scro;
    var itemIndex = findIndex$2(filteredItems, function(item) {
      return item[valueKey] === (activeItemValues === null || activeItemValues === void 0 ? void 0 : activeItemValues[0]);
    });
    (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : (_listRef$current$scro = _listRef$current.scrollToItem) === null || _listRef$current$scro === void 0 ? void 0 : _listRef$current$scro.call(_listRef$current, itemIndex);
  });
  return /* @__PURE__ */ React.createElement("div", _extends$1({
    role: "listbox",
    id: id2 + "-" + popupType,
    "aria-labelledby": labelId,
    "aria-multiselectable": multiple
  }, rest, {
    className: classes,
    ref: mergeRefs(menuBodyContainerRef, ref),
    style: _extends$1({}, style2, {
      maxHeight: maxHeight2
    })
  }), virtualized ? /* @__PURE__ */ React.createElement(AutoSizer, {
    defaultHeight: maxHeight2,
    style: {
      width: "auto",
      height: "auto"
    }
  }, function(_ref2) {
    var height2 = _ref2.height;
    return /* @__PURE__ */ React.createElement(List$1, _extends$1({
      as: VariableSizeList,
      ref: mergeRefs(listRef, virtualizedListRef),
      height: height2 || maxHeight2,
      itemCount: rowCount,
      itemData: filteredItems,
      itemSize: getRowHeight.bind(_this, filteredItems)
    }, listProps), renderItem);
  }) : filteredItems.map(function(item, index) {
    return renderItem({
      index,
      item
    });
  }));
});
Listbox.displayName = "Listbox";
var _templateObject$7;
var _excluded$1g = ["as", "role", "classPrefix", "active", "children", "className", "disabled", "focus", "value", "onKeyDown", "onSelect", "renderItem"];
var ListItem$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$role = props.role, role = _props$role === void 0 ? "option" : _props$role, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "dropdown-menu-item" : _props$classPrefix, active = props.active, children = props.children, className = props.className, disabled = props.disabled, focus = props.focus, value = props.value, onKeyDown = props.onKeyDown, onSelect = props.onSelect, renderItem = props.renderItem, rest = _objectWithoutPropertiesLoose(props, _excluded$1g);
  var _useCombobox = useCombobox(), id2 = _useCombobox.id;
  var handleClick = useEventCallback$2(function(event) {
    event.preventDefault();
    if (!disabled) {
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, event);
    }
  });
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, rootPrefix = _useClassNames.rootPrefix;
  var classes = withClassPrefix({
    active,
    focus,
    disabled
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role,
    "aria-selected": active,
    "aria-disabled": disabled,
    id: id2 ? id2 + "-opt-" + value : void 0,
    "data-key": value
  }, rest, {
    ref,
    className: merge2(className, rootPrefix(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteralLoose(["picker-list-item"])))),
    tabIndex: -1,
    onKeyDown: disabled ? null : onKeyDown,
    onClick: handleClick
  }), /* @__PURE__ */ React.createElement("span", {
    className: classes
  }, renderItem ? renderItem(value) : children));
});
ListItem$1.displayName = "ListItem";
var _excluded$1f = ["as", "classPrefix", "autoWidth", "className", "placement", "target"];
var omitProps = ["placement", "arrowOffsetLeft", "arrowOffsetTop", "positionLeft", "positionTop", "getPositionInstance", "getToggleInstance", "autoWidth"];
var resizePlacement = ["topStart", "topEnd", "leftEnd", "rightEnd", "auto", "autoVerticalStart", "autoVerticalEnd", "autoHorizontalEnd"];
var PickerPopup = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "picker-popup" : _props$classPrefix, autoWidth = props.autoWidth, className = props.className, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, target = props.target, rest = _objectWithoutPropertiesLoose(props, _excluded$1f);
  var overlayRef = reactExports.useRef(null);
  var handleResize = useEventCallback$2(function() {
    var instance = target === null || target === void 0 ? void 0 : target.current;
    if (instance && resizePlacement.includes(placement)) {
      instance.updatePosition();
    }
  });
  useElementResize(reactExports.useCallback(function() {
    return overlayRef.current;
  }, []), handleResize);
  reactExports.useEffect(function() {
    var toggle = target === null || target === void 0 ? void 0 : target.current;
    if (autoWidth && toggle !== null && toggle !== void 0 && toggle.root) {
      var width2 = getWidth(getDOMNode(toggle.root));
      if (overlayRef.current) {
        addStyle(overlayRef.current, "min-width", width2 + "px");
      }
    }
  }, [autoWidth, target, overlayRef]);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    "data-testid": "picker-popup"
  }, omit$1(rest, omitProps), {
    ref: mergeRefs(overlayRef, ref),
    className: classes
  }));
});
PickerPopup.displayName = "PickerPopup";
var ToggleButton = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  return /* @__PURE__ */ React.createElement(Button$1, _extends$1({}, props, {
    ref,
    as: "div",
    ripple: false
  }));
});
ToggleButton.displayName = "ToggleButton";
var globalKey = "rs-";
var getClassNamePrefix2 = function getClassNamePrefix3() {
  return globalKey;
};
var defaultClassPrefix = function defaultClassPrefix2(name) {
  return name ? "" + getClassNamePrefix2() + name : void 0;
};
var prefix$2 = curry$1(function(pre, className) {
  if (!pre || !className) {
    return "";
  }
  if (Array.isArray(className)) {
    return classNames(className.filter(function(name) {
      return !!name;
    }).map(function(name) {
      return pre + "-" + name;
    }));
  }
  return pre + "-" + className;
});
function useClassNames(componentClassName) {
  var className = defaultClassPrefix("icon");
  var addPrefix = reactExports.useCallback(function(blockClassName) {
    return prefix$2(className, blockClassName);
  }, []);
  return [classNames(className, defaultClassPrefix(componentClassName)), addPrefix];
}
var insertCssExports = requireInsertCss();
var prefix$1 = getClassNamePrefix2();
var styles$4 = "." + prefix$1 + "icon {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  vertical-align: middle;\n}\n." + prefix$1 + "icon[tabindex] {\n  cursor: pointer;\n}\n." + prefix$1 + "icon-spin {\n  -webkit-animation: icon-spin 2s infinite linear;\n          animation: icon-spin 2s infinite linear;\n}\n." + prefix$1 + "icon-pulse {\n  -webkit-animation: icon-spin 1s infinite steps(8);\n          animation: icon-spin 1s infinite steps(8);\n}\n." + prefix$1 + "icon-flip-horizontal {\n  -webkit-transform: scaleX(-1);\n      -ms-transform: scaleX(-1);\n          transform: scaleX(-1);\n}\n." + prefix$1 + "icon-flip-vertical {\n  -webkit-transform: scaleY(-1);\n      -ms-transform: scaleY(-1);\n          transform: scaleY(-1);\n}\n@-webkit-keyframes icon-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n            transform: rotate(359deg);\n  }\n}\n@keyframes icon-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n            transform: rotate(359deg);\n  }\n}";
var cssInjected = false;
var useInsertStyles = function useInsertStyles2(styleStr) {
  if (styleStr === void 0) {
    styleStr = styles$4;
  }
  reactExports.useEffect(function() {
    if (!cssInjected) {
      insertCssExports.insertCss(styleStr, {
        prepend: true
      });
      cssInjected = true;
    }
  }, []);
};
var defaultProps$1 = {
  as: "svg",
  fill: "currentColor",
  width: "1em",
  height: "1em"
};
function filterProps(props) {
  var nextProps = {};
  Object.entries(props).forEach(function(_ref) {
    var key = _ref[0], value = _ref[1];
    if (typeof value !== "undefined") {
      nextProps[key] = value;
    }
  });
  return nextProps;
}
var Icon = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _classNames;
  var Component = props.as, spin = props.spin, pulse = props.pulse, flip2 = props.flip, fill = props.fill, className = props.className, rotate = props.rotate, children = props.children, viewBox = props.viewBox, width2 = props.width, height2 = props.height, style2 = props.style, rest = _objectWithoutPropertiesLoose(props, ["as", "spin", "pulse", "flip", "fill", "className", "rotate", "children", "viewBox", "width", "height", "style"]);
  var _useClassNames = useClassNames(), componentClassName = _useClassNames[0], addPrefix = _useClassNames[1];
  var classes = classNames(className, componentClassName, (_classNames = {}, _classNames[addPrefix("spin")] = spin, _classNames[addPrefix("pulse")] = pulse, _classNames[addPrefix("flip-" + flip2)] = !!flip2, _classNames));
  var rotateStyles = {
    msTransform: "rotate(" + rotate + "deg)",
    transform: "rotate(" + rotate + "deg)"
  };
  useInsertStyles();
  var svgProps = filterProps({
    width: width2,
    height: height2,
    fill,
    viewBox,
    className: classes,
    style: rotate ? _extends$1({}, rotateStyles, style2) : style2
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    "aria-hidden": true,
    focusable: false,
    ref
  }, svgProps, rest), children);
});
Icon.displayName = "Icon";
Icon.defaultProps = defaultProps$1;
Icon.propTypes = {
  spin: PropTypes.bool,
  pulse: PropTypes.bool,
  rotate: PropTypes.number,
  viewBox: PropTypes.string,
  as: PropTypes.oneOfType([PropTypes.elementType, PropTypes.string]),
  flip: PropTypes.oneOf(["horizontal", "vertical"]),
  fill: PropTypes.string
};
var PickerIndicator = function PickerIndicator2(_ref) {
  var loading = _ref.loading, caretAs = _ref.caretAs, onClose = _ref.onClose, showCleanButton = _ref.showCleanButton, _ref$as = _ref.as, Component = _ref$as === void 0 ? InputGroup.Addon : _ref$as, disabled = _ref.disabled;
  var _useCustom = useCustom(), locale2 = _useCustom.locale;
  var _useClassNames = useClassNames$2("picker"), prefix2 = _useClassNames.prefix;
  var addon = function addon2() {
    if (loading) {
      return /* @__PURE__ */ React.createElement(Loader, {
        className: prefix2("loader"),
        "data-testid": "spinner"
      });
    }
    if (showCleanButton && !disabled) {
      return /* @__PURE__ */ React.createElement(CloseButton, {
        className: prefix2("clean"),
        tabIndex: -1,
        locale: {
          closeLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.clear
        },
        onClick: onClose
      });
    }
    return caretAs && /* @__PURE__ */ React.createElement(Icon, {
      as: caretAs,
      className: prefix2("caret-icon")
    });
  };
  var props = Component === InputGroup.Addon ? {
    disabled
  } : void 0;
  return /* @__PURE__ */ React.createElement(Component, props, addon());
};
var _excluded$1e = ["children", "className", "as"];
var PickerLabel = function PickerLabel2(_ref) {
  var children = _ref.children, className = _ref.className, _ref$as = _ref.as, Component = _ref$as === void 0 ? InputGroup.Addon : _ref$as, rest = _objectWithoutPropertiesLoose(_ref, _excluded$1e);
  return children ? /* @__PURE__ */ React.createElement(Component, _extends$1({
    "data-testid": "picker-label",
    className
  }, rest), children) : null;
};
var _templateObject$6;
var _excluded$1d = ["active", "as", "classPrefix", "children", "caret", "className", "disabled", "readOnly", "plaintext", "hasValue", "loading", "cleanable", "tabIndex", "inputValue", "focusItemValue", "onClean", "placement", "caretComponent", "caretAs", "label", "name"];
var PickerToggle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var active = props.active, _props$as = props.as, Component = _props$as === void 0 ? ToggleButton : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "picker-toggle" : _props$classPrefix, children = props.children, _props$caret = props.caret, caret2 = _props$caret === void 0 ? true : _props$caret, className = props.className, disabled = props.disabled, readOnly = props.readOnly, plaintext = props.plaintext, hasValue2 = props.hasValue, _props$loading = props.loading, loading = _props$loading === void 0 ? false : _props$loading, cleanable = props.cleanable, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, inputValueProp = props.inputValue, focusItemValue = props.focusItemValue, onClean = props.onClean, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, caretComponent = props.caretComponent, _props$caretAs = props.caretAs, caretAs = _props$caretAs === void 0 ? caretComponent : _props$caretAs, label = props.label, name = props.name, rest = _objectWithoutPropertiesLoose(props, _excluded$1d);
  var combobox = reactExports.useRef(null);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var _useCombobox = useCombobox(), id2 = _useCombobox.id, labelId = _useCombobox.labelId, popupType = _useCombobox.popupType;
  var inputValue = reactExports.useMemo(function() {
    if (typeof inputValueProp === "number" || typeof inputValueProp === "string") {
      return inputValueProp;
    } else if (Array.isArray(inputValueProp)) {
      return inputValueProp.join(",");
    }
    return "";
  }, [inputValueProp]);
  var classes = merge2(className, withClassPrefix({
    active
  }));
  var handleClean = useEventCallback$2(function(event) {
    var _combobox$current;
    event.stopPropagation();
    onClean === null || onClean === void 0 ? void 0 : onClean(event);
    (_combobox$current = combobox.current) === null || _combobox$current === void 0 ? void 0 : _combobox$current.focus();
  });
  var ToggleCaret = useToggleCaret(placement);
  var Caret = caretAs !== null && caretAs !== void 0 ? caretAs : ToggleCaret;
  if (plaintext) {
    return /* @__PURE__ */ React.createElement(Plaintext, {
      ref,
      localeKey: "notSelected"
    }, hasValue2 ? children : null);
  }
  var showCleanButton = cleanable && hasValue2 && !readOnly;
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "combobox",
    id: id2,
    "aria-haspopup": popupType,
    "aria-expanded": active,
    "aria-disabled": disabled,
    "aria-controls": id2 + "-" + popupType,
    "aria-labelledby": labelId,
    "aria-describedby": id2 + "-describe",
    "aria-activedescendant": active && focusItemValue ? id2 + "-opt-" + focusItemValue : void 0
  }, rest, {
    ref: mergeRefs(combobox, ref),
    disabled,
    tabIndex: disabled ? void 0 : tabIndex,
    className: classes
  }), /* @__PURE__ */ React.createElement(Stack$1, null, label && /* @__PURE__ */ React.createElement(Stack$1.Item, null, /* @__PURE__ */ React.createElement(PickerLabel, {
    as: "span",
    className: prefix2("label"),
    id: labelId
  }, label)), /* @__PURE__ */ React.createElement(Stack$1.Item, {
    grow: 1,
    style: {
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement("input", {
    readOnly: true,
    "aria-hidden": true,
    tabIndex: -1,
    "data-testid": "picker-toggle-input",
    name,
    value: inputValue,
    className: prefix2("textbox", "read-only"),
    style: {
      pointerEvents: "none"
    }
  }), children ? /* @__PURE__ */ React.createElement("span", {
    className: prefix2(hasValue2 ? "value" : "placeholder"),
    id: id2 + "-describe",
    "data-testid": "picker-describe"
  }, children) : null), /* @__PURE__ */ React.createElement(Stack$1.Item, {
    className: prefix2(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteralLoose(["indicator"])))
  }, /* @__PURE__ */ React.createElement(PickerIndicator, {
    as: React.Fragment,
    loading,
    caretAs: caret2 ? Caret : null,
    onClose: handleClean,
    showCleanButton
  }))));
});
PickerToggle.displayName = "PickerToggle";
function usePickerRef(ref) {
  var trigger2 = reactExports.useRef(null);
  var root2 = reactExports.useRef(null);
  var target = reactExports.useRef(null);
  var overlay = reactExports.useRef(null);
  var list = reactExports.useRef(null);
  var searchInput = reactExports.useRef(null);
  var treeView = reactExports.useRef(null);
  var handleOpen = useEventCallback$2(function() {
    var _trigger$current;
    trigger2 === null || trigger2 === void 0 ? void 0 : (_trigger$current = trigger2.current) === null || _trigger$current === void 0 ? void 0 : _trigger$current.open();
  });
  var handleClose = useEventCallback$2(function() {
    var _trigger$current2;
    trigger2 === null || trigger2 === void 0 ? void 0 : (_trigger$current2 = trigger2.current) === null || _trigger$current2 === void 0 ? void 0 : _trigger$current2.close();
  });
  var handleUpdatePosition = useEventCallback$2(function() {
    var _trigger$current3;
    trigger2 === null || trigger2 === void 0 ? void 0 : (_trigger$current3 = trigger2.current) === null || _trigger$current3 === void 0 ? void 0 : _trigger$current3.updatePosition();
  });
  reactExports.useImperativeHandle(ref, function() {
    return {
      get root() {
        var _ref, _trigger$current4;
        return (_ref = (root2 === null || root2 === void 0 ? void 0 : root2.current) || (trigger2 === null || trigger2 === void 0 ? void 0 : (_trigger$current4 = trigger2.current) === null || _trigger$current4 === void 0 ? void 0 : _trigger$current4.root)) !== null && _ref !== void 0 ? _ref : null;
      },
      get overlay() {
        var _overlay$current;
        if (!(overlay !== null && overlay !== void 0 && overlay.current)) {
          throw new Error("The overlay is not found. Please confirm whether the picker is open.");
        }
        return (_overlay$current = overlay === null || overlay === void 0 ? void 0 : overlay.current) !== null && _overlay$current !== void 0 ? _overlay$current : null;
      },
      get target() {
        var _target$current;
        return (_target$current = target === null || target === void 0 ? void 0 : target.current) !== null && _target$current !== void 0 ? _target$current : null;
      },
      get list() {
        if (!(list !== null && list !== void 0 && list.current)) {
          throw new Error("\n            The list is not found.\n            1.Please set virtualized for the component.\n            2.Please confirm whether the picker is open.\n          ");
        }
        return list === null || list === void 0 ? void 0 : list.current;
      },
      type: RSUITE_PICKER_TYPE,
      updatePosition: handleUpdatePosition,
      open: handleOpen,
      close: handleClose
    };
  });
  return {
    trigger: trigger2,
    root: root2,
    overlay,
    target,
    list,
    searchInput,
    treeView
  };
}
var baseIteratee = _baseIteratee, isArrayLike = isArrayLike_1, keys = keys_1;
function createFind$1(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
  };
}
var _createFind = createFind$1;
var createFind = _createFind, findIndex = findIndex_1;
var find = createFind(findIndex);
var find_1 = find;
const find$1 = /* @__PURE__ */ getDefaultExportFromCjs(find_1);
function findNodeOfTree(data, check) {
  var findNode = function findNode2(nodes) {
    if (nodes === void 0) {
      nodes = [];
    }
    for (var i2 = 0; i2 < nodes.length; i2 += 1) {
      var item = nodes[i2];
      if (Array.isArray(item.children)) {
        var node2 = findNode2(item.children);
        if (node2) {
          return node2;
        }
      }
      if (check(item)) {
        return item;
      }
    }
    return void 0;
  };
  return findNode(data);
}
var baseIndexOf$1 = _baseIndexOf;
function charsEndIndex$1(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf$1(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var _charsEndIndex = charsEndIndex$1;
var baseIndexOf = _baseIndexOf;
function charsStartIndex$1(strSymbols, chrSymbols) {
  var index = -1, length2 = strSymbols.length;
  while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var _charsStartIndex = charsStartIndex$1;
var baseToString = _baseToString, baseTrim = _baseTrim, castSlice = _castSlice, charsEndIndex = _charsEndIndex, charsStartIndex = _charsStartIndex, stringToArray = _stringToArray, toString$1 = toString_1;
function trim$1(string, chars2, guard) {
  string = toString$1(string);
  if (string && (guard || chars2 === void 0)) {
    return baseTrim(string);
  }
  if (!string || !(chars2 = baseToString(chars2))) {
    return string;
  }
  var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars2), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
  return castSlice(strSymbols, start2, end2).join("");
}
var trim_1 = trim$1;
const trim$2 = /* @__PURE__ */ getDefaultExportFromCjs(trim_1);
function shouldDisplay(label, searchKeyword) {
  if (!trim$2(searchKeyword)) {
    return true;
  }
  var keyword = searchKeyword.toLocaleLowerCase();
  if (typeof label === "string" || typeof label === "number") {
    return ("" + label).toLocaleLowerCase().indexOf(keyword) >= 0;
  } else if (/* @__PURE__ */ React.isValidElement(label)) {
    var nodes = reactToString(label);
    return nodes.join("").toLocaleLowerCase().indexOf(keyword) >= 0;
  }
  return false;
}
function onMenuKeyDown(event, events2) {
  var down = events2.down, up = events2.up, enter = events2.enter, del = events2.del, esc = events2.esc, right2 = events2.right, left2 = events2.left;
  switch (event.key) {
    case KEY_VALUES.DOWN:
      down === null || down === void 0 ? void 0 : down(event);
      event.preventDefault();
      break;
    case KEY_VALUES.UP:
      up === null || up === void 0 ? void 0 : up(event);
      event.preventDefault();
      break;
    case KEY_VALUES.ENTER:
      enter === null || enter === void 0 ? void 0 : enter(event);
      event.preventDefault();
      break;
    case KEY_VALUES.BACKSPACE:
      del === null || del === void 0 ? void 0 : del(event);
      break;
    case KEY_VALUES.ESC:
    case KEY_VALUES.TAB:
      esc === null || esc === void 0 ? void 0 : esc(event);
      break;
    case KEY_VALUES.LEFT:
      left2 === null || left2 === void 0 ? void 0 : left2(event);
      break;
    case KEY_VALUES.RIGHT:
      right2 === null || right2 === void 0 ? void 0 : right2(event);
      break;
  }
}
var useFocusItemValue = function useFocusItemValue2(defaultFocusItemValue, props) {
  var _props$valueKey = props.valueKey, valueKey = _props$valueKey === void 0 ? "value" : _props$valueKey, _props$focusableQuery = props.focusableQueryKey, focusableQueryKey = _props$focusableQuery === void 0 ? '[data-key][aria-disabled="false"]' : _props$focusableQuery, _props$defaultLayer = props.defaultLayer, defaultLayer = _props$defaultLayer === void 0 ? 0 : _props$defaultLayer, _props$focusToOption = props.focusToOption, focusToOption = _props$focusToOption === void 0 ? true : _props$focusToOption, data = props.data, target = props.target, rtl = props.rtl, callback = props.callback, _props$getParent = props.getParent, getParent = _props$getParent === void 0 ? function(item) {
    return item === null || item === void 0 ? void 0 : item.parent;
  } : _props$getParent;
  var _useState = reactExports.useState(defaultFocusItemValue), focusItemValue = _useState[0], setFocusItemValue = _useState[1];
  var _useState2 = reactExports.useState(defaultLayer), layer = _useState2[0], setLayer = _useState2[1];
  var _useState3 = reactExports.useState([]), keys2 = _useState3[0], setKeys = _useState3[1];
  var focusCallback = useEventCallback$2(function(value, event) {
    if (focusToOption) {
      var menu = isFunction$5(target) ? target() : target;
      var focusElement = menu === null || menu === void 0 ? void 0 : menu.querySelector('[data-key="' + value + '"]');
      focusElement === null || focusElement === void 0 ? void 0 : focusElement.focus();
    }
    callback === null || callback === void 0 ? void 0 : callback(value, event);
  });
  var getScrollContainer = useEventCallback$2(function() {
    var menu = isFunction$5(target) ? target() : target;
    var subMenu = menu === null || menu === void 0 ? void 0 : menu.querySelector('[data-layer="' + layer + '"]');
    if (subMenu) {
      return subMenu;
    }
    return menu === null || menu === void 0 ? void 0 : menu.querySelector('[role="listbox"]');
  });
  var getFocusableMenuItems = function getFocusableMenuItems2() {
    if (!target) {
      return [];
    }
    var currentKeys = keys2;
    if (layer < 1) {
      var popup = isFunction$5(target) ? target() : target;
      var rootMenu = popup === null || popup === void 0 ? void 0 : popup.querySelector('[data-layer="0"]');
      if (rootMenu) {
        var _rootMenu$querySelect;
        currentKeys = Array.from((_rootMenu$querySelect = rootMenu.querySelectorAll(focusableQueryKey)) !== null && _rootMenu$querySelect !== void 0 ? _rootMenu$querySelect : []).map(function(item) {
          var _item$dataset;
          return (_item$dataset = item.dataset) === null || _item$dataset === void 0 ? void 0 : _item$dataset.key;
        });
      } else {
        var _popup$querySelectorA;
        currentKeys = Array.from((_popup$querySelectorA = popup === null || popup === void 0 ? void 0 : popup.querySelectorAll(focusableQueryKey)) !== null && _popup$querySelectorA !== void 0 ? _popup$querySelectorA : []).map(function(item) {
          var _item$dataset2;
          return (_item$dataset2 = item.dataset) === null || _item$dataset2 === void 0 ? void 0 : _item$dataset2.key;
        });
      }
    }
    return currentKeys.map(function(key) {
      return find$1(data, function(i2) {
        return "" + i2[valueKey] === key;
      });
    });
  };
  var findFocusItemIndex = useEventCallback$2(function(callback2) {
    var items = getFocusableMenuItems();
    for (var i2 = 0; i2 < items.length; i2 += 1) {
      var _items$i;
      if (shallowEqual(focusItemValue, (_items$i = items[i2]) === null || _items$i === void 0 ? void 0 : _items$i[valueKey])) {
        callback2(items, i2);
        return;
      }
    }
    callback2(items, -1);
  });
  var scrollListItem = useEventCallback$2(function(direction, itemValue, willOverflow) {
    var container = getScrollContainer();
    var item = container === null || container === void 0 ? void 0 : container.querySelector('[data-key="' + itemValue + '"]');
    if (willOverflow && container) {
      var scrollHeight = container.scrollHeight, clientHeight = container.clientHeight;
      container.scrollTop = direction === "top" ? scrollHeight - clientHeight : 0;
      return;
    }
    if (item && container) {
      if (!isVisible(item, container, direction)) {
        var height2 = getHeight(item);
        scrollTo$1(container, direction, height2);
      }
    }
  });
  var focusNextMenuItem = useEventCallback$2(function(event) {
    findFocusItemIndex(function(items, index) {
      var willOverflow = index + 2 > items.length;
      var nextIndex = willOverflow ? 0 : index + 1;
      var focusItem = items[nextIndex];
      if (!isUndefined$2(focusItem)) {
        setFocusItemValue(focusItem[valueKey]);
        focusCallback(focusItem[valueKey], event);
        scrollListItem("bottom", focusItem[valueKey], willOverflow);
      }
    });
  });
  var focusPrevMenuItem = useEventCallback$2(function(event) {
    findFocusItemIndex(function(items, index) {
      var willOverflow = index === 0;
      var nextIndex = willOverflow ? items.length - 1 : index - 1;
      var focusItem = items[nextIndex];
      if (!isUndefined$2(focusItem)) {
        setFocusItemValue(focusItem[valueKey]);
        focusCallback(focusItem[valueKey], event);
        scrollListItem("top", focusItem[valueKey], willOverflow);
      }
    });
  });
  var getSubMenuKeys = function getSubMenuKeys2(nextLayer) {
    var menu = isFunction$5(target) ? target() : target;
    var subMenu = menu === null || menu === void 0 ? void 0 : menu.querySelector('[data-layer="' + nextLayer + '"]');
    if (subMenu) {
      var _Array$from;
      return (_Array$from = Array.from(subMenu.querySelectorAll(focusableQueryKey))) === null || _Array$from === void 0 ? void 0 : _Array$from.map(function(item) {
        var _item$dataset3;
        return (_item$dataset3 = item.dataset) === null || _item$dataset3 === void 0 ? void 0 : _item$dataset3.key;
      });
    }
    return null;
  };
  var focusNextLevelMenu = useEventCallback$2(function(event) {
    var nextLayer = layer + 1;
    var nextKeys = getSubMenuKeys(nextLayer);
    if (nextKeys) {
      setKeys(nextKeys);
      setLayer(nextLayer);
      setFocusItemValue(nextKeys[0]);
      focusCallback(nextKeys[0], event);
    }
  });
  var focusPrevLevelMenu = useEventCallback$2(function(event) {
    var nextLayer = layer - 1;
    var nextKeys = getSubMenuKeys(nextLayer);
    if (nextKeys) {
      var _getParent;
      setKeys(nextKeys);
      setLayer(nextLayer);
      var focusItem = findNodeOfTree(data, function(item) {
        return item[valueKey] === focusItemValue;
      });
      var parentItemValue = (_getParent = getParent(focusItem)) === null || _getParent === void 0 ? void 0 : _getParent[valueKey];
      if (parentItemValue) {
        setFocusItemValue(parentItemValue);
        focusCallback(parentItemValue, event);
      }
    }
  });
  var handleKeyDown = useEventCallback$2(function(event) {
    var _onMenuKeyDown;
    onMenuKeyDown(event, (_onMenuKeyDown = {
      down: focusNextMenuItem,
      up: focusPrevMenuItem
    }, _onMenuKeyDown[rtl ? "left" : "right"] = focusNextLevelMenu, _onMenuKeyDown[rtl ? "right" : "left"] = focusPrevLevelMenu, _onMenuKeyDown));
  });
  return {
    focusItemValue,
    setFocusItemValue,
    layer,
    setLayer,
    keys: keys2,
    setKeys,
    onKeyDown: handleKeyDown
  };
};
function scrollTo$1(container, direction, step) {
  var scrollTop2 = container.scrollTop;
  container.scrollTop = direction === "top" ? scrollTop2 - step : scrollTop2 + step;
}
function hasVerticalScroll(element) {
  var scrollHeight = element.scrollHeight, clientHeight = element.clientHeight;
  return scrollHeight > clientHeight;
}
function isVisible(element, container, direction) {
  if (!hasVerticalScroll(container)) {
    return true;
  }
  var _element$getBoundingC = element.getBoundingClientRect(), top2 = _element$getBoundingC.top, bottom2 = _element$getBoundingC.bottom, height2 = _element$getBoundingC.height;
  var _container$getBoundin = container.getBoundingClientRect(), containerTop = _container$getBoundin.top, containerBottom = _container$getBoundin.bottom;
  if (direction === "top") {
    return top2 + height2 > containerTop;
  }
  return bottom2 - height2 < containerBottom;
}
var useToggleKeyDownEvent = function useToggleKeyDownEvent2(props) {
  var _props$toggle = props.toggle, toggle = _props$toggle === void 0 ? true : _props$toggle, trigger2 = props.trigger, target = props.target, overlay = props.overlay, searchInput = props.searchInput, active = props.active, readOnly = props.readOnly, disabled = props.disabled, loading = props.loading, onExit = props.onExit, onKeyDown = props.onKeyDown, onMenuKeyDown2 = props.onMenuKeyDown, onMenuPressEnter = props.onMenuPressEnter, onMenuPressBackspace = props.onMenuPressBackspace;
  var handleClose = useEventCallback$2(function() {
    var _trigger$current, _trigger$current$clos, _trigger$current2, _trigger$current2$foc;
    (_trigger$current = trigger2.current) === null || _trigger$current === void 0 ? void 0 : (_trigger$current$clos = _trigger$current.close) === null || _trigger$current$clos === void 0 ? void 0 : _trigger$current$clos.call(_trigger$current);
    (_trigger$current2 = trigger2.current) === null || _trigger$current2 === void 0 ? void 0 : (_trigger$current2$foc = _trigger$current2.focus) === null || _trigger$current2$foc === void 0 ? void 0 : _trigger$current2$foc.call(_trigger$current2);
  });
  var handleOpen = useEventCallback$2(function() {
    var _trigger$current3, _trigger$current3$ope;
    (_trigger$current3 = trigger2.current) === null || _trigger$current3 === void 0 ? void 0 : (_trigger$current3$ope = _trigger$current3.open) === null || _trigger$current3$ope === void 0 ? void 0 : _trigger$current3$ope.call(_trigger$current3);
  });
  var handleToggleDropdown = useEventCallback$2(function() {
    if (active) {
      handleClose();
      return;
    }
    handleOpen();
  });
  var onToggle = useEventCallback$2(function(event) {
    if (readOnly || disabled || loading) {
      return;
    }
    if (event.target === (target === null || target === void 0 ? void 0 : target.current)) {
      if (toggle && event.key === KEY_VALUES.ENTER) {
        handleToggleDropdown();
      }
      if (event.key === KEY_VALUES.BACKSPACE) {
        onExit === null || onExit === void 0 ? void 0 : onExit(event);
      }
    }
    if (overlay !== null && overlay !== void 0 && overlay.current) {
      onMenuKeyDown2 === null || onMenuKeyDown2 === void 0 ? void 0 : onMenuKeyDown2(event);
      if (event.key === KEY_VALUES.ENTER) {
        onMenuPressEnter === null || onMenuPressEnter === void 0 ? void 0 : onMenuPressEnter(event);
      }
      if (event.key === KEY_VALUES.BACKSPACE && event.target !== (searchInput === null || searchInput === void 0 ? void 0 : searchInput.current)) {
        onMenuPressBackspace === null || onMenuPressBackspace === void 0 ? void 0 : onMenuPressBackspace(event);
      }
      if (event.key.length === 1 && /\w/.test(event.key)) {
        var _event$target;
        if (((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.tagName) !== "INPUT") {
          var _searchInput$current;
          searchInput === null || searchInput === void 0 ? void 0 : (_searchInput$current = searchInput.current) === null || _searchInput$current === void 0 ? void 0 : _searchInput$current.focus();
        }
      }
    }
    if (event.key === KEY_VALUES.ESC || event.key === KEY_VALUES.TAB) {
      handleClose();
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
  });
  return onToggle;
};
function useSearch(data, props) {
  var labelKey = props.labelKey, searchBy = props.searchBy, callback = props.callback;
  var _useState = reactExports.useState(""), searchKeyword = _useState[0], setSearchKeyword = _useState[1];
  var resetSearch = reactExports.useCallback(function() {
    setSearchKeyword("");
  }, []);
  var checkShouldDisplay = reactExports.useCallback(function(item, keyword) {
    var checkValue = typeof item === "object" ? item === null || item === void 0 ? void 0 : item[labelKey] : String(item);
    var _keyword = isUndefined$2(keyword) ? searchKeyword : keyword;
    if (typeof searchBy === "function") {
      return searchBy(_keyword, checkValue, item);
    }
    return shouldDisplay(checkValue, _keyword);
  }, [labelKey, searchBy, searchKeyword]);
  var filteredData = reactExports.useMemo(function() {
    return data.filter(function(item) {
      return checkShouldDisplay(item, searchKeyword);
    });
  }, [checkShouldDisplay, data, searchKeyword]);
  var handleSearch = function handleSearch2(searchKeyword2, event) {
    var filteredData2 = data.filter(function(item) {
      return checkShouldDisplay(item, searchKeyword2);
    });
    setSearchKeyword(searchKeyword2);
    callback === null || callback === void 0 ? void 0 : callback(searchKeyword2, filteredData2, event);
  };
  return {
    searchKeyword,
    filteredData,
    checkShouldDisplay,
    handleSearch,
    resetSearch
  };
}
var _excluded$1c = ["name", "classPrefix", "className", "placement", "appearance", "cleanable", "block", "disabled", "countable", "readOnly", "plaintext", "hasValue"];
function usePickerClassName(props) {
  var _withClassPrefix;
  var name = props.name, classPrefix = props.classPrefix, className = props.className, placement = props.placement, appearance = props.appearance, cleanable = props.cleanable, block = props.block, disabled = props.disabled, countable = props.countable, readOnly = props.readOnly, plaintext = props.plaintext, hasValue2 = props.hasValue, rest = _objectWithoutPropertiesLoose(props, _excluded$1c);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix(name, appearance, "toggle-wrapper", (_withClassPrefix = {}, _withClassPrefix["placement-" + kebabCase$1(placementPolyfill(placement))] = placement, _withClassPrefix["read-only"] = readOnly, _withClassPrefix["has-value"] = hasValue2, _withClassPrefix.cleanable = cleanable, _withClassPrefix.block = block, _withClassPrefix.disabled = disabled, _withClassPrefix.countable = countable, _withClassPrefix.plaintext = plaintext, _withClassPrefix)));
  var usedClassNamePropKeys = Object.keys(omit$1(props, [].concat(Object.keys(rest || {}), ["disabled", "readOnly", "plaintext", "name"])));
  return [classes, usedClassNamePropKeys];
}
var pickerPropTypes = _extends$1({}, animationPropTypes, {
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  style: PropTypes.object,
  locale: PropTypes.any,
  appearance: oneOf(["default", "subtle"]),
  block: PropTypes.bool,
  containerPadding: PropTypes.number,
  container: PropTypes.oneOfType([PropTypes.any, PropTypes.func]),
  disabled: PropTypes.bool,
  menuClassName: PropTypes.string,
  menuStyle: PropTypes.object,
  placeholder: PropTypes.node,
  placement: oneOf(PLACEMENT),
  preventOverflow: PropTypes.bool,
  open: PropTypes.bool,
  defaultOpen: PropTypes.bool,
  cleanable: PropTypes.bool,
  renderExtraFooter: PropTypes.func,
  renderValue: PropTypes.func,
  onOpen: PropTypes.func,
  onClose: PropTypes.func,
  onClean: PropTypes.func,
  listProps: PropTypes.any
});
var listPickerPropTypes = _extends$1({}, pickerPropTypes, {
  data: PropTypes.array.isRequired,
  valueKey: PropTypes.string,
  labelKey: PropTypes.string,
  childrenKey: PropTypes.string,
  disabledItemValues: PropTypes.array,
  value: PropTypes.any,
  defaultValue: PropTypes.any,
  onChange: PropTypes.func
});
var Search$4 = {};
var Search$3 = { exports: {} };
var Search$2 = {};
var hasRequiredSearch;
function requireSearch() {
  if (hasRequiredSearch) return Search$2;
  hasRequiredSearch = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function Search2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 14 14",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M9.293 10.707a.999.999 0 111.414-1.414l3 3a.999.999 0 11-1.414 1.414l-3-3z"
      }), /* @__PURE__ */ React2.createElement("path", {
        d: "M6 10a4 4 0 100-8 4 4 0 000 8zm0 2A6 6 0 116 0a6 6 0 010 12z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(Search2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(Search$2);
  return Search$2;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _Search = _interopRequireDefault2(requireSearch());
  var Search2 = (0, _createSvgIcon2["default"])({
    as: _Search["default"],
    ariaLabel: "search",
    category: "legacy",
    displayName: "Search"
  });
  var _default = Search2;
  exports["default"] = _default;
  module.exports = exports.default;
})(Search$3, Search$3.exports);
var SearchExports = Search$3.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _Search["default"];
    }
  });
  var _Search = _interopRequireDefault2(SearchExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(Search$4);
const Search$1 = /* @__PURE__ */ getDefaultExportFromCjs(Search$4);
var _templateObject$5, _templateObject2$2;
var _excluded$1b = ["as", "classPrefix", "value", "className", "placeholder", "inputRef", "onChange"];
var SearchBox = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "search-box" : _props$classPrefix, value = props.value, className = props.className, placeholder = props.placeholder, inputRef = props.inputRef, onChange = props.onChange, rest = _objectWithoutPropertiesLoose(props, _excluded$1b);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), /* @__PURE__ */ React.createElement(InputGroup, {
    inside: true
  }, /* @__PURE__ */ React.createElement(Input$1, {
    role: "searchbox",
    className: prefix2(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteralLoose(["input"]))),
    value,
    onChange,
    placeholder,
    ref: inputRef
  }), /* @__PURE__ */ React.createElement(InputGroup.Addon, null, /* @__PURE__ */ React.createElement(Search$1, {
    className: prefix2(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteralLoose(["icon"])))
  }))));
});
SearchBox.displayName = "SearchBox";
var _templateObject$4;
var _excluded$1a = ["as", "appearance", "data", "valueKey", "labelKey", "value", "classPrefix", "placeholder", "defaultValue", "disabled", "cleanable", "placement", "menuClassName", "menuAutoWidth", "menuMaxHeight", "menuStyle", "groupBy", "locale", "toggleAs", "style", "searchable", "disabledItemValues", "virtualized", "listProps", "id", "onGroupTitleClick", "searchBy", "onEntered", "onExited", "onClean", "onChange", "onSelect", "onSearch", "sort", "renderValue", "renderMenu", "renderMenuGroup", "renderMenuItem", "renderExtraFooter"];
var emptyArray = [];
var SelectPicker = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "default" : _props$appearance, _props$data = props.data, data = _props$data === void 0 ? emptyArray : _props$data, _props$valueKey = props.valueKey, valueKey = _props$valueKey === void 0 ? "value" : _props$valueKey, _props$labelKey = props.labelKey, labelKey = _props$labelKey === void 0 ? "label" : _props$labelKey, valueProp = props.value, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "picker" : _props$classPrefix, placeholder = props.placeholder, defaultValue = props.defaultValue, disabled = props.disabled, _props$cleanable = props.cleanable, cleanable = _props$cleanable === void 0 ? true : _props$cleanable, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, menuClassName = props.menuClassName, _props$menuAutoWidth = props.menuAutoWidth, menuAutoWidth = _props$menuAutoWidth === void 0 ? true : _props$menuAutoWidth, _props$menuMaxHeight = props.menuMaxHeight, menuMaxHeight = _props$menuMaxHeight === void 0 ? 320 : _props$menuMaxHeight, menuStyle = props.menuStyle, groupBy2 = props.groupBy, overrideLocale = props.locale, toggleAs = props.toggleAs, style2 = props.style, _props$searchable = props.searchable, searchable = _props$searchable === void 0 ? true : _props$searchable, _props$disabledItemVa = props.disabledItemValues, disabledItemValues = _props$disabledItemVa === void 0 ? emptyArray : _props$disabledItemVa, virtualized = props.virtualized, listProps = props.listProps, id2 = props.id, onGroupTitleClick = props.onGroupTitleClick, searchBy = props.searchBy, onEntered = props.onEntered, onExited = props.onExited, onClean = props.onClean, onChange = props.onChange, onSelect = props.onSelect, onSearch = props.onSearch, sort = props.sort, renderValue = props.renderValue, renderMenu = props.renderMenu, renderMenuGroup = props.renderMenuGroup, renderMenuItem = props.renderMenuItem, renderExtraFooter = props.renderExtraFooter, rest = _objectWithoutPropertiesLoose(props, _excluded$1a);
  var _usePickerRef = usePickerRef(ref), trigger2 = _usePickerRef.trigger, root2 = _usePickerRef.root, target = _usePickerRef.target, overlay = _usePickerRef.overlay, list = _usePickerRef.list, searchInput = _usePickerRef.searchInput;
  var _useCustom = useCustom("Picker", overrideLocale), locale2 = _useCustom.locale;
  var _ref = useControlled$2(valueProp, defaultValue), value = _ref[0], setValue2 = _ref[1];
  var _useFocusItemValue = useFocusItemValue(value, {
    data,
    valueKey,
    target: function target2() {
      return overlay.current;
    }
  }), focusItemValue = _useFocusItemValue.focusItemValue, setFocusItemValue = _useFocusItemValue.setFocusItemValue, onFocusItem = _useFocusItemValue.onKeyDown;
  var _useSearch = useSearch(data, {
    labelKey,
    searchBy,
    callback: function callback(searchKeyword2, filteredData2, event) {
      var _filteredData$;
      setFocusItemValue(filteredData2 === null || filteredData2 === void 0 ? void 0 : (_filteredData$ = filteredData2[0]) === null || _filteredData$ === void 0 ? void 0 : _filteredData$[valueKey]);
      onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchKeyword2, event);
    }
  }), searchKeyword = _useSearch.searchKeyword, filteredData = _useSearch.filteredData, resetSearch = _useSearch.resetSearch, handleSearch = _useSearch.handleSearch;
  var _useState = reactExports.useState(false), active = _useState[0], setActive = _useState[1];
  var handleClose = useEventCallback$2(function() {
    var _trigger$current, _trigger$current$clos;
    (_trigger$current = trigger2.current) === null || _trigger$current === void 0 ? void 0 : (_trigger$current$clos = _trigger$current.close) === null || _trigger$current$clos === void 0 ? void 0 : _trigger$current$clos.call(_trigger$current);
  });
  var handleSelect = useEventCallback$2(function(value2, item, event) {
    var _target$current;
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(value2, item, event);
    (_target$current = target.current) === null || _target$current === void 0 ? void 0 : _target$current.focus();
  });
  var handleChangeValue = useEventCallback$2(function(value2, event) {
    onChange === null || onChange === void 0 ? void 0 : onChange(value2, event);
  });
  var handleMenuPressEnter = useEventCallback$2(function(event) {
    if (!focusItemValue) {
      return;
    }
    var focusItem = data.find(function(item) {
      return shallowEqual(item[valueKey], focusItemValue);
    });
    setValue2(focusItemValue);
    handleSelect(focusItemValue, focusItem, event);
    handleChangeValue(focusItemValue, event);
    handleClose();
  });
  var handleItemSelect = useEventCallback$2(function(value2, item, event) {
    setValue2(value2);
    setFocusItemValue(value2);
    handleSelect(value2, item, event);
    handleChangeValue(value2, event);
    handleClose();
  });
  var handleClean = useEventCallback$2(function(event) {
    if (disabled || !cleanable) {
      return;
    }
    setValue2(null);
    setFocusItemValue(value);
    handleChangeValue(null, event);
  });
  var onPickerKeyDown = useToggleKeyDownEvent(_extends$1({
    toggle: !focusItemValue || !active,
    trigger: trigger2,
    target,
    overlay,
    searchInput,
    active,
    onExit: handleClean,
    onMenuKeyDown: onFocusItem,
    onMenuPressEnter: handleMenuPressEnter
  }, rest));
  var handleExited = useEventCallback$2(function() {
    resetSearch();
    setActive(false);
    onSearch === null || onSearch === void 0 ? void 0 : onSearch("");
    setFocusItemValue(null);
  });
  var handleEntered = useEventCallback$2(function() {
    setActive(true);
    setFocusItemValue(value);
  });
  var activeItem = data.find(function(item) {
    return shallowEqual(item[valueKey], value);
  });
  var hasValue2 = !!activeItem || !isNil$1(value) && isFunction$5(renderValue);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var selectedElement = placeholder;
  if (activeItem !== null && activeItem !== void 0 && activeItem[labelKey]) {
    selectedElement = activeItem[labelKey];
  }
  if (!isNil$1(value) && isFunction$5(renderValue)) {
    selectedElement = renderValue(value, activeItem, selectedElement);
    if (isNil$1(selectedElement)) {
      hasValue2 = false;
    }
  }
  var renderPopup = function renderPopup2(positionProps, speakerRef) {
    var left2 = positionProps.left, top2 = positionProps.top, className = positionProps.className;
    var classes2 = merge2(className, menuClassName, prefix2("select-menu"));
    var styles2 = _extends$1({}, menuStyle, {
      left: left2,
      top: top2
    });
    var items = filteredData;
    if (groupBy2) {
      items = getDataGroupBy(items, groupBy2, sort);
    } else if (typeof sort === "function") {
      items = items.sort(sort(false));
    }
    var menu = items.length ? /* @__PURE__ */ React.createElement(Listbox, {
      listProps,
      listRef: list,
      disabledItemValues,
      valueKey,
      labelKey,
      renderMenuGroup,
      renderMenuItem,
      maxHeight: menuMaxHeight,
      classPrefix: "picker-select-menu",
      listItemClassPrefix: "picker-select-menu-item",
      listItemAs: ListItem$1,
      activeItemValues: [value],
      focusItemValue,
      data: items,
      query: searchKeyword,
      groupBy: groupBy2,
      onSelect: handleItemSelect,
      onGroupTitleClick,
      virtualized
    }) : /* @__PURE__ */ React.createElement("div", {
      className: prefix2(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteralLoose(["none"])))
    }, locale2 === null || locale2 === void 0 ? void 0 : locale2.noResultsText);
    return /* @__PURE__ */ React.createElement(PickerPopup, {
      ref: mergeRefs(overlay, speakerRef),
      autoWidth: menuAutoWidth,
      className: classes2,
      style: styles2,
      onKeyDown: onPickerKeyDown,
      target: trigger2
    }, searchable && /* @__PURE__ */ React.createElement(SearchBox, {
      placeholder: locale2 === null || locale2 === void 0 ? void 0 : locale2.searchPlaceholder,
      onChange: handleSearch,
      value: searchKeyword,
      inputRef: searchInput
    }), renderMenu ? renderMenu(menu) : menu, renderExtraFooter === null || renderExtraFooter === void 0 ? void 0 : renderExtraFooter());
  };
  var _usePickerClassName = usePickerClassName(_extends$1({}, props, {
    classPrefix,
    appearance,
    hasValue: hasValue2,
    name: "select",
    cleanable
  })), classes = _usePickerClassName[0], usedClassNamePropKeys = _usePickerClassName[1];
  return /* @__PURE__ */ React.createElement(PickerToggleTrigger, {
    id: id2,
    pickerProps: pick$1(props, pickTriggerPropKeys),
    ref: trigger2,
    placement,
    onEntered: createChainedFunction$1(handleEntered, onEntered),
    onExited: createChainedFunction$1(handleExited, onExited),
    speaker: renderPopup
  }, /* @__PURE__ */ React.createElement(Component, {
    className: classes,
    style: style2,
    ref: root2
  }, /* @__PURE__ */ React.createElement(PickerToggle, _extends$1({}, omit$1(rest, [].concat(omitTriggerPropKeys, usedClassNamePropKeys)), {
    ref: target,
    appearance,
    onClean: createChainedFunction$1(handleClean, onClean),
    onKeyDown: onPickerKeyDown,
    as: toggleAs,
    disabled,
    cleanable: cleanable && !disabled,
    hasValue: hasValue2,
    inputValue: value !== null && value !== void 0 ? value : "",
    focusItemValue,
    active,
    placement
  }), selectedElement || (locale2 === null || locale2 === void 0 ? void 0 : locale2.placeholder))));
});
SelectPicker.displayName = "SelectPicker";
SelectPicker.propTypes = _extends$1({}, listPickerPropTypes, {
  locale: PropTypes.any,
  appearance: oneOf(["default", "subtle"]),
  menuAutoWidth: PropTypes.bool,
  menuMaxHeight: PropTypes.number,
  renderMenu: PropTypes.func,
  renderMenuItem: PropTypes.func,
  renderMenuGroup: PropTypes.func,
  onSelect: PropTypes.func,
  onGroupTitleClick: PropTypes.func,
  onSearch: PropTypes.func,
  /**
   * group by key in `data`
   */
  groupBy: PropTypes.any,
  sort: PropTypes.func,
  searchable: PropTypes.bool,
  virtualized: PropTypes.bool,
  searchBy: PropTypes.func
});
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
};
/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
const isObject$3 = isobject;
var getValue$1 = function(target, path, options) {
  if (!isObject$3(options)) {
    options = { default: options };
  }
  if (!isValidObject(target)) {
    return typeof options.default !== "undefined" ? options.default : target;
  }
  if (typeof path === "number") {
    path = String(path);
  }
  const isArray2 = Array.isArray(path);
  const isString2 = typeof path === "string";
  const splitChar = options.separator || ".";
  const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
  if (!isString2 && !isArray2) {
    return target;
  }
  if (isString2 && path in target) {
    return isValid(path, target, options) ? target[path] : options.default;
  }
  let segs = isArray2 ? path : split$1(path, splitChar, options);
  let len = segs.length;
  let idx = 0;
  do {
    let prop = segs[idx];
    if (typeof prop === "number") {
      prop = String(prop);
    }
    while (prop && prop.slice(-1) === "\\") {
      prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
    }
    if (prop in target) {
      if (!isValid(prop, target, options)) {
        return options.default;
      }
      target = target[prop];
    } else {
      let hasProp2 = false;
      let n2 = idx + 1;
      while (n2 < len) {
        prop = join([prop, segs[n2++]], joinChar, options);
        if (hasProp2 = prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
          idx = n2 - 1;
          break;
        }
      }
      if (!hasProp2) {
        return options.default;
      }
    }
  } while (++idx < len && isValidObject(target));
  if (idx === len) {
    return target;
  }
  return options.default;
};
function join(segs, joinChar, options) {
  if (typeof options.join === "function") {
    return options.join(segs);
  }
  return segs[0] + joinChar + segs[1];
}
function split$1(path, splitChar, options) {
  if (typeof options.split === "function") {
    return options.split(path);
  }
  return path.split(splitChar);
}
function isValid(key, target, options) {
  if (typeof options.isValid === "function") {
    return options.isValid(key, target);
  }
  return true;
}
function isValidObject(val) {
  return isObject$3(val) || Array.isArray(val) || typeof val === "function";
}
const get$1 = /* @__PURE__ */ getDefaultExportFromCjs(getValue$1);
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isPrimitive$2 = function isPrimitive(val) {
  if (typeof val === "object") {
    return val === null;
  }
  return typeof val !== "function";
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$2 = isobject;
function isObjectObject(o) {
  return isObject$2(o) === true && Object.prototype.toString.call(o) === "[object Object]";
}
var isPlainObject$3 = function isPlainObject(o) {
  var ctor, prot;
  if (isObjectObject(o) === false) return false;
  ctor = o.constructor;
  if (typeof ctor !== "function") return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
};
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).
 * Released under the MIT License.
 */
const { deleteProperty } = Reflect;
const isPrimitive$1 = isPrimitive$2;
const isPlainObject$2 = isPlainObject$3;
const isObject$1 = (value) => {
  return typeof value === "object" && value !== null || typeof value === "function";
};
const isUnsafeKey = (key) => {
  return key === "__proto__" || key === "constructor" || key === "prototype";
};
const validateKey = (key) => {
  if (!isPrimitive$1(key)) {
    throw new TypeError("Object keys must be strings or symbols");
  }
  if (isUnsafeKey(key)) {
    throw new Error(`Cannot set unsafe key: "${key}"`);
  }
};
const toStringKey = (input) => {
  return Array.isArray(input) ? input.flat().map(String).join(",") : input;
};
const createMemoKey = (input, options) => {
  if (typeof input !== "string" || !options) return input;
  let key = input + ";";
  if (options.arrays !== void 0) key += `arrays=${options.arrays};`;
  if (options.separator !== void 0) key += `separator=${options.separator};`;
  if (options.split !== void 0) key += `split=${options.split};`;
  if (options.merge !== void 0) key += `merge=${options.merge};`;
  if (options.preservePaths !== void 0) key += `preservePaths=${options.preservePaths};`;
  return key;
};
const memoize$2 = (input, options, fn2) => {
  const key = toStringKey(options ? createMemoKey(input, options) : input);
  validateKey(key);
  const value = setValue.cache.get(key) || fn2();
  setValue.cache.set(key, value);
  return value;
};
const splitString = (input, options = {}) => {
  const sep = options.separator || ".";
  const preserve = sep === "/" ? false : options.preservePaths;
  if (typeof input === "string" && preserve !== false && /\//.test(input)) {
    return [input];
  }
  const parts = [];
  let part = "";
  const push = (part2) => {
    let number;
    if (part2.trim() !== "" && Number.isInteger(number = Number(part2))) {
      parts.push(number);
    } else {
      parts.push(part2);
    }
  };
  for (let i2 = 0; i2 < input.length; i2++) {
    const value = input[i2];
    if (value === "\\") {
      part += input[++i2];
      continue;
    }
    if (value === sep) {
      push(part);
      part = "";
      continue;
    }
    part += value;
  }
  if (part) {
    push(part);
  }
  return parts;
};
const split = (input, options) => {
  if (options && typeof options.split === "function") return options.split(input);
  if (typeof input === "symbol") return [input];
  if (Array.isArray(input)) return input;
  return memoize$2(input, options, () => splitString(input, options));
};
const assignProp = (obj, prop, value, options) => {
  validateKey(prop);
  if (value === void 0) {
    deleteProperty(obj, prop);
  } else if (options && options.merge) {
    const merge2 = options.merge === "function" ? options.merge : Object.assign;
    if (merge2 && isPlainObject$2(obj[prop]) && isPlainObject$2(value)) {
      obj[prop] = merge2(obj[prop], value);
    } else {
      obj[prop] = value;
    }
  } else {
    obj[prop] = value;
  }
  return obj;
};
const setValue = (target, path, value, options) => {
  if (!path || !isObject$1(target)) return target;
  const keys2 = split(path, options);
  let obj = target;
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2];
    const next2 = keys2[i2 + 1];
    validateKey(key);
    if (next2 === void 0) {
      assignProp(obj, key, value, options);
      break;
    }
    if (typeof next2 === "number" && !Array.isArray(obj[key])) {
      obj = obj[key] = [];
      continue;
    }
    if (!isObject$1(obj[key])) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  return target;
};
setValue.split = split;
setValue.cache = /* @__PURE__ */ new Map();
setValue.clear = () => {
  setValue.cache = /* @__PURE__ */ new Map();
};
var setValue_1 = setValue;
const set$3 = /* @__PURE__ */ getDefaultExportFromCjs(setValue_1);
function isEmpty$3(value) {
  return typeof value === "undefined" || value === null || value === "";
}
function pathTransform(path) {
  const arr = path.split(".");
  if (arr.length === 1) {
    return path;
  }
  return path.split(".").map((item, index) => {
    if (index === 0) {
      return item;
    }
    return /^\d+$/.test(item) ? `array.${item}` : `object.${item}`;
  }).join(".");
}
const schemaSpecKey = "objectTypeSchemaSpec";
function getFieldType(schemaSpec, fieldName, nestedObject) {
  if (nestedObject) {
    const namePath = fieldName.split(".").join(`.${schemaSpecKey}.`);
    return get$1(schemaSpec, namePath);
  }
  return schemaSpec === null || schemaSpec === void 0 ? void 0 : schemaSpec[fieldName];
}
function getFieldValue$1(data, fieldName, nestedObject) {
  return nestedObject ? get$1(data, fieldName) : data === null || data === void 0 ? void 0 : data[fieldName];
}
class Schema {
  constructor(schema) {
    this.checkResult = {};
    this.$spec = schema;
  }
  getFieldType(fieldName, nestedObject) {
    return getFieldType(this.$spec, fieldName, nestedObject);
  }
  setFieldCheckResult(fieldName, checkResult, nestedObject) {
    if (nestedObject) {
      const namePath = fieldName.split(".").join(".object.");
      set$3(this.checkResult, namePath, checkResult);
      return;
    }
    this.checkResult[fieldName] = checkResult;
  }
  setSchemaOptionsForAllType(data) {
    if (data === this.data) {
      return;
    }
    Object.entries(this.$spec).forEach(([key, type]) => {
      type.setSchemaOptions(this.$spec, data === null || data === void 0 ? void 0 : data[key]);
    });
    this.data = data;
  }
  /**
   * Get the check result of the schema
   * @returns CheckResult<ErrorMsgType | string>
   */
  getCheckResult(path, result = this.checkResult) {
    if (path) {
      return (result === null || result === void 0 ? void 0 : result[path]) || get$1(result, pathTransform(path)) || { hasError: false };
    }
    return result;
  }
  /**
   * Get the error messages of the schema
   */
  getErrorMessages(path, result = this.checkResult) {
    let messages = [];
    if (path) {
      const { errorMessage, object, array } = (result === null || result === void 0 ? void 0 : result[path]) || get$1(result, pathTransform(path)) || {};
      if (errorMessage) {
        messages = [errorMessage];
      } else if (object) {
        messages = Object.keys(object).map((key) => {
          var _a2;
          return (_a2 = object[key]) === null || _a2 === void 0 ? void 0 : _a2.errorMessage;
        });
      } else if (array) {
        messages = array.map((item) => item === null || item === void 0 ? void 0 : item.errorMessage);
      }
    } else {
      messages = Object.keys(result).map((key) => {
        var _a2;
        return (_a2 = result[key]) === null || _a2 === void 0 ? void 0 : _a2.errorMessage;
      });
    }
    return messages.filter(Boolean);
  }
  /**
   * Get all the keys of the schema
   */
  getKeys() {
    return Object.keys(this.$spec);
  }
  /**
   * Get the schema specification
   */
  getSchemaSpec() {
    return this.$spec;
  }
  checkForField(fieldName, data, options = {}) {
    var _a2;
    this.setSchemaOptionsForAllType(data);
    const { nestedObject } = options;
    const fieldChecker = this.getFieldType(fieldName, nestedObject);
    if (!fieldChecker) {
      return { hasError: false };
    }
    const fieldValue = getFieldValue$1(data, fieldName, nestedObject);
    const checkResult = fieldChecker.check(fieldValue, data, fieldName);
    this.setFieldCheckResult(fieldName, checkResult, nestedObject);
    if (!checkResult.hasError) {
      const { checkIfValueExists } = fieldChecker.proxyOptions;
      (_a2 = fieldChecker.otherFields) === null || _a2 === void 0 ? void 0 : _a2.forEach((field) => {
        if (checkIfValueExists) {
          if (!isEmpty$3(getFieldValue$1(data, field, nestedObject))) {
            this.checkForField(field, data, options);
          }
          return;
        }
        this.checkForField(field, data, options);
      });
    }
    return checkResult;
  }
  checkForFieldAsync(fieldName, data, options = {}) {
    this.setSchemaOptionsForAllType(data);
    const { nestedObject } = options;
    const fieldChecker = this.getFieldType(fieldName, nestedObject);
    if (!fieldChecker) {
      return Promise.resolve({ hasError: false });
    }
    const fieldValue = getFieldValue$1(data, fieldName, nestedObject);
    const checkResult = fieldChecker.checkAsync(fieldValue, data, fieldName);
    return checkResult.then(async (result) => {
      var _a2;
      this.setFieldCheckResult(fieldName, result, nestedObject);
      if (!result.hasError) {
        const { checkIfValueExists } = fieldChecker.proxyOptions;
        const checkAll = [];
        (_a2 = fieldChecker.otherFields) === null || _a2 === void 0 ? void 0 : _a2.forEach((field) => {
          if (checkIfValueExists) {
            if (!isEmpty$3(getFieldValue$1(data, field, nestedObject))) {
              checkAll.push(this.checkForFieldAsync(field, data, options));
            }
            return;
          }
          checkAll.push(this.checkForFieldAsync(field, data, options));
        });
        await Promise.all(checkAll);
      }
      return result;
    });
  }
  check(data) {
    const checkResult = {};
    Object.keys(this.$spec).forEach((key) => {
      if (typeof data === "object") {
        checkResult[key] = this.checkForField(key, data);
      }
    });
    return checkResult;
  }
  checkAsync(data) {
    const checkResult = {};
    const promises = [];
    const keys2 = [];
    Object.keys(this.$spec).forEach((key) => {
      keys2.push(key);
      promises.push(this.checkForFieldAsync(key, data));
    });
    return Promise.all(promises).then((values2) => {
      for (let i2 = 0; i2 < values2.length; i2 += 1) {
        checkResult[keys2[i2]] = values2[i2];
      }
      return checkResult;
    });
  }
}
function SchemaModel(o) {
  return new Schema(o);
}
SchemaModel.combine = function combine(...specs) {
  return new Schema(specs.map((model) => model.$spec).reduce((accumulator, currentValue) => Object.assign(accumulator, currentValue), {}));
};
var FormContext = /* @__PURE__ */ React.createContext({});
var FormValueContext = /* @__PURE__ */ React.createContext({});
var FormProvider = FormContext.Provider;
var FormValueProvider = FormValueContext.Provider;
function useFormContext$1() {
  return reactExports.useContext(FormContext);
}
var _templateObject$3, _templateObject2$1;
var _excluded$19 = ["as", "classPrefix", "className", "show", "children", "placement"];
var FormErrorMessage = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _prefix;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "form-error-message" : _props$classPrefix, className = props.className, show = props.show, children = props.children, placement = props.placement, rest = _objectWithoutPropertiesLoose(props, _excluded$19);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var classes = withClassPrefix("show");
  var wrapperClasses = merge2(className, prefix2("wrapper", (_prefix = {}, _prefix["placement-" + kebabCase$1(placementPolyfill(placement))] = placement, _prefix)));
  return show ? /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: wrapperClasses
  }), /* @__PURE__ */ React.createElement("span", {
    className: classes
  }, /* @__PURE__ */ React.createElement("span", {
    className: prefix2(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteralLoose(["arrow"])))
  }), /* @__PURE__ */ React.createElement("span", {
    className: prefix2(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose(["inner"])))
  }, children))) : null;
});
FormErrorMessage.displayName = "FormErrorMessage";
FormErrorMessage.propTypes = {
  show: PropTypes.bool,
  classPrefix: PropTypes.string,
  children: PropTypes.node,
  className: PropTypes.string,
  placement: oneOf(["bottomStart", "bottomEnd", "topStart", "topEnd", "leftStart", "rightStart", "leftEnd", "rightEnd"])
};
function useRegisterModel(name, rule) {
  var _ref = useFormContext$1() || {}, pushFieldRule = _ref.pushFieldRule, removeFieldRule = _ref.removeFieldRule;
  var refRule = reactExports.useRef(rule);
  refRule.current = rule;
  reactExports.useEffect(function() {
    pushFieldRule === null || pushFieldRule === void 0 ? void 0 : pushFieldRule(name, refRule);
    return function() {
      removeFieldRule === null || removeFieldRule === void 0 ? void 0 : removeFieldRule(name);
    };
  }, [name, pushFieldRule, removeFieldRule]);
}
var baseSet = _baseSet;
function set$1(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var set_1 = set$1;
const set$2 = /* @__PURE__ */ getDefaultExportFromCjs(set_1);
function nameToPath(name) {
  return name.includes(".") ? name.replace(".", ".object.") : name;
}
function getErrorMessage(error) {
  var _error$array;
  if (error !== null && error !== void 0 && error.array && ((_error$array = error.array) === null || _error$array === void 0 ? void 0 : _error$array.length) > 0) {
    return error.array[0].errorMessage;
  }
  return error === null || error === void 0 ? void 0 : error.errorMessage;
}
function useField$1(props) {
  var name = props.name, formValue = props.formValue, formError = props.formError, value = props.value, nestedField = props.nestedField, errorMessage = props.errorMessage, errorFromContext = props.errorFromContext;
  var fieldValue = reactExports.useMemo(function() {
    if (typeof value !== "undefined") {
      return value;
    }
    return nestedField ? get$4(formValue, name) : formValue === null || formValue === void 0 ? void 0 : formValue[name];
  }, [formValue, name, nestedField, value]);
  var fieldError = reactExports.useMemo(function() {
    if (typeof errorMessage !== "undefined" || !errorFromContext) {
      return errorMessage;
    }
    if (nestedField) {
      return getErrorMessage(get$4(formError, nameToPath(name)));
    }
    var fieldError2 = formError === null || formError === void 0 ? void 0 : formError[name];
    if (typeof fieldError2 === "string") {
      return fieldError2;
    }
    return getErrorMessage(fieldError2);
  }, [errorFromContext, errorMessage, formError, name, nestedField]);
  var setFieldValue = reactExports.useCallback(function(fieldName, fieldValue2) {
    var _extends2;
    if (nestedField) {
      return set$2(_extends$1({}, formValue), fieldName, fieldValue2);
    }
    return _extends$1({}, formValue, (_extends2 = {}, _extends2[fieldName] = fieldValue2, _extends2));
  }, [formValue, nestedField]);
  return {
    fieldValue,
    fieldError,
    setFieldValue
  };
}
var _excluded$18 = ["as", "disabled", "readOnly", "loading", "plaintext", "children", "className", "color", "checkedChildren", "unCheckedChildren", "classPrefix", "checked", "defaultChecked", "size", "locale", "onChange"];
var Toggle = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "span" : _props$as, disabled = props.disabled, readOnly = props.readOnly, _props$loading = props.loading, loading = _props$loading === void 0 ? false : _props$loading, plaintext = props.plaintext, children = props.children, className = props.className, color2 = props.color, checkedChildren = props.checkedChildren, unCheckedChildren = props.unCheckedChildren, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "toggle" : _props$classPrefix, checkedProp = props.checked, defaultChecked = props.defaultChecked, size2 = props.size, localeProp = props.locale, onChange = props.onChange, rest = _objectWithoutPropertiesLoose(props, _excluded$18);
  var inputRef = reactExports.useRef(null);
  var _useControlled = useControlled$2(checkedProp, defaultChecked), checked = _useControlled[0], setChecked = _useControlled[1];
  var _useCustom = useCustom("Toggle", localeProp), locale2 = _useCustom.locale;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix(size2, color2, {
    checked,
    disabled,
    loading
  }));
  var inner = checked ? checkedChildren : unCheckedChildren;
  var label = checked ? locale2.on : locale2.off;
  var labelId = useUniqueId("rs-label");
  var innerId = inner ? labelId + "-inner" : void 0;
  var labelledby = children ? labelId : innerId;
  var _partitionHTMLProps = partitionHTMLProps(rest), htmlInputProps2 = _partitionHTMLProps[0], restProps = _partitionHTMLProps[1];
  var handleInputChange = useEventCallback$2(function(e3) {
    if (disabled || readOnly || loading) {
      return;
    }
    var checked2 = e3.target.checked;
    setChecked(checked2);
    onChange === null || onChange === void 0 ? void 0 : onChange(checked2, e3);
  });
  if (plaintext) {
    return /* @__PURE__ */ React.createElement(Plaintext, null, inner || label);
  }
  return /* @__PURE__ */ React.createElement("label", _extends$1({
    ref,
    className: classes
  }, restProps), /* @__PURE__ */ React.createElement("input", _extends$1({}, htmlInputProps2, {
    ref: inputRef,
    type: "checkbox",
    checked: checkedProp,
    defaultChecked,
    disabled,
    readOnly,
    onChange: handleInputChange,
    className: prefix2("input"),
    role: "switch",
    "aria-checked": checked,
    "aria-disabled": disabled,
    "aria-labelledby": labelledby,
    "aria-label": labelledby ? void 0 : label,
    "aria-busy": loading || void 0
  })), /* @__PURE__ */ React.createElement(Component, {
    className: prefix2("presentation")
  }, /* @__PURE__ */ React.createElement("span", {
    className: prefix2("inner"),
    id: innerId
  }, inner), loading && /* @__PURE__ */ React.createElement(Loader, {
    className: prefix2("loader")
  })), children && /* @__PURE__ */ React.createElement("span", {
    className: prefix2("label"),
    id: labelId
  }, children));
});
Toggle.displayName = "Toggle";
Toggle.propTypes = {
  disabled: PropTypes.bool,
  readOnly: PropTypes.bool,
  plaintext: PropTypes.bool,
  checked: PropTypes.bool,
  defaultChecked: PropTypes.bool,
  checkedChildren: PropTypes.node,
  unCheckedChildren: PropTypes.node,
  loading: PropTypes.bool,
  classPrefix: PropTypes.string,
  className: PropTypes.string,
  children: PropTypes.node,
  onChange: PropTypes.func,
  as: PropTypes.elementType,
  size: oneOf(["sm", "md", "lg"]),
  locale: PropTypes.shape({
    on: PropTypes.string,
    off: PropTypes.string
  })
};
var _templateObject$2;
var _excluded$17 = ["as", "accepter", "classPrefix", "checkAsync", "checkTrigger", "errorPlacement", "errorMessage", "name", "value", "readOnly", "plaintext", "disabled", "onChange", "onBlur", "defaultValue", "shouldResetWithUnmount", "rule", "id"];
var FormControl$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _accepterProps;
  var _useContext = reactExports.useContext(FormContext), readOnlyContext = _useContext.readOnly, plaintextContext = _useContext.plaintext, disabledContext = _useContext.disabled, errorFromContext = _useContext.errorFromContext, formError = _useContext.formError, nestedField = _useContext.nestedField, removeFieldValue = _useContext.removeFieldValue, removeFieldError = _useContext.removeFieldError, onFieldChange = _useContext.onFieldChange, contextCheckTrigger = _useContext.checkTrigger, checkFieldForNextValue = _useContext.checkFieldForNextValue, checkFieldAsyncForNextValue = _useContext.checkFieldAsyncForNextValue;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$accepter = props.accepter, AccepterComponent = _props$accepter === void 0 ? Input$1 : _props$accepter, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "form-control" : _props$classPrefix, checkAsync = props.checkAsync, checkTrigger = props.checkTrigger, _props$errorPlacement = props.errorPlacement, errorPlacement = _props$errorPlacement === void 0 ? "bottomStart" : _props$errorPlacement, errorMessage = props.errorMessage, name = props.name, value = props.value, _props$readOnly = props.readOnly, readOnly = _props$readOnly === void 0 ? readOnlyContext : _props$readOnly, _props$plaintext = props.plaintext, plaintext = _props$plaintext === void 0 ? plaintextContext : _props$plaintext, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? disabledContext : _props$disabled, onChange = props.onChange, onBlur = props.onBlur, defaultValue = props.defaultValue, _props$shouldResetWit = props.shouldResetWithUnmount, shouldResetWithUnmount = _props$shouldResetWit === void 0 ? false : _props$shouldResetWit, rule = props.rule, id2 = props.id, rest = _objectWithoutPropertiesLoose(props, _excluded$17);
  var _useFormGroup = useFormGroup(id2), controlId = _useFormGroup.controlId, helpTextId = _useFormGroup.helpTextId, labelId = _useFormGroup.labelId, errorMessageId = _useFormGroup.errorMessageId;
  if (!onFieldChange) {
    throw new Error("\n      <FormControl> must be inside a component decorated with <Form>.\n      And need to update React to 16.6.0 +.\n    ");
  }
  useRegisterModel(name, rule);
  useWillUnmount(function() {
    if (shouldResetWithUnmount) {
      removeFieldValue === null || removeFieldValue === void 0 ? void 0 : removeFieldValue(name);
      removeFieldError === null || removeFieldError === void 0 ? void 0 : removeFieldError(name);
    }
  });
  var trigger2 = checkTrigger || contextCheckTrigger;
  var formValue = reactExports.useContext(FormValueContext);
  var _useField = useField$1({
    name,
    errorMessage,
    formValue,
    formError,
    value,
    nestedField,
    errorFromContext
  }), fieldValue = _useField.fieldValue, fieldError = _useField.fieldError, setFieldValue = _useField.setFieldValue;
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix;
  var classes = withClassPrefix("wrapper");
  var handleFieldChange = useEventCallback$2(function(value2, event) {
    if (trigger2 === "change") {
      handleFieldCheck(value2);
    }
    onFieldChange === null || onFieldChange === void 0 ? void 0 : onFieldChange(name, value2, event);
    onChange === null || onChange === void 0 ? void 0 : onChange(value2, event);
  });
  var handleFieldBlur = useEventCallback$2(function(event) {
    if (trigger2 === "blur") {
      handleFieldCheck(fieldValue);
    }
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
  });
  var handleFieldCheck = useEventCallback$2(function(value2) {
    var nextFormValue = setFieldValue(name, value2);
    if (checkAsync) {
      checkFieldAsyncForNextValue(name, nextFormValue);
    } else {
      checkFieldForNextValue(name, nextFormValue);
    }
  });
  var fieldHasError = Boolean(fieldError);
  var valueKey = AccepterComponent === Toggle ? "checked" : "value";
  var accepterProps = (_accepterProps = {}, _accepterProps[valueKey] = fieldValue === void 0 ? defaultValue : fieldValue, _accepterProps);
  return /* @__PURE__ */ React.createElement(Component, {
    className: classes,
    ref,
    "data-testid": "form-control-wrapper"
  }, /* @__PURE__ */ React.createElement(AccepterComponent, _extends$1({
    id: controlId,
    "aria-labelledby": labelId,
    "aria-describedby": helpTextId,
    "aria-invalid": fieldHasError || void 0,
    "aria-errormessage": fieldHasError ? errorMessageId : void 0
  }, accepterProps, rest, {
    readOnly,
    plaintext,
    disabled,
    name,
    onChange: handleFieldChange,
    onBlur: handleFieldBlur
  })), /* @__PURE__ */ React.createElement(FormErrorMessage, {
    id: errorMessageId,
    role: "alert",
    "aria-relevant": "all",
    show: fieldHasError,
    className: prefix2(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose(["message-wrapper"]))),
    placement: errorPlacement
  }, fieldError));
});
FormControl$1.displayName = "FormControl";
FormControl$1.propTypes = {
  name: PropTypes.string.isRequired,
  checkTrigger: oneOf(["change", "blur", "none"]),
  checkAsync: PropTypes.bool,
  accepter: PropTypes.any,
  onChange: PropTypes.func,
  onBlur: PropTypes.func,
  classPrefix: PropTypes.string,
  errorMessage: PropTypes.node,
  errorPlacement: oneOf(["bottomStart", "bottomEnd", "topStart", "topEnd", "leftStart", "rightStart", "leftEnd", "rightEnd"]),
  value: PropTypes.any
};
var _excluded$16 = ["as", "classPrefix", "htmlFor", "className", "id"];
var FormControlLabel$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useFormGroup = useFormGroup(), labelId = _useFormGroup.labelId, controlId = _useFormGroup.controlId;
  var _props$as = props.as, Component = _props$as === void 0 ? "label" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "form-control-label" : _props$classPrefix, _props$htmlFor = props.htmlFor, htmlFor = _props$htmlFor === void 0 ? controlId : _props$htmlFor, className = props.className, _props$id = props.id, id2 = _props$id === void 0 ? labelId : _props$id, rest = _objectWithoutPropertiesLoose(props, _excluded$16);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    id: id2,
    htmlFor
  }, rest, {
    ref,
    className: classes
  }));
});
FormControlLabel$1.displayName = "FormControlLabel";
FormControlLabel$1.propTypes = {
  className: PropTypes.string,
  htmlFor: PropTypes.string,
  classPrefix: PropTypes.string
};
var HelpO$2 = {};
var HelpO$1 = { exports: {} };
var HelpO = {};
var hasRequiredHelpO;
function requireHelpO() {
  if (hasRequiredHelpO) return HelpO;
  hasRequiredHelpO = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function HelpO2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 14 14",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M7 12.833A5.833 5.833 0 107 1.167a5.833 5.833 0 000 11.666zM7 14A7 7 0 117 0a7 7 0 010 14zm0-2.333a1.167 1.167 0 100-2.334 1.167 1.167 0 000 2.334zm.583-3.5v-.762c1.128-.47 1.75-1.189 1.75-2.155 0-1.489-.844-2.333-2.333-2.333-1.468 0-2.333.89-2.333 2.333a.583.583 0 101.166 0c0-.806.35-1.167 1.167-1.167.844 0 1.167.322 1.167 1.167 0 .481-.397.879-1.351 1.197A.583.583 0 006.417 7v1.167a.583.583 0 101.166 0z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(HelpO2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(HelpO);
  return HelpO;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _HelpO = _interopRequireDefault2(requireHelpO());
  var HelpO2 = (0, _createSvgIcon2["default"])({
    as: _HelpO["default"],
    ariaLabel: "help o",
    category: "legacy",
    displayName: "HelpO"
  });
  var _default = HelpO2;
  exports["default"] = _default;
  module.exports = exports.default;
})(HelpO$1, HelpO$1.exports);
var HelpOExports = HelpO$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _HelpO["default"];
    }
  });
  var _HelpO = _interopRequireDefault2(HelpOExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(HelpO$2);
const HelpIcon = /* @__PURE__ */ getDefaultExportFromCjs(HelpO$2);
var _excluded$15 = ["as", "classPrefix", "className", "tooltip", "children", "id"];
var FormHelpText = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _useFormGroup = useFormGroup(), helpTextId = _useFormGroup.helpTextId;
  var _props$as = props.as, Component = _props$as === void 0 ? "span" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "form-help-text" : _props$classPrefix, className = props.className, tooltip = props.tooltip, children = props.children, _props$id = props.id, id2 = _props$id === void 0 ? helpTextId : _props$id, rest = _objectWithoutPropertiesLoose(props, _excluded$15);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix({
    tooltip
  }));
  if (tooltip) {
    return /* @__PURE__ */ React.createElement(Whisper, {
      ref,
      placement: "topEnd",
      speaker: /* @__PURE__ */ React.createElement(Tooltip$1, _extends$1({
        id: id2
      }, rest), children)
    }, /* @__PURE__ */ React.createElement(Component, {
      role: "img",
      "aria-label": "help",
      className: classes
    }, /* @__PURE__ */ React.createElement(HelpIcon, {
      "aria-hidden": true
    })));
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    id: id2
  }, rest, {
    ref,
    className: classes
  }), children);
});
FormHelpText.displayName = "FormHelpText";
FormHelpText.propTypes = {
  className: PropTypes.string,
  tooltip: PropTypes.bool,
  children: PropTypes.node,
  classPrefix: PropTypes.string
};
function useSchemaModel(formModel) {
  var subRulesRef = reactExports.useRef([]);
  var pushFieldRule = reactExports.useCallback(function(name, fieldRule) {
    subRulesRef.current.push({
      name,
      fieldRule
    });
  }, []);
  var removeFieldRule = reactExports.useCallback(function(name) {
    var index = subRulesRef.current.findIndex(function(v2) {
      return v2.name === name;
    });
    subRulesRef.current.splice(index, 1);
  }, []);
  var getCombinedModel = reactExports.useCallback(function() {
    var realSubRules = subRulesRef.current.filter(function(v2) {
      return Boolean(v2.fieldRule.current);
    });
    if (realSubRules.length === 0) {
      return formModel;
    }
    return SchemaModel.combine(formModel, SchemaModel(realSubRules.map(function(_ref) {
      var _ref2;
      var name = _ref.name, fieldRule = _ref.fieldRule;
      return _ref2 = {}, _ref2[name] = fieldRule.current, _ref2;
    }).reduce(function(a3, b3) {
      return Object.assign(a3, b3);
    }, {})));
  }, [formModel]);
  return {
    getCombinedModel,
    pushFieldRule,
    removeFieldRule
  };
}
function _toPropertyKey(t3) {
  var i2 = _toPrimitive(t3, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive(t3, r2) {
  if ("object" != typeof t3 || !t3) return t3;
  var e3 = t3[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i2 = e3.call(t3, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t3);
}
function useFormValidate(formError, props) {
  var formValue = props.formValue, getCombinedModel = props.getCombinedModel, onCheck = props.onCheck, onError = props.onError, nestedField = props.nestedField;
  var _useControlled = useControlled$2(formError, {}), realFormError = _useControlled[0], setFormError = _useControlled[1];
  var checkOptions = {
    nestedObject: nestedField
  };
  var realFormErrorRef = reactExports.useRef(realFormError);
  realFormErrorRef.current = realFormError;
  var check = useEventCallback$2(function(callback) {
    var formError2 = {};
    var errorCount = 0;
    var model = getCombinedModel();
    Object.keys(model.getSchemaSpec()).forEach(function(key) {
      var checkResult = model.checkForField(key, formValue || {}, checkOptions);
      if (checkResult.hasError === true) {
        errorCount += 1;
        formError2[key] = (checkResult === null || checkResult === void 0 ? void 0 : checkResult.errorMessage) || checkResult;
      }
    });
    setFormError(formError2);
    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError2);
    callback === null || callback === void 0 ? void 0 : callback(formError2);
    if (errorCount > 0) {
      onError === null || onError === void 0 ? void 0 : onError(formError2);
      return false;
    }
    return true;
  });
  var checkFieldForNextValue = useEventCallback$2(function(fieldName, nextValue, callback) {
    var model = getCombinedModel();
    var resultOfCurrentField = model.checkForField(fieldName, nextValue, checkOptions);
    var nextFormError = _extends$1({}, formError);
    if (nestedField) {
      nextFormError = set$2(nextFormError, nameToPath(fieldName), resultOfCurrentField);
      setFormError(nextFormError);
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
      callback === null || callback === void 0 ? void 0 : callback(resultOfCurrentField);
      if (resultOfCurrentField.hasError) {
        onError === null || onError === void 0 ? void 0 : onError(nextFormError);
      }
      return !resultOfCurrentField.hasError;
    } else {
      var allResults = model.getCheckResult();
      var hasError = false;
      Object.keys(allResults).forEach(function(key) {
        var currentResult = allResults[key];
        if (currentResult.hasError) {
          nextFormError[key] = currentResult.errorMessage || currentResult;
          hasError = true;
        } else {
          var _nextFormError = nextFormError;
          _nextFormError[key];
          var rest = _objectWithoutPropertiesLoose(_nextFormError, [key].map(_toPropertyKey));
          nextFormError = rest;
        }
      });
      setFormError(nextFormError);
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
      callback === null || callback === void 0 ? void 0 : callback(resultOfCurrentField);
      if (hasError) {
        onError === null || onError === void 0 ? void 0 : onError(nextFormError);
      }
      return !hasError;
    }
  });
  var checkForField = useEventCallback$2(function(fieldName, callback) {
    return checkFieldForNextValue(fieldName, formValue || {}, callback);
  });
  var checkAsync = useEventCallback$2(function() {
    var promises = [];
    var keys2 = [];
    var model = getCombinedModel();
    Object.keys(model.getSchemaSpec()).forEach(function(key) {
      keys2.push(key);
      promises.push(model.checkForFieldAsync(key, formValue || {}, checkOptions));
    });
    return Promise.all(promises).then(function(values2) {
      var formError2 = {};
      var errorCount = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        if (values2[i2].hasError) {
          errorCount += 1;
          formError2[keys2[i2]] = values2[i2].errorMessage;
        }
      }
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError2);
      setFormError(formError2);
      if (errorCount > 0) {
        onError === null || onError === void 0 ? void 0 : onError(formError2);
      }
      return {
        hasError: errorCount > 0,
        formError: formError2
      };
    });
  });
  var checkFieldAsyncForNextValue = useEventCallback$2(function(fieldName, nextValue) {
    var model = getCombinedModel();
    return model.checkForFieldAsync(fieldName, nextValue, checkOptions).then(function(resultOfCurrentField) {
      var nextFormError = _extends$1({}, formError);
      if (nestedField) {
        nextFormError = set$2(nextFormError, nameToPath(fieldName), resultOfCurrentField);
        onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
        setFormError(nextFormError);
        if (resultOfCurrentField.hasError) {
          onError === null || onError === void 0 ? void 0 : onError(nextFormError);
        }
        return resultOfCurrentField;
      } else {
        var allResults = model.getCheckResult();
        var hasError = false;
        Object.keys(allResults).forEach(function(key) {
          var currentResult = allResults[key];
          if (currentResult.hasError) {
            nextFormError[key] = currentResult.errorMessage || currentResult;
            hasError = true;
          } else {
            var _nextFormError2 = nextFormError;
            _nextFormError2[key];
            var rest = _objectWithoutPropertiesLoose(_nextFormError2, [key].map(_toPropertyKey));
            nextFormError = rest;
          }
        });
        setFormError(nextFormError);
        onCheck === null || onCheck === void 0 ? void 0 : onCheck(nextFormError);
        if (hasError) {
          onError === null || onError === void 0 ? void 0 : onError(nextFormError);
        }
        return resultOfCurrentField;
      }
    });
  });
  var checkForFieldAsync = useEventCallback$2(function(fieldName) {
    return checkFieldAsyncForNextValue(fieldName, formValue || {});
  });
  var onRemoveError = reactExports.useCallback(function(name) {
    var formError2 = omit$1(realFormErrorRef.current, [nestedField ? nameToPath(name) : name]);
    realFormErrorRef.current = formError2;
    setFormError(formError2);
    onCheck === null || onCheck === void 0 ? void 0 : onCheck(formError2);
    return formError2;
  }, [nestedField, onCheck, setFormError]);
  var cleanErrors = useEventCallback$2(function() {
    setFormError({});
  });
  var resetErrors = useEventCallback$2(function(formError2) {
    if (formError2 === void 0) {
      formError2 = {};
    }
    setFormError(formError2);
  });
  var cleanErrorForField = useEventCallback$2(function(fieldName) {
    setFormError(omit$1(formError, [nestedField ? nameToPath(fieldName) : fieldName]));
  });
  return {
    formError: realFormError,
    check,
    checkForField,
    checkFieldForNextValue,
    checkAsync,
    checkForFieldAsync,
    checkFieldAsyncForNextValue,
    cleanErrors,
    resetErrors,
    cleanErrorForField,
    onRemoveError
  };
}
function useFormValue(controlledValue, props) {
  var formDefaultValue = props.formDefaultValue, nestedField = props.nestedField;
  var _useControlled = useControlled$2(controlledValue, formDefaultValue), formValue = _useControlled[0], setFormValue = _useControlled[1];
  var realFormValueRef = reactExports.useRef(formValue);
  realFormValueRef.current = formValue;
  var setFieldValue = reactExports.useCallback(function(fieldName, fieldValue) {
    var _extends2;
    var nextFormError = nestedField ? set$2(_extends$1({}, formValue), fieldName, fieldValue) : _extends$1({}, formValue, (_extends2 = {}, _extends2[fieldName] = fieldValue, _extends2));
    setFormValue(nextFormError);
    return nextFormError;
  }, [formValue, nestedField, setFormValue]);
  var onRemoveValue = reactExports.useCallback(function(name) {
    var formValue2 = omit$1(realFormValueRef.current, [name]);
    realFormValueRef.current = formValue2;
    setFormValue(formValue2);
    return formValue2;
  }, [setFormValue]);
  var resetFormValue = reactExports.useCallback(function(nextValue) {
    var value = nextValue || formDefaultValue;
    setFormValue(value);
    return value;
  }, [formDefaultValue, setFormValue]);
  return {
    formValue,
    setFormValue,
    setFieldValue,
    onRemoveValue,
    resetFormValue
  };
}
function useFormClassNames(_ref) {
  var _ref$classPrefix = _ref.classPrefix, classPrefix = _ref$classPrefix === void 0 ? "form" : _ref$classPrefix, className = _ref.className, fluid = _ref.fluid, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? "vertical" : _ref$layout, readOnly = _ref.readOnly, plaintext = _ref.plaintext, disabled = _ref.disabled;
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  return merge2(className, withClassPrefix(layout, fluid && layout === "vertical" ? "fluid" : "fixed-width", {
    readonly: readOnly,
    disabled,
    plaintext
  }));
}
function useFormRef(ref, props) {
  var rootRef = reactExports.useRef(null);
  var imperativeMethods = props.imperativeMethods;
  reactExports.useImperativeHandle(ref, function() {
    return _extends$1({
      root: rootRef.current
    }, imperativeMethods);
  });
  return rootRef;
}
var _excluded$14 = ["checkTrigger", "classPrefix", "errorFromContext", "formDefaultValue", "formValue", "formError", "fluid", "nestedField", "layout", "model", "readOnly", "plaintext", "className", "children", "disabled", "onSubmit", "onReset", "onCheck", "onError", "onChange"];
var defaultSchema = SchemaModel({});
var Form = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$checkTrigger = props.checkTrigger, checkTrigger = _props$checkTrigger === void 0 ? "change" : _props$checkTrigger, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "form" : _props$classPrefix, _props$errorFromConte = props.errorFromContext, errorFromContext = _props$errorFromConte === void 0 ? true : _props$errorFromConte, _props$formDefaultVal = props.formDefaultValue, formDefaultValue = _props$formDefaultVal === void 0 ? {} : _props$formDefaultVal, controlledFormValue = props.formValue, controlledFormError = props.formError, fluid = props.fluid, _props$nestedField = props.nestedField, nestedField = _props$nestedField === void 0 ? false : _props$nestedField, _props$layout = props.layout, layout = _props$layout === void 0 ? "vertical" : _props$layout, _props$model = props.model, formModel = _props$model === void 0 ? defaultSchema : _props$model, readOnly = props.readOnly, plaintext = props.plaintext, className = props.className, children = props.children, disabled = props.disabled, onSubmit = props.onSubmit, onReset = props.onReset, onCheck = props.onCheck, onError = props.onError, onChange = props.onChange, rest = _objectWithoutPropertiesLoose(props, _excluded$14);
  var _useSchemaModel = useSchemaModel(formModel), getCombinedModel = _useSchemaModel.getCombinedModel, pushFieldRule = _useSchemaModel.pushFieldRule, removeFieldRule = _useSchemaModel.removeFieldRule;
  var _useFormValue = useFormValue(controlledFormValue, {
    formDefaultValue,
    nestedField
  }), formValue = _useFormValue.formValue, onRemoveValue = _useFormValue.onRemoveValue, setFieldValue = _useFormValue.setFieldValue, resetFormValue = _useFormValue.resetFormValue;
  var formValidateProps = {
    formValue,
    getCombinedModel,
    onCheck,
    onError,
    nestedField
  };
  var _useFormValidate = useFormValidate(controlledFormError, formValidateProps), formError = _useFormValidate.formError, onRemoveError = _useFormValidate.onRemoveError, check = _useFormValidate.check, checkAsync = _useFormValidate.checkAsync, checkForField = _useFormValidate.checkForField, checkFieldForNextValue = _useFormValidate.checkFieldForNextValue, checkForFieldAsync = _useFormValidate.checkForFieldAsync, checkFieldAsyncForNextValue = _useFormValidate.checkFieldAsyncForNextValue, cleanErrors = _useFormValidate.cleanErrors, resetErrors = _useFormValidate.resetErrors, cleanErrorForField = _useFormValidate.cleanErrorForField;
  var classes = useFormClassNames({
    classPrefix,
    className,
    fluid,
    layout,
    readOnly,
    plaintext,
    disabled
  });
  var submit = useEventCallback$2(function(event) {
    if (check()) {
      onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(formValue, event);
    }
  });
  var reset = useEventCallback$2(function(event) {
    resetErrors();
    onReset === null || onReset === void 0 ? void 0 : onReset(resetFormValue(), event);
  });
  var handleSubmit = useEventCallback$2(function(event) {
    var _event$preventDefault, _event$stopPropagatio;
    event === null || event === void 0 ? void 0 : (_event$preventDefault = event.preventDefault) === null || _event$preventDefault === void 0 ? void 0 : _event$preventDefault.call(event);
    event === null || event === void 0 ? void 0 : (_event$stopPropagatio = event.stopPropagation) === null || _event$stopPropagatio === void 0 ? void 0 : _event$stopPropagatio.call(event);
    if (disabled || readOnly || plaintext) {
      return;
    }
    submit();
  });
  var handleReset = useEventCallback$2(function(event) {
    var _event$preventDefault2, _event$stopPropagatio2;
    event === null || event === void 0 ? void 0 : (_event$preventDefault2 = event.preventDefault) === null || _event$preventDefault2 === void 0 ? void 0 : _event$preventDefault2.call(event);
    event === null || event === void 0 ? void 0 : (_event$stopPropagatio2 = event.stopPropagation) === null || _event$stopPropagatio2 === void 0 ? void 0 : _event$stopPropagatio2.call(event);
    if (disabled || readOnly || plaintext) {
      return;
    }
    reset(event);
  });
  var imperativeMethods = {
    check,
    checkForField,
    checkAsync,
    checkForFieldAsync,
    cleanErrors,
    cleanErrorForField,
    reset,
    resetErrors,
    submit
  };
  var formRef = useFormRef(ref, {
    imperativeMethods
  });
  var removeFieldValue = useEventCallback$2(function(name) {
    var formValue2 = onRemoveValue(name);
    onChange === null || onChange === void 0 ? void 0 : onChange(formValue2);
  });
  var removeFieldError = useEventCallback$2(function(name) {
    onRemoveError(name);
  });
  var onFieldChange = useEventCallback$2(function(name, value, event) {
    var nextFormValue = setFieldValue(name, value);
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFormValue, event);
  });
  var formContextValue = {
    errorFromContext,
    checkTrigger,
    plaintext,
    readOnly,
    disabled,
    formError,
    nestedField,
    pushFieldRule,
    removeFieldValue,
    removeFieldError,
    removeFieldRule,
    onFieldChange,
    checkFieldForNextValue,
    checkFieldAsyncForNextValue
  };
  return /* @__PURE__ */ React.createElement("form", _extends$1({}, rest, {
    ref: formRef,
    onSubmit: handleSubmit,
    onReset: handleReset,
    className: classes
  }), /* @__PURE__ */ React.createElement(FormProvider, {
    value: formContextValue
  }, /* @__PURE__ */ React.createElement(FormValueProvider, {
    value: formValue
  }, children)));
});
Form.Control = FormControl$1;
Form.ControlLabel = FormControlLabel$1;
Form.ErrorMessage = FormErrorMessage;
Form.Group = FormGroup;
Form.HelpText = FormHelpText;
Form.displayName = "Form";
Form.propTypes = {
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  children: PropTypes.node,
  errorFromContext: PropTypes.bool,
  layout: oneOf(["horizontal", "vertical", "inline"]),
  fluid: PropTypes.bool,
  formValue: PropTypes.object,
  formDefaultValue: PropTypes.object,
  formError: PropTypes.object,
  checkTrigger: oneOf(["change", "blur", "none"]),
  onChange: PropTypes.func,
  onError: PropTypes.func,
  onCheck: PropTypes.func,
  onSubmit: PropTypes.func,
  model: PropTypes.any,
  readOnly: PropTypes.bool,
  plaintext: PropTypes.bool,
  disabled: PropTypes.bool
};
var _excluded$13 = ["as", "className", "classPrefix", "disabled", "decimalSeparator", "formatter", "readOnly", "plaintext", "value", "defaultValue", "size", "prefix", "postfix", "step", "buttonAppearance", "min", "max", "scrollable", "onChange", "onWheel", "onBlur", "onFocus"];
var isNumber = function isNumber2(value) {
  return /(^-?|^\+?|^\d?)\d*\.\d+$/.test(value + "");
};
function getDecimalLength(value) {
  if (isNumber(value)) {
    return value.toString().split(".")[1].length;
  }
  return 0;
}
function decimals() {
  for (var _len = arguments.length, values2 = new Array(_len), _key = 0; _key < _len; _key++) {
    values2[_key] = arguments[_key];
  }
  var lengths = values2.map(getDecimalLength);
  return Math.max.apply(Math, lengths);
}
function valueReachesMax(value, max2) {
  if (!isNil$1(value)) {
    return +value >= max2;
  }
  return false;
}
function valueReachesMin(value, min2) {
  if (!isNil$1(value)) {
    return +value <= min2;
  }
  return false;
}
var InputNumber = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? InputGroup : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "input-number" : _props$classPrefix, disabled = props.disabled, decimalSeparator = props.decimalSeparator, formatter = props.formatter, readOnly = props.readOnly, plaintext = props.plaintext, valueProp = props.value, defaultValue = props.defaultValue, size2 = props.size, prefixElement = props.prefix, postfix = props.postfix, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, _props$buttonAppearan = props.buttonAppearance, buttonAppearance = _props$buttonAppearan === void 0 ? "subtle" : _props$buttonAppearan, minProp = props.min, maxProp = props.max, _props$scrollable = props.scrollable, scrollable = _props$scrollable === void 0 ? true : _props$scrollable, onChange = props.onChange, onWheel = props.onWheel, onBlur = props.onBlur, onFocus = props.onFocus, restProps = _objectWithoutPropertiesLoose(props, _excluded$13);
  var min2 = minProp !== null && minProp !== void 0 ? minProp : -Infinity;
  var max2 = maxProp !== null && maxProp !== void 0 ? maxProp : Infinity;
  var _useControlled = useControlled$2(valueProp, defaultValue), value = _useControlled[0], setValue2 = _useControlled[1];
  var _useState = reactExports.useState(false), isFocused = _useState[0], setIsFocused = _useState[1];
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, withClassPrefix());
  var _partitionHTMLProps = partitionHTMLProps(restProps), htmlInputProps2 = _partitionHTMLProps[0], rest = _partitionHTMLProps[1];
  var inputRef = reactExports.useRef();
  var getSafeValue = function getSafeValue2(value2) {
    if (!Number.isNaN(value2)) {
      if (+value2 > max2) {
        value2 = max2;
      }
      if (+value2 < min2) {
        value2 = min2;
      }
    } else {
      value2 = "";
    }
    return value2.toString();
  };
  var handleChangeValue = useEventCallback$2(function(currentValue, event) {
    if (currentValue !== value) {
      setValue2(currentValue);
      onChange === null || onChange === void 0 ? void 0 : onChange(currentValue, event);
    }
  });
  var handleStepUp = useEventCallback$2(function(event) {
    var val = +(value || 0);
    var bit = decimals(val, step);
    handleChangeValue(getSafeValue((val + step).toFixed(bit)), event);
  });
  var handleStepDown = useEventCallback$2(function(event) {
    var val = +(value || 0);
    var bit = decimals(val, step);
    handleChangeValue(getSafeValue((val - step).toFixed(bit)), event);
  });
  var stepUpDisabled = disabled || readOnly || valueReachesMax(value, max2);
  var stepDownDisabled = disabled || readOnly || valueReachesMin(value, min2);
  var handleKeyDown = useEventCallback$2(function(event) {
    switch (event.key) {
      case KEY_VALUES.UP:
        event.preventDefault();
        handleStepUp(event);
        break;
      case KEY_VALUES.DOWN:
        event.preventDefault();
        handleStepDown(event);
        break;
      case KEY_VALUES.HOME:
        if (typeof minProp !== "undefined") {
          event.preventDefault();
          handleChangeValue(getSafeValue(minProp), event);
        }
        break;
      case KEY_VALUES.END:
        if (typeof maxProp !== "undefined") {
          event.preventDefault();
          handleChangeValue(getSafeValue(maxProp), event);
        }
        break;
    }
  });
  var handleWheel = useEventCallback$2(function(event) {
    if (!scrollable) {
      event.preventDefault();
      return;
    }
    if (!disabled && !readOnly && event.target === document.activeElement) {
      event.preventDefault();
      var delta = event["wheelDelta"] || -event.deltaY || -(event === null || event === void 0 ? void 0 : event.detail);
      if (delta > 0) {
        handleStepDown(event);
      }
      if (delta < 0) {
        handleStepUp(event);
      }
    }
    onWheel === null || onWheel === void 0 ? void 0 : onWheel(event);
  });
  var handleChange = useEventCallback$2(function(value2, event) {
    var separator = decimalSeparator || ".";
    var escapedSeparator = separator.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    var regex = new RegExp("^-?(?:\\d+)?(" + escapedSeparator + ")?\\d*$");
    if (!regex.test(value2) && value2 !== "") {
      return;
    }
    handleChangeValue(value2, event);
  });
  var replaceDecimalSeparator = reactExports.useCallback(function(value2) {
    if (decimalSeparator && value2) {
      return value2.toString().replace(".", decimalSeparator);
    }
    return value2;
  }, [decimalSeparator]);
  var restoreDecimalSeparator = reactExports.useCallback(function(value2) {
    if (decimalSeparator && value2) {
      return value2.replace(decimalSeparator, ".");
    }
    return value2;
  }, [decimalSeparator]);
  var handleBlur = useEventCallback$2(function(event) {
    var _event$target;
    var value2 = restoreDecimalSeparator((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.value);
    var targetValue = Number.parseFloat(value2);
    handleChangeValue(getSafeValue(targetValue), event);
    setIsFocused(false);
  });
  reactExports.useEffect(function() {
    var wheelListener;
    if (inputRef.current) {
      wheelListener = on(inputRef.current, "wheel", handleWheel, {
        passive: false
      });
    }
    return function() {
      var _wheelListener;
      (_wheelListener = wheelListener) === null || _wheelListener === void 0 ? void 0 : _wheelListener.off();
    };
  }, [handleWheel, scrollable]);
  var inputValue = reactExports.useMemo(function() {
    if (isNil$1(value)) {
      return "";
    }
    if (isFocused) {
      return replaceDecimalSeparator(value);
    }
    if (formatter) {
      return formatter(value);
    }
    return replaceDecimalSeparator(value);
  }, [formatter, isFocused, replaceDecimalSeparator, value]);
  var input = /* @__PURE__ */ React.createElement(Input$1, _extends$1({}, htmlInputProps2, {
    ref: plaintext ? ref : void 0,
    inputRef,
    autoComplete: "off",
    inputMode: "numeric",
    step,
    value: inputValue,
    disabled,
    readOnly,
    plaintext,
    onKeyDown: handleKeyDown,
    onChange: handleChange,
    onBlur: createChainedFunction$1(handleBlur, onBlur),
    onFocus: createChainedFunction$1(function() {
      return setIsFocused(true);
    }, onFocus)
  }));
  if (plaintext) {
    return input;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes,
    disabled,
    size: size2
  }), prefixElement && /* @__PURE__ */ React.createElement(InputGroupAddon, null, prefixElement), input, /* @__PURE__ */ React.createElement("span", {
    className: prefix2("btn-group-vertical")
  }, /* @__PURE__ */ React.createElement(Button$1, {
    tabIndex: -1,
    appearance: buttonAppearance,
    className: prefix2("touchspin-up"),
    onClick: handleStepUp,
    disabled: stepUpDisabled,
    "aria-label": "Increment"
  }, /* @__PURE__ */ React.createElement(AngleUpIcon, null)), /* @__PURE__ */ React.createElement(Button$1, {
    tabIndex: -1,
    appearance: buttonAppearance,
    className: prefix2("touchspin-down"),
    onClick: handleStepDown,
    disabled: stepDownDisabled,
    "aria-label": "Decrement"
  }, /* @__PURE__ */ React.createElement(AngleDownIcon, null))), postfix && /* @__PURE__ */ React.createElement(InputGroupAddon, null, postfix));
});
InputNumber.displayName = "InputNumber";
InputNumber.propTypes = {
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  min: PropTypes.number,
  max: PropTypes.number,
  step: PropTypes.number,
  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  prefix: PropTypes.node,
  postfix: PropTypes.node,
  disabled: PropTypes.bool,
  readOnly: PropTypes.bool,
  plaintext: PropTypes.bool,
  scrollable: PropTypes.bool,
  size: oneOf(["lg", "md", "sm", "xs"]),
  buttonAppearance: oneOf(["default", "primary", "link", "subtle", "ghost"]),
  onWheel: PropTypes.func,
  onChange: PropTypes.func
};
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var _baseRest = baseRest$1;
function getPatternGroups(format2, pattern) {
  var _format$match;
  return ((_format$match = format2.match(new RegExp("(" + pattern + ")+"))) === null || _format$match === void 0 ? void 0 : _format$match[0]) || "";
}
function getSelectIndexGap(options) {
  var pattern = options.pattern, formatStr = options.formatStr, valueOffset = options.valueOffset, selectedMonth = options.selectedMonth, localize2 = options.localize;
  var gap2 = 0;
  var monthIsAbbreviated = formatStr.includes("MMM");
  var monthIsFull = formatStr.includes("MMMM");
  if (monthIsAbbreviated || monthIsFull) {
    var isSelectedMonth = pattern === "M";
    if (isSelectedMonth && valueOffset === null) {
      return 0;
    }
    if (selectedMonth === null && valueOffset === 0) {
      return 0;
    }
    var month = selectedMonth ? selectedMonth + (isSelectedMonth ? valueOffset || 0 : 0) : 1;
    if (month > 12) {
      month = 1;
    } else if (month === 0) {
      month = 12;
    }
    var monthStr = localize2 === null || localize2 === void 0 ? void 0 : localize2.month(month - 1, {
      width: monthIsFull ? "wide" : "abbreviated"
    });
    gap2 = monthStr.length - (monthIsFull ? 4 : 3);
  }
  return gap2;
}
function getDatePattern(options) {
  var selectionIndex = options.selectionIndex, _options$positionOffs = options.positionOffset, positionOffset = _options$positionOffs === void 0 ? -1 : _options$positionOffs, formatStr = options.formatStr, dateString = options.dateString, valueOffset = options.valueOffset, selectedMonth = options.selectedMonth, localize2 = options.localize;
  var pattern = formatStr.charAt(selectionIndex || 0);
  if (selectionIndex < 0 || selectionIndex > dateString.length - 1) {
    pattern = formatStr.trim().charAt(0);
    return pattern;
  }
  var gap2 = 0;
  if (isCursorAfterMonth(selectionIndex, formatStr)) {
    gap2 = getSelectIndexGap({
      pattern,
      formatStr,
      valueOffset,
      selectedMonth,
      localize: localize2
    });
  }
  pattern = formatStr.charAt(selectionIndex - gap2);
  if (!pattern.match(/[y|d|M|H|h|m|s|a]/)) {
    var nextIndex = selectionIndex + positionOffset;
    pattern = getDatePattern(_extends$1({}, options, {
      selectionIndex: nextIndex
    }));
  }
  return pattern;
}
function isCursorAfterMonth(cursorIndex, formatStr) {
  return cursorIndex > formatStr.indexOf("M");
}
function getInputSelectedState$1(options) {
  var input = options.input, direction = options.direction, formatStr = options.formatStr, localize2 = options.localize, selectedMonth = options.selectedMonth, dateString = options.dateString, _options$valueOffset = options.valueOffset, valueOffset = _options$valueOffset === void 0 ? 0 : _options$valueOffset;
  var getPatternSelectedIndexes = function getPatternSelectedIndexes2(pattern) {
    var selectionStart = formatStr.indexOf(pattern);
    var selectionEnd = formatStr.lastIndexOf(pattern) + 1;
    var gap2 = getSelectIndexGap({
      pattern,
      formatStr,
      valueOffset,
      selectedMonth,
      localize: localize2
    });
    var isSelectedMonth = pattern === "M";
    var isNullMonth = selectedMonth === null && !(isSelectedMonth && valueOffset !== 0);
    if (isNullMonth) {
      return {
        selectionStart,
        selectionEnd
      };
    }
    if (isSelectedMonth) {
      return {
        selectionStart,
        selectionEnd: selectionEnd + gap2
      };
    }
    if (isCursorAfterMonth(selectionStart, formatStr)) {
      return {
        selectionStart: selectionStart + gap2,
        selectionEnd: selectionEnd + gap2
      };
    }
    return {
      selectionStart,
      selectionEnd
    };
  };
  if (typeof input.selectionEnd === "number" && typeof input.selectionStart === "number") {
    var selectionIndex = input.selectionStart;
    var positionOffset = -1;
    if (direction === "left") {
      selectionIndex = input.selectionStart - 1;
    } else if (direction === "right") {
      selectionIndex = input.selectionEnd + 1;
      positionOffset = 1;
    }
    var datePattern = getDatePattern({
      selectionIndex,
      positionOffset,
      formatStr,
      dateString,
      valueOffset,
      selectedMonth,
      localize: localize2
    });
    var indexes = getPatternSelectedIndexes(datePattern);
    return _extends$1({
      selectedPattern: datePattern
    }, indexes);
  }
  return {
    selectedPattern: "y",
    selectionStart: 0,
    selectionEnd: 0
  };
}
function validateDateTime$1(type, value) {
  switch (type) {
    case "year":
      if (value < 1 || value > 9999) {
        return false;
      }
      break;
    case "month":
      if (value < 1 || value > 12) {
        return false;
      }
      break;
    case "day":
      if (value < 1 || value > 31) {
        return false;
      }
      break;
    case "hour":
      if (value < 0 || value > 23) {
        return false;
      }
      break;
    case "minute":
      if (value < 0 || value > 59) {
        return false;
      }
      break;
    case "second":
      if (value < 0 || value > 59) {
        return false;
      }
      break;
    default:
      return false;
  }
  return true;
}
function modifyDate(date, type, value) {
  switch (type) {
    case "year":
      return setYear(date, value);
    case "month":
      return setMonth(date, value - 1);
    case "day":
      return setDate(date, value);
    case "hour":
      return setHours(date, value);
    case "minute":
      return setMinutes(date, value);
    case "second":
      return setSeconds(date, value);
  }
  return date;
}
function useInputSelection(input) {
  return function setSelectionRange(selectionStart, selectionEnd) {
    var isTest = input.current.dataset.test === "true";
    if (isTest) {
      safeSetSelection(input.current, selectionStart, selectionEnd);
      return;
    }
    requestAnimationFrame(function() {
      safeSetSelection(input.current, selectionStart, selectionEnd);
    });
  };
}
var createCompounder$1 = _createCompounder, upperFirst = upperFirst_1;
var startCase = createCompounder$1(function(result, word, index) {
  return result + (index ? " " : "") + upperFirst(word);
});
var startCase_1 = startCase;
const startCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(startCase_1);
function _isNativeFunction(t3) {
  try {
    return -1 !== Function.toString.call(t3).indexOf("[native code]");
  } catch (n2) {
    return "function" == typeof t3;
  }
}
function _construct(t3, e3, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e3);
  var p2 = new (t3.bind.apply(t3, o))();
  return r2 && _setPrototypeOf(p2, r2.prototype), p2;
}
function _wrapNativeSuper(t3) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t4) {
    if (null === t4 || !_isNativeFunction(t4)) return t4;
    if ("function" != typeof t4) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t4)) return r2.get(t4);
      r2.set(t4, Wrapper);
    }
    function Wrapper() {
      return _construct(t4, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t4.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t4);
  }, _wrapNativeSuper(t3);
}
var patternMap = {
  y: "year",
  M: "month",
  d: "day",
  H: "hour",
  h: "hour",
  m: "minute",
  s: "second",
  a: "meridian"
};
var DateField$1 = /* @__PURE__ */ function(_Object) {
  function DateField3(format2, value) {
    var _this2;
    _this2 = _Object.call(this) || this;
    _this2.format = void 0;
    _this2.patternArray = [];
    _this2.year = null;
    _this2.month = null;
    _this2.day = null;
    _this2.hour = null;
    _this2.minute = null;
    _this2.second = null;
    _this2.format = format2;
    var formatArray = format2.match(new RegExp("([y|d|M|H|h|m|s|a])+", "ig")) || [];
    _this2.patternArray = formatArray.map(function(pattern) {
      return {
        pattern,
        key: patternMap[pattern[0]]
      };
    });
    if (value && isValid$1(value)) {
      _this2.year = value.getFullYear();
      _this2.month = value.getMonth() + 1;
      _this2.day = value.getDate();
      _this2.hour = value.getHours();
      _this2.minute = value.getMinutes();
      _this2.second = value.getSeconds();
    }
    return _this2;
  }
  _inheritsLoose(DateField3, _Object);
  return DateField3;
}(/* @__PURE__ */ _wrapNativeSuper(Object));
function padNumber(number, length2) {
  var numberString = String(number);
  if (numberString.length >= length2) {
    return numberString;
  }
  var paddingCount = length2 - numberString.length;
  for (var i2 = 0; i2 < paddingCount; i2++) {
    numberString = "0" + numberString;
  }
  return numberString;
}
var useDateField$1 = function useDateField(format2, localize2, date) {
  var _useReducer = reactExports.useReducer(function(state, action) {
    switch (action.type) {
      case "setYear":
        return _extends$1({}, state, {
          year: action.value
        });
      case "setMonth":
        return _extends$1({}, state, {
          month: action.value
        });
      case "setDay":
        return _extends$1({}, state, {
          day: action.value
        });
      case "setHour":
        return _extends$1({}, state, {
          hour: action.value
        });
      case "setMinute":
        return _extends$1({}, state, {
          minute: action.value
        });
      case "setSecond":
        return _extends$1({}, state, {
          second: action.value
        });
      case "setNewDate":
        return new DateField$1(format2, action.value);
      default:
        return state;
    }
  }, new DateField$1(format2, date)), dateField = _useReducer[0], dispatch = _useReducer[1];
  var toDateString = function toDateString2() {
    var str = format2;
    dateField.patternArray.forEach(function(item) {
      var key = item.key, pattern = item.pattern;
      var hour = dateField.hour;
      var value = dateField[key];
      if (value !== null) {
        if (pattern === "MMM" && typeof value === "number") {
          value = localize2 === null || localize2 === void 0 ? void 0 : localize2.month(value - 1, {
            width: "abbreviated"
          });
        } else if (pattern === "MMMM" && typeof value === "number") {
          value = localize2 === null || localize2 === void 0 ? void 0 : localize2.month(value - 1, {
            width: "wide"
          });
        } else if (pattern === "aa") {
          if (typeof hour === "number") {
            value = hour > 12 ? "PM" : "AM";
          } else {
            value = "aa";
          }
        } else if (pattern === "hh" && typeof value === "number") {
          value = value === 0 ? 12 : value > 12 ? value - 12 : value;
        }
        if (typeof value === "number") {
          value = padNumber(value, pattern.length);
        }
        if (typeof value !== "undefined") {
          str = str.replace(pattern, value);
        }
      }
    });
    return str;
  };
  var validFieldValue = function validFieldValue2(type, value) {
    var _format$match;
    var isValid2 = true;
    (_format$match = format2.match(new RegExp("([y|d|M|H|h|m|s])+", "ig"))) === null || _format$match === void 0 ? void 0 : _format$match.forEach(function(pattern) {
      var key = patternMap[pattern[0]];
      var fieldValue = type === key ? value : dateField[key];
      if (fieldValue === null) {
        isValid2 = false;
        return;
      }
    });
    return isValid2;
  };
  var isEmptyValue = function isEmptyValue2(type, value) {
    var _format$match2;
    var checkValueArray = (_format$match2 = format2.match(new RegExp("([y|d|M|H|h|m|s])+", "ig"))) === null || _format$match2 === void 0 ? void 0 : _format$match2.map(function(pattern) {
      var key = patternMap[pattern[0]];
      var fieldValue = type === key ? value : dateField[key];
      return fieldValue !== null;
    });
    return checkValueArray === null || checkValueArray === void 0 ? void 0 : checkValueArray.every(function(item) {
      return item === false;
    });
  };
  var toDate2 = function toDate3(type, value) {
    var year = dateField.year, month = dateField.month, day = dateField.day, hour = dateField.hour, minute = dateField.minute, second = dateField.second;
    var date2 = new Date(
      year || 0,
      typeof month === "number" ? Math.max(month - 1, 0) : 0,
      // The default day is 1 when the value is null, otherwise it becomes the last day of the month.
      day || 1,
      hour || 0,
      minute || 0,
      second || 0
    );
    if (typeof type === "undefined" || typeof value === "undefined") {
      return date2;
    }
    if (value === null || !validFieldValue(type, value)) {
      if (isEmptyValue(type, value)) {
        return null;
      }
      return /* @__PURE__ */ new Date("");
    } else if ((type === "day" || type === "month") && value === 0) {
      return /* @__PURE__ */ new Date("");
    }
    if (type === "meridian" && typeof hour === "number") {
      var newHour = hour > 12 ? hour - 12 : hour + 12;
      type = "hour";
      value = newHour;
    }
    return modifyDate(date2, type, value);
  };
  return {
    dateField,
    dispatch,
    toDate: toDate2,
    toDateString,
    isEmptyValue
  };
};
function useDateInputState(_ref) {
  var formatStr = _ref.formatStr, locale2 = _ref.locale, date = _ref.date, isControlledDate = _ref.isControlledDate;
  var _useCustom = useCustom(), formatDate = _useCustom.formatDate;
  var _useDateField = useDateField$1(formatStr, locale2.localize, date), dateField = _useDateField.dateField, dispatch = _useDateField.dispatch, toDateString = _useDateField.toDateString, toDate2 = _useDateField.toDate, isEmptyValue = _useDateField.isEmptyValue;
  var setDateOffset = function setDateOffset2(pattern, offset2, callback) {
    var currentDate = /* @__PURE__ */ new Date();
    var year = dateField.year || currentDate.getFullYear();
    var month = dateField.month ? dateField.month - 1 : currentDate.getMonth();
    var day = dateField.day || 0;
    var hour = dateField.hour || 0;
    var minute = dateField.minute || 0;
    var second = dateField.second || 0;
    var actionName;
    var value;
    switch (pattern) {
      case "y":
        actionName = "setYear";
        value = addYears(new Date(year, 0), offset2).getFullYear();
        break;
      case "M":
        actionName = "setMonth";
        value = addMonths(new Date(year, month), offset2).getMonth() + 1;
        break;
      case "d":
        actionName = "setDay";
        var prevDate = new Date(year, month, day);
        value = addDays(prevDate, offset2).getDate();
        if (offset2 > 0) {
          value = isLastDayOfMonth(prevDate) ? 1 : value;
        } else {
          value = prevDate.getDate() === 1 ? lastDayOfMonth(prevDate).getDate() : value;
        }
        break;
      case "H":
      case "h":
        actionName = "setHour";
        value = addHours(new Date(year, month, day, hour), offset2).getHours();
        break;
      case "m":
        actionName = "setMinute";
        value = addMinutes(new Date(year, month, day, hour, minute), offset2).getMinutes();
        break;
      case "s":
        actionName = "setSecond";
        value = addSeconds(new Date(year, month, day, hour, minute, second), offset2).getSeconds();
        break;
      case "a":
        actionName = "setHour";
        value = hour >= 12 ? hour - 12 : hour + 12;
        break;
    }
    if (actionName && value) {
      dispatch({
        type: actionName,
        value
      });
      var field = patternMap[pattern];
      callback === null || callback === void 0 ? void 0 : callback(toDate2(field, value));
    }
  };
  var setDateField = function setDateField2(pattern, value, callback) {
    var field = patternMap[pattern];
    var actionName = "set" + startCase$1(field);
    dispatch({
      type: actionName,
      value
    });
    callback === null || callback === void 0 ? void 0 : callback(toDate2(field, value));
  };
  var getDateField = function getDateField2(pattern) {
    var fieldName = patternMap[pattern];
    return {
      name: fieldName,
      value: dateField[fieldName]
    };
  };
  var toControlledDateString = function toControlledDateString2() {
    if (date && isValid$1(date)) {
      return formatDate(date, formatStr, {
        locale: locale2
      });
    }
    return toDateString();
  };
  var setNewDate = reactExports.useCallback(function(value) {
    dispatch({
      type: "setNewDate",
      value
    });
  }, [dispatch]);
  reactExports.useEffect(function() {
    if (isControlledDate) {
      if (date && isValid$1(date)) {
        setNewDate(date);
      } else if (date === null) {
        setNewDate(null);
      }
    }
  }, [date, dispatch, isControlledDate, setNewDate]);
  return {
    dateField,
    setDateOffset,
    setDateField,
    setNewDate,
    getDateField,
    toDateString: isControlledDate ? toControlledDateString : toDateString,
    isEmptyValue
  };
}
function useKeyboardInputEvent(_ref) {
  var onSegmentChange = _ref.onSegmentChange, onSegmentValueChange = _ref.onSegmentValueChange, onSegmentValueChangeWithNumericKeys = _ref.onSegmentValueChangeWithNumericKeys, onSegmentValueRemove = _ref.onSegmentValueRemove, onKeyDown = _ref.onKeyDown;
  return function(event) {
    var _key$match, _key$match2;
    var key = event.key;
    switch (key) {
      case "ArrowRight":
      case "ArrowLeft":
        onSegmentChange === null || onSegmentChange === void 0 ? void 0 : onSegmentChange(event);
        event.preventDefault();
        break;
      case "ArrowUp":
      case "ArrowDown":
        onSegmentValueChange === null || onSegmentValueChange === void 0 ? void 0 : onSegmentValueChange(event);
        event.preventDefault();
        break;
      case "Backspace":
        onSegmentValueRemove === null || onSegmentValueRemove === void 0 ? void 0 : onSegmentValueRemove(event);
        event.preventDefault();
        break;
      case ((_key$match = key.match(/\d/)) === null || _key$match === void 0 ? void 0 : _key$match.input):
        onSegmentValueChangeWithNumericKeys === null || onSegmentValueChangeWithNumericKeys === void 0 ? void 0 : onSegmentValueChangeWithNumericKeys(event);
        event.preventDefault();
      case ((_key$match2 = key.match(/[a-z]/)) === null || _key$match2 === void 0 ? void 0 : _key$match2[0]):
        if (event.ctrlKey || event.metaKey) {
          break;
        }
        event.preventDefault();
        break;
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
  };
}
function useIsFocused(_ref) {
  var onFocusProp = _ref.onFocus, onBlurProp = _ref.onBlur;
  var _useState = reactExports.useState(false), isFocused = _useState[0], setIsFocused = _useState[1];
  var onFocus = reactExports.useCallback(function(event) {
    setIsFocused(true);
    onFocusProp === null || onFocusProp === void 0 ? void 0 : onFocusProp(event);
  }, [onFocusProp]);
  var onBlur = reactExports.useCallback(function(event) {
    setIsFocused(false);
    onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(event);
  }, [onBlurProp]);
  return [isFocused, {
    onFocus,
    onBlur
  }];
}
function useFieldCursor(format2, value) {
  var typeCount = reactExports.useRef(0);
  var increment = reactExports.useCallback(function() {
    typeCount.current += 1;
  }, []);
  var reset = reactExports.useCallback(function() {
    typeCount.current = 0;
  }, []);
  var isResetValue = reactExports.useCallback(function() {
    return typeCount.current === 0;
  }, []);
  var isMoveCursor = reactExports.useCallback(function(value2, pattern) {
    var patternGroup = getPatternGroups(format2, pattern);
    if (value2.toString().length === patternGroup.length) {
      return true;
    } else if (pattern === "y" && typeCount.current === 4) {
      return true;
    } else if (pattern !== "y" && typeCount.current === 2) {
      return true;
    }
    switch (pattern) {
      case "M":
        return parseInt(value2 + "0") > 12;
      case "d":
        return parseInt(value2 + "0") > 31;
      case "H":
        return parseInt(value2 + "0") > 23;
      case "h":
        return parseInt(value2 + "0") > 12;
      case "m":
      case "s":
        return parseInt(value2 + "0") > 59;
      default:
        return false;
    }
  }, [format2]);
  useUpdateEffect(function() {
    if (!value) {
      reset();
    }
  }, [value]);
  return {
    increment,
    reset,
    isMoveCursor,
    isResetValue
  };
}
var defaultSelectedState = {
  selectedPattern: "y",
  selectionStart: 0,
  selectionEnd: 0
};
function useSelectedState() {
  var _useState = reactExports.useState(defaultSelectedState), selectedState = _useState[0], setSelectedState = _useState[1];
  return {
    selectedState,
    setSelectedState
  };
}
var _excluded$12 = ["format", "value", "defaultValue", "placeholder", "onChange", "onKeyDown", "onBlur", "onFocus", "onPaste"];
var DateInput = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$format = props.format, formatStr = _props$format === void 0 ? "yyyy-MM-dd" : _props$format, valueProp = props.value, defaultValue = props.defaultValue, placeholder = props.placeholder, onChange = props.onChange, onKeyDown = props.onKeyDown, onBlur = props.onBlur, onFocus = props.onFocus, onPaste = props.onPaste, rest = _objectWithoutPropertiesLoose(props, _excluded$12);
  var inputRef = reactExports.useRef();
  var _useSelectedState = useSelectedState(), selectedState = _useSelectedState.selectedState, setSelectedState = _useSelectedState.setSelectedState;
  var _useCustom = useCustom("Calendar"), locale2 = _useCustom.locale, parseDate = _useCustom.parseDate;
  var dateLocale = locale2.dateLocale;
  var _useControlled = useControlled$2(valueProp, defaultValue), value = _useControlled[0], setValue2 = _useControlled[1], isControlled = _useControlled[2];
  var _useDateInputState = useDateInputState({
    formatStr,
    locale: dateLocale,
    date: value,
    isControlledDate: isControlled
  }), dateField = _useDateInputState.dateField, setDateOffset = _useDateInputState.setDateOffset, setDateField = _useDateInputState.setDateField, setNewDate = _useDateInputState.setNewDate, getDateField = _useDateInputState.getDateField, toDateString = _useDateInputState.toDateString, isEmptyValue = _useDateInputState.isEmptyValue;
  var _useFieldCursor = useFieldCursor(formatStr, valueProp), isMoveCursor = _useFieldCursor.isMoveCursor, isResetValue = _useFieldCursor.isResetValue, increment = _useFieldCursor.increment, reset = _useFieldCursor.reset;
  var dateString = toDateString();
  var keyPressOptions = reactExports.useMemo(function() {
    return {
      formatStr,
      localize: dateLocale.localize,
      selectedMonth: dateField.month,
      dateString
    };
  }, [dateField, dateString, formatStr, dateLocale]);
  var handleChange = useEventCallback$2(function(value2, event) {
    onChange === null || onChange === void 0 ? void 0 : onChange(value2, event);
    setValue2(value2);
  });
  var setSelectionRange = useInputSelection(inputRef);
  var onSegmentChange = useEventCallback$2(function(event, nextDirection) {
    var input = event.target;
    var key = event.key;
    var direction = nextDirection || (key === "ArrowRight" ? "right" : "left");
    var state = getInputSelectedState$1(_extends$1({}, keyPressOptions, {
      input,
      direction
    }));
    setSelectedState(state);
    setSelectionRange(state.selectionStart, state.selectionEnd);
    if (selectedState.selectedPattern !== state.selectedPattern) {
      reset();
    }
  });
  var onSegmentValueChange = useEventCallback$2(function(event) {
    var input = event.target;
    var key = event.key;
    var offset2 = key === "ArrowUp" ? 1 : -1;
    var state = getInputSelectedState$1(_extends$1({}, keyPressOptions, {
      input,
      valueOffset: offset2
    }));
    setSelectedState(state);
    setDateOffset(state.selectedPattern, offset2, function(date) {
      return handleChange(date, event);
    });
    setSelectionRange(state.selectionStart, state.selectionEnd);
  });
  var onSegmentValueChangeWithNumericKeys = useEventCallback$2(function(event) {
    var input = event.target;
    var key = event.key;
    var pattern = selectedState.selectedPattern;
    if (!pattern) {
      return;
    }
    var field = getDateField(pattern);
    var value2 = parseInt(key, 10);
    var padValue = parseInt("" + (field.value || "") + key, 10);
    var newValue = value2;
    if (validateDateTime$1(field.name, padValue) && !isResetValue()) {
      newValue = padValue;
    }
    setDateField(pattern, newValue, function(date) {
      return handleChange(date, event);
    });
    var selectedMonth = pattern === "M" ? newValue : dateField.month;
    var nextState = getInputSelectedState$1(_extends$1({}, keyPressOptions, {
      input,
      selectedMonth
    }));
    setSelectedState(nextState);
    setSelectionRange(nextState.selectionStart, nextState.selectionEnd);
    increment();
    if (isMoveCursor(newValue, pattern) && input.selectionEnd !== input.value.length) {
      onSegmentChange(event, "right");
    }
  });
  var onSegmentValueRemove = useEventCallback$2(function(event) {
    var input = event.target;
    if (selectedState.selectedPattern) {
      var nextState = getInputSelectedState$1(_extends$1({}, keyPressOptions, {
        input,
        valueOffset: null
      }));
      setSelectedState(nextState);
      setSelectionRange(nextState.selectionStart, nextState.selectionEnd);
      setDateField(selectedState.selectedPattern, null, function(date) {
        return handleChange(date, event);
      });
      reset();
    }
  });
  var handleClick = useEventCallback$2(function(event) {
    var input = event.target;
    var state = getInputSelectedState$1(_extends$1({}, keyPressOptions, {
      input
    }));
    setSelectedState(state);
    setSelectionRange(state.selectionStart, state.selectionEnd);
    if (selectedState.selectedPattern !== state.selectedPattern) {
      reset();
    }
  });
  var handlePaste = useEventCallback$2(function(event) {
    var _event$clipboardData;
    event.preventDefault();
    var pasteText = (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.getData("text");
    var nextDate = parseDate(pasteText, formatStr);
    if (isValid$1(nextDate)) {
      handleChange(nextDate, event);
      setNewDate(nextDate);
    }
    onPaste === null || onPaste === void 0 ? void 0 : onPaste(event);
  });
  var onKeyboardInput = useKeyboardInputEvent({
    onSegmentChange,
    onSegmentValueChange,
    onSegmentValueChangeWithNumericKeys,
    onSegmentValueRemove,
    onKeyDown
  });
  var _useIsFocused = useIsFocused({
    onBlur,
    onFocus
  }), focused = _useIsFocused[0], focusEventProps = _useIsFocused[1];
  var renderedValue = reactExports.useMemo(function() {
    if (!isEmptyValue()) {
      return dateString;
    }
    return !focused ? "" : dateString;
  }, [dateString, focused, isEmptyValue]);
  return /* @__PURE__ */ React.createElement(Input$1, _extends$1({
    inputMode: focused ? "numeric" : "text",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: false,
    ref: mergeRefs(inputRef, ref),
    onKeyDown: onKeyboardInput,
    onClick: handleClick,
    onPaste: handlePaste,
    value: renderedValue,
    placeholder: placeholder || formatStr
  }, focusEventProps, rest));
});
DateInput.displayName = "DateInput";
DateInput.propTypes = {
  defaultValue: PropTypes.instanceOf(Date),
  format: PropTypes.string,
  value: PropTypes.instanceOf(Date),
  placeholder: PropTypes.string,
  onChange: PropTypes.func,
  onKeyDown: PropTypes.func,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func
};
var Calendar$3 = {};
var Calendar$2 = { exports: {} };
var Calendar$1 = {};
var hasRequiredCalendar;
function requireCalendar() {
  if (hasRequiredCalendar) return Calendar$1;
  hasRequiredCalendar = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function Calendar2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 14 14",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M1 4v8.5a.5.5 0 00.5.5H8c0-.128.049-.256.146-.354.555-.555.854-1.6.854-3.146a.5.5 0 01.621-.485l.119.03A2.623 2.623 0 0012.999 6.5V4h-12zm3-2h6V0h1v2h1.5A1.5 1.5 0 0114 3.5v3a3.623 3.623 0 01-4.015 3.603c-.064 1.245-.335 2.212-.831 2.898H12.5a.5.5 0 00.5-.5v-2a.5.5 0 011 0v2a1.5 1.5 0 01-1.5 1.5h-11a1.5 1.5 0 01-1.5-1.5v-9a1.5 1.5 0 011.5-1.5H3v-2h1v2zm5 4V5h1v1h2v1h-2v1H9V7H7v2h1v1H7v2H6v-2H4v2H3v-2H1V9h2V7H1V6h2V5h1v1h2V5h1v1h2zM6 9V7H4v2h2z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(Calendar2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(Calendar$1);
  return Calendar$1;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _Calendar = _interopRequireDefault2(requireCalendar());
  var Calendar2 = (0, _createSvgIcon2["default"])({
    as: _Calendar["default"],
    ariaLabel: "calendar",
    category: "legacy",
    displayName: "Calendar"
  });
  var _default = Calendar2;
  exports["default"] = _default;
  module.exports = exports.default;
})(Calendar$2, Calendar$2.exports);
var CalendarExports = Calendar$2.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _Calendar["default"];
    }
  });
  var _Calendar = _interopRequireDefault2(CalendarExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(Calendar$3);
const IconCalendar = /* @__PURE__ */ getDefaultExportFromCjs(Calendar$3);
var ClockO$2 = {};
var ClockO$1 = { exports: {} };
var ClockO = {};
var hasRequiredClockO;
function requireClockO() {
  if (hasRequiredClockO) return ClockO;
  hasRequiredClockO = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function ClockO2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 27 32",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M16 9.714v8c0 .321-.25.571-.571.571H9.715a.564.564 0 01-.571-.571v-1.143c0-.321.25-.571.571-.571h4V9.714c0-.321.25-.571.571-.571h1.143c.321 0 .571.25.571.571zM23.429 16c0-5.357-4.357-9.714-9.714-9.714S4.001 10.643 4.001 16s4.357 9.714 9.714 9.714 9.714-4.357 9.714-9.714zm4 0c0 7.571-6.143 13.714-13.714 13.714S.001 23.571.001 16 6.144 2.286 13.715 2.286 27.429 8.429 27.429 16z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(ClockO2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(ClockO);
  return ClockO;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _ClockO = _interopRequireDefault2(requireClockO());
  var ClockO2 = (0, _createSvgIcon2["default"])({
    as: _ClockO["default"],
    ariaLabel: "clock o",
    category: "legacy",
    displayName: "ClockO"
  });
  var _default = ClockO2;
  exports["default"] = _default;
  module.exports = exports.default;
})(ClockO$1, ClockO$1.exports);
var ClockOExports = ClockO$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _ClockO["default"];
    }
  });
  var _ClockO = _interopRequireDefault2(ClockOExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(ClockO$2);
const IconClockO = /* @__PURE__ */ getDefaultExportFromCjs(ClockO$2);
var CalendarContext = /* @__PURE__ */ React.createContext({});
var CalendarProvider = CalendarContext.Provider;
var useCalendarContext = function useCalendarContext2() {
  return reactExports.useContext(CalendarContext);
};
function getAriaLabel(date, formatStr, format$1) {
  return format$1 ? format$1(date, formatStr) : format(date, formatStr);
}
var _excluded$11 = ["as", "className", "classPrefix", "active", "disabled", "month", "year"];
var MonthDropdownItem = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-month-dropdown-cell" : _props$classPrefix, active = props.active, disabled = props.disabled, _props$month = props.month, month = _props$month === void 0 ? 0 : _props$month, year = props.year, rest = _objectWithoutPropertiesLoose(props, _excluded$11);
  var _useCalendarContext = useCalendarContext(), date = _useCalendarContext.date, onSelect = _useCalendarContext.onChangeMonth;
  var _useCustom = useCustom("Calendar"), locale2 = _useCustom.locale, formatDate = _useCustom.formatDate;
  var formatStr = locale2.formattedMonthPattern;
  var currentMonth = reactExports.useMemo(function() {
    if (year && month) {
      return composeFunctions(function(d4) {
        return setYear(d4, year);
      }, function(d4) {
        return setMonth(d4, month - 1);
      })(date);
    }
    return date;
  }, [date, month, year]);
  var handleClick = reactExports.useCallback(function(event) {
    if (disabled) {
      return;
    }
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(currentMonth, event);
  }, [currentMonth, disabled, onSelect]);
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, withClassPrefix({
    active
  }), {
    disabled
  });
  var ariaLabel = currentMonth ? getAriaLabel(currentMonth, formatStr, formatDate) : "";
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    key: month,
    role: "gridcell",
    "aria-selected": active,
    "aria-disabled": disabled,
    "aria-label": ariaLabel,
    tabIndex: active ? 0 : -1,
    ref,
    className: classes,
    onClick: handleClick
  }, rest), /* @__PURE__ */ React.createElement("span", {
    className: prefix2("content")
  }, month));
});
MonthDropdownItem.displayName = "MonthDropdownItem";
var _excluded$10 = ["as", "className", "classPrefix", "limitStartYear", "limitEndYear", "show", "height", "width", "disabledMonth"], _excluded2$8 = ["className", "itemClassName", "as", "itemAs"];
var monthMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
function isEveryDateInMonth(year, month, predicate) {
  var days = getDaysInMonth(new Date(year, month));
  for (var i2 = 1; i2 <= days; i2++) {
    if (!predicate(new Date(year, month, i2))) {
      return false;
    }
  }
  return true;
}
var MonthDropdown = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-month-dropdown" : _props$classPrefix, limitStartYear = props.limitStartYear, _props$limitEndYear = props.limitEndYear, limitEndYear = _props$limitEndYear === void 0 ? 5 : _props$limitEndYear, show = props.show, _props$height = props.height, defaultHeight = _props$height === void 0 ? 221 : _props$height, _props$width = props.width, defaultWidth = _props$width === void 0 ? 256 : _props$width, disabledMonth = props.disabledMonth, rest = _objectWithoutPropertiesLoose(props, _excluded$10);
  var _useCalendarContext = useCalendarContext(), _useCalendarContext$d = _useCalendarContext.date, date = _useCalendarContext$d === void 0 ? /* @__PURE__ */ new Date() : _useCalendarContext$d, targetId = _useCalendarContext.targetId, monthDropdownProps = _useCalendarContext.monthDropdownProps;
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var thisYear = getYear(/* @__PURE__ */ new Date());
  var startYear = limitStartYear ? thisYear - limitStartYear + 1 : 1900;
  var rowCount = reactExports.useMemo(function() {
    var endYear = thisYear + limitEndYear;
    return endYear - startYear;
  }, [limitEndYear, startYear, thisYear]);
  var isMonthDisabled = reactExports.useCallback(function(year, month) {
    if (disabledMonth) {
      return isEveryDateInMonth(year, month, disabledMonth);
    }
    return false;
  }, [disabledMonth]);
  var _ref = monthDropdownProps || {}, listClassName = _ref.className, itemClassName = _ref.itemClassName, List3 = _ref.as, _ref$itemAs = _ref.itemAs, Item = _ref$itemAs === void 0 ? "div" : _ref$itemAs, restListProps = _objectWithoutPropertiesLoose(_ref, _excluded2$8);
  var rowRenderer = reactExports.useCallback(function(_ref2) {
    var index = _ref2.index, style2 = _ref2.style;
    var selectedMonth = getMonth(date);
    var selectedYear = getYear(date);
    var year = startYear + index;
    var isSelectedYear = year === selectedYear;
    var titleClassName = prefix2("year", {
      "year-active": isSelectedYear
    });
    return /* @__PURE__ */ React.createElement(Item, {
      role: "row",
      "aria-label": "" + year,
      className: merge2(itemClassName, prefix2("row"), {
        "first-row": index === 0,
        "last-row": index === rowCount - 1
      }),
      style: style2
    }, /* @__PURE__ */ React.createElement("div", {
      className: titleClassName,
      role: "rowheader"
    }, year), /* @__PURE__ */ React.createElement("div", {
      className: prefix2("list")
    }, monthMap.map(function(item, month) {
      return /* @__PURE__ */ React.createElement(MonthDropdownItem, {
        disabled: isMonthDisabled(year, month),
        active: isSelectedYear && month === selectedMonth,
        key: month + "_" + item,
        month: month + 1,
        year
      });
    })));
  }, [Item, date, isMonthDisabled, merge2, prefix2, itemClassName, rowCount, startYear]);
  var classes = merge2(className, withClassPrefix(), {
    show
  });
  var itemSize = 75;
  var initialItemIndex = getYear(date) - startYear;
  var initialScrollOffset = itemSize * initialItemIndex;
  if (!show) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    role: "grid",
    tabIndex: -1,
    className: classes,
    "aria-labelledby": targetId ? targetId + "-grid-label" : void 0,
    id: targetId ? targetId + "-calendar-month-dropdown" : void 0,
    "data-testid": "calendar-month-dropdown"
  }, rest), /* @__PURE__ */ React.createElement("div", {
    className: prefix2("scroll")
  }, /* @__PURE__ */ React.createElement(AutoSizer, {
    defaultHeight,
    defaultWidth
  }, function(_ref3) {
    var height2 = _ref3.height, width2 = _ref3.width;
    return /* @__PURE__ */ React.createElement(FixedSizeList, _extends$1({
      className: merge2(prefix2("row-wrapper"), listClassName),
      width: width2 || defaultWidth,
      height: height2 || defaultHeight,
      itemSize,
      itemCount: rowCount,
      initialScrollOffset,
      innerElementType: List3
    }, restListProps), rowRenderer);
  })));
});
MonthDropdown.displayName = "MonthDropdown";
var baseRest = _baseRest, createWrap = _createWrap, getHolder = _getHolder, replaceHolders = _replaceHolders;
var WRAP_PARTIAL_FLAG = 32;
var partial = baseRest(function(func, partials) {
  var holders = replaceHolders(partials, getHolder(partial));
  return createWrap(func, WRAP_PARTIAL_FLAG, void 0, partials, holders);
});
partial.placeholder = {};
var partial_1 = partial;
const partial$1 = /* @__PURE__ */ getDefaultExportFromCjs(partial_1);
var capitalize$2 = capitalize_1, createCompounder = _createCompounder;
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize$2(word) : word);
});
var camelCase_1 = camelCase;
const camelCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(camelCase_1);
var _excluded$$ = ["as", "className", "classPrefix", "show", "showMeridian"];
function getRanges$1(meridian) {
  return {
    hours: {
      start: 0,
      end: meridian ? 11 : 23
    },
    minutes: {
      start: 0,
      end: 59
    },
    seconds: {
      start: 0,
      end: 59
    }
  };
}
function getMeridianHours(hours) {
  return hours >= 12 ? hours - 12 : hours;
}
var getTime = function getTime2(props) {
  var format2 = props.format, date = props.date, showMeridian = props.showMeridian;
  var time2 = date || /* @__PURE__ */ new Date();
  var nextTime = {};
  if (!format2) {
    return nextTime;
  }
  if (/(H|h)/.test(format2)) {
    var hours = getHours$1(time2);
    nextTime.hours = showMeridian ? getMeridianHours(hours) : hours;
  }
  if (/m/.test(format2)) {
    nextTime.minutes = getMinutes$1(time2);
  }
  if (/s/.test(format2)) {
    nextTime.seconds = getSeconds(time2);
  }
  return nextTime;
};
var scrollTo = function scrollTo2(time2, row) {
  if (!row) {
    return;
  }
  Object.entries(time2).forEach(function(_ref) {
    var type = _ref[0], value = _ref[1];
    var container = row.querySelector('[data-type="' + type + '"]');
    var node2 = container === null || container === void 0 ? void 0 : container.querySelector('[data-key="' + type + "-" + value + '"]');
    if (node2 && container) {
      var position2 = getPosition$1(node2, container);
      if (position2) {
        scrollTopAnimation(container, position2.top, scrollTop(container) !== 0);
      }
    }
  });
};
var TimeDropdown = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-time-dropdown" : _props$classPrefix, show = props.show, _props$showMeridian = props.showMeridian, showMeridian = _props$showMeridian === void 0 ? false : _props$showMeridian, rest = _objectWithoutPropertiesLoose(props, _excluded$$);
  var _useCalendarContext = useCalendarContext(), locale2 = _useCalendarContext.locale, format2 = _useCalendarContext.format, date = _useCalendarContext.date, onSelect = _useCalendarContext.onChangeTime, targetId = _useCalendarContext.targetId;
  var rowRef = reactExports.useRef(null);
  reactExports.useEffect(function() {
    var time3 = getTime({
      format: format2,
      date,
      showMeridian
    });
    if (show && rowRef.current) {
      scrollTo(time3, rowRef.current);
    }
  }, [date, format2, show, showMeridian]);
  var handleClick = function handleClick2(type, d4, event) {
    var nextDate = date || /* @__PURE__ */ new Date();
    switch (type) {
      case "hours":
        nextDate = setHours(date, showMeridian && getHours$1(nextDate) >= 12 ? d4 + 12 : d4);
        break;
      case "minutes":
        nextDate = setMinutes(date, d4);
        break;
      case "seconds":
        nextDate = setSeconds(date, d4);
        break;
    }
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(nextDate, event);
  };
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, rootPrefix = _useClassNames.rootPrefix, merge2 = _useClassNames.merge;
  var renderColumn = function renderColumn2(type, active) {
    if (!isNumber$2(active)) {
      return null;
    }
    var _getRanges$type = getRanges$1(showMeridian)[type], start2 = _getRanges$type.start, end2 = _getRanges$type.end;
    var items = [];
    var hideFunc = props[camelCase$1("hide_" + type)];
    var disabledFunc = props[camelCase$1("disabled_" + type)];
    for (var i2 = start2; i2 <= end2; i2 += 1) {
      if (!(hideFunc !== null && hideFunc !== void 0 && hideFunc(i2, date))) {
        var disabled = disabledFunc === null || disabledFunc === void 0 ? void 0 : disabledFunc(i2, date);
        var itemClasses = prefix2("cell", {
          "cell-active": active === i2,
          "cell-disabled": disabled
        });
        items.push(/* @__PURE__ */ React.createElement("li", {
          key: i2,
          role: "option",
          tabIndex: -1,
          "aria-label": i2 + " " + type,
          "aria-selected": active === i2,
          "aria-disabled": disabled,
          "data-key": type + "-" + i2,
          onClick: !disabled ? partial$1(handleClick, type, i2) : void 0
        }, /* @__PURE__ */ React.createElement("span", {
          className: itemClasses
        }, showMeridian && type === "hours" && i2 === 0 ? "12" : i2)));
      }
    }
    return /* @__PURE__ */ React.createElement("div", {
      className: prefix2("column")
    }, /* @__PURE__ */ React.createElement("div", {
      className: prefix2("column-title")
    }, locale2 === null || locale2 === void 0 ? void 0 : locale2[type]), /* @__PURE__ */ React.createElement("ul", {
      "data-type": type,
      role: "listbox",
      "aria-label": "Select " + type
    }, items));
  };
  var time2 = getTime({
    format: format2,
    date,
    showMeridian
  });
  var classes = merge2(className, rootPrefix(classPrefix), {
    show
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "group",
    tabIndex: -1,
    id: targetId ? targetId + "-" + classPrefix : void 0
  }, omitHideDisabledProps(rest), {
    ref,
    className: classes
  }), /* @__PURE__ */ React.createElement("div", {
    className: prefix2("content")
  }, /* @__PURE__ */ React.createElement("div", {
    className: prefix2("row"),
    ref: rowRef
  }, renderColumn("hours", time2.hours), renderColumn("minutes", time2.minutes), renderColumn("seconds", time2.seconds))));
});
TimeDropdown.displayName = "TimeDropdown";
var _excluded$_ = ["as", "classPrefix", "disabled", "selected", "date", "onSelect", "unSameMonth", "rangeStart", "rangeEnd", "inRange"];
var TableCell$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-table" : _props$classPrefix, disabled = props.disabled, selected = props.selected, date = props.date, onSelect = props.onSelect, unSameMonth = props.unSameMonth, rangeStart = props.rangeStart, rangeEnd = props.rangeEnd, inRange = props.inRange, rest = _objectWithoutPropertiesLoose(props, _excluded$_);
  var _useCalendarContext = useCalendarContext(), onMouseMove = _useCalendarContext.onMouseMove, cellClassName = _useCalendarContext.cellClassName, renderCell = _useCalendarContext.renderCell, renderCellOnPicker = _useCalendarContext.renderCellOnPicker, overrideLocale = _useCalendarContext.locale;
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var _useCustom = useCustom("Calendar", overrideLocale), locale2 = _useCustom.locale, formatDate = _useCustom.formatDate;
  var formatStr = locale2.formattedDayPattern;
  var ariaLabel = getAriaLabel(date, formatStr, formatDate);
  var todayDate = /* @__PURE__ */ new Date();
  var isToday = isSameDay(date, todayDate);
  var classes = merge2(prefix2("cell", {
    "cell-un-same-month": unSameMonth,
    "cell-is-today": isToday,
    "cell-selected": selected,
    "cell-selected-start": rangeStart,
    "cell-selected-end": rangeEnd,
    "cell-in-range": !unSameMonth && inRange,
    "cell-disabled": disabled
  }), cellClassName === null || cellClassName === void 0 ? void 0 : cellClassName(date));
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    ref,
    role: "gridcell",
    "aria-label": ariaLabel,
    "aria-selected": selected || void 0,
    "aria-disabled": disabled || void 0,
    tabIndex: selected ? 0 : -1,
    title: isToday ? ariaLabel + " (" + (locale2 === null || locale2 === void 0 ? void 0 : locale2.today) + ")" : ariaLabel,
    className: classes,
    onMouseEnter: !disabled && onMouseMove ? onMouseMove.bind(null, date) : void 0,
    onClick: onSelect ? partial$1(onSelect, date, disabled) : void 0
  }, rest), /* @__PURE__ */ React.createElement("div", {
    className: prefix2("cell-content")
  }, renderCellOnPicker ? renderCellOnPicker(date) : /* @__PURE__ */ React.createElement("span", {
    className: prefix2("cell-day")
  }, getDate(date)), renderCell === null || renderCell === void 0 ? void 0 : renderCell(date)));
});
TableCell$1.displayName = "CalendarTableCell";
var _excluded$Z = ["as", "className", "classPrefix", "weekendDate", "rowIndex"];
var TableRow$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _locale$dateLocale$op, _locale$dateLocale;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-table" : _props$classPrefix, _props$weekendDate = props.weekendDate, weekendDate = _props$weekendDate === void 0 ? /* @__PURE__ */ new Date() : _props$weekendDate, rowIndex = props.rowIndex, rest = _objectWithoutPropertiesLoose(props, _excluded$Z);
  var _useCalendarContext = useCalendarContext(), _useCalendarContext$d = _useCalendarContext.date, selected = _useCalendarContext$d === void 0 ? /* @__PURE__ */ new Date() : _useCalendarContext$d, dateRange = _useCalendarContext.dateRange, hoverRangeValue = _useCalendarContext.hoverRangeValue, isoWeek = _useCalendarContext.isoWeek, weekStart = _useCalendarContext.weekStart, showWeekNumbers = _useCalendarContext.showWeekNumbers, locale2 = _useCalendarContext.locale, inSameMonth = _useCalendarContext.inSameMonth, disabledDate = _useCalendarContext.disabledDate, onSelect = _useCalendarContext.onSelect;
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var handleSelect = reactExports.useCallback(function(date, disabled, event) {
    if (disabled) {
      return;
    }
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(date, event);
  }, [onSelect]);
  var renderDays = function renderDays2() {
    var days = [];
    var _ref = dateRange || [], selectedStartDate = _ref[0], selectedEndDate = _ref[1];
    var _ref2 = hoverRangeValue !== null && hoverRangeValue !== void 0 ? hoverRangeValue : [], hoverStartDate = _ref2[0], hoverEndDate = _ref2[1];
    var isRangeSelectionMode = typeof dateRange !== "undefined";
    for (var i2 = 0; i2 < 7; i2 += 1) {
      var thisDate = addDays(weekendDate, i2);
      var disabled = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(thisDate, dateRange, DATERANGE_DISABLED_TARGET.CALENDAR);
      var unSameMonth = !(inSameMonth !== null && inSameMonth !== void 0 && inSameMonth(thisDate));
      var rangeStart = !unSameMonth && selectedStartDate && isSameDay(thisDate, selectedStartDate);
      var rangeEnd = !unSameMonth && selectedEndDate && isSameDay(thisDate, selectedEndDate);
      var isSelected = isRangeSelectionMode ? rangeStart || rangeEnd : isSameDay(thisDate, selected);
      var inRange = false;
      if (selectedStartDate && selectedEndDate) {
        if (isBefore(thisDate, selectedEndDate) && isAfter$1(thisDate, selectedStartDate)) {
          inRange = true;
        }
        if (isBefore(thisDate, selectedStartDate) && isAfter$1(thisDate, selectedEndDate)) {
          inRange = true;
        }
      }
      if (!isSelected && hoverStartDate && hoverEndDate) {
        if (!isAfter$1(thisDate, hoverEndDate) && !isBefore(thisDate, hoverStartDate)) {
          inRange = true;
        }
        if (!isAfter$1(thisDate, hoverStartDate) && !isBefore(thisDate, hoverEndDate)) {
          inRange = true;
        }
      }
      days.push(/* @__PURE__ */ React.createElement(TableCell$1, {
        key: format(thisDate, "yyyy-MM-dd"),
        date: thisDate,
        disabled,
        selected: isSelected,
        onSelect: handleSelect,
        unSameMonth,
        rangeStart,
        rangeEnd,
        inRange
      }));
    }
    return days;
  };
  var classes = merge2(className, prefix2("row"));
  var _ref3 = (_locale$dateLocale$op = locale2 === null || locale2 === void 0 ? void 0 : (_locale$dateLocale = locale2.dateLocale) === null || _locale$dateLocale === void 0 ? void 0 : _locale$dateLocale.options) !== null && _locale$dateLocale$op !== void 0 ? _locale$dateLocale$op : {}, firstWeekContainsDate = _ref3.firstWeekContainsDate, weekStartsOn = _ref3.weekStartsOn;
  var week = format(weekendDate, isoWeek ? "I" : "w", {
    locale: locale2 === null || locale2 === void 0 ? void 0 : locale2.dateLocale,
    firstWeekContainsDate,
    weekStartsOn: weekStart || weekStartsOn
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    role: "row",
    "aria-rowindex": rowIndex,
    className: classes
  }), showWeekNumbers && /* @__PURE__ */ React.createElement("div", {
    role: "rowheader",
    "aria-label": "Week " + week,
    className: prefix2("cell-week-number")
  }, week), renderDays());
});
TableRow$1.displayName = "CalendarTableRow";
var _excluded$Y = ["as", "className", "classPrefix"];
var TableHeaderRow = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-table" : _props$classPrefix, rest = _objectWithoutPropertiesLoose(props, _excluded$Y);
  var _useCalendarContext = useCalendarContext(), locale2 = _useCalendarContext.locale, showWeekNumbers = _useCalendarContext.showWeekNumbers, isoWeek = _useCalendarContext.isoWeek, weekStart = _useCalendarContext.weekStart;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var classes = merge2(className, prefix2("row", "header-row"));
  var weeks = getWeekKeys(isoWeek ? 1 : weekStart);
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "row"
  }, rest, {
    ref,
    className: classes
  }), showWeekNumbers && /* @__PURE__ */ React.createElement("div", {
    className: prefix2("header-cell"),
    role: "columnheader"
  }), weeks.map(function(key) {
    return /* @__PURE__ */ React.createElement("div", {
      key,
      className: prefix2("header-cell"),
      role: "columnheader",
      "aria-label": upperFirst$3(key)
    }, /* @__PURE__ */ React.createElement("span", {
      className: prefix2("header-cell-content")
    }, locale2 === null || locale2 === void 0 ? void 0 : locale2[key]));
  }));
});
TableHeaderRow.displayName = "CalendarTableHeaderRow";
var _excluded$X = ["as", "className", "classPrefix", "rows"];
var Table$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-table" : _props$classPrefix, _props$rows = props.rows, rows = _props$rows === void 0 ? [] : _props$rows, rest = _objectWithoutPropertiesLoose(props, _excluded$X);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, withClassPrefix());
  var _useCalendarContext = useCalendarContext(), targetId = _useCalendarContext.targetId;
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "grid",
    tabIndex: -1,
    id: targetId ? targetId + "-" + classPrefix : void 0
  }, rest, {
    ref,
    className: classes
  }), /* @__PURE__ */ React.createElement(TableHeaderRow, null), rows.map(function(week, index) {
    return /* @__PURE__ */ React.createElement(TableRow$1, {
      key: index,
      weekendDate: week,
      rowIndex: index + 1
    });
  }));
});
Table$1.displayName = "CalendarTable";
Table$1.propTypes = {
  rows: PropTypes.array,
  className: PropTypes.string,
  classPrefix: PropTypes.string
};
var _excluded$W = ["as", "className", "classPrefix"];
var CalendarBody = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-body" : _props$classPrefix, rest = _objectWithoutPropertiesLoose(props, _excluded$W);
  var _useCalendarContext = useCalendarContext(), _useCalendarContext$d = _useCalendarContext.date, date = _useCalendarContext$d === void 0 ? /* @__PURE__ */ new Date() : _useCalendarContext$d, isoWeek = _useCalendarContext.isoWeek, overrideLocale = _useCalendarContext.locale, weekStart = _useCalendarContext.weekStart;
  var _useCustom = useCustom("Calendar", overrideLocale), locale2 = _useCustom.locale, formatDate = _useCustom.formatDate;
  var thisMonthDate = setDate(date, 1);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, withClassPrefix = _useClassNames.withClassPrefix;
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), /* @__PURE__ */ React.createElement(Table$1, {
    rows: getWeekStartDates(thisMonthDate, {
      isoWeek,
      weekStart,
      locale: locale2 === null || locale2 === void 0 ? void 0 : locale2.dateLocale
    }),
    "aria-label": formatDate(thisMonthDate, locale2.formattedMonthPattern)
  }));
});
CalendarBody.displayName = "CalendarBody";
var DateRangePickerContext = /* @__PURE__ */ React.createContext({});
var useDateRangePickerContext = function useDateRangePickerContext2() {
  return reactExports.useContext(DateRangePickerContext) || {};
};
var _excluded$V = ["as", "className", "classPrefix", "disabledBackward", "disabledForward", "showDate", "showMeridian", "showMonth", "showTime", "disabledTime", "onMoveBackward", "onMoveForward", "onToggleMeridian", "onToggleMonthDropdown", "onToggleTimeDropdown", "renderTitle", "renderToolbar"];
var CalendarHeader = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar-header" : _props$classPrefix, disabledBackward = props.disabledBackward, disabledForward = props.disabledForward, showDate = props.showDate, showMeridian = props.showMeridian, showMonth = props.showMonth, showTime = props.showTime, disabledTime = props.disabledTime, onMoveBackward = props.onMoveBackward, onMoveForward = props.onMoveForward, onToggleMeridian = props.onToggleMeridian, onToggleMonthDropdown = props.onToggleMonthDropdown, onToggleTimeDropdown = props.onToggleTimeDropdown, renderTitleProp = props.renderTitle, renderToolbar = props.renderToolbar, rest = _objectWithoutPropertiesLoose(props, _excluded$V);
  var _useCalendarContext = useCalendarContext(), locale2 = _useCalendarContext.locale, _useCalendarContext$d = _useCalendarContext.date, date = _useCalendarContext$d === void 0 ? /* @__PURE__ */ new Date() : _useCalendarContext$d, format2 = _useCalendarContext.format, inline = _useCalendarContext.inline, disabledDate = _useCalendarContext.disabledDate, targetId = _useCalendarContext.targetId;
  var _useDateRangePickerCo = useDateRangePickerContext(), isSelectedIdle = _useDateRangePickerCo.isSelectedIdle;
  var _useClassNames = useClassNames$2(classPrefix), prefix2 = _useClassNames.prefix, withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var btnProps = {
    appearance: "subtle",
    size: inline ? "sm" : "xs"
  };
  var getTimeFormat = reactExports.useCallback(function() {
    var timeFormat = [];
    if (!format2) {
      return "";
    }
    if (/([Hh])/.test(format2)) {
      timeFormat.push(showMeridian ? "hh" : "HH");
    }
    if (/m/.test(format2)) {
      timeFormat.push("mm");
    }
    if (/s/.test(format2)) {
      timeFormat.push("ss");
    }
    return timeFormat.join(":");
  }, [format2, showMeridian]);
  var getDateFormat = reactExports.useCallback(function() {
    if (showMonth) {
      return (locale2 === null || locale2 === void 0 ? void 0 : locale2.formattedMonthPattern) || "yyyy-MM";
    }
    return "yyyy";
  }, [locale2, showMonth]);
  var renderTitle = reactExports.useCallback(function() {
    var _renderTitleProp;
    return (_renderTitleProp = renderTitleProp === null || renderTitleProp === void 0 ? void 0 : renderTitleProp(date)) !== null && _renderTitleProp !== void 0 ? _renderTitleProp : date && /* @__PURE__ */ React.createElement(FormattedDate, {
      date,
      formatStr: getDateFormat()
    });
  }, [date, getDateFormat, renderTitleProp]);
  var dateTitleClasses = prefix2("title", "title-date", {
    error: disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date)
  });
  var timeTitleClasses = prefix2("title", "title-time", {
    error: disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(date)
  });
  var backwardClass = prefix2("backward", {
    "btn-disabled": disabledBackward
  });
  var forwardClass = prefix2("forward", {
    "btn-disabled": disabledForward
  });
  var monthToolbar = /* @__PURE__ */ React.createElement("div", {
    className: prefix2("month-toolbar")
  }, /* @__PURE__ */ React.createElement(IconButton$1, _extends$1({}, btnProps, {
    // TODO: aria-label should be translated by i18n
    "aria-label": "Previous month",
    className: backwardClass,
    onClick: disabledBackward ? void 0 : onMoveBackward,
    icon: /* @__PURE__ */ React.createElement(AngleLeftIcon, null)
  })), /* @__PURE__ */ React.createElement(Button$1, _extends$1({}, btnProps, {
    "aria-label": "Select month",
    id: targetId ? targetId + "-grid-label" : void 0,
    className: dateTitleClasses,
    onClick: onToggleMonthDropdown
  }), renderTitle()), /* @__PURE__ */ React.createElement(IconButton$1, _extends$1({}, btnProps, {
    "aria-label": "Next month",
    className: forwardClass,
    onClick: disabledForward ? void 0 : onMoveForward,
    icon: /* @__PURE__ */ React.createElement(AngleRightIcon, null)
  })));
  var hasMonth = showDate || showMonth;
  var classes = merge2(className, withClassPrefix({
    "has-month": hasMonth,
    "has-time": showTime
  }));
  var disableSelectTime = typeof isSelectedIdle === "undefined" ? false : !isSelectedIdle;
  return /* @__PURE__ */ React.createElement(Component, _extends$1({}, rest, {
    ref,
    className: classes
  }), hasMonth && monthToolbar, showTime && /* @__PURE__ */ React.createElement("div", {
    className: prefix2("time-toolbar")
  }, /* @__PURE__ */ React.createElement(Button$1, _extends$1({}, btnProps, {
    "aria-label": "Select time",
    className: timeTitleClasses,
    onClick: onToggleTimeDropdown,
    disabled: disableSelectTime
  }), date && /* @__PURE__ */ React.createElement(FormattedDate, {
    date,
    formatStr: getTimeFormat()
  })), showMeridian && /* @__PURE__ */ React.createElement(Button$1, _extends$1({}, btnProps, {
    "aria-label": "Toggle meridian",
    className: prefix2("meridian"),
    onClick: onToggleMeridian,
    disabled: disableSelectTime
  }), date && /* @__PURE__ */ React.createElement(FormattedDate, {
    date,
    formatStr: "a"
  }))), renderToolbar === null || renderToolbar === void 0 ? void 0 : renderToolbar(date));
});
CalendarHeader.displayName = "CalendarHeader";
var CalendarState = /* @__PURE__ */ function(CalendarState2) {
  CalendarState2["TIME"] = "TIME";
  CalendarState2["MONTH"] = "MONTH";
  return CalendarState2;
}({});
var useCalendarState$1 = function useCalendarState(defaultState) {
  var _useState = reactExports.useState(defaultState), calendarState = _useState[0], setCalendarState = _useState[1];
  var reset = reactExports.useCallback(function() {
    setCalendarState(void 0);
  }, []);
  var openMonth = reactExports.useCallback(function() {
    setCalendarState(CalendarState.MONTH);
  }, []);
  var openTime = reactExports.useCallback(function() {
    setCalendarState(CalendarState.TIME);
  }, []);
  return {
    calendarState,
    reset,
    openMonth,
    openTime
  };
};
var _excluded$U = ["as", "className", "classPrefix", "calendarDate", "dateRange", "disabledBackward", "defaultState", "disabledForward", "format", "hoverRangeValue", "inline", "isoWeek", "weekStart", "targetId", "limitEndYear", "limitStartYear", "locale", "monthDropdownProps", "showMeridian", "showWeekNumbers", "cellClassName", "disabledDate", "onChangeMonth", "onChangeTime", "onMouseMove", "onMoveBackward", "onMoveForward", "onSelect", "onToggleMeridian", "onToggleMonthDropdown", "onToggleTimeDropdown", "renderCell", "renderCellOnPicker", "renderTitle", "renderToolbar"];
var CalendarContainer = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "calendar" : _props$classPrefix, calendarDateProp = props.calendarDate, dateRange = props.dateRange, disabledBackward = props.disabledBackward, defaultState = props.defaultState, disabledForward = props.disabledForward, format2 = props.format, hoverRangeValue = props.hoverRangeValue, inline = props.inline, _props$isoWeek = props.isoWeek, isoWeek = _props$isoWeek === void 0 ? false : _props$isoWeek, _props$weekStart = props.weekStart, weekStart = _props$weekStart === void 0 ? 0 : _props$weekStart, targetId = props.targetId, limitEndYear = props.limitEndYear, limitStartYear = props.limitStartYear, locale2 = props.locale, monthDropdownProps = props.monthDropdownProps, showMeridian = props.showMeridian, showWeekNumbers = props.showWeekNumbers, cellClassName = props.cellClassName, disabledDate = props.disabledDate, onChangeMonth = props.onChangeMonth, onChangeTime = props.onChangeTime, onMouseMove = props.onMouseMove, onMoveBackward = props.onMoveBackward, onMoveForward = props.onMoveForward, onSelect = props.onSelect, onToggleMeridian = props.onToggleMeridian, onToggleMonthDropdown = props.onToggleMonthDropdown, onToggleTimeDropdown = props.onToggleTimeDropdown, renderCell = props.renderCell, renderCellOnPicker = props.renderCellOnPicker, renderTitle = props.renderTitle, renderToolbar = props.renderToolbar, rest = _objectWithoutPropertiesLoose(props, _excluded$U);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var _useCalendarState = useCalendarState$1(defaultState), calendarState = _useCalendarState.calendarState, reset = _useCalendarState.reset, openMonth = _useCalendarState.openMonth, openTime = _useCalendarState.openTime;
  var calendarDate = reactExports.useMemo(function() {
    return isValid$1(calendarDateProp) ? calendarDateProp : /* @__PURE__ */ new Date();
  }, [calendarDateProp]);
  var isDateDisabled = useEventCallback$2(function(date) {
    var _disabledDate;
    return (_disabledDate = disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date)) !== null && _disabledDate !== void 0 ? _disabledDate : false;
  });
  var isTimeDisabled = function isTimeDisabled2(date) {
    return disableTime(props, date);
  };
  var handleMoveForward = useEventCallback$2(function() {
    onMoveForward === null || onMoveForward === void 0 ? void 0 : onMoveForward(addMonths(calendarDate, 1));
  });
  var handleMoveBackward = useEventCallback$2(function() {
    onMoveBackward === null || onMoveBackward === void 0 ? void 0 : onMoveBackward(addMonths(calendarDate, -1));
  });
  var toggleMonthView = useEventCallback$2(function() {
    if (calendarState === CalendarState.MONTH) {
      reset();
    } else {
      openMonth();
    }
    onToggleMonthDropdown === null || onToggleMonthDropdown === void 0 ? void 0 : onToggleMonthDropdown(calendarState !== CalendarState.MONTH);
  });
  var toggleTimeView = useEventCallback$2(function() {
    if (calendarState === CalendarState.TIME) {
      reset();
    } else {
      openTime();
    }
    onToggleTimeDropdown === null || onToggleTimeDropdown === void 0 ? void 0 : onToggleTimeDropdown(calendarState !== CalendarState.TIME);
  });
  var handleCloseDropdown = useEventCallback$2(function() {
    return reset();
  });
  var renderDate = shouldRenderDate(format2);
  var renderTime = shouldRenderTime(format2);
  var renderMonth = shouldRenderMonth(format2);
  var onlyShowTime = renderTime && !renderDate && !renderMonth;
  var onlyShowMonth = renderMonth && !renderDate && !renderTime;
  var showTime = calendarState === CalendarState.TIME || onlyShowTime;
  var showMonth = calendarState === CalendarState.MONTH || onlyShowMonth;
  var inSameThisMonthDate = function inSameThisMonthDate2(date) {
    return isSameMonth(calendarDate, date);
  };
  var calendarClasses = merge2(className, withClassPrefix({
    "time-view": showTime,
    "month-view": showMonth,
    "show-week-numbers": showWeekNumbers
  }));
  var timeDropdownProps = pick$1(rest, calendarOnlyProps);
  var handleChangeMonth = useEventCallback$2(function(date, event) {
    reset();
    onChangeMonth === null || onChangeMonth === void 0 ? void 0 : onChangeMonth(date, event);
  });
  var contextValue = {
    date: calendarDate,
    dateRange,
    format: format2,
    hoverRangeValue,
    inline,
    isoWeek,
    weekStart,
    targetId,
    locale: locale2,
    showWeekNumbers,
    monthDropdownProps,
    cellClassName,
    disabledDate: isDateDisabled,
    inSameMonth: inSameThisMonthDate,
    onChangeMonth: handleChangeMonth,
    onChangeTime,
    onMouseMove,
    onSelect,
    renderCell,
    renderCellOnPicker
  };
  return /* @__PURE__ */ React.createElement(CalendarProvider, {
    value: contextValue
  }, /* @__PURE__ */ React.createElement(Component, _extends$1({
    "data-testid": "calendar"
  }, omitHideDisabledProps(rest), {
    className: calendarClasses,
    ref
  }), /* @__PURE__ */ React.createElement(CalendarHeader, {
    showMonth: renderMonth,
    showDate: renderDate,
    showTime: renderTime,
    showMeridian,
    disabledTime: isTimeDisabled,
    onMoveForward: handleMoveForward,
    onMoveBackward: handleMoveBackward,
    onToggleMonthDropdown: toggleMonthView,
    onToggleTimeDropdown: toggleTimeView,
    onToggleMeridian,
    renderTitle,
    renderToolbar,
    disabledBackward,
    disabledForward
  }), renderDate && /* @__PURE__ */ React.createElement(CalendarBody, null), renderMonth && /* @__PURE__ */ React.createElement(MonthDropdown, {
    show: showMonth,
    limitEndYear,
    limitStartYear,
    disabledMonth: isDateDisabled
  }), renderTime && /* @__PURE__ */ React.createElement(TimeDropdown, _extends$1({}, timeDropdownProps, {
    show: showTime,
    showMeridian
  })), (showMonth || showTime) && renderDate && /* @__PURE__ */ React.createElement("button", {
    className: prefix2("btn-close"),
    onClick: handleCloseDropdown,
    "aria-label": "Collapse " + (showMonth ? "month" : "time") + " view"
  }, /* @__PURE__ */ React.createElement(AngleUpIcon, null))));
});
CalendarContainer.displayName = "CalendarContainer";
var _excluded$T = ["value"];
function getDefaultRanges(value) {
  var today = /* @__PURE__ */ new Date();
  if (value instanceof Array) {
    return [{
      label: "today",
      value: [startOfDay(today), endOfDay(today)]
    }, {
      label: "yesterday",
      value: [startOfDay(subDays(today, 1)), endOfDay(subDays(today, 1))]
    }, {
      label: "last7Days",
      value: [startOfDay(subDays(today, 6)), endOfDay(today)]
    }];
  }
  return [{
    label: "today",
    value: today
  }, {
    label: "yesterday",
    value: subDays(today, 1)
  }];
}
var generateRangesIterator = function generateRangesIterator2(_ref) {
  var calendarDate = _ref.calendarDate;
  return function(_ref2) {
    var value = _ref2.value, rest = _objectWithoutPropertiesLoose(_ref2, _excluded$T);
    return _extends$1({
      value: typeof value === "function" ? value(calendarDate) : value
    }, rest);
  };
};
var getRanges = function getRanges2(_ref3) {
  var ranges = _ref3.ranges, calendarDate = _ref3.calendarDate;
  return typeof ranges === "undefined" ? getDefaultRanges(calendarDate) : ranges.map(generateRangesIterator({
    calendarDate
  }));
};
({
  disabledDate: deprecatePropTypeNew(PropTypes.func, 'Use "shouldDisableDate" property instead.'),
  disabledHours: deprecatePropTypeNew(PropTypes.func, 'Use "shouldDisableHour" property instead.'),
  disabledMinutes: deprecatePropTypeNew(PropTypes.func, 'Use "shouldDisableMinute" property instead.'),
  disabledSeconds: deprecatePropTypeNew(PropTypes.func, 'Use "shouldDisableSecond" property instead.')
});
var _excluded$S = ["className", "disableShortcut", "onShortcutClick", "calendarDate", "ranges", "locale"], _excluded2$7 = ["value", "closeOverlay", "label"];
var PredefinedRanges = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, disableShortcut = props.disableShortcut, onShortcutClick = props.onShortcutClick, calendarDate = props.calendarDate, rangesProp = props.ranges, locale2 = props.locale, rest = _objectWithoutPropertiesLoose(props, _excluded$S);
  var _useState = reactExports.useState(getRanges(props)), ranges = _useState[0], setRanges = _useState[1];
  useUpdateEffect(function() {
    setRanges(getRanges({
      ranges: rangesProp,
      calendarDate
    }));
  }, [calendarDate, rangesProp]);
  var hasLocaleKey = reactExports.useCallback(function(key) {
    return getDefaultRanges(calendarDate).some(function(item) {
      return item.label === key;
    });
  }, [calendarDate]);
  if (ranges.length === 0) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Stack$1, _extends$1({
    className,
    ref,
    alignItems: "flex-start",
    spacing: 4
  }, rest), ranges.map(function(range, index) {
    var value = range.value, closeOverlay = range.closeOverlay, label = range.label, rest2 = _objectWithoutPropertiesLoose(range, _excluded2$7);
    var disabled = disableShortcut === null || disableShortcut === void 0 ? void 0 : disableShortcut(value);
    var handleClickShortcut = function handleClickShortcut2(event) {
      if (disabled) {
        return;
      }
      onShortcutClick === null || onShortcutClick === void 0 ? void 0 : onShortcutClick(range, closeOverlay !== false ? true : false, event);
    };
    return /* @__PURE__ */ React.createElement(Button$1, _extends$1({
      appearance: "link",
      size: "sm",
      key: index,
      disabled,
      onClick: handleClickShortcut
    }, rest2), hasLocaleKey(label) && typeof label === "string" ? locale2 === null || locale2 === void 0 ? void 0 : locale2[label] : label);
  }));
});
var _excluded$R = ["className", "classPrefix", "calendarDate", "ranges", "locale", "hideOkBtn", "disableOkBtn", "disableShortcut", "onOk", "onShortcutClick"];
var OkButton = function OkButton2(_ref) {
  var disableOkBtn = _ref.disableOkBtn, calendarDate = _ref.calendarDate, onOk = _ref.onOk, children = _ref.children;
  var disabled = disableOkBtn === null || disableOkBtn === void 0 ? void 0 : disableOkBtn(calendarDate);
  return /* @__PURE__ */ React.createElement(Button$1, {
    appearance: "primary",
    size: "sm",
    disabled,
    onClick: disabled ? void 0 : onOk
  }, children);
};
var Toolbar = /* @__PURE__ */ React.forwardRef(function Toolbar2(props, ref) {
  var className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "picker-toolbar" : _props$classPrefix, calendarDate = props.calendarDate, ranges = props.ranges, locale2 = props.locale, hideOkBtn = props.hideOkBtn, disableOkBtn = props.disableOkBtn, disableShortcut = props.disableShortcut, onOk = props.onOk, onShortcutClick = props.onShortcutClick, rest = _objectWithoutPropertiesLoose(props, _excluded$R);
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix, withClassPrefix = _useClassNames.withClassPrefix;
  if (hideOkBtn && (ranges === null || ranges === void 0 ? void 0 : ranges.length) === 0) {
    return null;
  }
  var classes = merge2(className, withClassPrefix());
  return /* @__PURE__ */ React.createElement(Stack$1, _extends$1({
    ref,
    className: classes,
    justifyContent: "space-between",
    alignItems: "flex-start"
  }, rest), /* @__PURE__ */ React.createElement(PredefinedRanges, {
    wrap: true,
    className: prefix2("ranges"),
    ranges,
    calendarDate,
    locale: locale2,
    disableShortcut,
    onShortcutClick,
    "data-testid": "daterange-predefined-bottom"
  }), /* @__PURE__ */ React.createElement("div", {
    className: prefix2("right")
  }, !hideOkBtn && /* @__PURE__ */ React.createElement(OkButton, {
    disableOkBtn,
    calendarDate,
    onOk
  }, locale2 === null || locale2 === void 0 ? void 0 : locale2.ok)));
});
Toolbar.displayName = "Toolbar";
var DateType = /* @__PURE__ */ function(DateType2) {
  DateType2["Start"] = "Start";
  DateType2["End"] = "End";
  return DateType2;
}({});
function getInputSelectedState(options) {
  var input = options.input, direction = options.direction, formatStr = options.formatStr, rangeFormatStr = options.rangeFormatStr, localize2 = options.localize, selectedMonth = options.selectedMonth, _options$valueOffset = options.valueOffset, valueOffset = _options$valueOffset === void 0 ? 0 : _options$valueOffset, character2 = options.character, dateType = options.dateType, dateString = options.dateString;
  var getPatternSelectedIndexes = function getPatternSelectedIndexes2(pattern) {
    var selectionStart = 0;
    var selectionEnd = 0;
    if (dateType === DateType.Start) {
      selectionStart = rangeFormatStr.indexOf(pattern);
      selectionEnd = rangeFormatStr.split(character2)[0].lastIndexOf(pattern) + 1;
    } else if (dateType === DateType.End) {
      var position2 = rangeFormatStr.indexOf(character2) + character2.length;
      selectionStart = rangeFormatStr.indexOf(pattern, position2);
      selectionEnd = rangeFormatStr.lastIndexOf(pattern) + 1;
    }
    var endDateGap = dateString.indexOf(character2) - rangeFormatStr.indexOf(character2);
    if (dateType === DateType.End && endDateGap > 0) {
      selectionStart += endDateGap;
      selectionEnd += endDateGap;
    }
    var gap2 = getSelectIndexGap({
      pattern,
      formatStr,
      valueOffset,
      selectedMonth,
      localize: localize2
    });
    var isSelectedMonth = pattern === "M";
    var isNullMonth = selectedMonth === null && !(isSelectedMonth && valueOffset !== 0);
    if (isNullMonth) {
      return {
        selectionStart,
        selectionEnd
      };
    }
    if (isSelectedMonth) {
      return {
        selectionStart,
        selectionEnd: selectionEnd + gap2
      };
    }
    if (isCursorAfterMonth(selectionStart, formatStr)) {
      return {
        selectionStart: selectionStart + gap2,
        selectionEnd: selectionEnd + gap2
      };
    }
    return {
      selectionStart,
      selectionEnd
    };
  };
  if (typeof input.selectionEnd === "number" && typeof input.selectionStart === "number") {
    var index = input.selectionStart;
    var positionOffset = -1;
    if (direction === "left") {
      index = input.selectionStart - 1;
    } else if (direction === "right") {
      index = input.selectionEnd + 1;
      positionOffset = 1;
    }
    var endDateIndex = dateString.indexOf(character2) + character2.length;
    var datePattern = getDatePattern({
      selectionIndex: dateType === DateType.End ? index - endDateIndex : index,
      positionOffset,
      formatStr,
      dateString,
      valueOffset,
      selectedMonth,
      localize: localize2
    });
    var indexes = getPatternSelectedIndexes(datePattern);
    return _extends$1({
      selectedPattern: datePattern
    }, indexes);
  }
  return {
    selectedPattern: "y",
    selectionStart: 0,
    selectionEnd: 0
  };
}
function getDateType(dateString, character2, cursorIndex) {
  var splitIndex = dateString.indexOf(character2);
  if (cursorIndex > splitIndex) {
    return DateType.End;
  }
  return DateType.Start;
}
function isSwitchDateType(dateString, character2, cursorIndex, direction) {
  var characterIndex = dateString.indexOf(character2);
  var startIndex = cursorIndex;
  var endIndex = startIndex + character2.length;
  if (direction === "left") {
    endIndex = cursorIndex;
    startIndex = endIndex - character2.length;
  }
  if (dateString.substring(startIndex, endIndex) === character2) {
    return true;
  }
  if (direction === "right") {
    if (!dateString.substring(cursorIndex, characterIndex).match(/[0-9a-zA-Z]/)) {
      return true;
    }
  }
  if (!dateString.substring(characterIndex, cursorIndex).match(/[0-9a-zA-Z]/)) {
    return true;
  }
  return false;
}
var _excluded$Q = ["className", "classPrefix", "character", "format", "value", "defaultValue", "placeholder", "onChange", "onKeyDown", "onBlur", "onFocus", "onPaste"];
var DateRangeInput = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var className = props.className, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "date-range-input" : _props$classPrefix, _props$character = props.character, character2 = _props$character === void 0 ? " ~ " : _props$character, _props$format = props.format, formatStr = _props$format === void 0 ? "yyyy-MM-dd" : _props$format, valueProp = props.value, _props$defaultValue = props.defaultValue, defaultValue = _props$defaultValue === void 0 ? [] : _props$defaultValue, placeholder = props.placeholder, onChange = props.onChange, onKeyDown = props.onKeyDown, onBlur = props.onBlur, onFocus = props.onFocus, onPaste = props.onPaste, rest = _objectWithoutPropertiesLoose(props, _excluded$Q);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  var classes = merge2(className, withClassPrefix());
  var inputRef = reactExports.useRef();
  var _useSelectedState = useSelectedState(), selectedState = _useSelectedState.selectedState, setSelectedState = _useSelectedState.setSelectedState;
  var _useCustom = useCustom("Calendar"), locale2 = _useCustom.locale, parseDate = _useCustom.parseDate;
  var rangeFormatStr = "" + formatStr + character2 + formatStr;
  var dateLocale = locale2.dateLocale;
  var _useControlled = useControlled$2(valueProp, defaultValue), value = _useControlled[0], setValue2 = _useControlled[1], isControlled = _useControlled[2];
  var _useState = reactExports.useState(DateType.Start), dateType = _useState[0], setDateType = _useState[1];
  var dateInputOptions = {
    formatStr,
    locale: dateLocale,
    isControlledDate: isControlled
  };
  var startDateState = useDateInputState(_extends$1({}, dateInputOptions, {
    date: (value === null || value === void 0 ? void 0 : value[0]) || null
  }));
  var endDateState = useDateInputState(_extends$1({}, dateInputOptions, {
    date: (value === null || value === void 0 ? void 0 : value[1]) || null
  }));
  var _useFieldCursor = useFieldCursor(formatStr, valueProp), isMoveCursor = _useFieldCursor.isMoveCursor, isResetValue = _useFieldCursor.isResetValue, increment = _useFieldCursor.increment, reset = _useFieldCursor.reset;
  var getActiveState = function getActiveState2(type) {
    if (type === void 0) {
      type = dateType;
    }
    return type === DateType.Start ? startDateState : endDateState;
  };
  var _useIsFocused = useIsFocused({
    onBlur,
    onFocus
  }), focused = _useIsFocused[0], focusEventProps = _useIsFocused[1];
  var renderedValue = reactExports.useMemo(function() {
    var dateString = startDateState.toDateString() + character2 + endDateState.toDateString();
    if (!startDateState.isEmptyValue() || !endDateState.isEmptyValue()) {
      return dateString;
    }
    return !focused ? "" : dateString;
  }, [character2, endDateState, focused, startDateState]);
  var keyPressOptions = {
    formatStr,
    rangeFormatStr,
    localize: dateLocale.localize,
    selectedMonth: getActiveState().dateField.month,
    dateString: renderedValue,
    dateType,
    character: character2
  };
  var setSelectionRange = useInputSelection(inputRef);
  var handleChange = useEventCallback$2(function(date, event) {
    var nextValue = dateType === DateType.Start ? [date, value === null || value === void 0 ? void 0 : value[1]] : [value === null || value === void 0 ? void 0 : value[0], date];
    onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, event);
    setValue2(nextValue);
  });
  var onSegmentChange = useEventCallback$2(function(event, nextDirection) {
    var input = event.target;
    var key = event.key;
    var direction = nextDirection || (key === "ArrowRight" ? "right" : "left");
    if (input.selectionEnd === null || input.selectionStart === null) {
      return;
    }
    var cursorIndex = direction === "right" ? input.selectionEnd : input.selectionStart;
    var nextDateType = dateType;
    if (isSwitchDateType(renderedValue, character2, cursorIndex, direction)) {
      nextDateType = dateType === DateType.Start ? DateType.End : DateType.Start;
      setDateType(nextDateType);
    }
    var state = getInputSelectedState(_extends$1({}, keyPressOptions, {
      dateType: nextDateType,
      selectedMonth: getActiveState(nextDateType).dateField.month,
      input,
      direction
    }));
    setSelectedState(state);
    setSelectionRange(state.selectionStart, state.selectionEnd);
    if (selectedState.selectedPattern !== state.selectedPattern) {
      reset();
    }
  });
  var onSegmentValueChange = useEventCallback$2(function(event) {
    var input = event.target;
    var key = event.key;
    var offset2 = key === "ArrowUp" ? 1 : -1;
    var state = getInputSelectedState(_extends$1({}, keyPressOptions, {
      input,
      valueOffset: offset2
    }));
    setSelectedState(state);
    getActiveState().setDateOffset(state.selectedPattern, offset2, function(date) {
      return handleChange(date, event);
    });
    setSelectionRange(state.selectionStart, state.selectionEnd);
  });
  var onSegmentValueChangeWithNumericKeys = useEventCallback$2(function(event) {
    var input = event.target;
    var key = event.key;
    var pattern = selectedState.selectedPattern;
    if (!pattern) {
      return;
    }
    var field = getActiveState().getDateField(pattern);
    var value2 = parseInt(key, 10);
    var padValue = parseInt("" + (field.value || "") + key, 10);
    var newValue = value2;
    if (validateDateTime$1(field.name, padValue) && !isResetValue()) {
      newValue = padValue;
    }
    getActiveState().setDateField(pattern, newValue, function(date) {
      return handleChange(date, event);
    });
    var selectedMonth = pattern === "M" ? newValue : getActiveState().dateField.month;
    var nextState = getInputSelectedState(_extends$1({}, keyPressOptions, {
      input,
      selectedMonth
    }));
    setSelectedState(nextState);
    setSelectionRange(nextState.selectionStart, nextState.selectionEnd);
    increment();
    if (isMoveCursor(newValue, pattern) && input.selectionEnd !== input.value.length) {
      onSegmentChange(event, "right");
    }
  });
  var onSegmentValueRemove = useEventCallback$2(function(event) {
    var input = event.target;
    if (selectedState.selectedPattern) {
      var nextState = getInputSelectedState(_extends$1({}, keyPressOptions, {
        input,
        valueOffset: null
      }));
      setSelectedState(nextState);
      setSelectionRange(nextState.selectionStart, nextState.selectionEnd);
      getActiveState().setDateField(selectedState.selectedPattern, null, function(date) {
        return handleChange(date, event);
      });
      reset();
    }
  });
  var handleClick = useEventCallback$2(function(event) {
    var input = event.target;
    if (input.selectionStart === null) {
      return;
    }
    var cursorIndex = input.selectionStart === renderedValue.length ? 0 : input.selectionStart;
    var dateType2 = getDateType(renderedValue || rangeFormatStr, character2, cursorIndex);
    var state = getInputSelectedState(_extends$1({}, keyPressOptions, {
      dateType: dateType2,
      selectedMonth: getActiveState(dateType2).dateField.month,
      input
    }));
    setDateType(dateType2);
    setSelectedState(state);
    setSelectionRange(state.selectionStart, state.selectionEnd);
    if (selectedState.selectedPattern !== state.selectedPattern) {
      reset();
    }
  });
  var handlePaste = useEventCallback$2(function(event) {
    var _event$clipboardData;
    event.preventDefault();
    var pasteText = (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.getData("text");
    var _ref = pasteText.split(character2).map(function(date) {
      return parseDate(date, formatStr);
    }), start2 = _ref[0], end2 = _ref[1];
    if (isValid$1(start2) && isValid$1(end2)) {
      var nextValue = [start2, end2];
      onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, event);
      setValue2(nextValue);
      startDateState.setNewDate(start2);
      endDateState.setNewDate(end2);
    }
    onPaste === null || onPaste === void 0 ? void 0 : onPaste(event);
  });
  var onKeyboardInput = useKeyboardInputEvent({
    onSegmentChange,
    onSegmentValueChange,
    onSegmentValueChangeWithNumericKeys,
    onSegmentValueRemove,
    onKeyDown
  });
  return /* @__PURE__ */ React.createElement(Input$1, _extends$1({
    inputMode: focused ? "numeric" : "text",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: false,
    className: classes,
    ref: mergeRefs(inputRef, ref),
    onKeyDown: onKeyboardInput,
    onClick: handleClick,
    onPaste: handlePaste,
    value: renderedValue,
    placeholder: placeholder || rangeFormatStr
  }, focusEventProps, rest));
});
DateRangeInput.displayName = "DateRangeInput";
DateRangeInput.propTypes = {
  character: PropTypes.string,
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  format: PropTypes.string,
  placeholder: PropTypes.string,
  onChange: PropTypes.func,
  onKeyDown: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func
};
function useCustomizedInput(props) {
  var value = props.value, formatStr = props.formatStr, readOnly = props.readOnly, editable = props.editable, loading = props.loading, _props$mode = props.mode, mode = _props$mode === void 0 ? "date" : _props$mode, renderValue = props.renderValue;
  var _useState = reactExports.useState(false), active = _useState[0], setActive = _useState[1];
  var onActive = reactExports.useCallback(function() {
    return setActive(true);
  }, []);
  var onInactive = reactExports.useCallback(function() {
    return setActive(false);
  }, []);
  var customValue = null;
  var inputReadOnly = readOnly || !editable || loading || false;
  var customized = !active || !editable;
  if (typeof renderValue === "function" && value && customized) {
    if (Array.isArray(value) ? value.every(isValid$1) : isValid$1(value)) {
      customValue = renderValue(value, formatStr);
      inputReadOnly = true;
    }
  }
  var TargetInput = mode === "dateRange" ? DateRangeInput : DateInput;
  var CustomizedInput = customValue ? Input$1 : TargetInput;
  return {
    customValue,
    Input: CustomizedInput,
    inputReadOnly,
    events: {
      onActive,
      onInactive
    }
  };
}
function Header$1(props) {
  var _prefix;
  var _useClassNames = useClassNames$2("picker"), prefix2 = _useClassNames.prefix;
  var formatStr = props.formatStr, character2 = props.character, value = props.value, _props$activeKey = props.activeKey, activeKey = _props$activeKey === void 0 ? "start" : _props$activeKey, clickable = props.clickable, onSelect = props.onSelect;
  var _ref = value !== null && value !== void 0 ? value : [null, null], startDate = _ref[0], endDate = _ref[1];
  var v2 = startDate && endDate ? [startDate, endDate].sort(compareAsc) : [startDate, endDate];
  var start2 = v2[0] ? /* @__PURE__ */ React.createElement(FormattedDate, {
    date: v2[0],
    formatStr
  }) : formatStr;
  var end2 = v2[1] ? /* @__PURE__ */ React.createElement(FormattedDate, {
    date: v2[1],
    formatStr
  }) : formatStr;
  return /* @__PURE__ */ React.createElement("div", {
    className: prefix2("daterange-header", (_prefix = {}, _prefix["tab-active-" + activeKey] = clickable, _prefix)),
    "data-testid": "daterange-header"
  }, clickable ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Button$1, {
    size: "xs",
    appearance: "subtle",
    className: prefix2("header-date"),
    onClick: function onClick() {
      return onSelect === null || onSelect === void 0 ? void 0 : onSelect("start");
    },
    "aria-label": "Select start date"
  }, start2), /* @__PURE__ */ React.createElement("span", {
    className: prefix2("header-character")
  }, character2), /* @__PURE__ */ React.createElement(Button$1, {
    size: "xs",
    appearance: "subtle",
    className: prefix2("header-date"),
    onClick: function onClick() {
      return onSelect === null || onSelect === void 0 ? void 0 : onSelect("end");
    },
    "aria-label": "Select end date"
  }, end2)) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("span", {
    className: prefix2("header-date")
  }, start2), /* @__PURE__ */ React.createElement("span", {
    className: prefix2("header-character")
  }, character2), /* @__PURE__ */ React.createElement("span", {
    className: prefix2("header-date")
  }, end2)));
}
function useDateDisabled(props) {
  var shouldDisableDate = props.shouldDisableDate, DEPRECATED_disabledDate = props.DEPRECATED_disabledDate;
  var isDateDisabled = reactExports.useCallback(function(date, options) {
    var selectDate = options.selectDate, selectedDone = options.selectedDone, target = options.target;
    if (typeof shouldDisableDate === "function") {
      return shouldDisableDate(date, selectDate, selectedDone, target);
    }
    if (typeof DEPRECATED_disabledDate === "function") {
      return DEPRECATED_disabledDate(date, selectDate, selectedDone, target);
    }
    return false;
  }, [shouldDisableDate, DEPRECATED_disabledDate]);
  if (shouldDisableDate || DEPRECATED_disabledDate) {
    return isDateDisabled;
  }
  return void 0;
}
var _excluded$P = ["as", "calendarDate", "format", "disabledDate", "index", "limitEndYear", "limitStartYear", "onChangeCalendarMonth", "onChangeCalendarTime", "onToggleMeridian", "onSelect", "value"];
var Calendar = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? CalendarContainer : _props$as, _props$calendarDate = props.calendarDate, calendarDate = _props$calendarDate === void 0 ? [/* @__PURE__ */ new Date(), addMonths(/* @__PURE__ */ new Date(), 1)] : _props$calendarDate, _props$format = props.format, format2 = _props$format === void 0 ? "yyyy-MM-dd" : _props$format, disabledDate = props.disabledDate, _props$index = props.index, index = _props$index === void 0 ? 0 : _props$index, limitEndYear = props.limitEndYear, limitStartYear = props.limitStartYear, onChangeCalendarMonth = props.onChangeCalendarMonth, onChangeCalendarTime = props.onChangeCalendarTime, onToggleMeridian = props.onToggleMeridian, onSelect = props.onSelect, _props$value = props.value, value = _props$value === void 0 ? [] : _props$value, rest = _objectWithoutPropertiesLoose(props, _excluded$P);
  var onMoveForward = useEventCallback$2(function(nextPageDate) {
    onChangeCalendarMonth === null || onChangeCalendarMonth === void 0 ? void 0 : onChangeCalendarMonth(index, nextPageDate);
  });
  var onMoveBackward = useEventCallback$2(function(nextPageDate) {
    onChangeCalendarMonth === null || onChangeCalendarMonth === void 0 ? void 0 : onChangeCalendarMonth(index, nextPageDate);
  });
  var handleSelect = useEventCallback$2(function(date, event) {
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(index, date, event);
  });
  var handleChangeMonth = useEventCallback$2(function(nextPageDate) {
    onChangeCalendarMonth === null || onChangeCalendarMonth === void 0 ? void 0 : onChangeCalendarMonth(index, nextPageDate);
  });
  var handleChangeTime = useEventCallback$2(function(nextPageDate) {
    onChangeCalendarTime === null || onChangeCalendarTime === void 0 ? void 0 : onChangeCalendarTime(index, nextPageDate);
  });
  var handleToggleMeridian = useEventCallback$2(function(event) {
    onToggleMeridian(index, event);
  });
  var getCalendarDate = function getCalendarDate2() {
    return calendarDate[index];
  };
  var handleMoveForward = useEventCallback$2(function() {
    onMoveForward === null || onMoveForward === void 0 ? void 0 : onMoveForward(addMonths(getCalendarDate(), 1));
  });
  var handleMoveBackward = useEventCallback$2(function() {
    onMoveBackward === null || onMoveBackward === void 0 ? void 0 : onMoveBackward(addMonths(getCalendarDate(), -1));
  });
  var disabledMonth = function disabledMonth2(date) {
    return disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date, value, DATERANGE_DISABLED_TARGET.CALENDAR);
  };
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    "data-testid": "calendar-" + (index === 0 ? "start" : "end")
  }, rest, {
    format: format2,
    dateRange: value,
    disabledDate: disabledMonth,
    index,
    limitEndYear,
    limitStartYear,
    onChangeMonth: handleChangeMonth,
    onChangeTime: handleChangeTime,
    onMoveBackward: handleMoveBackward,
    onMoveForward: handleMoveForward,
    onToggleMeridian: handleToggleMeridian,
    onSelect: handleSelect,
    calendarDate: getCalendarDate(),
    ref
  }));
});
Calendar.displayName = "DateRangePicker.Calendar";
function getSafeCalendarDate(_ref) {
  var _value;
  var value = _ref.value, _ref$calendarKey = _ref.calendarKey, calendarKey = _ref$calendarKey === void 0 ? "start" : _ref$calendarKey, allowSameMonth = _ref.allowSameMonth;
  value = (_value = value) !== null && _value !== void 0 ? _value : [];
  var gap2 = allowSameMonth ? 0 : 1;
  if (value[0] && value[1]) {
    var diffMonth = differenceInCalendarMonths(value[1], value[0]);
    if (calendarKey === "start") {
      return [value[0], diffMonth <= 0 ? copyTime({
        from: value[1],
        to: addMonths(value[0], gap2)
      }) : value[1]];
    } else if (calendarKey === "end") {
      return [diffMonth <= 0 ? copyTime({
        from: value[0],
        to: addMonths(value[1], -gap2)
      }) : value[0], value[1]];
    }
  } else if (value[0]) {
    return [value[0], addMonths(value[0], gap2)];
  }
  var todayDate = /* @__PURE__ */ new Date();
  return [todayDate, addMonths(todayDate, gap2)];
}
var isSameRange = function isSameRange2(source, dest, format2) {
  if (null === source && null === dest) return true;
  if (null === source || null === dest) return false;
  var result = isSameDay(source[0], dest[0]) && isSameDay(source[1], dest[1]);
  if (shouldRenderTime(format2)) {
    result && (result = isSameSecond(source[0], dest[0]) && isSameSecond(source[1], dest[1]));
  }
  return result;
};
var getMonthHoverRange = function getMonthHoverRange2(date) {
  return [startOfMonth(date), endOfMonth(date)];
};
var getWeekHoverRange = function getWeekHoverRange2(date, options) {
  var isoWeek = options.isoWeek, weekStart = options.weekStart, locale2 = options.locale;
  if (isoWeek) {
    return [startOfISOWeek(date), endOfISOWeek(date)];
  }
  return [startOfWeek(date, {
    weekStartsOn: weekStart,
    locale: locale2
  }), endOfWeek(date, {
    weekStartsOn: weekStart,
    locale: locale2
  })];
};
var _templateObject$1, _templateObject2;
var _excluded$O = ["as", "classPrefix", "className", "appearance", "editable", "cleanable", "character", "calendarSnapping", "defaultCalendarValue", "defaultValue", "plaintext", "disabled", "disabledDate", "shouldDisableDate", "format", "hoverRange", "id", "isoWeek", "weekStart", "limitEndYear", "limitStartYear", "locale", "loading", "label", "menuClassName", "menuStyle", "oneTap", "placeholder", "placement", "ranges", "readOnly", "showOneCalendar", "showWeekNumbers", "showMeridian", "showHeader", "style", "size", "caretAs", "value", "monthDropdownProps", "onChange", "onClean", "onEnter", "onExit", "onOk", "onSelect", "onShortcutClick", "renderTitle", "renderValue"];
var DateRangePicker = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _ref, _ref2, _merge;
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "picker" : _props$classPrefix, className = props.className, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "default" : _props$appearance, _props$editable = props.editable, editable = _props$editable === void 0 ? true : _props$editable, _props$cleanable = props.cleanable, cleanable = _props$cleanable === void 0 ? true : _props$cleanable, _props$character = props.character, character2 = _props$character === void 0 ? " ~ " : _props$character, calendarSnapping = props.calendarSnapping, defaultCalendarValue = props.defaultCalendarValue, defaultValue = props.defaultValue, plaintext = props.plaintext, disabled = props.disabled, DEPRECATED_disabledDate = props.disabledDate, shouldDisableDate = props.shouldDisableDate, _props$format = props.format, formatStr = _props$format === void 0 ? "yyyy-MM-dd" : _props$format, hoverRange = props.hoverRange, idProp = props.id, _props$isoWeek = props.isoWeek, isoWeek = _props$isoWeek === void 0 ? false : _props$isoWeek, _props$weekStart = props.weekStart, weekStart = _props$weekStart === void 0 ? 0 : _props$weekStart, _props$limitEndYear = props.limitEndYear, limitEndYear = _props$limitEndYear === void 0 ? 1e3 : _props$limitEndYear, limitStartYear = props.limitStartYear, overrideLocale = props.locale, loading = props.loading, label = props.label, menuClassName = props.menuClassName, menuStyle = props.menuStyle, oneTap = props.oneTap, _props$placeholder = props.placeholder, placeholder = _props$placeholder === void 0 ? "" : _props$placeholder, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomStart" : _props$placement, ranges = props.ranges, readOnly = props.readOnly, _props$showOneCalenda = props.showOneCalendar, showOneCalendar = _props$showOneCalenda === void 0 ? false : _props$showOneCalenda, showWeekNumbers = props.showWeekNumbers, showMeridian = props.showMeridian, _props$showHeader = props.showHeader, showHeader = _props$showHeader === void 0 ? true : _props$showHeader, style2 = props.style, size2 = props.size, caretAsProp = props.caretAs, valueProp = props.value, monthDropdownProps = props.monthDropdownProps, onChange = props.onChange, onClean = props.onClean, onEnter = props.onEnter, onExit = props.onExit, onOk = props.onOk, onSelect = props.onSelect, onShortcutClick = props.onShortcutClick, renderTitle = props.renderTitle, renderValue = props.renderValue, restProps = _objectWithoutPropertiesLoose(props, _excluded$O);
  var id2 = useUniqueId("rs-", idProp);
  var _usePickerRef = usePickerRef(ref), trigger2 = _usePickerRef.trigger, root2 = _usePickerRef.root, target = _usePickerRef.target, overlay = _usePickerRef.overlay;
  var _useClassNames = useClassNames$2(classPrefix), merge2 = _useClassNames.merge, prefix2 = _useClassNames.prefix;
  var _useCustom = useCustom("DateRangePicker", overrideLocale), locale2 = _useCustom.locale, formatDate = _useCustom.formatDate;
  var calendarGap = showOneCalendar ? 0 : 1;
  var rangeFormatStr = "" + formatStr + character2 + formatStr;
  var _useControlled = useControlled$2(valueProp, defaultValue !== null && defaultValue !== void 0 ? defaultValue : null), value = _useControlled[0], setValue2 = _useControlled[1];
  var onlyShowMonth = shouldRenderMonth(formatStr) && !shouldRenderDate(formatStr);
  var _useState = reactExports.useState(true), isSelectedIdle = _useState[0], setSelectedIdle = _useState[1];
  var _useState2 = reactExports.useState((_ref = valueProp !== null && valueProp !== void 0 ? valueProp : defaultValue) !== null && _ref !== void 0 ? _ref : []), selectedDates = _useState2[0], setSelectedDates = _useState2[1];
  var _useState3 = reactExports.useState(value), hoverDateRange = _useState3[0], setHoverDateRange = _useState3[1];
  var _useState4 = reactExports.useState(getSafeCalendarDate({
    value: (_ref2 = value !== null && value !== void 0 ? value : defaultCalendarValue) !== null && _ref2 !== void 0 ? _ref2 : null
  })), calendarDate = _useState4[0], setCalendarDate = _useState4[1];
  var selectRangeValueRef = reactExports.useRef(null);
  var _useState5 = reactExports.useState(), activeCalendarKey = _useState5[0], setActiveCalendarKey = _useState5[1];
  var getCalendarDatetime = function getCalendarDatetime2(calendarKey) {
    var index = calendarKey === "start" ? 0 : 1;
    return (calendarDate === null || calendarDate === void 0 ? void 0 : calendarDate[index]) || (defaultCalendarValue === null || defaultCalendarValue === void 0 ? void 0 : defaultCalendarValue[index]);
  };
  var setCalendarDateRange = function setCalendarDateRange2(_ref3) {
    var dateRange = _ref3.dateRange, calendarKey = _ref3.calendarKey, eventName = _ref3.eventName;
    var nextValue = dateRange;
    if (shouldRenderTime(formatStr) && dateRange !== null && dateRange !== void 0 && dateRange.length && (eventName === "changeDate" || eventName === "changeMonth")) {
      var startDate = copyTime({
        from: getCalendarDatetime("start"),
        to: dateRange[0]
      });
      var endDate = copyTime({
        from: getCalendarDatetime("end"),
        to: dateRange.length === 1 ? addMonths(startDate, calendarGap) : dateRange[1]
      });
      nextValue = [startDate, endDate];
    } else if (dateRange === null && typeof defaultCalendarValue !== "undefined") {
      nextValue = defaultCalendarValue;
    }
    var nextCalendarDate = getSafeCalendarDate({
      value: nextValue,
      calendarKey,
      // When only the month is displayed and only one calendar is displayed,
      // there is no need to add a month and two calendar panels are allowed to display the same month
      allowSameMonth: onlyShowMonth || showOneCalendar
    });
    setCalendarDate(nextCalendarDate);
    if (onlyShowMonth && eventName === "changeMonth") {
      setSelectedDates(nextCalendarDate);
    }
  };
  reactExports.useEffect(function() {
    setSelectedDates(valueProp !== null && valueProp !== void 0 ? valueProp : []);
    setHoverDateRange(valueProp !== null && valueProp !== void 0 ? valueProp : null);
  }, [valueProp]);
  var getInputHtmlSize = function getInputHtmlSize2() {
    var padding2 = 4;
    var strings = rangeFormatStr;
    if (value) {
      var startDate = value[0], endDate = value[1];
      strings = "" + formatDate(startDate, formatStr) + character2 + formatDate(endDate, formatStr);
    }
    return getStringLength(strings) + padding2;
  };
  var getHoverRangeValue = function getHoverRangeValue2(date) {
    function getHoverRangeFunc() {
      if (hoverRange === "week") {
        return function(date2) {
          return getWeekHoverRange(date2, {
            isoWeek,
            weekStart,
            locale: locale2 === null || locale2 === void 0 ? void 0 : locale2.dateLocale
          });
        };
      } else if (hoverRange === "month") {
        return getMonthHoverRange;
      }
      return hoverRange;
    }
    var hoverRangeFunc = getHoverRangeFunc();
    if (isNil$1(hoverRangeFunc)) {
      return null;
    }
    var hoverValues = hoverRangeFunc(date);
    var isHoverRangeValid = hoverValues instanceof Array && hoverValues.length === 2;
    if (!isHoverRangeValid) {
      return null;
    }
    if (isAfter$1(hoverValues[0], hoverValues[1])) {
      hoverValues = reverseDateRangeOmitTime(hoverValues);
    }
    return hoverValues;
  };
  var setDateRange = function setDateRange2(event, nextValue, closeOverlay) {
    if (closeOverlay === void 0) {
      closeOverlay = true;
    }
    setSelectedDates(nextValue !== null && nextValue !== void 0 ? nextValue : []);
    setValue2(nextValue);
    if (!isSameRange(nextValue, value, formatStr)) {
      onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, event);
    }
    if (closeOverlay !== false) {
      handleClose();
    }
  };
  var onMouseMove = useEventCallback$2(function(date) {
    var nextHoverDateRange = getHoverRangeValue(date);
    if (!isSelectedIdle) {
      if (!isNil$1(nextHoverDateRange) && !isNil$1(selectRangeValueRef.current)) {
        var nextSelectedDates = [selectRangeValueRef.current[0], nextHoverDateRange[1]];
        if (isBefore(nextHoverDateRange[0], selectRangeValueRef.current[0])) {
          nextSelectedDates = [nextHoverDateRange[0], selectRangeValueRef.current[1]];
        }
        setSelectedDates(nextSelectedDates);
      } else {
        setHoverDateRange(function(prevHoverValue) {
          return isNil$1(prevHoverValue) ? null : [prevHoverValue[0], date];
        });
      }
    } else if (!isNil$1(nextHoverDateRange)) {
      setHoverDateRange(nextHoverDateRange);
    }
  });
  var handleSelectDate = useEventCallback$2(function(index, date, event) {
    var calendarKey = index === 0 ? "start" : "end";
    var nextSelectDates = hoverDateRange !== null && hoverDateRange !== void 0 ? hoverDateRange : [];
    var hoverRangeValue = getHoverRangeValue(date);
    var noHoverRangeValid = isNil$1(hoverRangeValue);
    if (oneTap) {
      setDateRange(event, noHoverRangeValid ? [startOfDay(date), endOfDay(date)] : hoverRangeValue);
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(date, event);
      return;
    }
    if (noHoverRangeValid) {
      if (isSelectedIdle) {
        nextSelectDates = [date];
      } else {
        nextSelectDates[1] = date;
      }
    } else {
      if (!isSelectedIdle) {
        nextSelectDates = selectedDates;
        selectRangeValueRef.current = null;
      } else {
        nextSelectDates = hoverRangeValue;
        selectRangeValueRef.current = hoverRangeValue;
      }
    }
    if (nextSelectDates.length === 2) {
      if (isAfter$1(nextSelectDates[0], nextSelectDates[1])) {
        nextSelectDates = reverseDateRangeOmitTime(nextSelectDates);
      }
      if (shouldRenderTime(formatStr)) {
        nextSelectDates = [copyTime({
          from: getCalendarDatetime("start"),
          to: nextSelectDates[0]
        }), copyTime({
          from: getCalendarDatetime("end"),
          to: nextSelectDates[1]
        })];
      }
      setHoverDateRange(nextSelectDates);
    } else {
      setHoverDateRange([nextSelectDates[0], nextSelectDates[0]]);
    }
    if (isSelectedIdle) {
      setActiveCalendarKey("end");
    } else {
      setActiveCalendarKey("start");
    }
    setSelectedDates(nextSelectDates);
    if (!isSameMonth(calendarDate[index], date) || calendarSnapping) {
      setCalendarDateRange({
        dateRange: nextSelectDates,
        calendarKey,
        eventName: "changeDate"
      });
    }
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(date, event);
    setSelectedIdle(!isSelectedIdle);
  });
  reactExports.useEffect(function() {
    var selectValueLength = selectedDates.length;
    var doneSelected = selectValueLength === 0 || selectValueLength === 2;
    doneSelected && setHoverDateRange(null);
  }, [selectedDates]);
  var onChangeCalendarMonth = useEventCallback$2(function(index, date) {
    var calendarKey = index === 0 ? "start" : "end";
    var nextCalendarDate = Array.from(calendarDate);
    nextCalendarDate[index] = date;
    setCalendarDateRange({
      dateRange: nextCalendarDate,
      calendarKey,
      eventName: "changeMonth"
    });
  });
  var onChangeCalendarTime = useEventCallback$2(function(index, date) {
    var calendarKey = index === 0 ? "start" : "end";
    var nextCalendarDate = Array.from(calendarDate);
    nextCalendarDate[index] = date;
    setCalendarDateRange({
      dateRange: nextCalendarDate,
      calendarKey,
      eventName: "changeTime"
    });
    setSelectedDates(function(prev2) {
      var next2 = [].concat(prev2);
      next2[index] = next2[index] ? copyTime({
        from: date,
        to: next2[index]
      }) : new Date(date.valueOf());
      return next2;
    });
  });
  var onToggleMeridian = useEventCallback$2(function(index) {
    var nextCalendarDate = Array.from(calendarDate);
    nextCalendarDate[index] = getReversedTimeMeridian(nextCalendarDate[index]);
    setCalendarDate(nextCalendarDate);
    if (selectedDates.length === 2) {
      var nextSelectedDates = Array.from(selectedDates);
      nextSelectedDates[index] = getReversedTimeMeridian(nextSelectedDates[index]);
      setSelectedDates(nextSelectedDates);
    }
  });
  var handleEnter = useEventCallback$2(function() {
    var nextCalendarDate;
    if (value && value.length) {
      var startDate = value[0], endData = value[1];
      nextCalendarDate = [startDate, isSameMonth(startDate, endData) ? addMonths(endData, calendarGap) : endData];
    } else {
      nextCalendarDate = getSafeCalendarDate({
        value: defaultCalendarValue !== null && defaultCalendarValue !== void 0 ? defaultCalendarValue : null
      });
    }
    setSelectedDates(value !== null && value !== void 0 ? value : []);
    setCalendarDateRange({
      dateRange: nextCalendarDate
    });
  });
  var handleShortcutPageDate = useEventCallback$2(function(range, closeOverlay, event) {
    if (closeOverlay === void 0) {
      closeOverlay = false;
    }
    var value2 = range.value;
    setCalendarDateRange({
      dateRange: value2,
      eventName: "shortcutSelection"
    });
    if (closeOverlay) {
      setDateRange(event, value2, closeOverlay);
    } else {
      setSelectedDates(value2 !== null && value2 !== void 0 ? value2 : []);
    }
    onShortcutClick === null || onShortcutClick === void 0 ? void 0 : onShortcutClick(range, event);
    setSelectedIdle(true);
  });
  var handleClickOK = useEventCallback$2(function(event) {
    setDateRange(event, selectedDates);
    onOk === null || onOk === void 0 ? void 0 : onOk(selectedDates, event);
  });
  var handleClean = useEventCallback$2(function(event) {
    setCalendarDateRange({
      dateRange: null
    });
    setDateRange(event, null);
    onClean === null || onClean === void 0 ? void 0 : onClean(event);
    event.stopPropagation();
  });
  var handleInputChange = useEventCallback$2(function(value2, event) {
    if (!value2) {
      return;
    }
    var startDate = value2[0], endDate = value2[1];
    var selectValue = [startDate, endDate];
    setHoverDateRange(selectValue);
    setSelectedDates(selectValue);
    setCalendarDateRange({
      dateRange: selectValue
    });
    setDateRange(event, selectValue, false);
  });
  var isDateDisabled = useDateDisabled({
    shouldDisableDate,
    DEPRECATED_disabledDate
  });
  var isRangeDisabled = function isRangeDisabled2(start2, end2, target2) {
    if (isDateDisabled) {
      while (isBefore(start2, end2) || isSameDay(start2, end2)) {
        if (isDateDisabled(start2, {
          selectDate: selectedDates,
          selectedDone: isSelectedIdle,
          target: target2
        })) {
          return true;
        }
        start2 = addDays(start2, 1);
      }
    }
    return false;
  };
  var isOkButtonDisabled = function isOkButtonDisabled2() {
    var start2 = selectedDates[0], end2 = selectedDates[1];
    if (!start2 || !end2 || !isSelectedIdle) {
      return true;
    }
    if (isErrorValue([start2, end2])) {
      return true;
    }
    return false;
  };
  var isShortcutDisabled = function isShortcutDisabled2(value2) {
    if (value2 === void 0) {
      value2 = [];
    }
    var _value = value2, start2 = _value[0], end2 = _value[1];
    if (!start2 || !end2) {
      return true;
    }
    return isRangeDisabled(start2, end2, DATERANGE_DISABLED_TARGET.TOOLBAR_SHORTCUT);
  };
  var handleClose = useEventCallback$2(function() {
    var _trigger$current, _trigger$current$clos;
    (_trigger$current = trigger2.current) === null || _trigger$current === void 0 ? void 0 : (_trigger$current$clos = _trigger$current.close) === null || _trigger$current$clos === void 0 ? void 0 : _trigger$current$clos.call(_trigger$current);
  });
  var handleInputKeyDown = useEventCallback$2(function(event) {
    onMenuKeyDown(event, {
      esc: handleClose,
      enter: function enter() {
        var _trigger$current2;
        var _ref4 = ((_trigger$current2 = trigger2.current) === null || _trigger$current2 === void 0 ? void 0 : _trigger$current2.getState()) || {}, open = _ref4.open;
        if (!open) {
          var _trigger$current3;
          (_trigger$current3 = trigger2.current) === null || _trigger$current3 === void 0 ? void 0 : _trigger$current3.open();
        }
      }
    });
  });
  var disableCalendarDate = isDateDisabled ? function(date, values2, type) {
    return isDateDisabled(date, {
      selectDate: values2,
      selectedDone: isSelectedIdle,
      target: type
    });
  } : void 0;
  var renderCalendarOverlay = function renderCalendarOverlay2(positionProps, speakerRef) {
    var left2 = positionProps.left, top2 = positionProps.top, className2 = positionProps.className;
    var classes2 = merge2(className2, menuClassName, prefix2("popup-daterange"));
    var panelClasses = prefix2("daterange-panel", {
      "daterange-panel-show-one-calendar": showOneCalendar
    });
    var panelStyles = {
      minWidth: showOneCalendar ? "auto" : 528
    };
    var styles2 = _extends$1({}, menuStyle, {
      left: left2,
      top: top2
    });
    var calendarProps = {
      locale: locale2,
      isoWeek,
      weekStart,
      limitEndYear,
      showMeridian,
      calendarDate,
      limitStartYear,
      showWeekNumbers,
      format: formatStr,
      value: selectedDates,
      monthDropdownProps,
      hoverRangeValue: hoverDateRange !== null && hoverDateRange !== void 0 ? hoverDateRange : void 0,
      disabledDate: disableCalendarDate,
      onSelect: handleSelectDate,
      onChangeCalendarMonth,
      onChangeCalendarTime,
      onToggleMeridian,
      onMouseMove,
      renderTitle
    };
    var getCalendars = function getCalendars2() {
      if (showOneCalendar) {
        return /* @__PURE__ */ React.createElement(Calendar, _extends$1({
          index: activeCalendarKey === "end" ? 1 : 0
        }, calendarProps));
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Calendar, _extends$1({
        index: 0
      }, calendarProps)), /* @__PURE__ */ React.createElement(Calendar, _extends$1({
        index: 1
      }, calendarProps)));
    };
    var sideRanges = (ranges === null || ranges === void 0 ? void 0 : ranges.filter(function(range) {
      return (range === null || range === void 0 ? void 0 : range.placement) === "left";
    })) || [];
    var bottomRanges = ranges === null || ranges === void 0 ? void 0 : ranges.filter(function(range) {
      return (range === null || range === void 0 ? void 0 : range.placement) === "bottom" || (range === null || range === void 0 ? void 0 : range.placement) === void 0;
    });
    return /* @__PURE__ */ React.createElement(PickerPopup, {
      role: "dialog",
      "aria-labelledby": label ? id2 + "-label" : void 0,
      tabIndex: -1,
      className: classes2,
      ref: mergeRefs(overlay, speakerRef),
      target: trigger2,
      style: styles2
    }, /* @__PURE__ */ React.createElement("div", {
      className: panelClasses,
      style: panelStyles
    }, /* @__PURE__ */ React.createElement(Stack$1, {
      alignItems: "flex-start"
    }, sideRanges.length > 0 && /* @__PURE__ */ React.createElement(PredefinedRanges, {
      direction: "column",
      spacing: 0,
      className: prefix2("daterange-predefined"),
      ranges: sideRanges,
      calendarDate,
      locale: locale2,
      disableShortcut: isShortcutDisabled,
      onShortcutClick: handleShortcutPageDate,
      "data-testid": "daterange-predefined-side"
    }), /* @__PURE__ */ React.createElement(Stack$1.Item, null, /* @__PURE__ */ React.createElement("div", {
      className: prefix2("daterange-content")
    }, showHeader && /* @__PURE__ */ React.createElement(Header$1, {
      value: isSelectedIdle ? selectedDates : hoverDateRange,
      formatStr,
      character: character2,
      clickable: showOneCalendar,
      activeKey: activeCalendarKey,
      onSelect: setActiveCalendarKey
    }), /* @__PURE__ */ React.createElement("div", {
      className: prefix2("daterange-calendar-" + (showOneCalendar ? "single" : "group"))
    }, /* @__PURE__ */ React.createElement(DateRangePickerContext.Provider, {
      value: {
        isSelectedIdle
      }
    }, getCalendars()))), /* @__PURE__ */ React.createElement(Toolbar, {
      locale: locale2,
      calendarDate: selectedDates,
      disableOkBtn: isOkButtonDisabled,
      disableShortcut: isShortcutDisabled,
      hideOkBtn: oneTap,
      onOk: handleClickOK,
      onShortcutClick: handleShortcutPageDate,
      ranges: bottomRanges
    })))));
  };
  var hasValue2 = !isNil$1(value) && value.length > 1;
  var _usePickerClassName = usePickerClassName(_extends$1({}, props, {
    classPrefix,
    name: "daterange",
    appearance,
    hasValue: hasValue2,
    cleanable
  })), classes = _usePickerClassName[0], usedClassNamePropKeys = _usePickerClassName[1];
  var caretAs = reactExports.useMemo(function() {
    if (caretAsProp === null) {
      return null;
    }
    return caretAsProp || (shouldOnlyRenderTime(formatStr) ? IconClockO : IconCalendar);
  }, [caretAsProp, formatStr]);
  var isErrorValue = function isErrorValue2(value2) {
    if (!value2) {
      return false;
    }
    if (Array.isArray(value2) && value2.length === 0) {
      return false;
    }
    var startDate = value2[0], endDate = value2[1];
    if (!isValid$1(startDate) || !isValid$1(endDate)) {
      return true;
    }
    if (isBefore(endDate, startDate)) {
      return true;
    }
    var disabledOptions = {
      selectDate: value2,
      selectedDone: isSelectedIdle,
      target: DATERANGE_DISABLED_TARGET.INPUT
    };
    if (isDateDisabled !== null && isDateDisabled !== void 0 && isDateDisabled(startDate, disabledOptions) || isDateDisabled !== null && isDateDisabled !== void 0 && isDateDisabled(endDate, disabledOptions)) {
      return true;
    }
    return false;
  };
  var _partitionHTMLProps = partitionHTMLProps(restProps, {
    htmlProps: [],
    includeAria: true
  }), ariaProps = _partitionHTMLProps[0], rest = _partitionHTMLProps[1];
  var showCleanButton = cleanable && hasValue2 && !readOnly;
  var invalidValue = value && isErrorValue(value);
  var _useCustomizedInput = useCustomizedInput({
    mode: "dateRange",
    value,
    formatStr,
    renderValue,
    readOnly,
    editable,
    loading
  }), customValue = _useCustomizedInput.customValue, inputReadOnly = _useCustomizedInput.inputReadOnly, Input3 = _useCustomizedInput.Input, events2 = _useCustomizedInput.events;
  return /* @__PURE__ */ React.createElement(PickerToggleTrigger, {
    trigger: "active",
    ref: trigger2,
    pickerProps: pick$1(props, pickTriggerPropKeys),
    placement,
    onEnter: createChainedFunction$1(events2.onActive, handleEnter, onEnter),
    onExit: createChainedFunction$1(events2.onInactive, onExit),
    speaker: renderCalendarOverlay
  }, /* @__PURE__ */ React.createElement(Component, {
    ref: root2,
    className: merge2(className, classes, (_merge = {}, _merge[prefix2("error")] = invalidValue, _merge)),
    style: style2
  }, plaintext ? /* @__PURE__ */ React.createElement(DateRangeInput, {
    value,
    format: formatStr,
    plaintext
  }) : /* @__PURE__ */ React.createElement(InputGroup, _extends$1({}, omit$1(rest, [].concat(omitTriggerPropKeys, usedClassNamePropKeys, calendarOnlyProps)), {
    inside: true,
    className: prefix2(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["input-group"]))),
    disabled,
    size: size2
  }), /* @__PURE__ */ React.createElement(PickerLabel, {
    className: prefix2(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["label"]))),
    id: id2 + "-label"
  }, label), /* @__PURE__ */ React.createElement(Input3, _extends$1({
    "aria-haspopup": "dialog",
    "aria-invalid": invalidValue,
    "aria-labelledby": label ? id2 + "-label" : void 0
  }, ariaProps, {
    ref: target,
    id: id2,
    value: customValue || value,
    character: character2,
    format: formatStr,
    placeholder: placeholder ? placeholder : rangeFormatStr,
    disabled,
    readOnly: inputReadOnly,
    htmlSize: getInputHtmlSize(),
    onChange: handleInputChange,
    onKeyDown: handleInputKeyDown
  })), /* @__PURE__ */ React.createElement(PickerIndicator, {
    loading,
    caretAs,
    onClose: handleClean,
    showCleanButton
  }))));
});
DateRangePicker.displayName = "DateRangePicker";
DateRangePicker.propTypes = _extends$1({}, pickerPropTypes, {
  ranges: PropTypes.array,
  value: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
  defaultValue: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
  defaultCalendarValue: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
  hoverRange: PropTypes.oneOfType([oneOf(["week", "month"]), PropTypes.func]),
  format: PropTypes.string,
  isoWeek: PropTypes.bool,
  weekStart: PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6]),
  oneTap: PropTypes.bool,
  limitEndYear: PropTypes.number,
  limitStartYear: PropTypes.number,
  onChange: PropTypes.func,
  onOk: PropTypes.func,
  disabledDate: deprecatePropTypeNew(PropTypes.func, 'Use "shouldDisableDate" property instead.'),
  shouldDisableDate: PropTypes.func,
  onSelect: PropTypes.func,
  showWeekNumbers: PropTypes.bool,
  showMeridian: PropTypes.bool,
  showOneCalendar: PropTypes.bool
});
function isAfterDay(date1, date2) {
  return isAfter$1(new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()), new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
}
function isBeforeDay(date1, date2) {
  return isBefore(new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()), new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
}
function allowedMaxDays(days) {
  return function(date, selectValue, selectedDone, target) {
    var beforeLimit = false;
    var afterLimit = false;
    if (selectValue !== null && selectValue !== void 0 && selectValue[0]) {
      var startDate = selectValue[0];
      beforeLimit = composeFunctions(function(f2) {
        return addDays(f2, -days + 1);
      }, function(f2) {
        return isAfterDay(f2, date);
      })(startDate);
      afterLimit = composeFunctions(function(f2) {
        return addDays(f2, days - 1);
      }, function(f2) {
        return isBeforeDay(f2, date);
      })(startDate);
    }
    if (target === "CALENDAR" && !selectedDone && (beforeLimit || afterLimit)) {
      return true;
    }
    return false;
  };
}
function allowedDays(days) {
  return function(date, selectValue, selectedDone, target) {
    var beforeLimit = false;
    var afterLimit = false;
    if (selectValue !== null && selectValue !== void 0 && selectValue[0]) {
      var startDate = selectValue[0];
      beforeLimit = composeFunctions(function(f2) {
        return addDays(f2, -days + 1);
      }, function(f2) {
        return !isSameDay(f2, date);
      })(startDate);
      afterLimit = composeFunctions(function(f2) {
        return addDays(f2, days - 1);
      }, function(f2) {
        return !isSameDay(f2, date);
      })(startDate);
    }
    if (target === "CALENDAR" && !selectedDone && beforeLimit && afterLimit) {
      return true;
    }
    return false;
  };
}
function allowedRange(startDate, endDate) {
  return function(date) {
    if (isBeforeDay(date, new Date(startDate)) || isAfterDay(date, new Date(endDate))) {
      return true;
    }
    return false;
  };
}
function before(beforeDate) {
  if (beforeDate === void 0) {
    beforeDate = /* @__PURE__ */ new Date();
  }
  return function(date) {
    if (isBeforeDay(date, new Date(beforeDate))) {
      return true;
    }
    return false;
  };
}
function after(afterDate) {
  if (afterDate === void 0) {
    afterDate = /* @__PURE__ */ new Date();
  }
  return function(date) {
    if (isAfterDay(date, new Date(afterDate))) {
      return true;
    }
    return false;
  };
}
function beforeToday() {
  return before();
}
function afterToday() {
  return after();
}
function combine$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return function() {
    for (var _len2 = arguments.length, disabledDateArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      disabledDateArgs[_key2] = arguments[_key2];
    }
    return args.reduce(function(a3, b3) {
      return a3.apply(void 0, disabledDateArgs) || b3.apply(void 0, disabledDateArgs);
    });
  };
}
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  after,
  afterToday,
  allowedDays,
  allowedMaxDays,
  allowedRange,
  before,
  beforeToday,
  combine: combine$1
}, Symbol.toStringTag, { value: "Module" }));
Object.keys(utils$1).forEach(function(key) {
  DateRangePicker[key] = utils$1[key];
});
var Tab$1 = function Tab() {
  return /* @__PURE__ */ React.createElement(React.Fragment, null);
};
Tab$1.displayName = "Tab";
Tab$1.propTypes = {
  disabled: PropTypes.bool,
  eventKey: PropTypes.string,
  title: PropTypes.node,
  children: PropTypes.node,
  icon: PropTypes.node
};
var _excluded$N = ["as", "classPrefix", "children", "active", "className"];
var TabPanel = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "tab-panel" : _props$classPrefix, children = props.children, active = props.active, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded$N);
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, merge2 = _useClassNames.merge;
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    role: "tabpanel",
    ref,
    tabIndex: 0,
    hidden: !active,
    className: merge2(className, withClassPrefix())
  }, rest), children);
});
TabPanel.displayName = "TabPanel";
var _templateObject;
var _excluded$M = ["as", "classPrefix", "appearance", "className", "children", "activeKey", "defaultActiveKey", "id", "reversed", "vertical", "onSelect"];
function getFocusableTabs(tablist) {
  var tabs = tablist === null || tablist === void 0 ? void 0 : tablist.querySelectorAll("[role=tab]");
  return Array.from(tabs).filter(function(tab) {
    return !(tab.getAttribute("aria-disabled") === "true");
  });
}
function getFocusedTab(tablist) {
  var tabs = getFocusableTabs(tablist);
  return tabs.find(function(tab) {
    return tab.getAttribute("aria-selected");
  });
}
function nextItem$2(tablist) {
  if (!tablist) {
    return null;
  }
  var item = getFocusedTab(tablist);
  var items = getFocusableTabs(tablist);
  if (!item) {
    return items[0];
  }
  var nextItem2 = items[items.indexOf(item) + 1];
  if (!nextItem2 || nextItem2.getAttribute("role") !== "tab") {
    return items[0];
  }
  return nextItem2;
}
function previousItem$2(tablist) {
  if (!tablist) {
    return null;
  }
  var item = getFocusedTab(tablist);
  var items = getFocusableTabs(tablist);
  if (!item) {
    return items[items.length - 1];
  }
  var previousItem2 = items[items.indexOf(item) - 1];
  if (!previousItem2 || previousItem2.getAttribute("role") !== "tab") {
    return items[items.length - 1];
  }
  return previousItem2;
}
var renderPanels = function renderPanels2(children, tabProps) {
  var id2 = tabProps.id, activeKey = tabProps.activeKey;
  return ReactChildren.map(children, function(child) {
    var _child$props = child.props, eventKey = _child$props.eventKey, children2 = _child$props.children;
    var selected = eventKey === activeKey;
    return /* @__PURE__ */ React.createElement(TabPanel, {
      "aria-labelledby": id2 + "-" + eventKey,
      "aria-hidden": !selected,
      id: id2 + "-panel-" + eventKey,
      active: selected
    }, children2);
  });
};
var renderTabs = function renderTabs2(children, tabPanelProps) {
  var id2 = tabPanelProps.id, activeKey = tabPanelProps.activeKey;
  return ReactChildren.map(children, function(child) {
    var _child$props2 = child.props, eventKey = _child$props2.eventKey, title = _child$props2.title, disabled = _child$props2.disabled, icon = _child$props2.icon;
    var selected = eventKey === activeKey;
    return /* @__PURE__ */ React.createElement(Nav.Item, {
      role: "tab",
      as: "button",
      type: "button",
      "aria-selected": selected,
      "aria-controls": id2 + "-panel-" + eventKey,
      "aria-disabled": disabled,
      "data-event-key": eventKey,
      disabled,
      icon,
      id: id2 + "-" + eventKey,
      tabIndex: selected ? void 0 : -1,
      eventKey
    }, title);
  });
};
var Tabs$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var _props$as = props.as, Component = _props$as === void 0 ? "div" : _props$as, _props$classPrefix = props.classPrefix, classPrefix = _props$classPrefix === void 0 ? "tabs" : _props$classPrefix, _props$appearance = props.appearance, appearance = _props$appearance === void 0 ? "tabs" : _props$appearance, className = props.className, children = props.children, activeKeyProp = props.activeKey, defaultActiveKey = props.defaultActiveKey, idProp = props.id, reversed = props.reversed, vertical = props.vertical, onSelect = props.onSelect, rest = _objectWithoutPropertiesLoose(props, _excluded$M);
  var id2 = useUniqueId("tab-", idProp);
  var _useCustom = useCustom(), rtl = _useCustom.rtl;
  var _useControlled = useControlled$2(activeKeyProp, defaultActiveKey), activeKey = _useControlled[0], setActiveKey = _useControlled[1];
  var _useClassNames = useClassNames$2(classPrefix), withClassPrefix = _useClassNames.withClassPrefix, prefix2 = _useClassNames.prefix, merge2 = _useClassNames.merge;
  var tablistRef = React.useRef(null);
  var handleSelect = useEventCallback$2(function(eventKey, event) {
    setActiveKey(eventKey);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKey, event);
  });
  var handleKeyDown = useEventCallback$2(function(event) {
    var _getFocusableTabs;
    var target = event.target;
    if (target.getAttribute("role") !== "tab") {
      return;
    }
    var previousItemKey = vertical ? "ArrowUp" : "ArrowLeft";
    var nextItemKey = vertical ? "ArrowDown" : "ArrowRight";
    if (!vertical && rtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    var item = null;
    switch (event.key) {
      case previousItemKey:
        item = previousItem$2(tablistRef.current);
        event.preventDefault();
        break;
      case nextItemKey:
        item = nextItem$2(tablistRef.current);
        event.preventDefault();
        break;
      case "Home":
        item = (_getFocusableTabs = getFocusableTabs(tablistRef.current)) === null || _getFocusableTabs === void 0 ? void 0 : _getFocusableTabs[0];
        event.preventDefault();
        break;
      case "End":
        var tabs = getFocusableTabs(tablistRef.current);
        item = tabs[tabs.length - 1];
        event.preventDefault();
        break;
    }
    if (item) {
      var _item;
      var _item$dataset = (_item = item) === null || _item === void 0 ? void 0 : _item.dataset, eventKey = _item$dataset.eventKey;
      handleSelect(eventKey, event);
      item.focus();
    }
  });
  return /* @__PURE__ */ React.createElement(Component, _extends$1({
    className: merge2(className, withClassPrefix({
      reversed,
      vertical
    }))
  }, rest, {
    ref
  }), /* @__PURE__ */ React.createElement(Nav, {
    role: "tablist",
    "aria-orientation": vertical ? "vertical" : "horizontal",
    reversed,
    vertical,
    appearance,
    activeKey,
    onSelect: handleSelect,
    onKeyDown: handleKeyDown,
    ref: tablistRef
  }, renderTabs(children, {
    id: id2,
    activeKey
  })), /* @__PURE__ */ React.createElement("div", {
    className: prefix2(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["content"])))
  }, renderPanels(children, {
    id: id2,
    activeKey
  })));
});
Tabs$1.Tab = Tab$1;
Tabs$1.displayName = "Tabs";
Tabs$1.propTypes = {
  appearance: PropTypes.oneOf(["tabs", "subtle", "pills"]),
  activeKey: PropTypes.any,
  defaultActiveKey: PropTypes.any,
  reversed: PropTypes.bool,
  vertical: PropTypes.bool,
  id: PropTypes.string,
  className: PropTypes.string,
  classPrefix: PropTypes.string,
  children: PropTypes.node,
  onSelect: PropTypes.func
};
var Delete = {};
var createSvgIcon$1 = {};
function isPlainObject$1(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (!isPlainObject$1(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject$1(target) && isPlainObject$1(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject$1(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject$1(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$1(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function formatMuiErrorMessage$1(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
var reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$1 = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g$1 = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$2 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$1 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u2;
u2 = Symbol.for("react.module.reference");
function v$1(a3) {
  if ("object" === typeof a3 && null !== a3) {
    var r2 = a3.$$typeof;
    switch (r2) {
      case b$1:
        switch (a3 = a3.type, a3) {
          case d$1:
          case f$1:
          case e$1:
          case m$2:
          case n$1:
            return a3;
          default:
            switch (a3 = a3 && a3.$$typeof, a3) {
              case k$1:
              case h$1:
              case l$1:
              case q$1:
              case p$1:
              case g$1:
                return a3;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
reactIs_production_min$1.ContextConsumer = h$1;
reactIs_production_min$1.ContextProvider = g$1;
reactIs_production_min$1.Element = b$1;
reactIs_production_min$1.ForwardRef = l$1;
reactIs_production_min$1.Fragment = d$1;
reactIs_production_min$1.Lazy = q$1;
reactIs_production_min$1.Memo = p$1;
reactIs_production_min$1.Portal = c$1;
reactIs_production_min$1.Profiler = f$1;
reactIs_production_min$1.StrictMode = e$1;
reactIs_production_min$1.Suspense = m$2;
reactIs_production_min$1.SuspenseList = n$1;
reactIs_production_min$1.isAsyncMode = function() {
  return false;
};
reactIs_production_min$1.isConcurrentMode = function() {
  return false;
};
reactIs_production_min$1.isContextConsumer = function(a3) {
  return v$1(a3) === h$1;
};
reactIs_production_min$1.isContextProvider = function(a3) {
  return v$1(a3) === g$1;
};
reactIs_production_min$1.isElement = function(a3) {
  return "object" === typeof a3 && null !== a3 && a3.$$typeof === b$1;
};
reactIs_production_min$1.isForwardRef = function(a3) {
  return v$1(a3) === l$1;
};
reactIs_production_min$1.isFragment = function(a3) {
  return v$1(a3) === d$1;
};
reactIs_production_min$1.isLazy = function(a3) {
  return v$1(a3) === q$1;
};
reactIs_production_min$1.isMemo = function(a3) {
  return v$1(a3) === p$1;
};
reactIs_production_min$1.isPortal = function(a3) {
  return v$1(a3) === c$1;
};
reactIs_production_min$1.isProfiler = function(a3) {
  return v$1(a3) === f$1;
};
reactIs_production_min$1.isStrictMode = function(a3) {
  return v$1(a3) === e$1;
};
reactIs_production_min$1.isSuspense = function(a3) {
  return v$1(a3) === m$2;
};
reactIs_production_min$1.isSuspenseList = function(a3) {
  return v$1(a3) === n$1;
};
reactIs_production_min$1.isValidElementType = function(a3) {
  return "string" === typeof a3 || "function" === typeof a3 || a3 === d$1 || a3 === f$1 || a3 === e$1 || a3 === m$2 || a3 === n$1 || a3 === t$1 || "object" === typeof a3 && null !== a3 && (a3.$$typeof === q$1 || a3.$$typeof === p$1 || a3.$$typeof === g$1 || a3.$$typeof === h$1 || a3.$$typeof === l$1 || a3.$$typeof === u2 || void 0 !== a3.getModuleId) ? true : false;
};
reactIs_production_min$1.typeOf = v$1;
function capitalize$1(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage$1(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce$2(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function deprecatedPropType(validator, reason) {
  {
    return () => null;
  }
}
function isMuiElement(element, muiNames) {
  var _a2, _b2, _c2;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    element.type.muiName ?? ((_c2 = (_b2 = (_a2 = element.type) == null ? void 0 : _a2._payload) == null ? void 0 : _b2.value) == null ? void 0 : _c2.muiName)
  ) !== -1;
}
function ownerDocument$1(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument$1(node2);
  return doc.defaultView || window;
}
function requirePropFactory(componentNameInError, Component) {
  {
    return () => null;
  }
}
function setRef$1(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let globalId$1 = 0;
function useGlobalId$1(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId$1 += 1;
      setDefaultId(`mui-${globalId$1}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId$1 = React$1["useId".toString()];
function useId$1(idOverride) {
  if (maybeReactUseId$1 !== void 0) {
    const reactId = maybeReactUseId$1();
    return idOverride ?? reactId;
  }
  return useGlobalId$1(idOverride);
}
function unsupportedProp(props, propName, componentName, location, propFullName) {
  {
    return null;
  }
}
function useControlled$1({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue2] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue2(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback$1(fn2) {
  const ref = reactExports.useRef(fn2);
  useEnhancedEffect$1(() => {
    ref.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef$1(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef$1(ref, instance);
      });
    };
  }, refs);
}
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const EMPTY = [];
function useOnMount(fn2) {
  reactExports.useEffect(fn2, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error) {
  }
  return false;
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
const usePreviousProps = (value) => {
  const ref = reactExports.useRef({});
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};
const visuallyHidden$1 = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function resolveProps(defaultProps2, props) {
  const output = {
    ...props
  };
  for (const key in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key)) {
      const propName = key;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps2[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            }
          }
        }
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
function composeClasses$1(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start2 = true;
    for (let i2 = 0; i2 < slot.length; i2 += 1) {
      const value = slot[i2];
      if (value) {
        buffer += (start2 === true ? "" : " ") + getUtilityClass(value);
        start2 = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
const defaultGenerator$1 = (componentName) => componentName;
const createClassNameGenerator$1 = () => {
  let generate = defaultGenerator$1;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator$1;
    }
  };
};
const ClassNameGenerator$1 = createClassNameGenerator$1();
const globalStateClasses$1 = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass$1(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses$1[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses$1(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass$1(componentName, slot, globalStatePrefix);
  });
  return result;
}
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function isHostComponent$2(element) {
  return typeof element === "string";
}
function appendOwnerState$1(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent$2(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function r$1(e3) {
  var t3, f2, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n2 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o = e3.length;
    for (t3 = 0; t3 < o; t3++) e3[t3] && (f2 = r$1(e3[t3])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e3) e3[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e3, t3, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e3 = arguments[f2]) && (t3 = r$1(e3)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
function extractEventHandlers$1(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers$1(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps$1(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = {
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers$1({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers$1(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers$1(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = {
    ...internalSlotProps == null ? void 0 : internalSlotProps.style,
    ...additionalProps == null ? void 0 : additionalProps.style,
    ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
    ...externalSlotProps == null ? void 0 : externalSlotProps.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function resolveComponentProps$1(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function useSlotProps$1(parameters) {
  var _a2;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...other
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps$1(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps$1({
    ...other,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef$1(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_a2 = parameters.additionalProps) == null ? void 0 : _a2.ref);
  const props = appendOwnerState$1(elementType, {
    ...mergedProps,
    ref
  }, ownerState);
  return props;
}
function getReactNodeRef(element) {
  if (!element || !/* @__PURE__ */ reactExports.isValidElement(element)) {
    return null;
  }
  return element.props.propertyIsEnumerable("ref") ? element.props.ref : (
    // @ts-expect-error element.ref is not included in the ReactElement type
    // We cannot check for it, but isValidElement is true at this point
    // https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/70189
    element.ref
  );
}
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
function sortContainerQueries(theme, css2) {
  if (!theme.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a3, b3) => {
    var _a2, _b2;
    const regex = /min-width:\s*([0-9.]+)/;
    return +(((_a2 = a3.match(regex)) == null ? void 0 : _a2[1]) || 0) - +(((_b2 = b3.match(regex)) == null ? void 0 : _b2[1]) || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key) => {
    const value = css2[key];
    delete acc[key];
    acc[key] = value;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node22, name) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key) => {
      let result = typeof key === "number" ? key : values$1[key] || key;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _a2;
  const breakpointsInOrder = (_a2 = breakpointsInput.keys) == null ? void 0 : _a2.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i2) => {
      if (i2 < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys2 = Object.keys(base);
  if (keys2.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys2.reduce((acc, breakpoint, i2) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i2] != null ? breakpointValues[i2] : breakpointValues[previous];
      previous = i2;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$3(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize$1(fn2) {
  const cache2 = {};
  return (arg2) => {
    if (cache2[arg2] === void 0) {
      cache2[arg2] = fn2(arg2);
    }
    return cache2[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$1((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a3, b3] = prop.split("");
  const property2 = properties[a3];
  const direction = directions[b3] || "";
  return Array.isArray(direction) ? direction.map((dir) => property2 + dir) : [property2 + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys2, prop, transformer) {
  if (!keys2.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$2(props, keys2) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys2, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style$2(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$2(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$3({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$3({
  prop: "gridColumn"
});
const gridRow = style$3({
  prop: "gridRow"
});
const gridAutoFlow = style$3({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$3({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$3({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$3({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$3({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$3({
  prop: "gridTemplateAreas"
});
const gridArea = style$3({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$3({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$3({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$3({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$3({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _a2, _b2, _c2, _d2, _e2;
      const breakpoint = ((_c2 = (_b2 = (_a2 = props.theme) == null ? void 0 : _a2.breakpoints) == null ? void 0 : _b2.values) == null ? void 0 : _c2[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_e2 = (_d2 = props.theme) == null ? void 0 : _d2.breakpoints) == null ? void 0 : _e2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$3({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$3({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$3({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$3({
  prop: "minHeight",
  transform: sizingTransform
});
style$3({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$3({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$3({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys2, object) => keys2.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = theme.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x3) => ({
                [styleKey]: x3
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const splitProps = (props) => {
  var _a2;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = ((_a2 = props == null ? void 0 : props.theme) == null ? void 0 : _a2.unstable_sxConfig) ?? defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp$1(props) {
  const {
    sx: inSx,
    ...other
  } = props;
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$1(result)) {
        return systemProps;
      }
      return {
        ...systemProps,
        ...result
      };
    };
  } else {
    finalSx = {
      ...systemProps,
      ...inSx
    };
  }
  return {
    ...otherProps,
    sx: finalSx
  };
}
function memoize(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache2[arg2] === void 0) cache2[arg2] = fn2(arg2);
    return cache2[arg2];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment$2 = false;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this2 = this;
    this._insertTag = function(tag) {
      var before2;
      if (_this2.tags.length === 0) {
        if (_this2.insertionPoint) {
          before2 = _this2.insertionPoint.nextSibling;
        } else if (_this2.prepend) {
          before2 = _this2.container.firstChild;
        } else {
          before2 = _this2.before;
        }
      } else {
        before2 = _this2.tags[_this2.tags.length - 1].nextSibling;
      }
      _this2.container.insertBefore(tag, before2);
      _this2.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? !isDevelopment$2 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e3) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine2(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent2, type, props, children, length2) {
  return { value, root: root2, parent: parent2, type, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent2, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property2 = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent2), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property2 > 0 && strlen(characters2) - length2)
              append(property2 > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root2, parent2, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index = offset2 = property2 = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property2 = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent2, index, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i2 = 0, j = 0, k3 = 0; i2 < index; ++i2)
    for (var x3 = 0, y4 = substr(value, post + 1, post = abs(j = points[i2])), z3 = value; x3 < size2; ++x3)
      if (z3 = trim(j > 0 ? rule[x3] + " " + y4 : replace(y4, /&\f/g, rule[x3])))
        props[k3++] = z3;
  return node(value, root2, parent2, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent2) {
  return node(value, root2, parent2, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent2, length2) {
  return node(value, root2, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent2 = element.parent;
  var isImplicitRule = element.column === parent2.column && element.line === parent2.line;
  while (parent2.type !== "rule") {
    parent2 = parent2.parent;
    if (!parent2) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent2)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent2.props;
  for (var i2 = 0, k3 = 0; i2 < rules.length; i2++) {
    for (var j = 0; j < parentRules.length; j++, k3++) {
      element.props[k3] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine2(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b2 = "function" === typeof Symbol && Symbol.for, c2 = b2 ? Symbol.for("react.element") : 60103, d3 = b2 ? Symbol.for("react.portal") : 60106, e2 = b2 ? Symbol.for("react.fragment") : 60107, f = b2 ? Symbol.for("react.strict_mode") : 60108, g = b2 ? Symbol.for("react.profiler") : 60114, h3 = b2 ? Symbol.for("react.provider") : 60109, k2 = b2 ? Symbol.for("react.context") : 60110, l = b2 ? Symbol.for("react.async_mode") : 60111, m$1 = b2 ? Symbol.for("react.concurrent_mode") : 60111, n = b2 ? Symbol.for("react.forward_ref") : 60112, p = b2 ? Symbol.for("react.suspense") : 60113, q2 = b2 ? Symbol.for("react.suspense_list") : 60120, r = b2 ? Symbol.for("react.memo") : 60115, t2 = b2 ? Symbol.for("react.lazy") : 60116, v = b2 ? Symbol.for("react.block") : 60121, w2 = b2 ? Symbol.for("react.fundamental") : 60117, x2 = b2 ? Symbol.for("react.responder") : 60118, y3 = b2 ? Symbol.for("react.scope") : 60119;
function z2(a3) {
  if ("object" === typeof a3 && null !== a3) {
    var u3 = a3.$$typeof;
    switch (u3) {
      case c2:
        switch (a3 = a3.type, a3) {
          case l:
          case m$1:
          case e2:
          case g:
          case f:
          case p:
            return a3;
          default:
            switch (a3 = a3 && a3.$$typeof, a3) {
              case k2:
              case n:
              case t2:
              case r:
              case h3:
                return a3;
              default:
                return u3;
            }
        }
      case d3:
        return u3;
    }
  }
}
function A(a3) {
  return z2(a3) === m$1;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m$1;
reactIs_production_min.ContextConsumer = k2;
reactIs_production_min.ContextProvider = h3;
reactIs_production_min.Element = c2;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e2;
reactIs_production_min.Lazy = t2;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d3;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a3) {
  return A(a3) || z2(a3) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a3) {
  return z2(a3) === k2;
};
reactIs_production_min.isContextProvider = function(a3) {
  return z2(a3) === h3;
};
reactIs_production_min.isElement = function(a3) {
  return "object" === typeof a3 && null !== a3 && a3.$$typeof === c2;
};
reactIs_production_min.isForwardRef = function(a3) {
  return z2(a3) === n;
};
reactIs_production_min.isFragment = function(a3) {
  return z2(a3) === e2;
};
reactIs_production_min.isLazy = function(a3) {
  return z2(a3) === t2;
};
reactIs_production_min.isMemo = function(a3) {
  return z2(a3) === r;
};
reactIs_production_min.isPortal = function(a3) {
  return z2(a3) === d3;
};
reactIs_production_min.isProfiler = function(a3) {
  return z2(a3) === g;
};
reactIs_production_min.isStrictMode = function(a3) {
  return z2(a3) === f;
};
reactIs_production_min.isSuspense = function(a3) {
  return z2(a3) === p;
};
reactIs_production_min.isValidElementType = function(a3) {
  return "string" === typeof a3 || "function" === typeof a3 || a3 === e2 || a3 === m$1 || a3 === g || a3 === f || a3 === p || a3 === q2 || "object" === typeof a3 && null !== a3 && (a3.$$typeof === t2 || a3.$$typeof === r || a3.$$typeof === h3 || a3.$$typeof === k2 || a3.$$typeof === n || a3.$$typeof === w2 || a3.$$typeof === x2 || a3.$$typeof === y3 || a3.$$typeof === v);
};
reactIs_production_min.typeOf = z2;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag2) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag2) {
  registerStyles(cache2, serialized, isStringTag2);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h4 = 0;
  var k3, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k3 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k3 = /* Math.imul(k, m): */
    (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16);
    k3 ^= /* k >>> r: */
    k3 >>> 24;
    h4 = /* Math.imul(k, m): */
    (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h4 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h4 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h4 ^= str.charCodeAt(i2) & 255;
      h4 = /* Math.imul(h, m): */
      (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  h4 ^= h4 >>> 13;
  h4 = /* Math.imul(h, m): */
  (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  return ((h4 ^ h4 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var isDevelopment$1 = false;
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property2) {
  return property2.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes3 = interpolation;
      if (keyframes3.anim === 1) {
        cursor = {
          name: keyframes3.name,
          styles: keyframes3.styles,
          next: cursor
        };
        return keyframes3.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment$1) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
require_extends();
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var isDevelopment = false;
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i2 = 1;
      for (; i2 < len; i2++) {
        styles2.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$2(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
/**
 * @mui/styled-engine v6.0.2
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$2(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values2);
  const keys2 = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between2(start2, end2) {
    const endIndex = keys2.indexOf(end2);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys2[endIndex]] === "number" ? values2[keys2[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys2.indexOf(key) + 1 < keys2.length) {
      return between2(key, keys2[keys2.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys2.indexOf(key);
    if (keyIndex === 0) {
      return up(keys2[1]);
    }
    if (keyIndex === keys2.length - 1) {
      return down(keys2[keyIndex]);
    }
    return between2(key, keys2[keys2.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: keys2,
    values: sortedValues,
    up,
    down,
    between: between2,
    only,
    not,
    unit,
    ...other
  };
}
const shape = {
  borderRadius: 4
};
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function applyStyles$2(key, styles2) {
  var _a2;
  const theme = this;
  if (theme.vars) {
    if (!((_a2 = theme.colorSchemes) == null ? void 0 : _a2[key]) || typeof theme.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme.getColorSchemeSelector(key);
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme.palette.mode === key) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles$2;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty$1(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty$1(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$1(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme = useTheme$1(defaultTheme2);
    const {
      className,
      component = "div",
      ...other
    } = extendSxProp$1(inProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, {
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme[themeId] || theme : theme,
      ...other
    });
  });
  return Box2;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function resolveTheme(themeId, theme, defaultTheme2) {
  return isObjectEmpty(theme) ? defaultTheme2 : theme[themeId] || theme;
}
const PROCESSED_PROPS = Symbol("mui.processed_props");
function attachTheme(props, themeId, defaultTheme2) {
  if (PROCESSED_PROPS in props) {
    return props[PROCESSED_PROPS];
  }
  const processedProps = {
    ...props,
    theme: resolveTheme(themeId, props.theme, defaultTheme2)
  };
  props[PROCESSED_PROPS] = processedProps;
  processedProps[PROCESSED_PROPS] = processedProps;
  return processedProps;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function processStyle(style2, props) {
  var _a2;
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(subStyle, props));
  }
  if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
    const {
      variants,
      ...otherStyles
    } = resolvedStyle;
    let result = otherStyles;
    let mergedState;
    variantLoop: for (let i2 = 0; i2 < variants.length; i2 += 1) {
      const variant = variants[i2];
      if (typeof variant.props === "function") {
        mergedState ?? (mergedState = {
          ...props,
          ...props.ownerState,
          ownerState: props.ownerState
        });
        if (!variant.props(mergedState)) {
          continue;
        }
      } else {
        for (const key in variant.props) {
          if (props[key] !== variant.props[key] && ((_a2 = props.ownerState) == null ? void 0 : _a2[key]) !== variant.props[key]) {
            continue variantLoop;
          }
        }
      }
      if (!Array.isArray(result)) {
        result = [result];
      }
      if (typeof variant.style === "function") {
        mergedState ?? (mergedState = {
          ...props,
          ...props.ownerState,
          ownerState: props.ownerState
        });
        result.push(variant.style(mergedState));
      } else {
        result.push(variant.style);
      }
    }
    return result;
  }
  return resolvedStyle;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx(attachTheme(props, themeId, defaultTheme2));
  };
  systemSx.__mui_systemSx = true;
  const styled2 = (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 == null ? void 0 : style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label,
      ...options
    });
    const transformStyleArg = (style2) => {
      if (typeof style2 === "function" && style2.__emotion_real !== style2 || isPlainObject$1(style2)) {
        return (props) => processStyle(style2, attachTheme(props, themeId, defaultTheme2));
      }
      return style2;
    };
    const muiStyledResolver = (style2, ...expressions) => {
      let transformedStyle = transformStyleArg(style2);
      const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(themeId, props.theme, defaultTheme2);
          if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
            return null;
          }
          const styleOverrides = theme.components[componentName].styleOverrides;
          const resolvedStyleOverrides = {};
          const propsWithTheme = attachTheme(props, themeId, defaultTheme2);
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(styleOverrides[slotKey], propsWithTheme);
          }
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          var _a2, _b2;
          const theme = resolveTheme(themeId, props.theme, defaultTheme2);
          const themeVariants = (_b2 = (_a2 = theme == null ? void 0 : theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b2.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyle({
            variants: themeVariants
          }, attachTheme(props, themeId, defaultTheme2));
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(style2) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyle = [...style2, ...placeholders];
        transformedStyle.raw = [...style2.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyle, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function isObjectEmpty(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
const styled$1 = createStyled2();
function getThemeProps$1(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$1(defaultTheme2);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  return getThemeProps$1({
    theme,
    name,
    props
  });
}
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && matchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect$1(() => {
    if (!matchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      setMatch(queryList.matches);
    };
    updateMatch();
    queryList.addEventListener("change", updateMatch);
    return () => {
      queryList.removeEventListener("change", updateMatch);
    };
  }, [query, matchMedia]);
  return match2;
}
const maybeReactUseSyncExternalStore = reactExports.useSyncExternalStore;
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (noSsr && matchMedia) {
      return () => matchMedia(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
  const [getSnapshot, subscribe] = reactExports.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify2) => {
      mediaQueryList.addEventListener("change", notify2);
      return () => {
        mediaQueryList.removeEventListener("change", notify2);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match2;
}
function useMediaQuery(queryInput, options = {}) {
  const theme = useTheme$2();
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const {
    defaultMatches = false,
    matchMedia = supportMatchMedia ? window.matchMedia : null,
    ssrMatchMedia = null,
    noSsr = false
  } = getThemeProps$1({
    name: "MuiUseMediaQuery",
    props: options,
    theme
  });
  let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
  query = query.replace(/^@media( ?)/m, "");
  const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
  const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
  return match2;
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  return clamp(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
    return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage$1(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage$1(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    if (warning && false) {
      console.warn(warning);
    }
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.includes("rgb")) {
    values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
  } else if (type.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h4 = values2[0];
  const s3 = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a3 = s3 * Math.min(l2, 1 - l2);
  const f2 = (n2, k3 = (n2 + h4 / 30) % 12) => l2 - a3 * Math.max(Math.min(k3 - 3, 9 - k3, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning) {
  try {
    return alpha(color2, value);
  } catch (error) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (255 - color2.values[i2]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (1 - color2.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
const RtlContext = /* @__PURE__ */ reactExports.createContext();
const useRtl = () => {
  const value = reactExports.useContext(RtlContext);
  return value ?? false;
};
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config2 = theme.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys2, value, arrayKeys = []) => {
  let temp = obj;
  keys2.forEach((k3, index) => {
    if (index === keys2.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k3)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k3] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k3]) {
        temp[k3] = arrayKeys.includes(k3) ? [] : {};
      }
      temp = temp[k3];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys2, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys2.includes(prop))) {
      return value;
    }
    const lastKey = keys2[keys2.length - 1];
    if (lastKey.toLowerCase().indexOf("opacity") >= 0) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme,
    (keys2, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys2, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys2.join("-")}`;
          const resolvedValue = getCssValue(keys2, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys2, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys2, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys2) => keys2[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    var _a2, _b2;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode = ((_b2 = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode) || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    var _a2, _b2;
    const stylesheets = [];
    const colorScheme = theme.defaultColorScheme || "light";
    function insertStyleSheet(key, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key === "string" ? {
          [key]: {
            ...css2
          }
        } : key);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = (_b2 = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key, {
      css: css2
    }]) => {
      var _a3, _b3;
      const cssColorSheme = (_b3 = (_a3 = colorSchemes[key]) == null ? void 0 : _a3.palette) == null ? void 0 : _b3.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key, {
        ...finalCss
      }), finalCss);
    });
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault(props) {
  return useThemeProps$1({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$2
  });
}
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index) => {
    output.push(child);
    if (index < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style$1 = ({
  ownerState,
  theme
}) => {
  let styles2 = {
    display: "flex",
    flexDirection: "column",
    ...handleBreakpoints({
      theme
    }, resolveBreakpointValues({
      values: ownerState.direction,
      breakpoints: theme.breakpoints.values
    }), (propValue) => ({
      flexDirection: propValue
    }))
  };
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme);
    const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses$1(slots, (slot) => generateUtilityClass$1(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style$1);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid(inProps, ref) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    const {
      component = "div",
      direction = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false,
      ...other
    } = props;
    const ownerState = {
      direction,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, {
      as: component,
      ownerState,
      ref,
      className: clsx(classes.root, className),
      ...other,
      children: divider ? joinChildren(children, divider) : children
    });
  });
  return Stack2;
}
const common = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common.white,
    default: common.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage$1(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage$1(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modes[mode]
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries = Object.entries(typography);
  entries.forEach((entry) => {
    const [key, value] = entry;
    if (typeof value === "object") {
      vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round$3(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size2) => `${size2 / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size2, lineHeight, letterSpacing, casing) => ({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size2),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily === defaultFontFamily ? {
      letterSpacing: `${round$3(letterSpacing / size2)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant2 = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0,
      ...other
    } = options;
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    ...other
  } = options;
  if (options.vars) {
    throw new Error(formatMuiErrorMessage$1(20));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other == null ? void 0 : other.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_, index) => {
  if (index === 0) {
    return void 0;
  }
  const overlay = getOverlayAlpha(index);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
  return {
    inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
    inputUnderline: mode === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
    switchTrack: mode === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode) {
  return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    ...rest
  } = options;
  const palette = createPalette(paletteInput);
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys2) {
  var _a2;
  return !!keys2[0].match(/(cssVarPrefix|colorSchemeSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys2[0].match(/sxConfig$/) || // ends with sxConfig
  keys2[0] === "palette" && !!((_a2 = keys2[1]) == null ? void 0 : _a2.match(/(mode|contrastThreshold|tonalOffset)/));
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(24)].map((_, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index + 1}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme) => (colorScheme, css2) => {
  const selector = theme.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          ":root": css2,
          [`@media (prefers-color-scheme: dark)`]: {
            ":root": excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`:root, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        ":root": {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `:root, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          ":root": css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return ":root";
};
function isSerializable(val) {
  return isPlainObject$1(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index = 0; index < array.length; index++) {
      const [key, value] = array[index];
      if (!isSerializable(value) || key.startsWith("unstable_")) {
        delete object[key];
      } else if (isPlainObject$1(value)) {
        object[key] = {
          ...value
        };
        serializeTheme(object[key]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function assignNode(obj, keys2) {
  keys2.forEach((k3) => {
    if (!obj[k3]) {
      obj[k3] = {};
    }
  });
}
function setColor(obj, key, defaultValue) {
  if (!obj[key] && defaultValue) {
    obj[key] = defaultValue;
  }
}
function toRgb(color2) {
  if (!color2 || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key) {
  if (!(`${key}Channel` in obj)) {
    obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn2) => {
  try {
    return fn2();
  } catch (error) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode,
        ...scheme == null ? void 0 : scheme.palette
      }
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode,
      ...scheme == null ? void 0 : scheme.palette
    }
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette,
    opacity: {
      ...getOpacity(mode),
      ...scheme == null ? void 0 : scheme.opacity
    },
    overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage$1(21, defaultColorScheme));
  }
  const muiTheme = attachColorScheme$1(colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSchemes, builtInDark, void 0, "dark");
  }
  let theme = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme.colorSchemes).forEach((key) => {
    const palette = theme.colorSchemes[key].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", private_safeDarken(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeDarken(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeDarken(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeDarken(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", private_safeLighten(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeLighten(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeLighten(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeLighten(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", private_safeLighten(palette.warning.main, 0.62));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeLighten(palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeLighten(palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", private_safeLighten(palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", private_safeLighten(palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", private_safeLighten(palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", private_safeLighten(palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", private_safeLighten(private_safeAlpha(palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", private_safeLighten(palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", private_safeLighten(palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", private_safeLighten(palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", private_safeLighten(palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", private_safeDarken(palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", private_safeDarken(palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", private_safeDarken(palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", private_safeDarken(palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", private_safeDarken(palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", private_safeDarken(palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", private_safeDarken(palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", private_safeDarken(palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", private_safeDarken(palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", private_safeDarken(palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", private_safeDarken(palette.warning.main, 0.5));
      const snackbarContentBackground = private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", private_safeDarken(palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", private_safeDarken(palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", private_safeDarken(palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", private_safeDarken(palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", private_safeDarken(palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", private_safeDarken(palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", private_safeDarken(private_safeAlpha(palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", private_safeAlpha(palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme)
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme, parserConfig);
  theme.vars = vars;
  Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
    theme[key] = value;
  });
  theme.generateThemeVars = generateThemeVars;
  theme.generateStyleSheets = generateStyleSheets;
  theme.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme.spacing = theme.generateSpacing();
  theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input == null ? void 0 : input.unstable_sxConfig
  };
  theme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme.toRuntimeSource = stringifyTheme;
  return theme;
}
function attachColorScheme(theme, scheme, colorScheme) {
  if (!theme.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette == null ? void 0 : palette.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme.defaultColorScheme = defaultColorSchemeInput;
    theme.colorSchemes = colorSchemesInput;
    if (theme.palette.mode === "light") {
      theme.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme.palette
      };
      attachColorScheme(theme, "dark", colorSchemesInput.dark);
    }
    if (theme.palette.mode === "dark") {
      theme.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme.palette
      };
      attachColorScheme(theme, "light", colorSchemesInput.light);
    }
    return theme;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme$1 = createTheme();
const THEME_ID = "$$material";
function useTheme() {
  const theme = useTheme$1(defaultTheme$1);
  return theme[THEME_ID] || theme;
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
    ...props,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function globalCss(styles2) {
  return function GlobalStylesWrapper(props) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
        styles: typeof styles2 === "function" ? (theme) => styles2({
          theme,
          ...props
        }) : styles2
      })
    );
  };
}
function internal_createExtendSxProp() {
  return extendSxProp$1;
}
const arg = {
  theme: void 0
};
function memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return (props) => {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = styleFn(arg);
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass$1("MuiSvgIcon", slot);
}
generateUtilityClasses$1("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses$1x = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize$1(color2)}`, `fontSize${capitalize$1(fontSize)}`]
  };
  return composeClasses$1(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize$1(ownerState.color)}`], styles2[`fontSize${capitalize$1(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme
}) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k, _l, _m, _n;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: (_d2 = (_a2 = theme.transitions) == null ? void 0 : _a2.create) == null ? void 0 : _d2.call(_a2, "fill", {
      duration: (_c2 = (_b2 = (theme.vars ?? theme).transitions) == null ? void 0 : _b2.duration) == null ? void 0 : _c2.shorter
    }),
    variants: [
      {
        props: (props) => !props.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: ((_f2 = (_e2 = theme.typography) == null ? void 0 : _e2.pxToRem) == null ? void 0 : _f2.call(_e2, 20)) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: ((_h2 = (_g2 = theme.typography) == null ? void 0 : _g2.pxToRem) == null ? void 0 : _h2.call(_g2, 24)) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: ((_j2 = (_i2 = theme.typography) == null ? void 0 : _i2.pxToRem) == null ? void 0 : _j2.call(_i2, 35)) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((theme.vars ?? theme).palette).filter(([, value]) => value && value.main).map(([color2]) => {
        var _a3, _b3;
        return {
          props: {
            color: color2
          },
          style: {
            color: (_b3 = (_a3 = (theme.vars ?? theme).palette) == null ? void 0 : _a3[color2]) == null ? void 0 : _b3.main
          }
        };
      }),
      {
        props: {
          color: "action"
        },
        style: {
          color: (_l = (_k = (theme.vars ?? theme).palette) == null ? void 0 : _k.action) == null ? void 0 : _l.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (_n = (_m = (theme.vars ?? theme).palette) == null ? void 0 : _m.action) == null ? void 0 : _n.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  };
}));
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24",
    ...other
  } = props;
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = {
    ...props,
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  };
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$1x(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, {
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref,
    ...more,
    ...other,
    ...hasSvgAsChild && children.props,
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  });
});
if (SvgIcon) {
  SvgIcon.muiName = "SvgIcon";
}
function createSvgIcon(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, {
      "data-testid": `${displayName}Icon`,
      ref,
      ...props,
      children: path
    });
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
const unstable_ClassNameGenerator = {
  configure: (generator) => {
    ClassNameGenerator$1.configure(generator);
  }
};
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize: capitalize$1,
  createChainedFunction,
  createSvgIcon,
  debounce: debounce$2,
  deprecatedPropType,
  isMuiElement,
  ownerDocument: ownerDocument$1,
  ownerWindow,
  requirePropFactory,
  setRef: setRef$1,
  unstable_ClassNameGenerator,
  unstable_memoTheme: memoTheme,
  unstable_useEnhancedEffect: useEnhancedEffect$1,
  unstable_useId: useId$1,
  unsupportedProp,
  useControlled: useControlled$1,
  useEventCallback: useEventCallback$1,
  useForkRef: useForkRef$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon) return createSvgIcon$1;
  hasRequiredCreateSvgIcon = 1;
  (function(exports) {
    "use client";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _utils.createSvgIcon;
      }
    });
    var _utils = require$$0;
  })(createSvgIcon$1);
  return createSvgIcon$1;
}
var _interopRequireDefault$z = interopRequireDefaultExports;
Object.defineProperty(Delete, "__esModule", {
  value: true
});
var default_1$z = Delete.default = void 0;
var _createSvgIcon$z = _interopRequireDefault$z(requireCreateSvgIcon());
var _jsxRuntime$z = jsxRuntimeExports;
default_1$z = Delete.default = (0, _createSvgIcon$z.default)(/* @__PURE__ */ (0, _jsxRuntime$z.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete");
var Edit = {};
var _interopRequireDefault$y = interopRequireDefaultExports;
Object.defineProperty(Edit, "__esModule", {
  value: true
});
var default_1$y = Edit.default = void 0;
var _createSvgIcon$y = _interopRequireDefault$y(requireCreateSvgIcon());
var _jsxRuntime$y = jsxRuntimeExports;
default_1$y = Edit.default = (0, _createSvgIcon$y.default)(/* @__PURE__ */ (0, _jsxRuntime$y.jsx)("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
}), "Edit");
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction$1(d4) {
  return d4 instanceof Function;
}
function isNumberArray(d4) {
  return Array.isArray(d4) && d4.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo$1(getDeps, fn2, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn2(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: false,
    onChange
  };
}
function createCell(table, row, column2, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column2.id}`,
    row,
    column: column2,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo$1(() => [table, column2, row, cell], (table2, column22, row2, cell2) => ({
      table: table2,
      column: column22,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column2, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent2) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id2 = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id2) {
    throw new Error();
  }
  let column2 = {
    id: `${String(id2)}`,
    accessorFn,
    parent: parent2,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo$1(() => [true], () => {
      var _column$columns;
      return [column2, ...(_column$columns = column2.columns) == null ? void 0 : _column$columns.flatMap((d4) => d4.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns")),
    getLeafColumns: memo$1(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column2.columns) != null && _column$columns2.length) {
        let leafColumns = column2.columns.flatMap((column22) => column22.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column2];
    }, getMemoOptions(table.options, "debugColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column2, table);
  }
  return column2;
}
const debug = "debugHeaders";
function createHeader(table, column2, options) {
  var _options$id;
  const id2 = (_options$id = options.id) != null ? _options$id : column2.id;
  let header = {
    id: id2,
    column: column2,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h4) => {
        if (h4.subHeaders && h4.subHeaders.length) {
          h4.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h4);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column: column2
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
const Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo$1(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left2, right2) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left2 == null ? void 0 : left2.map((columnId) => leafColumns.find((d4) => d4.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right2 == null ? void 0 : right2.map((columnId) => leafColumns.find((d4) => d4.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column2) => !(left2 != null && left2.includes(column2.id)) && !(right2 != null && right2.includes(column2.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug));
    table.getCenterHeaderGroups = memo$1(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left2, right2) => {
      leafColumns = leafColumns.filter((column2) => !(left2 != null && left2.includes(column2.id)) && !(right2 != null && right2.includes(column2.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug));
    table.getLeftHeaderGroups = memo$1(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left2) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left2 == null ? void 0 : left2.map((columnId) => leafColumns.find((d4) => d4.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug));
    table.getRightHeaderGroups = memo$1(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right2) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right2 == null ? void 0 : right2.map((columnId) => leafColumns.find((d4) => d4.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug));
    table.getFooterGroups = memo$1(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getLeftFooterGroups = memo$1(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getCenterFooterGroups = memo$1(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getRightFooterGroups = memo$1(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getFlatHeaders = memo$1(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getLeftFlatHeaders = memo$1(() => [table.getLeftHeaderGroups()], (left2) => {
      return left2.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getCenterFlatHeaders = memo$1(() => [table.getCenterHeaderGroups()], (left2) => {
      return left2.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getRightFlatHeaders = memo$1(() => [table.getRightHeaderGroups()], (left2) => {
      return left2.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getCenterLeafHeaders = memo$1(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug));
    table.getLeftLeafHeaders = memo$1(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug));
    table.getRightLeafHeaders = memo$1(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug));
    table.getLeafHeaders = memo$1(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left2, center, right2) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left2[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right2[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column2) => column2.getIsVisible()).forEach((column2) => {
      var _column$columns;
      if ((_column$columns = column2.columns) != null && _column$columns.length) {
        findMaxDepth(column2.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column2;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column2 = headerToGroup.column.parent;
      } else {
        column2 = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column2) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column2, {
          id: [headerFamily, depth, column2.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d4) => d4.column === column2).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column2, index) => createHeader(table, column2, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
const createRow$1 = (table, id2, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id: id2,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column2 = table.getColumn(columnId);
      if (!(column2 != null && column2.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column2.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column2 = table.getColumn(columnId);
      if (!(column2 != null && column2.accessorFn)) {
        return void 0;
      }
      if (!column2.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column2.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d4) => d4.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo$1(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column2) => {
        return createCell(table, row, column2, column2.id);
      });
    }, getMemoOptions(table.options, "debugRows")),
    _getAllCellsByColumnId: memo$1(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows"))
  };
  for (let i2 = 0; i2 < table._features.length; i2++) {
    const feature = table._features[i2];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
const ColumnFaceting = {
  createColumn: (column2, table) => {
    column2._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column2.id);
    column2.getFacetedRowModel = () => {
      if (!column2._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column2._getFacetedRowModel();
    };
    column2._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column2.id);
    column2.getFacetedUniqueValues = () => {
      if (!column2._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column2._getFacetedUniqueValues();
    };
    column2._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column2.id);
    column2.getFacetedMinMaxValues = () => {
      if (!column2._getFacetedMinMaxValues) {
        return void 0;
      }
      return column2._getFacetedMinMaxValues();
    };
  }
};
const includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
const includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
const equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
const arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
const equals$1 = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals$1.autoRemove = (val) => testFalsey(val);
const weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
const inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals: equals$1,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
const ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column2, table) => {
    column2.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column2.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column2.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction$1(column2.columnDef.filterFn) ? column2.columnDef.filterFn : column2.columnDef.filterFn === "auto" ? column2.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column2.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column2.columnDef.filterFn]
      );
    };
    column2.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column2.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column2.accessorFn;
    };
    column2.getIsFiltered = () => column2.getFilterIndex() > -1;
    column2.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d4) => d4.id === column2.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column2.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d4) => d4.id === column2.id)) != null ? _table$getState$colum2 : -1;
    };
    column2.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column2.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find((d4) => d4.id === column2.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column2)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d4) => d4.id !== column2.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column2.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d4) => {
            if (d4.id === column2.id) {
              return newFilterObj;
            }
            return d4;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
          const column2 = leafColumns.find((d4) => d4.id === filter.id);
          if (column2) {
            const filterFn = column2.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column2)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column2) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column2) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
const sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next2) => {
    const nextValue = next2.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
const min$1 = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
const max$1 = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
const extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value) min2 = max2 = value;
      } else {
        if (min2 > value) min2 = value;
        if (max2 < value) max2 = value;
      }
    }
  });
  return [min2, max2];
};
const mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2) return sum2 / count2;
  return;
};
const median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values2 = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values2)) {
    return;
  }
  if (values2.length === 1) {
    return values2[0];
  }
  const mid = Math.floor(values2.length / 2);
  const nums = values2.sort((a3, b3) => a3 - b3);
  return values2.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
const unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d4) => d4.getValue(columnId))).values());
};
const uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d4) => d4.getValue(columnId))).size;
};
const count = (_columnId, leafRows) => {
  return leafRows.length;
};
const aggregationFns = {
  sum,
  min: min$1,
  max: max$1,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
const ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column2, table) => {
    column2.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column2.id)) {
          return old.filter((d4) => d4 !== column2.id);
        }
        return [...old != null ? old : [], column2.id];
      });
    };
    column2.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column2.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column2.accessorFn || !!column2.columnDef.getGroupingValue);
    };
    column2.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column2.id);
    };
    column2.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column2.id);
    };
    column2.getToggleGroupingHandler = () => {
      const canGroup = column2.getCanGroup();
      return () => {
        if (!canGroup) return;
        column2.toggleGrouping();
      };
    };
    column2.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column2.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column2.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column2) {
        throw new Error();
      }
      return isFunction$1(column2.columnDef.aggregationFn) ? column2.columnDef.aggregationFn : column2.columnDef.aggregationFn === "auto" ? column2.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column2.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column2.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column2 = table.getColumn(columnId);
      if (!(column2 != null && column2.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column2.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column2, row, table) => {
    cell.getIsGrouped = () => column2.getIsGrouped() && column2.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column2.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g2) => leafColumns.find((col) => col.id === g2)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
const ColumnOrdering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column2, table) => {
    column2.getIndex = memo$1((position2) => [_getVisibleLeafColumns(table, position2)], (columns) => columns.findIndex((d4) => d4.id === column2.id), getMemoOptions(table.options, "debugColumns"));
    column2.getIsFirstColumn = (position2) => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position2);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column2.id;
    };
    column2.getIsLastColumn = (position2) => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position2);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column2.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo$1(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d4) => d4.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable"));
  }
};
const getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
const ColumnPinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column2, table) => {
    column2.pin = (position2) => {
      const columnIds = column2.getLeafColumns().map((d4) => d4.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position2 === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d4) => !(columnIds != null && columnIds.includes(d4))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d4) => !(columnIds != null && columnIds.includes(d4))), ...columnIds]
          };
        }
        if (position2 === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d4) => !(columnIds != null && columnIds.includes(d4))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d4) => !(columnIds != null && columnIds.includes(d4)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d4) => !(columnIds != null && columnIds.includes(d4))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d4) => !(columnIds != null && columnIds.includes(d4)))
        };
      });
    };
    column2.getCanPin = () => {
      const leafColumns = column2.getLeafColumns();
      return leafColumns.some((d4) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d4.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column2.getIsPinned = () => {
      const leafColumnIds = column2.getLeafColumns().map((d4) => d4.id);
      const {
        left: left2,
        right: right2
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d4) => left2 == null ? void 0 : left2.includes(d4));
      const isRight = leafColumnIds.some((d4) => right2 == null ? void 0 : right2.includes(d4));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column2.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position2 = column2.getIsPinned();
      return position2 ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position2]) == null ? void 0 : _table$getState$colum2.indexOf(column2.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo$1(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left2, right2) => {
      const leftAndRight = [...left2 != null ? left2 : [], ...right2 != null ? right2 : []];
      return allCells.filter((d4) => !leftAndRight.includes(d4.column.id));
    }, getMemoOptions(table.options, "debugRows"));
    row.getLeftVisibleCells = memo$1(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left2) => {
      const cells = (left2 != null ? left2 : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d4) => ({
        ...d4,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows"));
    row.getRightVisibleCells = memo$1(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right2) => {
      const cells = (right2 != null ? right2 : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d4) => ({
        ...d4,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position2) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position2) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position2]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo$1(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left2) => {
      return (left2 != null ? left2 : []).map((columnId) => allColumns.find((column2) => column2.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns"));
    table.getRightLeafColumns = memo$1(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right2) => {
      return (right2 != null ? right2 : []).map((columnId) => allColumns.find((column2) => column2.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns"));
    table.getCenterLeafColumns = memo$1(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left2, right2) => {
      const leftAndRight = [...left2 != null ? left2 : [], ...right2 != null ? right2 : []];
      return allColumns.filter((d4) => !leftAndRight.includes(d4.id));
    }, getMemoOptions(table.options, "debugColumns"));
  }
};
const defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
const getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
const ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column2, table) => {
    column2.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column2.id];
      return Math.min(Math.max((_column$columnDef$min = column2.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column2.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column2.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column2.getStart = memo$1((position2) => [position2, _getVisibleLeafColumns(table, position2), table.getState().columnSizing], (position2, columns) => columns.slice(0, column2.getIndex(position2)).reduce((sum2, column22) => sum2 + column22.getSize(), 0), getMemoOptions(table.options, "debugColumns"));
    column2.getAfter = memo$1((position2) => [position2, _getVisibleLeafColumns(table, position2), table.getState().columnSizing], (position2, columns) => columns.slice(column2.getIndex(position2) + 1).reduce((sum2, column22) => sum2 + column22.getSize(), 0), getMemoOptions(table.options, "debugColumns"));
    column2.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column2.id]: _,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column2.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column2.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column2.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column2.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column2 = table.getColumn(header.column.id);
      const canResize = column2 == null ? void 0 : column2.getCanResize();
      return (e3) => {
        if (!column2 || !canResize) {
          return;
        }
        e3.persist == null || e3.persist();
        if (isTouchStartEvent(e3)) {
          if (e3.touches && e3.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d4) => [d4.column.id, d4.column.getSize()]) : [[column2.id, column2.getSize()]];
        const clientX = isTouchStartEvent(e3) ? Math.round(e3.touches[0].clientX) : e3.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = _contextDocument || typeof document !== "undefined" ? document : null;
        const mouseEvents = {
          moveHandler: (e22) => onMove(e22.clientX),
          upHandler: (e22) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e22.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e22) => {
            if (e22.cancelable) {
              e22.preventDefault();
              e22.stopPropagation();
            }
            onMove(e22.touches[0].clientX);
            return false;
          },
          upHandler: (e22) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e22.cancelable) {
              e22.preventDefault();
              e22.stopPropagation();
            }
            onEnd((_e$touches$ = e22.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e3)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column2.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean") return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop2 = () => {
    };
    window.addEventListener("test", noop2, options);
    window.removeEventListener("test", noop2);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e3) {
  return e3.type === "touchstart";
}
const ColumnVisibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column2, table) => {
    column2.toggleVisibility = (value) => {
      if (column2.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column2.id]: value != null ? value : !column2.getIsVisible()
        }));
      }
    };
    column2.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column2.columns;
      return (_ref = childColumns.length ? childColumns.some((c3) => c3.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column2.id]) != null ? _ref : true;
    };
    column2.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column2.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column2.getToggleVisibilityHandler = () => {
      return (e3) => {
        column2.toggleVisibility == null || column2.toggleVisibility(e3.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo$1(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows"));
    row.getVisibleCells = memo$1(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left2, center, right2) => [...left2, ...center, ...right2], getMemoOptions(table.options, "debugRows"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo$1(() => [getColumns(), getColumns().filter((d4) => d4.getIsVisible()).map((d4) => d4.id).join("_")], (columns) => {
        return columns.filter((d4) => d4.getIsVisible == null ? void 0 : d4.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns"));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column2) => ({
        ...obj,
        [column2.id]: !value ? !(column2.getCanHide != null && column2.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column2) => !(column2.getIsVisible != null && column2.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column2) => column2.getIsVisible == null ? void 0 : column2.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e3) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e3.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position2) {
  return !position2 ? table.getVisibleLeafColumns() : position2 === "center" ? table.getCenterVisibleLeafColumns() : position2 === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
const GlobalFaceting = {
  createTable: (table) => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
const GlobalFiltering = {
  getInitialState: (state) => {
    return {
      globalFilter: void 0,
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column2) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column2.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column2, table) => {
    column2.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column2.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column2)) != null ? _table$options$getCol : true) && !!column2.accessorFn;
    };
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn
      } = table.options;
      return isFunction$1(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
  }
};
const RowExpanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e3) => {
        e3.persist == null || e3.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id2) => {
        const splitId = id2.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};
const defaultPageIndex = 0;
const defaultPageSize = 10;
const getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
const RowPagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize2 = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize2);
        return {
          ...old,
          pageIndex,
          pageSize: pageSize2
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo$1(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i2) => i2);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};
const getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
const RowPinning = {
  getInitialState: (state) => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position2, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
        let {
          id: id2
        } = _ref;
        return id2;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
        let {
          id: id2
        } = _ref2;
        return id2;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position2 === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d4) => !(rowIds != null && rowIds.has(d4))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d4) => !(rowIds != null && rowIds.has(d4))), ...Array.from(rowIds)]
          };
        }
        if (position2 === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d4) => !(rowIds != null && rowIds.has(d4))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d4) => !(rowIds != null && rowIds.has(d4)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d4) => !(rowIds != null && rowIds.has(d4))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d4) => !(rowIds != null && rowIds.has(d4)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top: top2,
        bottom: bottom2
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d4) => top2 == null ? void 0 : top2.includes(d4));
      const isBottom = rowIds.some((d4) => bottom2 == null ? void 0 : bottom2.includes(d4));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position2 = row.getIsPinned();
      if (!position2) return -1;
      const visiblePinnedRowIds = (_ref4 = position2 === "top" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5) => {
        let {
          id: id2
        } = _ref5;
        return id2;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: (table) => {
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position2) => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position2) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position2]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position2) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d4) => ({
        ...d4,
        position: position2
      }));
    };
    table.getTopRows = memo$1(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows"));
    table.getBottomRows = memo$1(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows"));
    table.getCenterRows = memo$1(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top2, bottom2) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top2 != null ? top2 : [], ...bottom2 != null ? bottom2 : []]);
      return allRows.filter((d4) => !topAndBottom.has(d4.id));
    }, getMemoOptions(table.options, "debugRows"));
  }
};
const RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo$1(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable"));
    table.getFilteredSelectedRowModel = memo$1(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable"));
    table.getGroupedSelectedRowModel = memo$1(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d4) => d4.getIsSelected() || d4.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e3) => {
        table.toggleAllRowsSelected(e3.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e3) => {
        table.toggleAllPageRowsSelected(e3.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e3) => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e3.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
const mutateRowIsSelected = (selectedRowIds, id2, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id2, true);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id2] = true;
    }
  } else {
    delete selectedRowIds[id2];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
const reSplitAlphaNumeric = /([0-9]+)/gm;
const alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const datetime = (rowA, rowB, columnId) => {
  const a3 = rowA.getValue(columnId);
  const b3 = rowB.getValue(columnId);
  return a3 > b3 ? 1 : a3 < b3 ? -1 : 0;
};
const basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a3, b3) {
  return a3 === b3 ? 0 : a3 > b3 ? 1 : -1;
}
function toString(a3) {
  if (typeof a3 === "number") {
    if (isNaN(a3) || a3 === Infinity || a3 === -Infinity) {
      return "";
    }
    return String(a3);
  }
  if (typeof a3 === "string") {
    return a3;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a3 = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b3 = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a3.length && b3.length) {
    const aa2 = a3.shift();
    const bb2 = b3.shift();
    const an = parseInt(aa2, 10);
    const bn = parseInt(bb2, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa2 > bb2) {
        return 1;
      }
      if (bb2 > aa2) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a3.length - b3.length;
}
const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
const RowSorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e3) => {
        return e3.shiftKey;
      }
    };
  },
  createColumn: (column2, table) => {
    column2.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString2 = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column2.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString2 = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString2) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column2.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column2.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column2.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column2) {
        throw new Error();
      }
      return isFunction$1(column2.columnDef.sortingFn) ? column2.columnDef.sortingFn : column2.columnDef.sortingFn === "auto" ? column2.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column2.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column2.columnDef.sortingFn];
    };
    column2.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column2.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d4) => d4.id === column2.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d4) => d4.id === column2.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column2.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column2.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d4) => {
            if (d4.id === column2.id) {
              return {
                ...d4,
                desc: nextDesc
              };
            }
            return d4;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d4) => d4.id !== column2.id);
        } else {
          newSorting = [{
            id: column2.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column2.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column2.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column2.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column2.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column2.getFirstSortDir();
      const isSorted = column2.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column2.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column2.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column2.accessorFn;
    };
    column2.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column2.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column2.accessorFn;
    };
    column2.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d4) => d4.id === column2.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column2.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d4) => d4.id === column2.id)) != null ? _table$getState$sorti2 : -1;
    };
    column2.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d4) => d4.id !== column2.id) : []);
    };
    column2.getToggleSortingHandler = () => {
      const canSort = column2.getCanSort();
      return (e3) => {
        if (!canSort) return;
        e3.persist == null || e3.persist();
        column2.toggleSorting == null || column2.toggleSorting(void 0, column2.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e3) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
const builtInFeatures = [
  Headers,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  //depends on ColumnFaceting
  GlobalFiltering,
  //depends on ColumnFiltering
  RowSorting,
  ColumnGrouping,
  //depends on RowSorting
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(options) {
  var _options$_features, _options$initialState;
  const _features = [...builtInFeatures, ...(_options$_features = options._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions2 = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions2, options2);
    }
    return {
      ...defaultOptions2,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState2 = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState2 = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState2)) != null ? _feature$getInitialSt : initialState2;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions2,
      ...options
    },
    initialState: initialState2,
    _queue: (cb2) => {
      queued.push(cb2);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent2) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent2)) != null ? _table$options$getRow : `${parent2 ? [parent2.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id2, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id2];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id2];
        if (!row) {
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo$1(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo$1(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent2, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column2 = createColumn(table, columnDef, depth, parent2);
          const groupingColumnDef = columnDef;
          column2.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column2, depth + 1) : [];
          return column2;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns")),
    getAllFlatColumns: memo$1(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column2) => {
        return column2.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns")),
    _getAllFlatColumnsById: memo$1(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column2) => {
        acc[column2.id] = column2;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns")),
    getAllLeafColumns: memo$1(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column2) => column2.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns")),
    getColumn: (columnId) => {
      const column2 = table._getAllFlatColumnsById()[columnId];
      return column2;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo$1(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i2 = 0; i2 < originalRows.length; i2++) {
        const row = createRow$1(table, table._getRowId(originalRows[i2], i2, parentRow), originalRows[i2], i2, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i2], i2);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function getExpandedRowModel() {
  return (table) => memo$1(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {
    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {
      return rowModel;
    }
    if (!paginateExpandedRows) {
      return rowModel;
    }
    return expandRows(rowModel);
  }, getMemoOptions(table.options, "debugTable"));
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = (row) => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}
function getFacetedMinMaxValues() {
  return (table, columnId) => memo$1(() => {
    var _table$getColumn;
    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];
  }, (facetedRowModel) => {
    if (!facetedRowModel) return void 0;
    const uniqueValues = facetedRowModel.flatRows.flatMap((flatRow) => {
      var _flatRow$getUniqueVal;
      return (_flatRow$getUniqueVal = flatRow.getUniqueValues(columnId)) != null ? _flatRow$getUniqueVal : [];
    }).map(Number).filter((value) => !Number.isNaN(value));
    if (!uniqueValues.length) return;
    let facetedMinValue = uniqueValues[0];
    let facetedMaxValue = uniqueValues[uniqueValues.length - 1];
    for (const value of uniqueValues) {
      if (value < facetedMinValue) facetedMinValue = value;
      else if (value > facetedMaxValue) facetedMaxValue = value;
    }
    return [facetedMinValue, facetedMaxValue];
  }, getMemoOptions(table.options, "debugTable"));
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  var _table$options$maxLea;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i2 = 0; i2 < rowsToFilter2.length; i2++) {
      var _row$subRows;
      let row = rowsToFilter2[i2];
      const newRow = createRow$1(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  var _table$options$maxLea2;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i2 = 0; i2 < rowsToFilter2.length; i2++) {
      let row = rowsToFilter2[i2];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {
          const newRow = createRow$1(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFacetedRowModel() {
  return (table, columnId) => memo$1(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {
    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      return preRowModel;
    }
    const filterableIds = [...columnFilters.map((d4) => d4.id).filter((d4) => d4 !== columnId), globalFilter ? "__global__" : void 0].filter(Boolean);
    const filterRowsImpl = (row) => {
      for (let i2 = 0; i2 < filterableIds.length; i2++) {
        if (row.columnFilters[filterableIds[i2]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(preRowModel.rows, filterRowsImpl, table);
  }, getMemoOptions(table.options, "debugTable"));
}
function getFacetedUniqueValues() {
  return (table, columnId) => memo$1(() => {
    var _table$getColumn;
    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];
  }, (facetedRowModel) => {
    if (!facetedRowModel) return /* @__PURE__ */ new Map();
    let facetedUniqueValues = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < facetedRowModel.flatRows.length; i2++) {
      const values2 = facetedRowModel.flatRows[i2].getUniqueValues(columnId);
      for (let j = 0; j < values2.length; j++) {
        const value = values2[j];
        if (facetedUniqueValues.has(value)) {
          var _facetedUniqueValues$;
          facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);
        } else {
          facetedUniqueValues.set(value, 1);
        }
      }
    }
    return facetedUniqueValues;
  }, getMemoOptions(table.options, "debugTable"));
}
function getFilteredRowModel() {
  return (table) => memo$1(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i2 = 0; i2 < rowModel.flatRows.length; i2++) {
        rowModel.flatRows[i2].columnFilters = {};
        rowModel.flatRows[i2].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d4) => {
      var _filterFn$resolveFilt;
      const column2 = table.getColumn(d4.id);
      if (!column2) {
        return;
      }
      const filterFn = column2.getFilterFn();
      if (!filterFn) {
        return;
      }
      resolvedColumnFilters.push({
        id: d4.id,
        filterFn,
        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d4.value)) != null ? _filterFn$resolveFilt : d4.value
      });
    });
    const filterableIds = (columnFilters != null ? columnFilters : []).map((d4) => d4.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column2) => column2.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column2) => {
        var _globalFilterFn$resol;
        resolvedGlobalFilters.push({
          id: column2.id,
          filterFn: globalFilterFn,
          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j = 0; j < rowModel.flatRows.length; j++) {
      const row = rowModel.flatRows[j];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i2 = 0; i2 < resolvedColumnFilters.length; i2++) {
          currentColumnFilter = resolvedColumnFilters[i2];
          const id2 = currentColumnFilter.id;
          row.columnFilters[id2] = currentColumnFilter.filterFn(row, id2, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id2] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i2 = 0; i2 < resolvedGlobalFilters.length; i2++) {
          currentGlobalFilter = resolvedGlobalFilters[i2];
          const id2 = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id2, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id2] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i2 = 0; i2 < filterableIds.length; i2++) {
        if (row.columnFilters[filterableIds[i2]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, getMemoOptions(table.options, "debugTable", "getFilteredRowModel", () => table._autoResetPageIndex()));
}
function getGroupedRowModel() {
  return (table) => memo$1(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {
    if (!rowModel.rows.length || !grouping.length) {
      rowModel.rows.forEach((row) => {
        row.depth = 0;
        row.parentId = void 0;
      });
      return rowModel;
    }
    const existingGrouping = grouping.filter((columnId) => table.getColumn(columnId));
    const groupedFlatRows = [];
    const groupedRowsById = {};
    const groupUpRecursively = function(rows, depth, parentId) {
      if (depth === void 0) {
        depth = 0;
      }
      if (depth >= existingGrouping.length) {
        return rows.map((row) => {
          row.depth = depth;
          groupedFlatRows.push(row);
          groupedRowsById[row.id] = row;
          if (row.subRows) {
            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);
          }
          return row;
        });
      }
      const columnId = existingGrouping[depth];
      const rowGroupsMap = groupBy(rows, columnId);
      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {
        let [groupingValue, groupedRows2] = _ref;
        let id2 = `${columnId}:${groupingValue}`;
        id2 = parentId ? `${parentId}>${id2}` : id2;
        const subRows = groupUpRecursively(groupedRows2, depth + 1, id2);
        subRows.forEach((subRow) => {
          subRow.parentId = id2;
        });
        const leafRows = depth ? flattenBy(groupedRows2, (row2) => row2.subRows) : groupedRows2;
        const row = createRow$1(table, id2, leafRows[0].original, index, depth, void 0, parentId);
        Object.assign(row, {
          groupingColumnId: columnId,
          groupingValue,
          subRows,
          leafRows,
          getValue: (columnId2) => {
            if (existingGrouping.includes(columnId2)) {
              if (row._valuesCache.hasOwnProperty(columnId2)) {
                return row._valuesCache[columnId2];
              }
              if (groupedRows2[0]) {
                var _groupedRows$0$getVal;
                row._valuesCache[columnId2] = (_groupedRows$0$getVal = groupedRows2[0].getValue(columnId2)) != null ? _groupedRows$0$getVal : void 0;
              }
              return row._valuesCache[columnId2];
            }
            if (row._groupingValuesCache.hasOwnProperty(columnId2)) {
              return row._groupingValuesCache[columnId2];
            }
            const column2 = table.getColumn(columnId2);
            const aggregateFn = column2 == null ? void 0 : column2.getAggregationFn();
            if (aggregateFn) {
              row._groupingValuesCache[columnId2] = aggregateFn(columnId2, leafRows, groupedRows2);
              return row._groupingValuesCache[columnId2];
            }
          }
        });
        subRows.forEach((subRow) => {
          groupedFlatRows.push(subRow);
          groupedRowsById[subRow.id] = subRow;
        });
        return row;
      });
      return aggregatedGroupedRows;
    };
    const groupedRows = groupUpRecursively(rowModel.rows, 0);
    groupedRows.forEach((subRow) => {
      groupedFlatRows.push(subRow);
      groupedRowsById[subRow.id] = subRow;
    });
    return {
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById
    };
  }, getMemoOptions(table.options, "debugTable", "getGroupedRowModel", () => {
    table._queue(() => {
      table._autoResetExpanded();
      table._autoResetPageIndex();
    });
  }));
}
function groupBy(rows, columnId) {
  const groupMap = /* @__PURE__ */ new Map();
  return rows.reduce((map2, row) => {
    const resKey = `${row.getGroupingValue(columnId)}`;
    const previous = map2.get(resKey);
    if (!previous) {
      map2.set(resKey, [row]);
    } else {
      previous.push(row);
    }
    return map2;
  }, groupMap);
}
function getPaginationRowModel(opts) {
  return (table) => memo$1(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? void 0 : table.getState().expanded], (pagination, rowModel) => {
    if (!rowModel.rows.length) {
      return rowModel;
    }
    const {
      pageSize: pageSize2,
      pageIndex
    } = pagination;
    let {
      rows,
      flatRows,
      rowsById
    } = rowModel;
    const pageStart = pageSize2 * pageIndex;
    const pageEnd = pageStart + pageSize2;
    rows = rows.slice(pageStart, pageEnd);
    let paginatedRowModel;
    if (!table.options.paginateExpandedRows) {
      paginatedRowModel = expandRows({
        rows,
        flatRows,
        rowsById
      });
    } else {
      paginatedRowModel = {
        rows,
        flatRows,
        rowsById
      };
    }
    paginatedRowModel.flatRows = [];
    const handleRow = (row) => {
      paginatedRowModel.flatRows.push(row);
      if (row.subRows.length) {
        row.subRows.forEach(handleRow);
      }
    };
    paginatedRowModel.rows.forEach(handleRow);
    return paginatedRowModel;
  }, getMemoOptions(table.options, "debugTable"));
}
function getSortedRowModel() {
  return (table) => memo$1(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column2 = table.getColumn(sortEntry.id);
      if (!column2) return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column2.columnDef.sortUndefined,
        invertSorting: column2.columnDef.invertSorting,
        sortingFn: column2.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = rows.map((row) => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i2 = 0; i2 < availableSorting.length; i2 += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i2];
          const columnInfo = columnInfoById[sortEntry.id];
          const sortUndefined = columnInfo.sortUndefined;
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;
          if (sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === void 0;
            const bUndefined = bValue === void 0;
            if (aUndefined || bUndefined) {
              if (sortUndefined === "first") return aUndefined ? -1 : 1;
              if (sortUndefined === "last") return aUndefined ? 1 : -1;
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, getMemoOptions(table.options, "debugTable", "getSortedRowModel", () => table._autoResetPageIndex()));
}
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = reactExports.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = reactExports.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev2) => ({
    ...prev2,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}
/**
   * match-sorter-utils
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
const characterMap = {
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  Ấ: "A",
  Ắ: "A",
  Ẳ: "A",
  Ẵ: "A",
  Ặ: "A",
  Æ: "AE",
  Ầ: "A",
  Ằ: "A",
  Ȃ: "A",
  Ç: "C",
  Ḉ: "C",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  Ế: "E",
  Ḗ: "E",
  Ề: "E",
  Ḕ: "E",
  Ḝ: "E",
  Ȇ: "E",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  Ḯ: "I",
  Ȋ: "I",
  Ð: "D",
  Ñ: "N",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  Ố: "O",
  Ṍ: "O",
  Ṓ: "O",
  Ȏ: "O",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  Ý: "Y",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  ấ: "a",
  ắ: "a",
  ẳ: "a",
  ẵ: "a",
  ặ: "a",
  æ: "ae",
  ầ: "a",
  ằ: "a",
  ȃ: "a",
  ç: "c",
  ḉ: "c",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  ế: "e",
  ḗ: "e",
  ề: "e",
  ḕ: "e",
  ḝ: "e",
  ȇ: "e",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  ḯ: "i",
  ȋ: "i",
  ð: "d",
  ñ: "n",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  ố: "o",
  ṍ: "o",
  ṓ: "o",
  ȏ: "o",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  ý: "y",
  ÿ: "y",
  Ā: "A",
  ā: "a",
  Ă: "A",
  ă: "a",
  Ą: "A",
  ą: "a",
  Ć: "C",
  ć: "c",
  Ĉ: "C",
  ĉ: "c",
  Ċ: "C",
  ċ: "c",
  Č: "C",
  č: "c",
  C̆: "C",
  c̆: "c",
  Ď: "D",
  ď: "d",
  Đ: "D",
  đ: "d",
  Ē: "E",
  ē: "e",
  Ĕ: "E",
  ĕ: "e",
  Ė: "E",
  ė: "e",
  Ę: "E",
  ę: "e",
  Ě: "E",
  ě: "e",
  Ĝ: "G",
  Ǵ: "G",
  ĝ: "g",
  ǵ: "g",
  Ğ: "G",
  ğ: "g",
  Ġ: "G",
  ġ: "g",
  Ģ: "G",
  ģ: "g",
  Ĥ: "H",
  ĥ: "h",
  Ħ: "H",
  ħ: "h",
  Ḫ: "H",
  ḫ: "h",
  Ĩ: "I",
  ĩ: "i",
  Ī: "I",
  ī: "i",
  Ĭ: "I",
  ĭ: "i",
  Į: "I",
  į: "i",
  İ: "I",
  ı: "i",
  Ĳ: "IJ",
  ĳ: "ij",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  Ḱ: "K",
  ḱ: "k",
  K̆: "K",
  k̆: "k",
  Ĺ: "L",
  ĺ: "l",
  Ļ: "L",
  ļ: "l",
  Ľ: "L",
  ľ: "l",
  Ŀ: "L",
  ŀ: "l",
  Ł: "l",
  ł: "l",
  Ḿ: "M",
  ḿ: "m",
  M̆: "M",
  m̆: "m",
  Ń: "N",
  ń: "n",
  Ņ: "N",
  ņ: "n",
  Ň: "N",
  ň: "n",
  ŉ: "n",
  N̆: "N",
  n̆: "n",
  Ō: "O",
  ō: "o",
  Ŏ: "O",
  ŏ: "o",
  Ő: "O",
  ő: "o",
  Œ: "OE",
  œ: "oe",
  P̆: "P",
  p̆: "p",
  Ŕ: "R",
  ŕ: "r",
  Ŗ: "R",
  ŗ: "r",
  Ř: "R",
  ř: "r",
  R̆: "R",
  r̆: "r",
  Ȓ: "R",
  ȓ: "r",
  Ś: "S",
  ś: "s",
  Ŝ: "S",
  ŝ: "s",
  Ş: "S",
  Ș: "S",
  ș: "s",
  ş: "s",
  Š: "S",
  š: "s",
  Ţ: "T",
  ţ: "t",
  ț: "t",
  Ț: "T",
  Ť: "T",
  ť: "t",
  Ŧ: "T",
  ŧ: "t",
  T̆: "T",
  t̆: "t",
  Ũ: "U",
  ũ: "u",
  Ū: "U",
  ū: "u",
  Ŭ: "U",
  ŭ: "u",
  Ů: "U",
  ů: "u",
  Ű: "U",
  ű: "u",
  Ų: "U",
  ų: "u",
  Ȗ: "U",
  ȗ: "u",
  V̆: "V",
  v̆: "v",
  Ŵ: "W",
  ŵ: "w",
  Ẃ: "W",
  ẃ: "w",
  X̆: "X",
  x̆: "x",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Y̆: "Y",
  y̆: "y",
  Ź: "Z",
  ź: "z",
  Ż: "Z",
  ż: "z",
  Ž: "Z",
  ž: "z",
  ſ: "s",
  ƒ: "f",
  Ơ: "O",
  ơ: "o",
  Ư: "U",
  ư: "u",
  Ǎ: "A",
  ǎ: "a",
  Ǐ: "I",
  ǐ: "i",
  Ǒ: "O",
  ǒ: "o",
  Ǔ: "U",
  ǔ: "u",
  Ǖ: "U",
  ǖ: "u",
  Ǘ: "U",
  ǘ: "u",
  Ǚ: "U",
  ǚ: "u",
  Ǜ: "U",
  ǜ: "u",
  Ứ: "U",
  ứ: "u",
  Ṹ: "U",
  ṹ: "u",
  Ǻ: "A",
  ǻ: "a",
  Ǽ: "AE",
  ǽ: "ae",
  Ǿ: "O",
  ǿ: "o",
  Þ: "TH",
  þ: "th",
  Ṕ: "P",
  ṕ: "p",
  Ṥ: "S",
  ṥ: "s",
  X́: "X",
  x́: "x",
  Ѓ: "Г",
  ѓ: "г",
  Ќ: "К",
  ќ: "к",
  A̋: "A",
  a̋: "a",
  E̋: "E",
  e̋: "e",
  I̋: "I",
  i̋: "i",
  Ǹ: "N",
  ǹ: "n",
  Ồ: "O",
  ồ: "o",
  Ṑ: "O",
  ṑ: "o",
  Ừ: "U",
  ừ: "u",
  Ẁ: "W",
  ẁ: "w",
  Ỳ: "Y",
  ỳ: "y",
  Ȁ: "A",
  ȁ: "a",
  Ȅ: "E",
  ȅ: "e",
  Ȉ: "I",
  ȉ: "i",
  Ȍ: "O",
  ȍ: "o",
  Ȑ: "R",
  ȑ: "r",
  Ȕ: "U",
  ȕ: "u",
  B̌: "B",
  b̌: "b",
  Č̣: "C",
  č̣: "c",
  Ê̌: "E",
  ê̌: "e",
  F̌: "F",
  f̌: "f",
  Ǧ: "G",
  ǧ: "g",
  Ȟ: "H",
  ȟ: "h",
  J̌: "J",
  ǰ: "j",
  Ǩ: "K",
  ǩ: "k",
  M̌: "M",
  m̌: "m",
  P̌: "P",
  p̌: "p",
  Q̌: "Q",
  q̌: "q",
  Ř̩: "R",
  ř̩: "r",
  Ṧ: "S",
  ṧ: "s",
  V̌: "V",
  v̌: "v",
  W̌: "W",
  w̌: "w",
  X̌: "X",
  x̌: "x",
  Y̌: "Y",
  y̌: "y",
  A̧: "A",
  a̧: "a",
  B̧: "B",
  b̧: "b",
  Ḑ: "D",
  ḑ: "d",
  Ȩ: "E",
  ȩ: "e",
  Ɛ̧: "E",
  ɛ̧: "e",
  Ḩ: "H",
  ḩ: "h",
  I̧: "I",
  i̧: "i",
  Ɨ̧: "I",
  ɨ̧: "i",
  M̧: "M",
  m̧: "m",
  O̧: "O",
  o̧: "o",
  Q̧: "Q",
  q̧: "q",
  U̧: "U",
  u̧: "u",
  X̧: "X",
  x̧: "x",
  Z̧: "Z",
  z̧: "z"
};
const chars = Object.keys(characterMap).join("|");
const allAccents = new RegExp(chars, "g");
function removeAccents(str) {
  return str.replace(allAccents, (match2) => {
    return characterMap[match2];
  });
}
/**
 * @name match-sorter
 * @license MIT license.
 * @copyright (c) 2099 Kent C. Dodds
 * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
 */
const rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
function rankItem(item, value, options) {
  var _options$threshold;
  options = options || {};
  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;
  if (!options.accessors) {
    const rank = getMatchRanking(item, value, options);
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: item,
      rank,
      accessorIndex: -1,
      accessorThreshold: options.threshold,
      passed: rank >= options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item, options.accessors);
  const rankingInfo = {
    rankedValue: item,
    rank: rankings.NO_MATCH,
    accessorIndex: -1,
    accessorThreshold: options.threshold,
    passed: false
  };
  for (let i2 = 0; i2 < valuesToRank.length; i2++) {
    const rankValue = valuesToRank[i2];
    let newRank = getMatchRanking(rankValue.itemValue, value, options);
    const {
      minRanking,
      maxRanking,
      threshold = options.threshold
    } = rankValue.attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    newRank = Math.min(newRank, maxRanking);
    if (newRank >= threshold && newRank > rankingInfo.rank) {
      rankingInfo.rank = newRank;
      rankingInfo.passed = true;
      rankingInfo.accessorIndex = i2;
      rankingInfo.accessorThreshold = threshold;
      rankingInfo.rankedValue = rankValue.itemValue;
    }
  }
  return rankingInfo;
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  let acronym = "";
  const wordsInString = string.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string, index) {
    for (let j = index, J2 = string.length; j < J2; j++) {
      const stringChar = string[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i2 = 1, I3 = stringToRank.length; i2 < I3; i2++) {
    const matchChar = stringToRank[i2];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function compareItems(a3, b3) {
  return a3.rank === b3.rank ? 0 : a3.rank > b3.rank ? -1 : 1;
}
function prepareValueForComparison(value, _ref) {
  let {
    keepDiacritics
  } = _ref;
  value = `${value}`;
  if (!keepDiacritics) {
    value = removeAccents(value);
  }
  return value;
}
function getItemValues(item, accessor) {
  let accessorFn = accessor;
  if (typeof accessor === "object") {
    accessorFn = accessor.accessor;
  }
  const value = accessorFn(item);
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getAllValuesToRank(item, accessors) {
  const allValues = [];
  for (let j = 0, J2 = accessors.length; j < J2; j++) {
    const accessor = accessors[j];
    const attributes = getAccessorAttributes(accessor);
    const itemValues = getItemValues(item, accessor);
    for (let i2 = 0, I3 = itemValues.length; i2 < I3; i2++) {
      allValues.push({
        itemValue: itemValues[i2],
        attributes
      });
    }
  }
  return allValues;
}
const defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getAccessorAttributes(accessor) {
  if (typeof accessor === "function") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...accessor
  };
}
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = reactExports.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    reactExports.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.start(...args);
    });
  }
  stop(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.stop(...args);
    });
  }
  pulsate(...args) {
    this.mount().then(() => {
      var _a2;
      return (_a2 = this.ref.current) == null ? void 0 : _a2.pulsate(...args);
    });
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p2 = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p2.resolve = resolve;
  p2.reject = reject;
  return p2;
}
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this2;
    _this2 = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this2.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this2.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this2.state = {
      status: initialStatus
    };
    _this2.nextCallback = null;
    return _this2;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var _addClass = function addClass$12(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c3) {
    return addClass(node2, c3);
  });
};
var removeClass = function removeClass2(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c3) {
    return removeClass$1(node2, c3);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this2;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this2.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this2.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this2.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this2.removeClasses(node2, "exit");
      _this2.addClass(node2, appearing ? "appear" : "enter", "base");
      if (_this2.props.onEnter) {
        _this2.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this2.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this2.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this2.addClass(node2, type, "active");
      if (_this2.props.onEntering) {
        _this2.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this2.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this2.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this2.removeClasses(node2, type);
      _this2.addClass(node2, type, "done");
      if (_this2.props.onEntered) {
        _this2.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this2.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this2.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
      _this2.removeClasses(node2, "appear");
      _this2.removeClasses(node2, "enter");
      _this2.addClass(node2, "exit", "base");
      if (_this2.props.onExit) {
        _this2.props.onExit(maybeNode);
      }
    };
    _this2.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this2.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
      _this2.addClass(node2, "exit", "active");
      if (_this2.props.onExiting) {
        _this2.props.onExiting(maybeNode);
      }
    };
    _this2.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this2.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
      _this2.removeClasses(node2, "exit");
      _this2.addClass(node2, "exit", "done");
      if (_this2.props.onExited) {
        _this2.props.onExited(maybeNode);
      }
    };
    _this2.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this2.props.nodeRef ? [_this2.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this2.getClassNames = function(type) {
      var classNames2 = _this2.props.classNames;
      var isStringClassNames = typeof classNames2 === "string";
      var prefix2 = isStringClassNames && classNames2 ? classNames2 + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames2[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this2;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node2, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node2) forceReflow(node2);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node2, className);
    }
  };
  _proto.removeClasses = function removeClasses(node2, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node2, baseClassName);
    }
    if (activeClassName) {
      removeClass(node2, activeClassName);
    }
    if (doneClassName) {
      removeClass(node2, doneClassName);
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition, _extends$1({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c3) {
    return c3;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k3) {
    return obj[k3];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this2;
    _this2 = _React$Component.call(this, props, context) || this;
    var handleExited = _this2.handleExited.bind(_assertThisInitialized(_this2));
    _this2.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this2;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$1({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses$1("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme
}) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme
}) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className,
    ...other
  } = props;
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start2 = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event == null ? void 0 : event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = reactExports.useCallback((event, cb2) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, {
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  });
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass$1("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses$1("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const useUtilityClasses$1w = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses$1(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type,
    ...other
  } = props;
  const buttonRef = reactExports.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef$1(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback$1((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore) {
        ripple[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback$1((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback$1((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback$1((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef$1(ref, buttonRef);
  const ownerState = {
    ...props,
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  };
  const classes = useUtilityClasses$1w(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, {
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type,
    ...buttonProps,
    ...other,
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, {
      ref: handleRippleRef,
      center: centerRipple,
      ...TouchRippleProps
    }) : null]
  });
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass$1("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses$1("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const useUtilityClasses$1v = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize$1(color2)}`, edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size2)}`]
  };
  return composeClasses$1(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  }),
  variants: [{
    props: {
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2,
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${(theme.vars || theme).palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha((theme.vars || theme).palette[color2].main, theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme.vars || theme).palette.action.disabled
  }
})));
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    disableRipple = false,
    size: size2 = "medium",
    ...other
  } = props;
  const ownerState = {
    ...props,
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    disableRipple,
    size: size2
  };
  const classes = useUtilityClasses$1v(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, {
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    disableRipple,
    ref,
    ...other,
    ownerState,
    children
  });
});
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: style2.transitionDuration ?? (typeof timeout === "number" ? timeout : timeout[options.mode] || 0),
    easing: style2.transitionTimingFunction ?? (typeof easing2 === "object" ? easing2[options.mode] : easing2),
    delay: style2.transitionDelay
  };
}
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$3 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(nodeRef, getReactNodeRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout,
    ...other,
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        style: {
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0,
          ...styles$3[state],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...childProps
      });
    }
  });
});
if (Grow) {
  Grow.muiSupportAuto = true;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement2(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$2(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$2(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property2) {
        style3[property2] = "";
        return style3;
      }, {});
      if (!isHTMLElement$2(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round$2 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$2(element)) {
    scaleX = element.offsetWidth > 0 ? round$2(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$2(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement2(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x3 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y4 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y4,
    right: x3 + width2,
    bottom: y4 + height2,
    left: x3,
    x: x3,
    y: y4
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains$1(parent2, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent2.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent2.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$2(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE3 = /Trident/i.test(getUAString());
  if (isIE3 && isHTMLElement$2(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$2(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max(min$12, min(value, max$12));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x3 = _ref.x, y4 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$2(x3 * dpr) / dpr || 0,
    y: round$2(y4 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x3,
    y: y4
  }) : {
    x: x3,
    y: y4
  };
  x3 = _ref3.x;
  y4 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y4 -= offsetY - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x3 -= offsetX - popperRect.width;
      x3 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x3,
    y: y4
  }, getWindow(popper2)) : {
    x: x3,
    y: y4
  };
  x3 = _ref4.x;
  y4 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y4 + "px)" : "translate3d(" + x3 + "px, " + y4 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft2 = win.pageXOffset;
  var scrollTop2 = win.pageYOffset;
  return {
    scrollLeft: scrollLeft2,
    scrollTop: scrollTop2
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x3 = 0;
  var y4 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x3 + getWindowScrollBarX(element),
    y: y4
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y4 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x3 += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x3,
    y: y4
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$2(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$2(element) ? getOffsetParent(element) : element;
  if (!isElement2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement2(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b3) {
    return overflows[a3] - overflows[b3];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i3) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i3).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
      var _ret = _loop(_i2);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x3 = _data$state$placement.x, y4 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x3;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement$2(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$2(rect.width) / element.offsetWidth || 1;
  var scaleY = round$2(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$2(offsetParent);
  var offsetParentIsScaled = isHTMLElement$2(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$2(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m4) {
          return m4.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef$1(getReactNodeRef(children), forwardedRef);
  useEnhancedEffect$1(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$1(() => {
    if (mountNode && !disablePortal) {
      setRef$1(forwardedRef, mountNode);
      return () => {
        setRef$1(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
function getPopperUtilityClass(slot) {
  return generateUtilityClass$1("MuiPopper", slot);
}
generateUtilityClasses$1("MuiPopper", ["root"]);
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement$1(element) {
  return element.nodeType !== void 0;
}
const useUtilityClasses$1u = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getPopperUtilityClass, classes);
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps,
    // @ts-ignore internal logic
    ownerState: ownerStateProp,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...other
  } = props;
  const tooltipRef = reactExports.useRef(null);
  const ownRef = useForkRef$1(tooltipRef, forwardedRef);
  const popperRef = reactExports.useRef(null);
  const handlePopperRef = useForkRef$1(popperRef, popperRefProp);
  const handlePopperRefRef = reactExports.useRef(handlePopperRef);
  useEnhancedEffect$1(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = reactExports.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl$1(anchorEl));
  reactExports.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  reactExports.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect$1(() => {
    if (!resolvedAnchorElement || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, {
      placement: rtlPlacement,
      ...popperOptions,
      modifiers: popperModifiers
    });
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$1u(props);
  const Root = slots.root ?? "div";
  const rootProps = useSlotProps$1({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, {
    ...rootProps,
    children: typeof children === "function" ? children(childProps) : children
  });
});
const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(function Popper2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false,
    slotProps = {},
    slots = {},
    ...other
  } = props;
  const [exited, setExited] = reactExports.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    container = resolvedAnchorEl && isHTMLElement$1(resolvedAnchorEl) ? ownerDocument$1(resolvedAnchorEl).body : ownerDocument$1(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, {
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots,
      ...other,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display,
        ...style2
      },
      TransitionProps: transitionProps,
      children
    })
  });
});
const PopperRoot = styled(Popper$1, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper22(inProps, ref) {
  const isRtl = useRtl();
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopper"
  });
  const {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps,
    ...other
  } = props;
  const RootComponent = (slots == null ? void 0 : slots.root) ?? (components == null ? void 0 : components.Root);
  const otherProps = {
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    ...other
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, {
    as: component,
    direction: isRtl ? "rtl" : "ltr",
    slots: {
      root: RootComponent
    },
    slotProps: slotProps ?? componentsProps,
    ...otherProps,
    ref
  });
});
function getTooltipUtilityClass(slot) {
  return generateUtilityClass$1("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses$1("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function round$1(value) {
  return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses$1t = (ownerState) => {
  const {
    classes,
    disableInteractive,
    arrow: arrow2,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
    tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize$1(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses$1(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled(Popper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(memoTheme(({
  theme
}) => ({
  zIndex: (theme.vars || theme).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open
    }) => !open,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
})));
const TooltipTooltip = styled("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize$1(ownerState.placement.split("-")[0])}`]];
  }
})(memoTheme(({
  theme
}) => ({
  backgroundColor: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.92),
  borderRadius: (theme.vars || theme).shape.borderRadius,
  color: (theme.vars || theme).palette.common.white,
  fontFamily: theme.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme.typography.fontWeightMedium,
  [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      padding: "8px 16px",
      fontSize: theme.typography.pxToRem(14),
      lineHeight: `${round$1(16 / 14)}em`,
      fontWeight: theme.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
})));
const TooltipArrow = styled("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (props, styles2) => styles2.arrow
})(memoTheme(({
  theme
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme.vars ? theme.vars.palette.Tooltip.bg : alpha(theme.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let hystersisOpen = false;
const hystersisTimer = new Timeout();
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler) {
  return (event, ...params) => {
    if (eventHandler) {
      eventHandler(event, ...params);
    }
    handler(event, ...params);
  };
}
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(function Tooltip2(inProps, ref) {
  var _a2, _b2, _c2;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const {
    arrow: arrow2 = false,
    children: childrenProp,
    classes: classesProp,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title,
    TransitionComponent: TransitionComponentProp = Grow,
    TransitionProps,
    ...other
  } = props;
  const children = /* @__PURE__ */ reactExports.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    children: childrenProp
  });
  const theme = useTheme();
  const isRtl = useRtl();
  const [childNode, setChildNode] = reactExports.useState();
  const [arrowRef, setArrowRef] = reactExports.useState(null);
  const ignoreNonTouchEvents = reactExports.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = useTimeout();
  const enterTimer = useTimeout();
  const leaveTimer = useTimeout();
  const touchTimer = useTimeout();
  const [openState, setOpenState] = useControlled$1({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open = openState;
  const id2 = useId$1(idProp);
  const prevUserSelect = reactExports.useRef();
  const stopTouchInteraction = useEventCallback$1(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    touchTimer.clear();
  });
  reactExports.useEffect(() => stopTouchInteraction, [stopTouchInteraction]);
  const handleOpen = (event) => {
    hystersisTimer.clear();
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open) {
      onOpen(event);
    }
  };
  const handleClose = useEventCallback$1(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      hystersisTimer.start(800 + leaveDelay, () => {
        hystersisOpen = false;
      });
      setOpenState(false);
      if (onClose && open) {
        onClose(event);
      }
      closeTimer.start(theme.transitions.duration.shortest, () => {
        ignoreNonTouchEvents.current = false;
      });
    }
  );
  const handleMouseOver = (event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    enterTimer.clear();
    leaveTimer.clear();
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.start(hystersisOpen ? enterNextDelay : enterDelay, () => {
        handleOpen(event);
      });
    } else {
      handleOpen(event);
    }
  };
  const handleMouseLeave = (event) => {
    enterTimer.clear();
    leaveTimer.start(leaveDelay, () => {
      handleClose(event);
    });
  };
  const [, setChildIsFocusVisible] = reactExports.useState(false);
  const handleBlur = (event) => {
    if (!isFocusVisible(event.target)) {
      setChildIsFocusVisible(false);
      handleMouseLeave(event);
    }
  };
  const handleFocus = (event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    if (isFocusVisible(event.target)) {
      setChildIsFocusVisible(true);
      handleMouseOver(event);
    }
  };
  const detectTouchStart = (event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  };
  const handleTouchStart = (event) => {
    detectTouchStart(event);
    leaveTimer.clear();
    closeTimer.clear();
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.start(enterTouchDelay, () => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleMouseOver(event);
    });
  };
  const handleTouchEnd = (event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    leaveTimer.start(leaveTouchDelay, () => {
      handleClose(event);
    });
  };
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (nativeEvent.key === "Escape") {
        handleClose(nativeEvent);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleClose, open]);
  const handleRef = useForkRef$1(getReactNodeRef(children), setChildNode, ref);
  if (!title && title !== 0) {
    open = false;
  }
  const popperRef = reactExports.useRef();
  const handleMouseMove = (event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  };
  const nameOrDescProps = {};
  const titleIsString = typeof title === "string";
  if (describeChild) {
    nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps["aria-describedby"] = open ? id2 : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title : null;
    nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id2 : null;
  }
  const childrenProps = {
    ...nameOrDescProps,
    ...other,
    ...children.props,
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef,
    ...followCursor ? {
      onMouseMove: handleMouseMove
    } : {}
  };
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }
  const popperOptions = reactExports.useMemo(() => {
    var _a3;
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if ((_a3 = PopperProps.popperOptions) == null ? void 0 : _a3.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    return {
      ...PopperProps.popperOptions,
      modifiers: tooltipModifiers
    };
  }, [arrowRef, PopperProps]);
  const ownerState = {
    ...props,
    isRtl,
    arrow: arrow2,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  };
  const classes = useUtilityClasses$1t(ownerState);
  const PopperComponent = slots.popper ?? components.Popper ?? TooltipPopper;
  const TransitionComponent = slots.transition ?? components.Transition ?? TransitionComponentProp ?? Grow;
  const TooltipComponent = slots.tooltip ?? components.Tooltip ?? TooltipTooltip;
  const ArrowComponent = slots.arrow ?? components.Arrow ?? TooltipArrow;
  const popperProps = appendOwnerState$1(PopperComponent, {
    ...PopperProps,
    ...slotProps.popper ?? componentsProps.popper,
    className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_a2 = slotProps.popper ?? componentsProps.popper) == null ? void 0 : _a2.className)
  }, ownerState);
  const transitionProps = appendOwnerState$1(TransitionComponent, {
    ...TransitionProps,
    ...slotProps.transition ?? componentsProps.transition
  }, ownerState);
  const tooltipProps = appendOwnerState$1(TooltipComponent, {
    ...slotProps.tooltip ?? componentsProps.tooltip,
    className: clsx(classes.tooltip, (_b2 = slotProps.tooltip ?? componentsProps.tooltip) == null ? void 0 : _b2.className)
  }, ownerState);
  const tooltipArrowProps = appendOwnerState$1(ArrowComponent, {
    ...slotProps.arrow ?? componentsProps.arrow,
    className: clsx(classes.arrow, (_c2 = slotProps.arrow ?? componentsProps.arrow) == null ? void 0 : _c2.className)
  }, ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ reactExports.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperComponent, {
      as: PopperComponentProp ?? Popper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open : false,
      id: id2,
      transition: true,
      ...interactiveWrapperListeners,
      ...popperProps,
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
        timeout: theme.transitions.duration.shorter,
        ...TransitionPropsInner,
        ...transitionProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipComponent, {
          ...tooltipProps,
          children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowComponent, {
            ...tooltipArrowProps,
            ref: setArrowRef
          }) : null]
        })
      })
    })]
  });
});
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
function toUnitless(length2) {
  return parseFloat(length2);
}
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
const boxClasses = generateUtilityClasses$1("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator$1.generate
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass$1("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses$1("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useUtilityClasses$1s = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size: size2,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize$1(color2)}`, `size${capitalize$1(size2)}`, `${variant}Size${capitalize$1(size2)}`, `color${capitalize$1(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["icon", "startIcon", `iconSize${capitalize$1(size2)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize$1(size2)}`]
  };
  const composedClasses = composeClasses$1(slots, getButtonUtilityClass, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...composedClasses
  };
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color)}`], styles2[`size${capitalize$1(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize$1(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(memoTheme(({
  theme
}) => {
  var _a2, _b2;
  const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
  return {
    ...theme.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme.vars || theme).shadows[2],
        "&:hover": {
          boxShadow: (theme.vars || theme).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme.vars || theme).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme.vars || theme).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main && palette.dark && palette.contrastText).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedColor": (theme.vars || theme).palette[color2].main,
        "--variant-outlinedBorder": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.5)` : alpha(theme.palette[color2].main, 0.5),
        "--variant-containedColor": (theme.vars || theme).palette[color2].contrastText,
        "--variant-containedBg": (theme.vars || theme).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme.vars || theme).palette[color2].dark,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme.vars || theme).palette[color2].main,
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        "--variant-containedColor": theme.vars ? (
          // this is safe because grey does not change between default light/dark mode
          theme.vars.palette.text.primary
        ) : (_b2 = (_a2 = theme.palette).getContrastText) == null ? void 0 : _b2.call(_a2, inheritContainedBackgroundColor),
        "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
            "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }]
  };
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, ...commonIconStyles]
});
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, ...commonIconStyles]
});
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size: size2 = "medium",
    startIcon: startIconProp,
    type,
    variant = "text",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size: size2,
    type,
    variant
  };
  const classes = useUtilityClasses$1s(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, {
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type,
    ...other,
    classes,
    children: [startIcon, children, endIcon]
  });
});
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass$1("MuiCircularProgress", slot);
}
generateUtilityClasses$1("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$1r = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize$1(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize$1(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses$1(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (props, styles2) => styles2.svg
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize$1(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size: size2 = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    disableShrink,
    size: size2,
    thickness,
    value,
    variant
  };
  const classes = useUtilityClasses$1r(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, {
    className: clsx(classes.root, className),
    style: {
      width: size2,
      height: size2,
      ...rootStyle,
      ...style2
    },
    ownerState,
    ref,
    role: "progressbar",
    ...rootProps,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  });
});
const ListContext = /* @__PURE__ */ reactExports.createContext({});
function getListUtilityClass(slot) {
  return generateUtilityClass$1("MuiList", slot);
}
generateUtilityClasses$1("MuiList", ["root", "padding", "dense", "subheader"]);
const useUtilityClasses$1q = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses$1(slots, getListUtilityClass, classes);
};
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.subheader,
    style: {
      paddingTop: 0
    }
  }]
});
const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader,
    ...other
  } = props;
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = {
    ...props,
    component,
    dense,
    disablePadding
  };
  const classes = useUtilityClasses$1q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, {
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState,
      ...other,
      children: [subheader, children]
    })
  });
});
function nextItem$1(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text2 = nextFocus.innerText;
  if (text2 === void 0) {
    text2 = nextFocus.textContent;
  }
  text2 = text2.trim().toLowerCase();
  if (text2.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text2[0] === textCriteria.keys[0];
  }
  return text2.startsWith(textCriteria.keys.join(""));
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu",
    ...other
  } = props;
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument$1(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown = (event) => {
    const list = listRef.current;
    const key = event.key;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (isModifierKeyPressed) {
      if (onKeyDown) {
        onKeyDown(event);
      }
      return;
    }
    const currentFocus = ownerDocument$1(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef$1(listRef, ref);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index) => {
    if (index === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List, {
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1,
    ...other,
    children: items
  });
});
function isHostComponent$1(element) {
  return typeof element === "string";
}
function isOverflowing(container) {
  const doc = ownerDocument$1(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument$1(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument$1(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument$1(container).body;
    } else {
      const parent2 = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent2 == null ? void 0 : parent2.nodeName) === "HTML" && containerWindow.getComputedStyle(parent2).overflowY === "scroll" ? parent2 : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property: property2
    }) => {
      if (value) {
        el2.style.setProperty(property2, value);
      } else {
        el2.style.removeProperty(property2);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i2) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i2,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a3, b3) => a3.tabIndex === b3.tabIndex ? a3.documentOrder - b3.documentOrder : a3.tabIndex - b3.tabIndex).map((a3) => a3.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(getReactNodeRef(children), rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument$1(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument$1(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      var _a2, _b2;
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        const isShiftTab = Boolean(((_a2 = lastKeydown.current) == null ? void 0 : _a2.shiftKey) && ((_b2 = lastKeydown.current) == null ? void 0 : _b2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function useSlot(name, parameters) {
  const {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    getSlotOwnerState,
    internalForwardedProps,
    ...useSlotPropsParams
  } = parameters;
  const {
    component: rootComponent,
    slots = {
      [name]: void 0
    },
    slotProps = {
      [name]: void 0
    },
    ...other
  } = externalForwardedProps;
  const elementType = slots[name] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps$1(slotProps[name], ownerState);
  const {
    props: {
      component: slotComponent,
      ...mergedProps
    },
    internalRef
  } = mergeSlotProps$1({
    className,
    ...useSlotPropsParams,
    externalForwardedProps: name === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef$1(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
  const slotOwnerState = getSlotOwnerState ? getSlotOwnerState(mergedProps) : {};
  const finalOwnerState = {
    ...ownerState,
    ...slotOwnerState
  };
  const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState$1(elementType, {
    ...name === "root" && !rootComponent && !slots[name] && internalForwardedProps,
    ...name !== "root" && !slots[name] && internalForwardedProps,
    ...mergedProps,
    ...LeafComponent && {
      as: LeafComponent
    },
    ref
  }, finalOwnerState);
  Object.keys(slotOwnerState).forEach((propName) => {
    delete props[propName];
  });
  return [elementType, props];
}
const styles$2 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(nodeRef, getReactNodeRef(children), ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout,
    ...other,
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        style: {
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0,
          ...styles$2[state],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...childProps
      });
    }
  });
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass$1("MuiBackdrop", slot);
}
generateUtilityClasses$1("MuiBackdrop", ["root", "invisible"]);
const useUtilityClasses$1p = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses$1(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: true
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
});
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    invisible = false,
    open,
    components = {},
    componentsProps = {},
    slotProps = {},
    slots = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    invisible
  };
  const classes = useUtilityClasses$1p(ownerState);
  const backwardCompatibleSlots = {
    transition: TransitionComponentProp,
    root: components.Root,
    ...slots
  };
  const backwardCompatibleSlotProps = {
    ...componentsProps,
    ...slotProps
  };
  const externalForwardedProps = {
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BackdropRoot,
    externalForwardedProps,
    className: clsx(classes.root, className),
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState
  });
  delete transitionProps.ownerState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
    in: open,
    timeout: transitionDuration,
    ...other,
    ...transitionProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
      "aria-hidden": true,
      ...rootProps,
      classes,
      ref,
      children
    })
  });
});
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager: manager2 = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument$1(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager2.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback$1(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager2.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager2.isTopModal(getModal()), [manager2]);
  const handlePortalRef = useEventCallback$1((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager2.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager2]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onClick) == null ? void 0 : _a2.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers$1(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = {
      ...propsEventHandlers,
      ...otherHandlers
    };
    return {
      role: "presentation",
      ...externalEventHandlers,
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    };
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return {
      "aria-hidden": true,
      ...externalEventHandlers,
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    };
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass$1("MuiModal", slot);
}
generateUtilityClasses$1("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$1o = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses$1(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(memoTheme(({
  theme
}) => ({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.open && ownerState.exited,
    style: {
      visibility: "hidden"
    }
  }]
})));
const ModalBackdrop = styled(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    onClose,
    onTransitionEnter,
    onTransitionExited,
    open,
    slotProps = {},
    slots = {},
    // eslint-disable-next-line react/prop-types
    theme,
    ...other
  } = props;
  const propsWithDefaults = {
    ...props,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  };
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal({
    ...propsWithDefaults,
    rootRef: ref
  });
  const ownerState = {
    ...propsWithDefaults,
    exited
  };
  const classes = useUtilityClasses$1o(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const externalForwardedProps = {
    slots: {
      root: components.Root,
      backdrop: components.Backdrop,
      ...slots
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: ModalRoot,
    externalForwardedProps,
    getSlotProps: getRootProps,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const [BackdropSlot, backdropProps] = useSlot("backdrop", {
    elementType: BackdropComponent,
    externalForwardedProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps({
        ...otherHandlers,
        onClick: (e3) => {
          if (onBackdropClick) {
            onBackdropClick(e3);
          }
          if (otherHandlers == null ? void 0 : otherHandlers.onClick) {
            otherHandlers.onClick(e3);
          }
        }
      });
    },
    className: clsx(BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  const backdropRef = useForkRef$1(BackdropProps == null ? void 0 : BackdropProps.ref, backdropProps.ref);
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
      ...rootProps,
      ...other,
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, {
        ...backdropProps,
        ref: backdropRef
      }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    })
  });
});
function getPaperUtilityClass(slot) {
  return generateUtilityClass$1("MuiPaper", slot);
}
generateUtilityClasses$1("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const useUtilityClasses$1n = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses$1(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(memoTheme(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  color: (theme.vars || theme).palette.text.primary,
  transition: theme.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.square,
    style: {
      borderRadius: theme.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(theme.vars || theme).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
})));
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  var _a2;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const theme = useTheme();
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    elevation,
    square,
    variant
  };
  const classes = useUtilityClasses$1n(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, {
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref,
    ...other,
    style: {
      ...variant === "elevation" && {
        "--Paper-shadow": (theme.vars || theme).shadows[elevation],
        ...theme.vars && {
          "--Paper-overlay": (_a2 = theme.vars.overlays) == null ? void 0 : _a2[elevation]
        },
        ...!theme.vars && theme.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
        }
      },
      ...other.style
    }
  });
});
function getPopoverUtilityClass(slot) {
  return generateUtilityClass$1("MuiPopover", slot);
}
generateUtilityClasses$1("MuiPopover", ["root", "paper"]);
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$1m = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses$1(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled(Modal, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled(Paper, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots = {},
    slotProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering,
      ...TransitionProps
    } = {},
    disableScrollLock = false,
    ...other
  } = props;
  const externalPaperSlotProps = (slotProps == null ? void 0 : slotProps.paper) ?? PaperPropsProp;
  const paperRef = reactExports.useRef();
  const ownerState = {
    ...props,
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  };
  const classes = useUtilityClasses$1m(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument$1(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce$2(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument$1(resolveAnchorEl(anchorEl)).body : void 0);
  const externalForwardedProps = {
    slots,
    slotProps: {
      ...slotProps,
      paper: externalPaperSlotProps
    }
  };
  const [PaperSlot, paperProps] = useSlot("paper", {
    elementType: PopoverPaper,
    externalForwardedProps,
    additionalProps: {
      elevation,
      className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className),
      style: isPositioned ? externalPaperSlotProps.style : {
        ...externalPaperSlotProps.style,
        opacity: 0
      }
    },
    ownerState
  });
  const [RootSlot, {
    slotProps: rootSlotPropsProp,
    ...rootProps
  }] = useSlot("root", {
    elementType: PopoverRoot,
    externalForwardedProps,
    additionalProps: {
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  });
  const handlePaperRef = useForkRef$1(paperRef, paperProps.ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
    ...rootProps,
    ...!isHostComponent$1(RootSlot) && {
      slotProps: rootSlotPropsProp,
      disableScrollLock
    },
    ...other,
    ref,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration,
      ...TransitionProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, {
        ...paperProps,
        ref: handlePaperRef,
        children
      })
    })
  });
});
function getMenuUtilityClass(slot) {
  return generateUtilityClass$1("MuiMenu", slot);
}
generateUtilityClasses$1("MuiMenu", ["root", "paper", "list"]);
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$1l = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses$1(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering,
      ...TransitionProps
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {},
    ...other
  } = props;
  const isRtl = useRtl();
  const ownerState = {
    ...props,
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  };
  const classes = useUtilityClasses$1l(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  const PaperSlot = slots.paper ?? MenuPaper;
  const paperExternalSlotProps = slotProps.paper ?? PaperProps;
  const rootSlotProps = useSlotProps$1({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const paperSlotProps = useSlotProps$1({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, {
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open,
    ref,
    transitionDuration,
    TransitionProps: {
      onEntering: handleEntering,
      ...TransitionProps
    },
    ownerState,
    ...other,
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, {
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant,
      ...MenuListProps,
      className: clsx(classes.list, MenuListProps.className),
      children
    })
  });
});
function getListItemIconUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemIcon", slot);
}
const listItemIconClasses = generateUtilityClasses$1("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const useUtilityClasses$1k = (ownerState) => {
  const {
    alignItems,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses$1(slots, getListItemIconUtilityClass, classes);
};
const ListItemIconRoot = styled("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(memoTheme(({
  theme
}) => ({
  minWidth: 56,
  color: (theme.vars || theme).palette.action.active,
  flexShrink: 0,
  display: "inline-flex",
  variants: [{
    props: {
      alignItems: "flex-start"
    },
    style: {
      marginTop: 8
    }
  }]
})));
const ListItemIcon = /* @__PURE__ */ reactExports.forwardRef(function ListItemIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemIcon"
  });
  const {
    className,
    ...other
  } = props;
  const context = reactExports.useContext(ListContext);
  const ownerState = {
    ...props,
    alignItems: context.alignItems
  };
  const classes = useUtilityClasses$1k(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIconRoot, {
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other
  });
});
function getDividerUtilityClass(slot) {
  return generateUtilityClass$1("MuiDivider", slot);
}
const dividerClasses = generateUtilityClasses$1("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const useUtilityClasses$1j = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses$1(slots, getDividerUtilityClass, classes);
};
const DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(memoTheme(({
  theme
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme.vars || theme).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: true
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: true
    },
    style: {
      borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha(theme.palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: theme.spacing(2),
      marginRight: theme.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: theme.spacing(1),
      marginBottom: theme.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: true
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.children,
    style: {
      display: "flex",
      whiteSpace: "nowrap",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.children && ownerState.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(theme.vars || theme).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.orientation === "vertical" && ownerState.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
})));
const DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme.spacing(1)} * 1.2)`,
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${theme.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${theme.spacing(1)} * 1.2)`
    }
  }]
})));
const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDivider"
  });
  const {
    absolute = false,
    children,
    className,
    orientation = "horizontal",
    component = children || orientation === "vertical" ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    role = component !== "hr" ? "separator" : void 0,
    textAlign = "center",
    variant = "fullWidth",
    ...other
  } = props;
  const ownerState = {
    ...props,
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign,
    variant
  };
  const classes = useUtilityClasses$1j(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, {
    as: component,
    className: clsx(classes.root, className),
    role,
    ref,
    ownerState,
    "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0,
    ...other,
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  });
});
if (Divider) {
  Divider.muiSkipListHighlight = true;
}
function getTypographyUtilityClass(slot) {
  return generateUtilityClass$1("MuiTypography", slot);
}
generateUtilityClasses$1("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const extendSxProp = internal_createExtendSxProp();
const useUtilityClasses$1i = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize$1(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses$1(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(memoTheme(({
  theme
}) => {
  var _a2;
  return {
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
      props: {
        variant
      },
      style: value
    })), ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme.vars || theme).palette[color2].main
      }
    })), ...Object.entries(((_a2 = theme.palette) == null ? void 0 : _a2.text) || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
      props: {
        color: `text${capitalize$1(color2)}`
      },
      style: {
        color: (theme.vars || theme).palette.text[color2]
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  };
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const {
    color: color2,
    ...themeProps
  } = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const isSxColor = !v6Colors[color2];
  const props = extendSxProp({
    ...themeProps,
    ...isSxColor && {
      color: color2
    }
  });
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping,
    ...other
  } = props;
  const ownerState = {
    ...props,
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  };
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$1i(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, {
    as: Component,
    ref,
    className: clsx(classes.root, className),
    ...other,
    ownerState,
    style: {
      ...align !== "inherit" && {
        "--Typography-textAlign": align
      },
      ...other.style
    }
  });
});
const listItemTextClasses = generateUtilityClasses$1("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass$1("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses$1("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const overridesResolver$4 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$1h = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses$1(slots, getMenuItemUtilityClass, classes);
  return {
    ...classes,
    ...composedClasses
  };
};
const MenuItemRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: overridesResolver$4
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body1,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap",
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    [`&.${menuItemClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses.selected}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${menuItemClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses.root}`]: {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  },
  [`& + .${dividerClasses.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses.root}`]: {
    minWidth: 36
  },
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dense,
    style: {
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.dense,
    style: {
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4,
      ...theme.typography.body2,
      [`& .${listItemIconClasses.root} svg`]: {
        fontSize: "1.25rem"
      }
    }
  }]
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className,
    ...other
  } = props;
  const context = reactExports.useContext(ListContext);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = {
    ...props,
    dense: childContext.dense,
    divider,
    disableGutters
  };
  const classes = useUtilityClasses$1h(props);
  const handleRef = useForkRef$1(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, {
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className),
      ...other,
      ownerState,
      classes
    })
  });
});
const Stack = createStack({
  createStyledComponent: styled("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  }),
  useThemeProps: (inProps) => useThemeProps({
    props: inProps,
    name: "MuiStack"
  })
});
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useFormControl() {
  return reactExports.useContext(FormControlContext);
}
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass$1("PrivateSwitchBase", slot);
}
generateUtilityClasses$1("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const useUtilityClasses$1g = (ownerState) => {
  const {
    classes,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize$1(edge)}`],
    input: ["input"]
  };
  return composeClasses$1(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled(ButtonBase)({
  padding: 9,
  borderRadius: "50%",
  variants: [{
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: ({
      edge,
      ownerState
    }) => edge === "start" && ownerState.size !== "small",
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }, {
    props: ({
      edge,
      ownerState
    }) => edge === "end" && ownerState.size !== "small",
    style: {
      marginRight: -12
    }
  }]
});
const SwitchBaseInput = styled("input", {
  shouldForwardProp: rootShouldForwardProp
})({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref) {
  const {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    className,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id: id2,
    inputProps,
    inputRef,
    name,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required = false,
    tabIndex,
    type,
    value,
    ...other
  } = props;
  const [checked, setCheckedState] = useControlled$1({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };
  const handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  };
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type === "checkbox" || type === "radio";
  const ownerState = {
    ...props,
    checked,
    disabled,
    disableFocusRipple,
    edge
  };
  const classes = useUtilityClasses$1g(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, {
    component: "span",
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    tabIndex: null,
    role: void 0,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ownerState,
    ref,
    ...other,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, {
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      className: classes.input,
      disabled,
      id: hasLabelFor ? id2 : void 0,
      name,
      onChange: handleInputChange,
      readOnly,
      ref: inputRef,
      required,
      ownerState,
      tabIndex,
      type,
      ...type === "checkbox" && value === void 0 ? {} : {
        value
      },
      ...inputProps
    }), checked ? checkedIcon : icon]
  });
});
const CheckBoxOutlineBlankIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank");
const CheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox");
const IndeterminateCheckBoxIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass$1("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses$1("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
const useUtilityClasses$1f = (ownerState) => {
  const {
    classes,
    indeterminate,
    color: color2,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize$1(color2)}`, `size${capitalize$1(size2)}`]
  };
  const composedClasses = composeClasses$1(slots, getCheckboxUtilityClass, classes);
  return {
    ...classes,
    // forward the disabled and checked classes to the SwitchBase
    ...composedClasses
  };
};
const CheckboxRoot = styled(SwitchBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, styles2[`size${capitalize$1(ownerState.size)}`], ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  variants: [{
    props: {
      color: "default",
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2,
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
        color: (theme.vars || theme).palette[color2].main
      },
      [`&.${checkboxClasses.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: false
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
const defaultCheckedIcon$1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon$1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(function Checkbox2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const {
    checkedIcon = defaultCheckedIcon$1,
    color: color2 = "primary",
    icon: iconProp = defaultIcon$1,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size: size2 = "medium",
    disableRipple = false,
    className,
    ...other
  } = props;
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = {
    ...props,
    disableRipple,
    color: color2,
    indeterminate,
    size: size2
  };
  const classes = useUtilityClasses$1f(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxRoot, {
    type: "checkbox",
    inputProps: {
      "data-indeterminate": indeterminate,
      ...inputProps
    },
    icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
      fontSize: icon.props.fontSize ?? size2
    }),
    checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
      fontSize: indeterminateIcon.props.fontSize ?? size2
    }),
    ownerState,
    ref,
    className: clsx(classes.root, className),
    ...other,
    classes
  });
});
const RadioButtonUncheckedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "RadioButtonUnchecked");
const RadioButtonCheckedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
}), "RadioButtonChecked");
const RadioButtonIconRoot = styled("span", {
  shouldForwardProp: rootShouldForwardProp
})({
  position: "relative",
  display: "flex"
});
const RadioButtonIconBackground = styled(RadioButtonUncheckedIcon)({
  // Scale applied to prevent dot misalignment in Safari
  transform: "scale(1)"
});
const RadioButtonIconDot = styled(RadioButtonCheckedIcon)(memoTheme(({
  theme
}) => ({
  left: 0,
  position: "absolute",
  transform: "scale(0)",
  transition: theme.transitions.create("transform", {
    easing: theme.transitions.easing.easeIn,
    duration: theme.transitions.duration.shortest
  }),
  variants: [{
    props: {
      checked: true
    },
    style: {
      transform: "scale(1)",
      transition: theme.transitions.create("transform", {
        easing: theme.transitions.easing.easeOut,
        duration: theme.transitions.duration.shortest
      })
    }
  }]
})));
function RadioButtonIcon(props) {
  const {
    checked = false,
    classes = {},
    fontSize
  } = props;
  const ownerState = {
    ...props,
    checked
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioButtonIconRoot, {
    className: classes.root,
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIconBackground, {
      fontSize,
      className: classes.background,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIconDot, {
      fontSize,
      className: classes.dot,
      ownerState
    })]
  });
}
const RadioGroupContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useRadioGroup() {
  return reactExports.useContext(RadioGroupContext);
}
function getRadioUtilityClass(slot) {
  return generateUtilityClass$1("MuiRadio", slot);
}
const radioClasses = generateUtilityClasses$1("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]);
const useUtilityClasses$1e = (ownerState) => {
  const {
    classes,
    color: color2,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, size2 !== "medium" && `size${capitalize$1(size2)}`]
  };
  return {
    ...classes,
    ...composeClasses$1(slots, getRadioUtilityClass, classes)
  };
};
const RadioRoot = styled(SwitchBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiRadio",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size !== "medium" && styles2[`size${capitalize$1(ownerState.size)}`], styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${radioClasses.disabled}`]: {
    color: (theme.vars || theme).palette.action.disabled
  },
  variants: [{
    props: {
      color: "default",
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
      }
    }
  }, ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2,
      disableRipple: false
    },
    style: {
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
      }
    }
  })), ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${radioClasses.checked}`]: {
        color: (theme.vars || theme).palette[color2].main
      }
    }
  })), {
    // Should be last to override other colors
    props: {
      disableRipple: false
    },
    style: {
      // Reset on touch devices, it doesn't add specificity
      "&:hover": {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }]
})));
function areEqualValues$1(a3, b3) {
  if (typeof b3 === "object" && b3 !== null) {
    return a3 === b3;
  }
  return String(a3) === String(b3);
}
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIcon, {
  checked: true
});
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIcon, {});
const Radio = /* @__PURE__ */ reactExports.forwardRef(function Radio2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiRadio"
  });
  const {
    checked: checkedProp,
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon = defaultIcon,
    name: nameProp,
    onChange: onChangeProp,
    size: size2 = "medium",
    className,
    disableRipple = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    disableRipple,
    color: color2,
    size: size2
  };
  const classes = useUtilityClasses$1e(ownerState);
  const radioGroup = useRadioGroup();
  let checked = checkedProp;
  const onChange = createChainedFunction(onChangeProp, radioGroup && radioGroup.onChange);
  let name = nameProp;
  if (radioGroup) {
    if (typeof checked === "undefined") {
      checked = areEqualValues$1(radioGroup.value, props.value);
    }
    if (typeof name === "undefined") {
      name = radioGroup.name;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioRoot, {
    type: "radio",
    icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
      fontSize: defaultIcon.props.fontSize ?? size2
    }),
    checkedIcon: /* @__PURE__ */ reactExports.cloneElement(checkedIcon, {
      fontSize: defaultCheckedIcon.props.fontSize ?? size2
    }),
    ownerState,
    classes,
    name,
    checked,
    onChange,
    ref,
    className: clsx(classes.root, className),
    ...other
  });
});
var ArrowDownward = {};
var _interopRequireDefault$x = interopRequireDefaultExports;
Object.defineProperty(ArrowDownward, "__esModule", {
  value: true
});
var default_1$x = ArrowDownward.default = void 0;
var _createSvgIcon$x = _interopRequireDefault$x(requireCreateSvgIcon());
var _jsxRuntime$x = jsxRuntimeExports;
default_1$x = ArrowDownward.default = (0, _createSvgIcon$x.default)(/* @__PURE__ */ (0, _jsxRuntime$x.jsx)("path", {
  d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
}), "ArrowDownward");
var ArrowRight = {};
var _interopRequireDefault$w = interopRequireDefaultExports;
Object.defineProperty(ArrowRight, "__esModule", {
  value: true
});
var default_1$w = ArrowRight.default = void 0;
var _createSvgIcon$w = _interopRequireDefault$w(requireCreateSvgIcon());
var _jsxRuntime$w = jsxRuntimeExports;
default_1$w = ArrowRight.default = (0, _createSvgIcon$w.default)(/* @__PURE__ */ (0, _jsxRuntime$w.jsx)("path", {
  d: "m10 17 5-5-5-5z"
}), "ArrowRight");
var Cancel = {};
var _interopRequireDefault$v = interopRequireDefaultExports;
Object.defineProperty(Cancel, "__esModule", {
  value: true
});
var default_1$v = Cancel.default = void 0;
var _createSvgIcon$v = _interopRequireDefault$v(requireCreateSvgIcon());
var _jsxRuntime$v = jsxRuntimeExports;
default_1$v = Cancel.default = (0, _createSvgIcon$v.default)(/* @__PURE__ */ (0, _jsxRuntime$v.jsx)("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12z"
}), "Cancel");
var ChevronLeft = {};
var _interopRequireDefault$u = interopRequireDefaultExports;
Object.defineProperty(ChevronLeft, "__esModule", {
  value: true
});
var default_1$u = ChevronLeft.default = void 0;
var _createSvgIcon$u = _interopRequireDefault$u(requireCreateSvgIcon());
var _jsxRuntime$u = jsxRuntimeExports;
default_1$u = ChevronLeft.default = (0, _createSvgIcon$u.default)(/* @__PURE__ */ (0, _jsxRuntime$u.jsx)("path", {
  d: "M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"
}), "ChevronLeft");
var ChevronRight = {};
var _interopRequireDefault$t = interopRequireDefaultExports;
Object.defineProperty(ChevronRight, "__esModule", {
  value: true
});
var default_1$t = ChevronRight.default = void 0;
var _createSvgIcon$t = _interopRequireDefault$t(requireCreateSvgIcon());
var _jsxRuntime$t = jsxRuntimeExports;
default_1$t = ChevronRight.default = (0, _createSvgIcon$t.default)(/* @__PURE__ */ (0, _jsxRuntime$t.jsx)("path", {
  d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "ChevronRight");
var ClearAll = {};
var _interopRequireDefault$s = interopRequireDefaultExports;
Object.defineProperty(ClearAll, "__esModule", {
  value: true
});
var default_1$s = ClearAll.default = void 0;
var _createSvgIcon$s = _interopRequireDefault$s(requireCreateSvgIcon());
var _jsxRuntime$s = jsxRuntimeExports;
default_1$s = ClearAll.default = (0, _createSvgIcon$s.default)(/* @__PURE__ */ (0, _jsxRuntime$s.jsx)("path", {
  d: "M5 13h14v-2H5zm-2 4h14v-2H3zM7 7v2h14V7z"
}), "ClearAll");
var Close = {};
var _interopRequireDefault$r = interopRequireDefaultExports;
Object.defineProperty(Close, "__esModule", {
  value: true
});
var default_1$r = Close.default = void 0;
var _createSvgIcon$r = _interopRequireDefault$r(requireCreateSvgIcon());
var _jsxRuntime$r = jsxRuntimeExports;
default_1$r = Close.default = (0, _createSvgIcon$r.default)(/* @__PURE__ */ (0, _jsxRuntime$r.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
var ContentCopy = {};
var _interopRequireDefault$q = interopRequireDefaultExports;
Object.defineProperty(ContentCopy, "__esModule", {
  value: true
});
var default_1$q = ContentCopy.default = void 0;
var _createSvgIcon$q = _interopRequireDefault$q(requireCreateSvgIcon());
var _jsxRuntime$q = jsxRuntimeExports;
default_1$q = ContentCopy.default = (0, _createSvgIcon$q.default)(/* @__PURE__ */ (0, _jsxRuntime$q.jsx)("path", {
  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
}), "ContentCopy");
var DensityLarge = {};
var _interopRequireDefault$p = interopRequireDefaultExports;
Object.defineProperty(DensityLarge, "__esModule", {
  value: true
});
var default_1$p = DensityLarge.default = void 0;
var _createSvgIcon$p = _interopRequireDefault$p(requireCreateSvgIcon());
var _jsxRuntime$p = jsxRuntimeExports;
default_1$p = DensityLarge.default = (0, _createSvgIcon$p.default)(/* @__PURE__ */ (0, _jsxRuntime$p.jsx)("path", {
  d: "M3 3h18v2H3zm0 16h18v2H3z"
}), "DensityLarge");
var DensityMedium = {};
var _interopRequireDefault$o = interopRequireDefaultExports;
Object.defineProperty(DensityMedium, "__esModule", {
  value: true
});
var default_1$o = DensityMedium.default = void 0;
var _createSvgIcon$o = _interopRequireDefault$o(requireCreateSvgIcon());
var _jsxRuntime$o = jsxRuntimeExports;
default_1$o = DensityMedium.default = (0, _createSvgIcon$o.default)(/* @__PURE__ */ (0, _jsxRuntime$o.jsx)("path", {
  d: "M3 3h18v2H3zm0 16h18v2H3zm0-8h18v2H3z"
}), "DensityMedium");
var DensitySmall = {};
var _interopRequireDefault$n = interopRequireDefaultExports;
Object.defineProperty(DensitySmall, "__esModule", {
  value: true
});
var default_1$n = DensitySmall.default = void 0;
var _createSvgIcon$n = _interopRequireDefault$n(requireCreateSvgIcon());
var _jsxRuntime$n = jsxRuntimeExports;
default_1$n = DensitySmall.default = (0, _createSvgIcon$n.default)(/* @__PURE__ */ (0, _jsxRuntime$n.jsx)("path", {
  d: "M3 2h18v2H3zm0 18h18v2H3zm0-6h18v2H3zm0-6h18v2H3z"
}), "DensitySmall");
var DragHandle = {};
var _interopRequireDefault$m = interopRequireDefaultExports;
Object.defineProperty(DragHandle, "__esModule", {
  value: true
});
var default_1$m = DragHandle.default = void 0;
var _createSvgIcon$m = _interopRequireDefault$m(requireCreateSvgIcon());
var _jsxRuntime$m = jsxRuntimeExports;
default_1$m = DragHandle.default = (0, _createSvgIcon$m.default)(/* @__PURE__ */ (0, _jsxRuntime$m.jsx)("path", {
  d: "M20 9H4v2h16zM4 15h16v-2H4z"
}), "DragHandle");
var DynamicFeed = {};
var _interopRequireDefault$l = interopRequireDefaultExports;
Object.defineProperty(DynamicFeed, "__esModule", {
  value: true
});
var default_1$l = DynamicFeed.default = void 0;
var _createSvgIcon$l = _interopRequireDefault$l(requireCreateSvgIcon());
var _jsxRuntime$l = jsxRuntimeExports;
default_1$l = DynamicFeed.default = (0, _createSvgIcon$l.default)([/* @__PURE__ */ (0, _jsxRuntime$l.jsx)("path", {
  d: "M8 8H6v7c0 1.1.9 2 2 2h9v-2H8z"
}, "0"), /* @__PURE__ */ (0, _jsxRuntime$l.jsx)("path", {
  d: "M20 3h-8c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 8h-8V7h8zM4 12H2v7c0 1.1.9 2 2 2h9v-2H4z"
}, "1")], "DynamicFeed");
var ExpandMore = {};
var _interopRequireDefault$k = interopRequireDefaultExports;
Object.defineProperty(ExpandMore, "__esModule", {
  value: true
});
var default_1$k = ExpandMore.default = void 0;
var _createSvgIcon$k = _interopRequireDefault$k(requireCreateSvgIcon());
var _jsxRuntime$k = jsxRuntimeExports;
default_1$k = ExpandMore.default = (0, _createSvgIcon$k.default)(/* @__PURE__ */ (0, _jsxRuntime$k.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
var FilterAlt = {};
var _interopRequireDefault$j = interopRequireDefaultExports;
Object.defineProperty(FilterAlt, "__esModule", {
  value: true
});
var default_1$j = FilterAlt.default = void 0;
var _createSvgIcon$j = _interopRequireDefault$j(requireCreateSvgIcon());
var _jsxRuntime$j = jsxRuntimeExports;
default_1$j = FilterAlt.default = (0, _createSvgIcon$j.default)(/* @__PURE__ */ (0, _jsxRuntime$j.jsx)("path", {
  d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61"
}), "FilterAlt");
var FilterList = {};
var _interopRequireDefault$i = interopRequireDefaultExports;
Object.defineProperty(FilterList, "__esModule", {
  value: true
});
var default_1$i = FilterList.default = void 0;
var _createSvgIcon$i = _interopRequireDefault$i(requireCreateSvgIcon());
var _jsxRuntime$i = jsxRuntimeExports;
default_1$i = FilterList.default = (0, _createSvgIcon$i.default)(/* @__PURE__ */ (0, _jsxRuntime$i.jsx)("path", {
  d: "M10 18h4v-2h-4zM3 6v2h18V6zm3 7h12v-2H6z"
}), "FilterList");
var FilterListOff = {};
var _interopRequireDefault$h = interopRequireDefaultExports;
Object.defineProperty(FilterListOff, "__esModule", {
  value: true
});
var default_1$h = FilterListOff.default = void 0;
var _createSvgIcon$h = _interopRequireDefault$h(requireCreateSvgIcon());
var _jsxRuntime$h = jsxRuntimeExports;
default_1$h = FilterListOff.default = (0, _createSvgIcon$h.default)(/* @__PURE__ */ (0, _jsxRuntime$h.jsx)("path", {
  d: "M10.83 8H21V6H8.83zm5 5H18v-2h-4.17zM14 16.83V18h-4v-2h3.17l-3-3H6v-2h2.17l-3-3H3V6h.17L1.39 4.22 2.8 2.81l18.38 18.38-1.41 1.41z"
}), "FilterListOff");
var FirstPage = {};
var _interopRequireDefault$g = interopRequireDefaultExports;
Object.defineProperty(FirstPage, "__esModule", {
  value: true
});
var default_1$g = FirstPage.default = void 0;
var _createSvgIcon$g = _interopRequireDefault$g(requireCreateSvgIcon());
var _jsxRuntime$g = jsxRuntimeExports;
default_1$g = FirstPage.default = (0, _createSvgIcon$g.default)(/* @__PURE__ */ (0, _jsxRuntime$g.jsx)("path", {
  d: "M18.41 16.59 13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");
var Fullscreen = {};
var _interopRequireDefault$f = interopRequireDefaultExports;
Object.defineProperty(Fullscreen, "__esModule", {
  value: true
});
var default_1$f = Fullscreen.default = void 0;
var _createSvgIcon$f = _interopRequireDefault$f(requireCreateSvgIcon());
var _jsxRuntime$f = jsxRuntimeExports;
default_1$f = Fullscreen.default = (0, _createSvgIcon$f.default)(/* @__PURE__ */ (0, _jsxRuntime$f.jsx)("path", {
  d: "M7 14H5v5h5v-2H7zm-2-4h2V7h3V5H5zm12 7h-3v2h5v-5h-2zM14 5v2h3v3h2V5z"
}), "Fullscreen");
var FullscreenExit = {};
var _interopRequireDefault$e = interopRequireDefaultExports;
Object.defineProperty(FullscreenExit, "__esModule", {
  value: true
});
var default_1$e = FullscreenExit.default = void 0;
var _createSvgIcon$e = _interopRequireDefault$e(requireCreateSvgIcon());
var _jsxRuntime$e = jsxRuntimeExports;
default_1$e = FullscreenExit.default = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
  d: "M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"
}), "FullscreenExit");
var KeyboardDoubleArrowDown = {};
var _interopRequireDefault$d = interopRequireDefaultExports;
Object.defineProperty(KeyboardDoubleArrowDown, "__esModule", {
  value: true
});
var default_1$d = KeyboardDoubleArrowDown.default = void 0;
var _createSvgIcon$d = _interopRequireDefault$d(requireCreateSvgIcon());
var _jsxRuntime$d = jsxRuntimeExports;
default_1$d = KeyboardDoubleArrowDown.default = (0, _createSvgIcon$d.default)([/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  d: "M18 6.41 16.59 5 12 9.58 7.41 5 6 6.41l6 6z"
}, "0"), /* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  d: "m18 13-1.41-1.41L12 16.17l-4.59-4.58L6 13l6 6z"
}, "1")], "KeyboardDoubleArrowDown");
var LastPage = {};
var _interopRequireDefault$c = interopRequireDefaultExports;
Object.defineProperty(LastPage, "__esModule", {
  value: true
});
var default_1$c = LastPage.default = void 0;
var _createSvgIcon$c = _interopRequireDefault$c(requireCreateSvgIcon());
var _jsxRuntime$c = jsxRuntimeExports;
default_1$c = LastPage.default = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
  d: "M5.59 7.41 10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
var MoreHoriz = {};
var _interopRequireDefault$b = interopRequireDefaultExports;
Object.defineProperty(MoreHoriz, "__esModule", {
  value: true
});
var default_1$b = MoreHoriz.default = void 0;
var _createSvgIcon$b = _interopRequireDefault$b(requireCreateSvgIcon());
var _jsxRuntime$b = jsxRuntimeExports;
default_1$b = MoreHoriz.default = (0, _createSvgIcon$b.default)(/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
  d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}), "MoreHoriz");
var MoreVert = {};
var _interopRequireDefault$a = interopRequireDefaultExports;
Object.defineProperty(MoreVert, "__esModule", {
  value: true
});
var default_1$a = MoreVert.default = void 0;
var _createSvgIcon$a = _interopRequireDefault$a(requireCreateSvgIcon());
var _jsxRuntime$a = jsxRuntimeExports;
default_1$a = MoreVert.default = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}), "MoreVert");
var PushPin = {};
var _interopRequireDefault$9 = interopRequireDefaultExports;
Object.defineProperty(PushPin, "__esModule", {
  value: true
});
var default_1$9 = PushPin.default = void 0;
var _createSvgIcon$9 = _interopRequireDefault$9(requireCreateSvgIcon());
var _jsxRuntime$9 = jsxRuntimeExports;
default_1$9 = PushPin.default = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
  fillRule: "evenodd",
  d: "M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1 1 1-1v-7H19v-2c-1.66 0-3-1.34-3-3"
}), "PushPin");
var RestartAlt = {};
var _interopRequireDefault$8 = interopRequireDefaultExports;
Object.defineProperty(RestartAlt, "__esModule", {
  value: true
});
var default_1$8 = RestartAlt.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$8(requireCreateSvgIcon());
var _jsxRuntime$8 = jsxRuntimeExports;
default_1$8 = RestartAlt.default = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8m-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91"
}), "RestartAlt");
var Save = {};
var _interopRequireDefault$7 = interopRequireDefaultExports;
Object.defineProperty(Save, "__esModule", {
  value: true
});
var default_1$7 = Save.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
var _jsxRuntime$7 = jsxRuntimeExports;
default_1$7 = Save.default = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3m3-10H5V5h10z"
}), "Save");
var Search = {};
var _interopRequireDefault$6 = interopRequireDefaultExports;
Object.defineProperty(Search, "__esModule", {
  value: true
});
var default_1$6 = Search.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
var _jsxRuntime$6 = jsxRuntimeExports;
default_1$6 = Search.default = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}), "Search");
var SearchOff = {};
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(SearchOff, "__esModule", {
  value: true
});
var default_1$5 = SearchOff.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
var _jsxRuntime$5 = jsxRuntimeExports;
default_1$5 = SearchOff.default = (0, _createSvgIcon$5.default)([/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3 6.08 3 3.28 5.64 3.03 9h2.02C5.3 6.75 7.18 5 9.5 5 11.99 5 14 7.01 14 9.5S11.99 14 9.5 14c-.17 0-.33-.03-.5-.05v2.02c.17.02.33.03.5.03 1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19z"
}, "0"), /* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M6.47 10.82 4 13.29l-2.47-2.47-.71.71L3.29 14 .82 16.47l.71.71L4 14.71l2.47 2.47.71-.71L4.71 14l2.47-2.47z"
}, "1")], "SearchOff");
var Sort = {};
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(Sort, "__esModule", {
  value: true
});
var default_1$4 = Sort.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
var _jsxRuntime$4 = jsxRuntimeExports;
default_1$4 = Sort.default = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "M3 18h6v-2H3zM3 6v2h18V6zm0 7h12v-2H3z"
}), "Sort");
var SyncAlt = {};
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(SyncAlt, "__esModule", {
  value: true
});
var default_1$3 = SyncAlt.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
var _jsxRuntime$3 = jsxRuntimeExports;
default_1$3 = SyncAlt.default = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "m18 12 4-4-4-4v3H3v2h15zM6 12l-4 4 4 4v-3h15v-2H6z"
}), "SyncAlt");
var ViewColumn = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(ViewColumn, "__esModule", {
  value: true
});
var default_1$2 = ViewColumn.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
default_1$2 = ViewColumn.default = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "M14.67 5v14H9.33V5zm1 14H21V5h-5.33zm-7.34 0V5H3v14z"
}), "ViewColumn");
var VisibilityOff = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(VisibilityOff, "__esModule", {
  value: true
});
var default_1$1 = VisibilityOff.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
default_1$1 = VisibilityOff.default = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7M2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2m4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3z"
}), "VisibilityOff");
function memo(getDeps, fn2, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  return () => {
    var _a2, _b2, _c2, _d2;
    let depTime;
    if (opts.key && ((_a2 = opts.debug) == null ? void 0 : _a2.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b2 = opts.debug) == null ? void 0 : _b2.call(opts))) resultTime = Date.now();
    result = fn2(...newDeps);
    if (opts.key && ((_c2 = opts.debug) == null ? void 0 : _c2.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d2 = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d2.call(opts, result);
    return result;
  };
}
function notUndefined(value, msg2) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${""}`);
  } else {
    return value;
  }
}
const approxEqual = (a3, b3) => Math.abs(a3 - b3) < 1;
const debounce = (targetWindow, fn2, ms) => {
  let timeoutId;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId);
    timeoutId = targetWindow.setTimeout(() => fn2.apply(this, args), ms);
  };
};
const defaultKeyExtractor = (index) => index;
const defaultRangeExtractor = (range) => {
  const start2 = Math.max(range.startIndex - range.overscan, 0);
  const end2 = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i2 = start2; i2 <= end2; i2++) {
    arr.push(i2);
  }
  return arr;
};
const observeElementRect = (instance, cb2) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width: width2, height: height2 } = rect;
    cb2({ width: Math.round(width2), height: Math.round(height2) });
  };
  handler(element.getBoundingClientRect());
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const entry = entries[0];
    if (entry == null ? void 0 : entry.borderBoxSize) {
      const box = entry.borderBoxSize[0];
      if (box) {
        handler({ width: box.inlineSize, height: box.blockSize });
        return;
      }
    }
    handler(element.getBoundingClientRect());
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
const addEventListenerOptions = {
  passive: true
};
const supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
const observeElementOffset = (instance, cb2) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset2 = 0;
  const fallback3 = supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb2(offset2, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset2 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback3();
    cb2(offset2, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  return () => {
    element.removeEventListener("scroll", handler);
    element.removeEventListener("scrollend", endHandler);
  };
};
const measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size2 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size2;
    }
  }
  return Math.round(
    element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]
  );
};
const elementScroll = (offset2, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a2, _b2;
  const toOffset = offset2 + adjustments;
  (_b2 = (_a2 = instance.scrollElement) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b2.call(_a2, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.scrollToIndexTimeoutId = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get2 = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            this._measureElement(entry.target, entry);
          });
        });
      };
      return {
        disconnect: () => {
          var _a2;
          return (_a2 = get2()) == null ? void 0 : _a2.disconnect();
        },
        observe: (target) => {
          var _a2;
          return (_a2 = get2()) == null ? void 0 : _a2.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a2;
          return (_a2 = get2()) == null ? void 0 : _a2.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a2, _b2;
      (_b2 = (_a2 = this.options).onChange) == null ? void 0 : _b2.call(_a2, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: false,
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d4) => d4());
      this.unsubs = [];
      this.scrollElement = null;
      this.targetWindow = null;
      this.observer.disconnect();
      this.elementsCache.clear();
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a2;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a2 = this.scrollElement) == null ? void 0 : _a2.window) ?? null;
        }
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset2, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset2 ? "forward" : "backward" : null;
            this.scrollOffset = offset2;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m4 = index - 1; m4 >= 0; m4--) {
        const measurement = measurements[m4];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a3, b3) => {
        if (a3.end === b3.end) {
          return a3.index - b3.index;
        }
        return a3.end - b3.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count2, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count2,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count2, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i2 = min2; i2 < count2; i2++) {
          const key = getItemKey(i2);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i2 - 1] : this.getFurthestMeasurement(measurements, i2);
          const start2 = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size2 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i2);
          const end2 = start2 + size2;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i2 % this.options.lanes;
          measurements[i2] = {
            index: i2,
            start: start2,
            size: size2,
            end: end2,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],
      (measurements, outerSize, scrollOffset) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset
        }) : null;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.getIndexes = memo(
      () => [
        this.options.rangeExtractor,
        this.calculateRange(),
        this.options.overscan,
        this.options.count
      ],
      (rangeExtractor, range, overscan, count2) => {
        return range === null ? [] : rangeExtractor({
          startIndex: range.startIndex,
          endIndex: range.endIndex,
          overscan,
          count: count2
        });
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node2) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node2.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node2, entry) => {
      const index = this.indexFromElement(node2);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node2) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node2);
        this.elementsCache.set(key, node2);
      }
      if (node2.isConnected) {
        this.resizeItem(index, this.options.measureElement(node2, entry, this));
      }
    };
    this.resizeItem = (index, size2) => {
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size2 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size2));
        this.notify(false);
      }
    };
    this.measureElement = (node2) => {
      if (!node2) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node2, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k3 = 0, len = indexes.length; k3 < len; k3++) {
          const i2 = indexes[k3];
          const measurement = measurements[i2];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: false,
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset2) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset2
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align) => {
      const size2 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (toOffset <= scrollOffset) {
          align = "start";
        } else if (toOffset >= scrollOffset + size2) {
          align = "end";
        } else {
          align = "start";
        }
      }
      if (align === "start") {
        toOffset = toOffset;
      } else if (align === "end") {
        toOffset = toOffset - size2;
      } else if (align === "center") {
        toOffset = toOffset - size2 / 2;
      }
      const scrollSizeProp = this.options.horizontal ? "scrollWidth" : "scrollHeight";
      const scrollSize = this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;
      const maxOffset = scrollSize - size2;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const item = this.measurementsCache[index];
      if (!item) {
        return void 0;
      }
      const size2 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size2 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(toOffset, align), align];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.cancelScrollToIndex = () => {
      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {
        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);
        this.scrollToIndexTimeoutId = null;
      }
    };
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);
      if (!offsetAndAlign) return;
      const [offset2, align] = offsetAndAlign;
      this._scrollToOffset(offset2, { adjustments: void 0, behavior });
      if (behavior !== "smooth" && this.isDynamicMode() && this.targetWindow) {
        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {
          this.scrollToIndexTimeoutId = null;
          const elementInDOM = this.elementsCache.has(
            this.options.getItemKey(index)
          );
          if (elementInDOM) {
            const [latestOffset] = notUndefined(
              this.getOffsetForIndex(index, align)
            );
            if (!approxEqual(latestOffset, this.getScrollOffset())) {
              this.scrollToIndex(index, { align, behavior });
            }
          } else {
            this.scrollToIndex(index, { align, behavior });
          }
        });
      }
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      this.cancelScrollToIndex();
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a2;
      const measurements = this.getMeasurements();
      let end2;
      if (measurements.length === 0) {
        end2 = this.options.paddingStart;
      } else {
        end2 = this.options.lanes === 1 ? ((_a2 = measurements[measurements.length - 1]) == null ? void 0 : _a2.end) ?? 0 : Math.max(
          ...measurements.slice(-this.options.lanes).map((m4) => m4.end)
        );
      }
      return end2 - this.options.scrollMargin + this.options.paddingEnd;
    };
    this._scrollToOffset = (offset2, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset2, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset
}) {
  const count2 = measurements.length - 1;
  const getOffset2 = (index) => measurements[index].start;
  const startIndex = findNearestBinarySearch(0, count2, getOffset2, scrollOffset);
  let endIndex = startIndex;
  while (endIndex < count2 && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return { startIndex, endIndex };
}
const useIsomorphicLayoutEffect$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useVirtualizerBase(options) {
  const rerender = reactExports.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a2;
      if (sync) {
        reactDomExports.flushSync(rerender);
      } else {
        rerender();
      }
      (_a2 = options.onChange) == null ? void 0 : _a2.call(options, instance2, sync);
    }
  };
  const [instance] = reactExports.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  reactExports.useEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect$1(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableContainer", slot);
}
generateUtilityClasses$1("MuiTableContainer", ["root"]);
const useUtilityClasses$1d = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const {
    className,
    component = "div",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$1d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, {
    ref,
    as: component,
    className: clsx(classes.root, className),
    ownerState,
    ...other
  });
});
const TableContext = /* @__PURE__ */ reactExports.createContext();
function getTableUtilityClass(slot) {
  return generateUtilityClass$1("MuiTable", slot);
}
generateUtilityClasses$1("MuiTable", ["root", "stickyHeader"]);
const useUtilityClasses$1c = (ownerState) => {
  const {
    classes,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses$1(slots, getTableUtilityClass, classes);
};
const TableRoot = styled("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...theme.typography.body2,
    padding: theme.spacing(2),
    color: (theme.vars || theme).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
})));
const defaultComponent$4 = "table";
const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTable"
  });
  const {
    className,
    component = defaultComponent$4,
    padding: padding2 = "normal",
    size: size2 = "medium",
    stickyHeader = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    padding: padding2,
    size: size2,
    stickyHeader
  };
  const classes = useUtilityClasses$1c(ownerState);
  const table = reactExports.useMemo(() => ({
    padding: padding2,
    size: size2,
    stickyHeader
  }), [padding2, size2, stickyHeader]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, {
    value: table,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, {
      as: component,
      role: component === defaultComponent$4 ? null : "table",
      ref,
      className: clsx(classes.root, className),
      ownerState,
      ...other
    })
  });
});
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableBody", slot);
}
generateUtilityClasses$1("MuiTableBody", ["root"]);
const useUtilityClasses$1b = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-row-group"
});
const tablelvl2$2 = {
  variant: "body"
};
const defaultComponent$3 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const {
    className,
    component = defaultComponent$3,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$1b(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2$2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, {
      className: clsx(classes.root, className),
      as: component,
      ref,
      role: component === defaultComponent$3 ? null : "rowgroup",
      ownerState,
      ...other
    })
  });
});
function getTableRowUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses$1("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const useUtilityClasses$1a = (ownerState) => {
  const {
    classes,
    selected,
    hover,
    head,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
  };
  return composeClasses$1(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(memoTheme(({
  theme
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses.hover}:hover`]: {
    backgroundColor: (theme.vars || theme).palette.action.hover
  },
  [`&.${tableRowClasses.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
    }
  }
})));
const defaultComponent$2 = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const {
    className,
    component = defaultComponent$2,
    hover = false,
    selected = false,
    ...other
  } = props;
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const ownerState = {
    ...props,
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  };
  const classes = useUtilityClasses$1a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, {
    as: component,
    ref,
    className: clsx(classes.root, className),
    role: component === defaultComponent$2 ? null : "row",
    ownerState,
    ...other
  });
});
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass$1("MuiSkeleton", slot);
}
generateUtilityClasses$1("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const useUtilityClasses$19 = (ownerState) => {
  const {
    classes,
    variant,
    animation,
    hasChildren,
    width: width2,
    height: height2
  } = ownerState;
  const slots = {
    root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
  };
  return composeClasses$1(slots, getSkeletonUtilityClass, classes);
};
const pulseKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`;
const waveKeyframe = keyframes`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`;
const pulseAnimation = typeof pulseKeyframe !== "string" ? css`
        animation: ${pulseKeyframe} 2s ease-in-out 0.5s infinite;
      ` : null;
const waveAnimation = typeof waveKeyframe !== "string" ? css`
        animation: ${waveKeyframe} 2s linear 0.5s infinite;
      ` : null;
const SkeletonRoot = styled("span", {
  name: "MuiSkeleton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
  }
})(memoTheme(({
  theme
}) => {
  const radiusUnit = getUnit(theme.shape.borderRadius) || "px";
  const radiusValue = toUnitless(theme.shape.borderRadius);
  return {
    display: "block",
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme.vars ? theme.vars.palette.Skeleton.bg : alpha(theme.palette.text.primary, theme.palette.mode === "light" ? 0.11 : 0.13),
    height: "1.2em",
    variants: [{
      props: {
        variant: "text"
      },
      style: {
        marginTop: 0,
        marginBottom: 0,
        height: "auto",
        transformOrigin: "0 55%",
        transform: "scale(1, 0.60)",
        borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
        "&:empty:before": {
          content: '"\\00a0"'
        }
      }
    }, {
      props: {
        variant: "circular"
      },
      style: {
        borderRadius: "50%"
      }
    }, {
      props: {
        variant: "rounded"
      },
      style: {
        borderRadius: (theme.vars || theme).shape.borderRadius
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hasChildren,
      style: {
        "& > *": {
          visibility: "hidden"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hasChildren && !ownerState.width,
      style: {
        maxWidth: "fit-content"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.hasChildren && !ownerState.height,
      style: {
        height: "auto"
      }
    }, {
      props: {
        animation: "pulse"
      },
      style: pulseAnimation || {
        animation: `${pulseKeyframe} 2s ease-in-out 0.5s infinite`
      }
    }, {
      props: {
        animation: "wave"
      },
      style: {
        position: "relative",
        overflow: "hidden",
        /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
        WebkitMaskImage: "-webkit-radial-gradient(white, black)",
        "&::after": {
          background: `linear-gradient(
                90deg,
                transparent,
                ${(theme.vars || theme).palette.action.hover},
                transparent
              )`,
          content: '""',
          position: "absolute",
          transform: "translateX(-100%)",
          bottom: 0,
          left: 0,
          right: 0,
          top: 0
        }
      }
    }, {
      props: {
        animation: "wave"
      },
      style: {
        "&::after": waveAnimation || {
          animation: `${waveKeyframe} 2s linear 0.5s infinite`
        }
      }
    }]
  };
}));
const Skeleton = /* @__PURE__ */ reactExports.forwardRef(function Skeleton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSkeleton"
  });
  const {
    animation = "pulse",
    className,
    component = "span",
    height: height2,
    style: style2,
    variant = "text",
    width: width2,
    ...other
  } = props;
  const ownerState = {
    ...props,
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  };
  const classes = useUtilityClasses$19(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, {
    as: component,
    ref,
    className: clsx(classes.root, className),
    ownerState,
    ...other,
    style: {
      width: width2,
      height: height2,
      ...style2
    }
  });
});
function getTableCellUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses$1("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const useUtilityClasses$18 = (ownerState) => {
  const {
    classes,
    variant,
    align,
    padding: padding2,
    size: size2,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize$1(align)}`, padding2 !== "normal" && `padding${capitalize$1(padding2)}`, `size${capitalize$1(size2)}`]
  };
  return composeClasses$1(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize$1(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize$1(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme.vars ? `1px solid ${theme.vars.palette.TableCell.border}` : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (theme.vars || theme).palette.text.primary,
      lineHeight: theme.typography.pxToRem(24),
      fontWeight: theme.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (theme.vars || theme).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (theme.vars || theme).palette.text.secondary,
      lineHeight: theme.typography.pxToRem(21),
      fontSize: theme.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${tableCellClasses.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (theme.vars || theme).palette.background.default
    }
  }]
})));
const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp,
    ...other
  } = props;
  const table = reactExports.useContext(TableContext);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (component === "td") {
    scope = void 0;
  } else if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = {
    ...props,
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  };
  const classes = useUtilityClasses$18(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, {
    as: component,
    ref,
    className: clsx(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState,
    ...other
  });
});
let IDX = 36;
let HEX = "";
while (IDX--) {
  HEX += IDX.toString(36);
}
function uid(len = 11) {
  let str = "";
  let num = len;
  while (num--) {
    str += HEX[Math.random() * 36 | 0];
  }
  return str;
}
const escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char2) => `\\${char2}`);
const termsToRegExpString = (terms) => terms.replace(/\s{2,}/g, " ").split(" ").join("|");
const regexpQuery = ({
  terms,
  matchExactly = false
}) => {
  if (typeof terms !== "string") {
    throw new TypeError("Expected a string");
  }
  const escapedTerms = escapeRegexp(terms.trim());
  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;
};
const buildRegexp = ({
  terms,
  matchExactly = false
}) => {
  try {
    const fromString = /^([/~@;%#'])(.*?)\1([gimsuy]*)$/.exec(terms);
    if (fromString) {
      return new RegExp(fromString[2], fromString[3]);
    }
    return new RegExp(regexpQuery({ terms, matchExactly }), "ig");
  } catch (e3) {
    throw new TypeError("Expected terms to be either a string or a RegExp!");
  }
};
const hasProp = (prop) => (obj) => obj !== null && typeof obj === "object" && prop in obj;
const hasMatch = hasProp("match");
const chunkExists = (chunk) => typeof chunk !== "undefined";
function clip({
  curr,
  next: next2,
  prev: prev2,
  clipBy = 3
}) {
  const words2 = curr.text.split(" ");
  const len = words2.length;
  if (curr.match || clipBy >= len) {
    return curr.text;
  }
  const ellipsis = "...";
  if (chunkExists(next2) && chunkExists(prev2) && hasMatch(prev2) && hasMatch(next2)) {
    if (len > clipBy * 2) {
      return [
        ...words2.slice(0, clipBy),
        ellipsis,
        ...words2.slice(-clipBy)
      ].join(" ");
    }
    return curr.text;
  }
  if (chunkExists(next2) && hasMatch(next2)) {
    return [ellipsis, ...words2.slice(-clipBy)].join(" ");
  }
  if (chunkExists(prev2) && hasMatch(prev2)) {
    return [...words2.slice(0, clipBy), ellipsis].join(" ");
  }
  return curr.text;
}
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a3, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp2(a3, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp2(a3, prop, b3[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
const hasLength = (str) => str.length > 0;
const highlightWords = ({
  text: text2,
  query,
  clipBy,
  matchExactly = false
}) => {
  const safeQuery = typeof query === "string" ? query.trim() : query;
  if (safeQuery === "") {
    return [
      {
        key: uid(),
        text: text2,
        match: false
      }
    ];
  }
  const searchRegexp = buildRegexp({ terms: query, matchExactly });
  return text2.split(searchRegexp).filter(hasLength).map((str) => ({
    // Compose the object for a match
    key: uid(),
    text: str,
    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)
  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === "number" && {
    // We only overwrite the text if there is a clip
    text: clip(__spreadProps(__spreadValues(__spreadValues({
      curr: chunk
    }, index < chunks.length - 1 && { next: chunks[index + 1] }), index > 0 && { prev: chunks[index - 1] }), {
      // If this wasn't the first chunk, set the previous chunk
      clipBy
    }))
  }));
};
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$1 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty$1(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflowing;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value,
    ...other
  } = props;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(forwardedRef, inputRef);
  const heightRef = reactExports.useRef(null);
  const shadowRef = reactExports.useRef(null);
  const calculateTextareaStyles = reactExports.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0,
        overflowing: false
      };
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflowing
    };
  }, [maxRows, minRows, props.placeholder]);
  const syncHeight = reactExports.useCallback(() => {
    const textareaStyles = calculateTextareaStyles();
    if (isEmpty$1(textareaStyles)) {
      return;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    const input = inputRef.current;
    if (heightRef.current !== outerHeightStyle) {
      heightRef.current = outerHeightStyle;
      input.style.height = `${outerHeightStyle}px`;
    }
    input.style.overflow = textareaStyles.overflowing ? "hidden" : "";
  }, [calculateTextareaStyles]);
  useEnhancedEffect$1(() => {
    const handleResize = () => {
      syncHeight();
    };
    let rAF;
    const debounceHandleResize = debounce$2(handleResize);
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    containerWindow.addEventListener("resize", debounceHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(input);
    }
    return () => {
      debounceHandleResize.clear();
      cancelAnimationFrame(rAF);
      containerWindow.removeEventListener("resize", debounceHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [calculateTextareaStyles, syncHeight]);
  useEnhancedEffect$1(() => {
    syncHeight();
  });
  const handleChange = (event) => {
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: style2,
      ...other
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: {
        ...styles$1.shadow,
        ...style2,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass$1("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses$1("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var _InputGlobalStyles;
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$17 = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size: size2,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size2 && size2 !== "medium" && `size${capitalize$1(size2)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size2 === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses$1(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body1,
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState,
      size: size2
    }) => ownerState.multiline && size2 === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "100%"
    }
  }]
})));
const InputBaseInput = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme
}) => {
  const light2 = theme.palette.mode === "light";
  const placeholder = {
    color: "currentColor",
    ...theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: light2 ? 0.42 : 0.5
    },
    transition: theme.transitions.create("opacity", {
      duration: theme.transitions.duration.shorter
    })
  };
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
}));
const InputGlobalStyles = globalCss({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    color: color2,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    error,
    fullWidth = false,
    id: id2,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    margin: margin2,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    size: size2,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp,
    ...other
  } = props;
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef$1(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$1(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage$1(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = {
        type: void 0,
        minRows: rows,
        maxRows: rows,
        ...inputProps
      };
    } else {
      inputProps = {
        type: void 0,
        maxRows,
        minRows,
        ...inputProps
      };
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = {
    ...props,
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  };
  const classes = useUtilityClasses$17(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseInput;
  inputProps = {
    ...inputProps,
    ...slotProps.input ?? componentsProps.input
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && typeof InputGlobalStyles === "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (_InputGlobalStyles || (_InputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(InputGlobalStyles, {}))), /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, {
      ...rootProps,
      ref,
      onClick: handleClick,
      ...other,
      ...!isHostComponent$1(Root) && {
        ownerState: {
          ...ownerState,
          ...rootProps.ownerState
        }
      },
      className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, {
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id: id2,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type,
          ...inputProps,
          ...!isHostComponent$1(Input3) && {
            as: InputComponent,
            ownerState: {
              ...ownerState,
              ...inputProps.ownerState
            }
          },
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        })
      }), endAdornment, renderSuffix ? renderSuffix({
        ...fcs,
        startAdornment
      }) : null]
    })]
  });
});
const InputBase$1 = InputBase;
function getInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiInput", slot);
}
const inputClasses = {
  ...inputBaseClasses,
  ...generateUtilityClasses$1("MuiInput", ["root", "underline", "input"])
};
const useUtilityClasses$16 = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses$1(slots, getInputUtilityClass, classes);
  return {
    ...classes,
    // forward classes to the InputBase
    ...composedClasses
  };
};
const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme
}) => {
  const light2 = theme.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme.vars) {
    bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
  }
  return {
    position: "relative",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
      props: {
        color: color2,
        disableUnderline: false
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(theme.vars || theme).palette[color2].main}`
        }
      }
    }))]
  };
}));
const InputInput = styled(InputBaseInput, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text",
    ...other
  } = props;
  const classes = useUtilityClasses$16(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = slotProps ?? componentsPropsProp ? deepmerge(slotProps ?? componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = slots.root ?? components.Root ?? InputRoot;
  const InputSlot = slots.input ?? components.Input ?? InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, {
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type,
    ...other,
    classes
  });
});
if (Input) {
  Input.muiName = "Input";
}
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiFilledInput", slot);
}
const filledInputClasses = {
  ...inputBaseClasses,
  ...generateUtilityClasses$1("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
};
const useUtilityClasses$15 = (ownerState) => {
  const {
    classes,
    disableUnderline,
    startAdornment,
    endAdornment,
    size: size2,
    hiddenLabel,
    multiline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline", startAdornment && "adornedStart", endAdornment && "adornedEnd", size2 === "small" && `size${capitalize$1(size2)}`, hiddenLabel && "hiddenLabel", multiline && "multiline"],
    input: ["input"]
  };
  const composedClasses = composeClasses$1(slots, getFilledInputUtilityClass, classes);
  return {
    ...classes,
    // forward classes to the InputBase
    ...composedClasses
  };
};
const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme
}) => {
  const light2 = theme.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses.focused}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses.disabled}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${filledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => {
      var _a2;
      return {
        props: {
          disableUnderline: false,
          color: color2
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(_a2 = (theme.vars || theme).palette[color2]) == null ? void 0 : _a2.main}`
          }
        }
      };
    }), {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState,
        size: size2
      }) => ownerState.multiline && size2 === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel && ownerState.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
}));
const FilledInputInput = styled(InputBaseInput, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!theme.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
      caretColor: theme.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...theme.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [theme.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel && ownerState.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
})));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    hiddenLabel,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text",
    ...other
  } = props;
  const ownerState = {
    ...props,
    disableUnderline,
    fullWidth,
    inputComponent,
    multiline,
    type
  };
  const classes = useUtilityClasses$15(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = slotProps ?? componentsPropsProp ? deepmerge(filledInputComponentsProps, slotProps ?? componentsPropsProp) : filledInputComponentsProps;
  const RootSlot = slots.root ?? components.Root ?? FilledInputRoot;
  const InputSlot = slots.input ?? components.Input ?? FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, {
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type,
    ...other,
    classes
  });
});
if (FilledInput) {
  FilledInput.muiName = "Input";
}
var _span$3;
const NotchedOutlineRoot$1 = styled("fieldset", {
  shouldForwardProp: rootShouldForwardProp
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled("legend", {
  shouldForwardProp: rootShouldForwardProp
})(memoTheme(({
  theme
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme.transitions.create("width", {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme.transitions.create("max-width", {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel && ownerState.notched,
    style: {
      maxWidth: "100%",
      transition: theme.transitions.create("max-width", {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function NotchedOutline(props) {
  const {
    children,
    classes,
    className,
    label,
    notched,
    ...other
  } = props;
  const withLabel = label != null && label !== "";
  const ownerState = {
    ...props,
    notched,
    withLabel
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, {
    "aria-hidden": true,
    className,
    ownerState,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      )
    })
  });
}
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass$1("MuiOutlinedInput", slot);
}
const outlinedInputClasses = {
  ...inputBaseClasses,
  ...generateUtilityClasses$1("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
const useUtilityClasses$14 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses$1(slots, getOutlinedInputUtilityClass, classes);
  return {
    ...classes,
    // forward classes to the InputBase
    ...composedClasses
  };
};
const OutlinedInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme
}) => {
  const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.text.primary
    },
    [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette[color2].main
        }
      }
    })), {
      props: {},
      // to overide the above style
      style: {
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
            borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
          }
        },
        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.error.main
        },
        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState,
        size: size2
      }) => ownerState.multiline && size2 === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
}));
const NotchedOutlineRoot = styled(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(memoTheme(({
  theme
}) => {
  const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
}));
const OutlinedInputInput = styled(InputBaseInput, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme
}) => ({
  padding: "16.5px 14px",
  ...!theme.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
      caretColor: theme.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...theme.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [theme.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
})));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
  var _React$Fragment;
  const props = useDefaultProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    type = "text",
    ...other
  } = props;
  const classes = useUtilityClasses$14(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = {
    ...props,
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  };
  const RootSlot = slots.root ?? components.Root ?? OutlinedInputRoot;
  const InputSlot = slots.input ?? components.Input ?? OutlinedInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, {
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
      ownerState,
      className: classes.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, " ", "*"]
      })) : label,
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type,
    ...other,
    classes: {
      ...classes,
      notchedOutline: null
    }
  });
});
if (OutlinedInput) {
  OutlinedInput.muiName = "Input";
}
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses$1("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const useUtilityClasses$13 = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses$1(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return {
      ...styles2.root,
      ...ownerState.color === "secondary" && styles2.colorSecondary,
      ...ownerState.filled && styles2.filled
    };
  }
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  ...theme.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${formLabelClasses.focused}`]: {
        color: (theme.vars || theme).palette[color2].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${formLabelClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      },
      [`&.${formLabelClasses.error}`]: {
        color: (theme.vars || theme).palette.error.main
      }
    }
  }]
})));
const AsteriskComponent$1 = styled("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(memoTheme(({
  theme
}) => ({
  [`&.${formLabelClasses.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
})));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const {
    children,
    className,
    color: color2,
    component = "label",
    disabled,
    error,
    filled,
    focused,
    required,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = {
    ...props,
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  };
  const classes = useUtilityClasses$13(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, {
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref,
    ...other,
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: [" ", "*"]
    })]
  });
});
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass$1("MuiInputLabel", slot);
}
generateUtilityClasses$1("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const useUtilityClasses$12 = (ownerState) => {
  const {
    classes,
    formControl,
    size: size2,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size2 && size2 !== "normal" && `size${capitalize$1(size2)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses$1(slots, getInputLabelUtilityClasses, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...composedClasses
  };
};
const InputLabelRoot = styled(FormLabel, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disableAnimation,
    style: {
      transition: theme.transitions.create(["color", "transform", "max-width"], {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "filled" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant,
      ownerState,
      size: size2
    }) => variant === "filled" && ownerState.shrink && size2 === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "outlined" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
  const props = useDefaultProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const {
    disableAnimation = false,
    margin: margin2,
    shrink: shrinkProp,
    variant,
    className,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required", "focused"]
  });
  const ownerState = {
    ...props,
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required,
    focused: fcs.focused
  };
  const classes = useUtilityClasses$12(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, {
    "data-shrink": shrink,
    ref,
    className: clsx(classes.root, className),
    ...other,
    ownerState,
    classes
  });
});
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormControl", slot);
}
generateUtilityClasses$1("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const useUtilityClasses$11 = (ownerState) => {
  const {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize$1(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses$1(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return {
      ...styles2.root,
      ...styles2[`margin${capitalize$1(ownerState.margin)}`],
      ...ownerState.fullWidth && styles2.fullWidth
    };
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
});
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size: size2 = "medium",
    variant = "outlined",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size: size2,
    variant
  };
  const classes = useUtilityClasses$11(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size: size2,
      onBlur: () => {
        setFocused(false);
      },
      onEmpty: () => {
        setFilled(false);
      },
      onFilled: () => {
        setFilled(true);
      },
      onFocus: () => {
        setFocused(true);
      },
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size2, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, {
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref,
      ...other,
      children
    })
  });
});
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses$1("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var _span$2;
const useUtilityClasses$10 = (ownerState) => {
  const {
    classes,
    contained,
    size: size2,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size2 && `size${capitalize$1(size2)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses$1(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize$1(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  ...theme.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${formHelperTextClasses.error}`]: {
    color: (theme.vars || theme).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
})));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const {
    children,
    className,
    component = "p",
    disabled,
    error,
    filled,
    focused,
    margin: margin2,
    required,
    variant,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = {
    ...props,
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  };
  delete ownerState.ownerState;
  const classes = useUtilityClasses$10(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, {
    as: component,
    className: clsx(classes.root, className),
    ref,
    ...other,
    ownerState,
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        children: "​"
      }))
    ) : children
  });
});
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass$1("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses$1("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const useUtilityClasses$$ = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize$1(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses$1(slots, getNativeSelectUtilityClasses, classes);
};
const StyledSelectSelect = styled("select")(({
  theme
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${nativeSelectClasses.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme.vars || theme).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.variant !== "filled" && ownerState.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (theme.vars || theme).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme.vars || theme).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
}));
const NativeSelectSelect = styled(StyledSelectSelect, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses.multiple}`]: styles2.multiple
    }];
  }
})({});
const StyledSelectIcon = styled("svg")(({
  theme
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (theme.vars || theme).palette.action.active,
  [`&.${nativeSelectClasses.disabled}`]: {
    color: (theme.vars || theme).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
}));
const NativeSelectIcon = styled(StyledSelectIcon, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
  const {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard",
    ...other
  } = props;
  const ownerState = {
    ...props,
    disabled,
    variant,
    error
  };
  const classes = useUtilityClasses$$(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, {
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref,
      ...other
    }), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
function getSelectUtilityClasses(slot) {
  return generateUtilityClass$1("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses$1("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span$1;
const SelectSelect = styled(StyledSelectSelect, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses.select}`]: styles2.select
      },
      {
        [`&.${selectClasses.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses.error}`]: styles2.error
      },
      {
        [`&.${selectClasses.multiple}`]: styles2.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled(StyledSelectIcon, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const SelectNativeInput = styled("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles2) => styles2.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a3, b3) {
  if (typeof b3 === "object" && b3 !== null) {
    return a3 === b3;
  }
  return String(a3) === String(b3);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
const useUtilityClasses$_ = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize$1(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses$1(slots, getSelectUtilityClasses, classes);
};
const SelectInput$1 = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
  var _a2;
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    // catching `type` from Input which makes no sense for SelectInput
    type,
    value: valueProp,
    variant = "standard",
    ...other
  } = props;
  const [value, setValueState] = useControlled$1({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled$1({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef$1(ref, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument$1(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  };
  const handleClose = (event) => {
    update(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update(false, event);
    }
  };
  const handleKeyDown = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.includes(event.key)) {
        event.preventDefault();
        update(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage$1(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index) => {
          output.push(child);
          if (index < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
  const ownerState = {
    ...props,
    variant,
    value,
    open,
    error
  };
  const classes = useUtilityClasses$_(ownerState);
  const paperProps = {
    ...MenuProps.PaperProps,
    ...(_a2 = MenuProps.slotProps) == null ? void 0 : _a2.paper
  };
  const listboxId = useId$1();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, {
      as: "div",
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": listboxId,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus,
      ...SelectDisplayProps,
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : display
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, {
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      ...other,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, {
      id: `menu-${name || ""}`,
      anchorEl: anchorElement,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...MenuProps,
      MenuListProps: {
        "aria-labelledby": labelId,
        role: "listbox",
        "aria-multiselectable": multiple ? "true" : void 0,
        disableListWrap: true,
        id: listboxId,
        ...MenuProps.MenuListProps
      },
      slotProps: {
        ...MenuProps.slotProps,
        paper: {
          ...paperProps,
          style: {
            minWidth: menuMinWidth,
            ...paperProps != null ? paperProps.style : null
          }
        }
      },
      children: items
    })]
  });
});
const ArrowDropDownIcon$1 = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
const useUtilityClasses$Z = (ownerState) => {
  const {
    classes
  } = ownerState;
  return classes;
};
const styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
  slot: "Root"
};
const StyledInput = styled(Input, styledRootConfig)("");
const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
  const props = useThemeProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon$1,
    id: id2,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined",
    ...other
  } = props;
  const inputComponent = native ? NativeSelectInput : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = {
    ...props,
    variant,
    classes: classesProp
  };
  const classes = useUtilityClasses$Z(ownerState);
  const {
    root: root2,
    ...restOfClasses
  } = classes;
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef$1(ref, getReactNodeRef(InputComponent));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: {
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple,
        ...native ? {
          id: id2
        } : {
          autoWidth,
          defaultOpen,
          displayEmpty,
          labelId,
          MenuProps,
          onClose,
          onOpen,
          open,
          renderValue,
          SelectDisplayProps: {
            id: id2,
            ...SelectDisplayProps
          }
        },
        ...inputProps,
        classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses,
        ...input ? input.props.inputProps : {}
      },
      ...(multiple && native || displayEmpty) && variant === "outlined" ? {
        notched: true
      } : {},
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!input && {
        variant
      },
      ...other
    })
  });
});
Select.muiName = "Select";
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass$1("MuiTextField", slot);
}
generateUtilityClasses$1("MuiTextField", ["root"]);
const variantComponent = {
  standard: Input,
  filled: FilledInput,
  outlined: OutlinedInput
};
const useUtilityClasses$Y = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled(FormControl, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTextField"
  });
  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps: FormHelperTextPropsProp,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps: InputLabelPropsProp,
    inputProps: inputPropsProp,
    InputProps: InputPropsProp,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps: SelectPropsProp,
    slots = {},
    slotProps = {},
    type,
    value,
    variant = "outlined",
    ...other
  } = props;
  const ownerState = {
    ...props,
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  };
  const classes = useUtilityClasses$Y(ownerState);
  const id2 = useId$1(idOverride);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const externalForwardedProps = {
    slots,
    slotProps: {
      input: InputPropsProp,
      inputLabel: InputLabelPropsProp,
      htmlInput: inputPropsProp,
      formHelperText: FormHelperTextPropsProp,
      select: SelectPropsProp,
      ...slotProps
    }
  };
  const inputAdditionalProps = {};
  const inputLabelSlotProps = externalForwardedProps.slotProps.inputLabel;
  if (variant === "outlined") {
    if (inputLabelSlotProps && typeof inputLabelSlotProps.shrink !== "undefined") {
      inputAdditionalProps.notched = inputLabelSlotProps.shrink;
    }
    inputAdditionalProps.label = label;
  }
  if (select) {
    if (!SelectPropsProp || !SelectPropsProp.native) {
      inputAdditionalProps.id = void 0;
    }
    inputAdditionalProps["aria-describedby"] = void 0;
  }
  const [InputSlot, inputProps] = useSlot("input", {
    elementType: InputComponent,
    externalForwardedProps,
    additionalProps: inputAdditionalProps,
    ownerState
  });
  const [InputLabelSlot, inputLabelProps] = useSlot("inputLabel", {
    elementType: InputLabel,
    externalForwardedProps,
    ownerState
  });
  const [HtmlInputSlot, htmlInputProps2] = useSlot("htmlInput", {
    elementType: "input",
    externalForwardedProps,
    ownerState
  });
  const [FormHelperTextSlot, formHelperTextProps] = useSlot("formHelperText", {
    elementType: FormHelperText,
    externalForwardedProps,
    ownerState
  });
  const [SelectSlot, selectProps] = useSlot("select", {
    elementType: Select,
    externalForwardedProps,
    ownerState
  });
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, {
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id: id2,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps: htmlInputProps2,
    slots: {
      input: slots.htmlInput ? HtmlInputSlot : void 0
    },
    ...inputProps
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, {
    className: clsx(classes.root, className),
    disabled,
    error,
    fullWidth,
    ref,
    required,
    color: color2,
    variant,
    ownerState,
    ...other,
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelSlot, {
      htmlFor: id2,
      id: inputLabelId,
      ...inputLabelProps,
      children: label
    }), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectSlot, {
      "aria-describedby": helperTextId,
      id: id2,
      labelId: inputLabelId,
      value,
      input: InputElement,
      ...selectProps,
      children
    }) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextSlot, {
      id: helperTextId,
      ...formHelperTextProps,
      children: helperText
    })]
  });
});
function getCollapseUtilityClass(slot) {
  return generateUtilityClass$1("MuiCollapse", slot);
}
generateUtilityClasses$1("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const useUtilityClasses$X = (ownerState) => {
  const {
    orientation,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `${orientation}`],
    entered: ["entered"],
    hidden: ["hidden"],
    wrapper: ["wrapper", `${orientation}`],
    wrapperInner: ["wrapperInner", `${orientation}`]
  };
  return composeClasses$1(slots, getCollapseUtilityClass, classes);
};
const CollapseRoot = styled("div", {
  name: "MuiCollapse",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.state === "entered" && styles2.entered, ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden];
  }
})(memoTheme(({
  theme
}) => ({
  height: 0,
  overflow: "hidden",
  transition: theme.transitions.create("height"),
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      height: "auto",
      width: 0,
      transition: theme.transitions.create("width")
    }
  }, {
    props: {
      state: "entered"
    },
    style: {
      height: "auto",
      overflow: "visible"
    }
  }, {
    props: {
      state: "entered",
      orientation: "horizontal"
    },
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px",
    style: {
      visibility: "hidden"
    }
  }]
})));
const CollapseWrapper = styled("div", {
  name: "MuiCollapse",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => styles2.wrapper
})({
  // Hack to get children with a negative margin to not falsify the height computation.
  display: "flex",
  width: "100%",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "auto",
      height: "100%"
    }
  }]
});
const CollapseWrapperInner = styled("div", {
  name: "MuiCollapse",
  slot: "WrapperInner",
  overridesResolver: (props, styles2) => styles2.wrapperInner
})({
  width: "100%",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "auto",
      height: "100%"
    }
  }]
});
const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCollapse"
  });
  const {
    addEndListener,
    children,
    className,
    collapsedSize: collapsedSizeProp = "0px",
    component,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    orientation = "vertical",
    style: style2,
    timeout = duration.standard,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const ownerState = {
    ...props,
    orientation,
    collapsedSize: collapsedSizeProp
  };
  const classes = useUtilityClasses$X(ownerState);
  const theme = useTheme();
  const timer = useTimeout();
  const wrapperRef = reactExports.useRef(null);
  const autoTransitionDuration = reactExports.useRef();
  const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
  const isHorizontal = orientation === "horizontal";
  const size2 = isHorizontal ? "width" : "height";
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(ref, nodeRef);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const getWrapperSize = () => wrapperRef.current ? wrapperRef.current[isHorizontal ? "clientWidth" : "clientHeight"] : 0;
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "absolute";
    }
    node2.style[size2] = collapsedSize;
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const wrapperSize = getWrapperSize();
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "";
    }
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    if (timeout === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size2] = `${wrapperSize}px`;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback((node2, isAppearing) => {
    node2.style[size2] = "auto";
    if (onEntered) {
      onEntered(node2, isAppearing);
    }
  });
  const handleExit = normalizedTransitionCallback((node2) => {
    node2.style[size2] = `${getWrapperSize()}px`;
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleExiting = normalizedTransitionCallback((node2) => {
    const wrapperSize = getWrapperSize();
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    if (timeout === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size2] = collapsedSize;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onExiting) {
      onExiting(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTransitionDuration.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    in: inProp,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    nodeRef,
    timeout: timeout === "auto" ? null : timeout,
    ...other,
    children: (state, childProps) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseRoot, {
      as: component,
      className: clsx(classes.root, className, {
        "entered": classes.entered,
        "exited": !inProp && collapsedSize === "0px" && classes.hidden
      }[state]),
      style: {
        [isHorizontal ? "minWidth" : "minHeight"]: collapsedSize,
        ...style2
      },
      ref: handleRef,
      ...childProps,
      // `ownerState` is set after `childProps` to override any existing `ownerState` property in `childProps`
      // that might have been forwarded from the Transition component.
      ownerState: {
        ...ownerState,
        state
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapper, {
        ownerState: {
          ...ownerState,
          state
        },
        className: classes.wrapper,
        ref: wrapperRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapperInner, {
          ownerState: {
            ...ownerState,
            state
          },
          className: classes.wrapperInner,
          children
        })
      })
    })
  });
});
if (Collapse) {
  Collapse.muiSupportAuto = true;
}
function getTableFooterUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableFooter", slot);
}
generateUtilityClasses$1("MuiTableFooter", ["root"]);
const useUtilityClasses$W = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getTableFooterUtilityClass, classes);
};
const TableFooterRoot = styled("tfoot", {
  name: "MuiTableFooter",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-footer-group"
});
const tablelvl2$1 = {
  variant: "footer"
};
const defaultComponent$1 = "tfoot";
const TableFooter = /* @__PURE__ */ reactExports.forwardRef(function TableFooter2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableFooter"
  });
  const {
    className,
    component = defaultComponent$1,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$W(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableFooterRoot, {
      as: component,
      className: clsx(classes.root, className),
      ref,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState,
      ...other
    })
  });
});
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableHead", slot);
}
generateUtilityClasses$1("MuiTableHead", ["root"]);
const useUtilityClasses$V = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const {
    className,
    component = defaultComponent,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$V(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, {
      as: component,
      className: clsx(classes.root, className),
      ref,
      role: component === defaultComponent ? null : "rowgroup",
      ownerState,
      ...other
    })
  });
});
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass$1("MuiFormControlLabel", slot);
}
const formControlLabelClasses = generateUtilityClasses$1("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]);
const useUtilityClasses$U = (ownerState) => {
  const {
    classes,
    disabled,
    labelPlacement,
    error,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize$1(labelPlacement)}`, error && "error", required && "required"],
    label: ["label", disabled && "disabled"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses$1(slots, getFormControlLabelUtilityClasses, classes);
};
const FormControlLabelRoot = styled("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses.label}`]: styles2.label
    }, styles2.root, styles2[`labelPlacement${capitalize$1(ownerState.labelPlacement)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${formControlLabelClasses.disabled}`]: {
    cursor: "default"
  },
  [`& .${formControlLabelClasses.label}`]: {
    [`&.${formControlLabelClasses.disabled}`]: {
      color: (theme.vars || theme).palette.text.disabled
    }
  },
  variants: [{
    props: {
      labelPlacement: "start"
    },
    style: {
      flexDirection: "row-reverse",
      marginRight: -11
    }
  }, {
    props: {
      labelPlacement: "top"
    },
    style: {
      flexDirection: "column-reverse"
    }
  }, {
    props: {
      labelPlacement: "bottom"
    },
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      labelPlacement
    }) => labelPlacement === "start" || labelPlacement === "top" || labelPlacement === "bottom",
    style: {
      marginLeft: 16
      // used for row presentation of radio/checkbox
    }
  }]
})));
const AsteriskComponent = styled("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(memoTheme(({
  theme
}) => ({
  [`&.${formControlLabelClasses.error}`]: {
    color: (theme.vars || theme).palette.error.main
  }
})));
const FormControlLabel = /* @__PURE__ */ reactExports.forwardRef(function FormControlLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControlLabel"
  });
  const {
    checked,
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    inputRef,
    label: labelProp,
    labelPlacement = "end",
    name,
    onChange,
    required: requiredProp,
    slots = {},
    slotProps = {},
    value,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  const disabled = disabledProp ?? control.props.disabled ?? (muiFormControl == null ? void 0 : muiFormControl.disabled);
  const required = requiredProp ?? control.props.required;
  const controlProps = {
    disabled,
    required
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
      controlProps[key] = props[key];
    }
  });
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = {
    ...props,
    disabled,
    labelPlacement,
    required,
    error: fcs.error
  };
  const classes = useUtilityClasses$U(ownerState);
  const externalForwardedProps = {
    slots,
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [TypographySlot, typographySlotProps] = useSlot("typography", {
    elementType: Typography,
    externalForwardedProps,
    ownerState
  });
  let label = labelProp;
  if (label != null && label.type !== Typography && !disableTypography) {
    label = /* @__PURE__ */ jsxRuntimeExports.jsx(TypographySlot, {
      component: "span",
      ...typographySlotProps,
      className: clsx(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
      children: label
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControlLabelRoot, {
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other,
    children: [/* @__PURE__ */ reactExports.cloneElement(control, controlProps), required ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      children: [label, /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
        ownerState,
        "aria-hidden": true,
        className: classes.asterisk,
        children: [" ", "*"]
      })]
    }) : label]
  });
});
function stripDiacritics(string) {
  return string.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function createFilterOptions(config2 = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify: stringify2,
    trim: trim2 = false
  } = config2;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim2 ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = !input ? options : options.filter((option) => {
      let candidate = (stringify2 || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
const defaultFilterOptions = createFilterOptions();
const pageSize = 5;
const defaultIsActiveElementInListbox = (listboxRef) => {
  var _a2;
  return listboxRef.current !== null && ((_a2 = listboxRef.current.parentElement) == null ? void 0 : _a2.contains(document.activeElement));
};
const MULTIPLE_DEFAULT_VALUE = [];
function useAutocomplete(props) {
  const {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_classNamePrefix = "Mui",
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName = "useAutocomplete",
    defaultValue = props.multiple ? MULTIPLE_DEFAULT_VALUE : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionKey,
    getOptionLabel: getOptionLabelProp = (option) => option.label ?? option,
    groupBy: groupBy2,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = (option, value2) => option === value2,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id2 = useId$1(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = reactExports.useRef(false);
  const firstFocus = reactExports.useRef(true);
  const inputRef = reactExports.useRef(null);
  const listboxRef = reactExports.useRef(null);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [focusedTag, setFocusedTag] = reactExports.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled$1({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  });
  const [inputValue, setInputValueState] = useControlled$1({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  });
  const [focused, setFocused] = reactExports.useState(false);
  const resetInputValue = reactExports.useCallback((event, newValue, reason) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, reason);
    }
  }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const [open, setOpenState] = useControlled$1({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  });
  const [inputPristine, setInputPristine] = reactExports.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  const popupOpen = open && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  const previousProps = usePreviousProps({
    filteredOptions,
    value,
    inputValue
  });
  reactExports.useEffect(() => {
    const valueChange = value !== previousProps.value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value, "reset");
  }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
  const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
  const focusTag = useEventCallback$1((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  reactExports.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index, direction) {
    if (!listboxRef.current || index < 0 || index >= filteredOptions.length) {
      return -1;
    }
    let nextFocus = index;
    while (true) {
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && option.hasAttribute("tabindex") && !nextFocusDisabled) {
        return nextFocus;
      }
      if (direction === "next") {
        nextFocus = (nextFocus + 1) % filteredOptions.length;
      } else {
        nextFocus = (nextFocus - 1 + filteredOptions.length) % filteredOptions.length;
      }
      if (nextFocus === index) {
        return -1;
      }
    }
  }
  const setHighlightedIndex = useEventCallback$1(({
    event,
    index,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index;
    if (index === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id2}-option-${index}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev2 = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
    if (prev2) {
      prev2.classList.remove(`${unstable_classNamePrefix}-focused`);
      prev2.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
    }
    let listboxNode = listboxRef.current;
    if (listboxRef.current.getAttribute("role") !== "listbox") {
      listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    }
    if (!listboxNode) {
      return;
    }
    if (index === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
    if (!option) {
      return;
    }
    option.classList.add(`${unstable_classNamePrefix}-focused`);
    if (reason === "keyboard") {
      option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse" && reason !== "touch") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy2 ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy2 ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback$1(({
    event,
    diff,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  const getPreviousHighlightedOptionIndex = () => {
    const isSameValue = (value1, value2) => {
      const label1 = value1 ? getOptionLabel(value1) : "";
      const label2 = value2 ? getOptionLabel(value2) : "";
      return label1 === label2;
    };
    if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i2) => getOptionLabel(value[i2]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
      const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
      if (previousHighlightedOption) {
        return filteredOptions.findIndex((option) => {
          return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
        });
      }
    }
    return -1;
  };
  const syncHighlightedIndex = reactExports.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    const previousHighlightedOptionIndex = getPreviousHighlightedOptionIndex();
    if (previousHighlightedOptionIndex !== -1) {
      highlightedIndexRef.current = previousHighlightedOptionIndex;
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && value.findIndex((val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = filteredOptions.findIndex((optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  const handleListboxRef = useEventCallback$1((node2) => {
    setRef$1(listboxRef, node2);
    if (!node2) {
      return;
    }
    syncHighlightedIndex();
  });
  reactExports.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i2) => val === newValue[i2])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = reactExports.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = newValue.findIndex((valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue, reason);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index, direction) {
    if (index === -1) {
      return -1;
    }
    let nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction) => {
    if (!multiple) {
      return;
    }
    if (inputValue === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue === "" && value.length > 0) {
            const index = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index]
            });
          }
          break;
        case "Delete":
          if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
            const index = focusedTag;
            const newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index]
            });
          }
          break;
      }
    }
  };
  const handleFocus = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur = (event) => {
    if (unstable_isActiveElementInListbox(listboxRef)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value, "blur");
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseMove = (event) => {
    const index = Number(event.currentTarget.getAttribute("data-option-index"));
    if (highlightedIndexRef.current !== index) {
      setHighlightedIndex({
        event,
        index,
        reason: "mouse"
      });
    }
  };
  const handleOptionTouchStart = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "touch"
    });
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index) => (event) => {
    const newValue = value.slice();
    newValue.splice(index, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    if (event.target.getAttribute("id") !== id2) {
      event.preventDefault();
    }
  };
  const handleClick = (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (!disabledProp && (inputValue === "" || !open)) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy2) {
    groupedOptions = filteredOptions.reduce((acc, option, index) => {
      const group = groupBy2(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        acc.push({
          key: index,
          index,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur();
  }
  return {
    getRootProps: (other = {}) => ({
      "aria-owns": listboxAvailable ? `${id2}-listbox` : null,
      ...other,
      onKeyDown: handleKeyDown(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id2}-label`,
      htmlFor: id2
    }),
    getInputProps: () => ({
      id: id2,
      value: inputValue,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperatively so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id2}-listbox` : void 0,
      "aria-expanded": listboxAvailable,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox",
      disabled: disabledProp
    }),
    getClearProps: () => ({
      tabIndex: -1,
      type: "button",
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      type: "button",
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index
    }) => ({
      key: index,
      "data-tag-index": index,
      tabIndex: -1,
      ...!readOnly && {
        onDelete: handleTagDelete(index)
      }
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id2}-listbox`,
      "aria-labelledby": `${id2}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index,
      option
    }) => {
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: (getOptionKey == null ? void 0 : getOptionKey(option)) ?? getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id2}-option-${index}`,
        onMouseMove: handleOptionMouseMove,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id: id2,
    inputValue,
    value,
    dirty,
    expanded: popupOpen && anchorEl,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
function getListSubheaderUtilityClass(slot) {
  return generateUtilityClass$1("MuiListSubheader", slot);
}
generateUtilityClasses$1("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const useUtilityClasses$T = (ownerState) => {
  const {
    classes,
    color: color2,
    disableGutters,
    inset,
    disableSticky
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "default" && `color${capitalize$1(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
  };
  return composeClasses$1(slots, getListSubheaderUtilityClass, classes);
};
const ListSubheaderRoot = styled("li", {
  name: "MuiListSubheader",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
  }
})(memoTheme(({
  theme
}) => ({
  boxSizing: "border-box",
  lineHeight: "48px",
  listStyle: "none",
  color: (theme.vars || theme).palette.text.secondary,
  fontFamily: theme.typography.fontFamily,
  fontWeight: theme.typography.fontWeightMedium,
  fontSize: theme.typography.pxToRem(14),
  variants: [{
    props: {
      color: "primary"
    },
    style: {
      color: (theme.vars || theme).palette.primary.main
    }
  }, {
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.inset,
    style: {
      paddingLeft: 72
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disableSticky,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 1,
      backgroundColor: (theme.vars || theme).palette.background.paper
    }
  }]
})));
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(function ListSubheader2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListSubheader"
  });
  const {
    className,
    color: color2 = "default",
    component = "li",
    disableGutters = false,
    disableSticky = false,
    inset = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    component,
    disableGutters,
    disableSticky,
    inset
  };
  const classes = useUtilityClasses$T(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListSubheaderRoot, {
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState,
    ...other
  });
});
if (ListSubheader) {
  ListSubheader.muiSkipListHighlight = true;
}
const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function getChipUtilityClass(slot) {
  return generateUtilityClass$1("MuiChip", slot);
}
const chipClasses = generateUtilityClasses$1("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorDefault", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const useUtilityClasses$S = (ownerState) => {
  const {
    classes,
    disabled,
    size: size2,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize$1(size2)}`, `color${capitalize$1(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize$1(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize$1(color2)}`, `${variant}${capitalize$1(color2)}`],
    label: ["label", `label${capitalize$1(size2)}`],
    avatar: ["avatar", `avatar${capitalize$1(size2)}`, `avatarColor${capitalize$1(color2)}`],
    icon: ["icon", `icon${capitalize$1(size2)}`, `iconColor${capitalize$1(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize$1(size2)}`, `deleteIconColor${capitalize$1(color2)}`, `deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
  };
  return composeClasses$1(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size: size2,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatar${capitalize$1(size2)}`]
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatarColor${capitalize$1(color2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses.icon}`]: styles2[`icon${capitalize$1(size2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2[`iconColor${capitalize$1(iconColor)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(size2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIconColor${capitalize$1(color2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
    }, styles2.root, styles2[`size${capitalize$1(size2)}`], styles2[`color${capitalize$1(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize$1(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize$1(color2)}`], styles2[variant], styles2[`${variant}${capitalize$1(color2)}`]];
  }
})(memoTheme(({
  theme
}) => {
  const textColor = theme.palette.mode === "light" ? theme.palette.grey[700] : theme.palette.grey[300];
  return {
    maxWidth: "100%",
    fontFamily: theme.typography.fontFamily,
    fontSize: theme.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (theme.vars || theme).palette.text.primary,
    backgroundColor: (theme.vars || theme).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme.transitions.create(["background-color", "box-shadow"]),
    // reset cursor explicitly in case ButtonBase is used
    cursor: "unset",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme.vars ? theme.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme.typography.pxToRem(12)
    },
    [`& .${chipClasses.avatarColorPrimary}`]: {
      color: (theme.vars || theme).palette.primary.contrastText,
      backgroundColor: (theme.vars || theme).palette.primary.dark
    },
    [`& .${chipClasses.avatarColorSecondary}`]: {
      color: (theme.vars || theme).palette.secondary.contrastText,
      backgroundColor: (theme.vars || theme).palette.secondary.dark
    },
    [`& .${chipClasses.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme.typography.pxToRem(10)
    },
    [`& .${chipClasses.icon}`]: {
      marginLeft: 5,
      marginRight: -6
    },
    [`& .${chipClasses.deleteIcon}`]: {
      WebkitTapHighlightColor: "transparent",
      color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme.palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme.palette.text.primary, 0.4)
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        height: 24,
        [`& .${chipClasses.icon}`]: {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        },
        [`& .${chipClasses.deleteIcon}`]: {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }
      }
    }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.contrastText).map(([color2]) => {
      return {
        props: {
          color: color2
        },
        style: {
          backgroundColor: (theme.vars || theme).palette[color2].main,
          color: (theme.vars || theme).palette[color2].contrastText,
          [`& .${chipClasses.deleteIcon}`]: {
            color: theme.vars ? `rgba(${theme.vars.palette[color2].contrastTextChannel} / 0.7)` : alpha(theme.palette[color2].contrastText, 0.7),
            "&:hover, &:active": {
              color: (theme.vars || theme).palette[color2].contrastText
            }
          }
        }
      };
    }), {
      props: (props) => props.iconColor === props.color,
      style: {
        [`& .${chipClasses.icon}`]: {
          color: theme.vars ? theme.vars.palette.Chip.defaultIconColor : textColor
        }
      }
    }, {
      props: (props) => props.iconColor === props.color && props.color !== "default",
      style: {
        [`& .${chipClasses.icon}`]: {
          color: "inherit"
        }
      }
    }, {
      props: {
        onDelete: true
      },
      style: {
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      }
    }, ...Object.entries(theme.palette).filter(([, value]) => value && value.dark).map(([color2]) => {
      return {
        props: {
          color: color2,
          onDelete: true
        },
        style: {
          [`&.${chipClasses.focusVisible}`]: {
            background: (theme.vars || theme).palette[color2].dark
          }
        }
      };
    }), {
      props: {
        clickable: true
      },
      style: {
        userSelect: "none",
        WebkitTapHighlightColor: "transparent",
        cursor: "pointer",
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        },
        "&:active": {
          boxShadow: (theme.vars || theme).shadows[1]
        }
      }
    }, ...Object.entries(theme.palette).filter(([, value]) => value && value.dark).map(([color2]) => ({
      props: {
        color: color2,
        clickable: true
      },
      style: {
        [`&:hover, &.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette[color2].dark
        }
      }
    })), {
      props: {
        variant: "outlined"
      },
      style: {
        backgroundColor: "transparent",
        border: theme.vars ? `1px solid ${theme.vars.palette.Chip.defaultBorder}` : `1px solid ${theme.palette.mode === "light" ? theme.palette.grey[400] : theme.palette.grey[700]}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: (theme.vars || theme).palette.action.hover
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette.action.focus
        },
        [`& .${chipClasses.avatar}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.avatarSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.icon}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.iconSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.deleteIcon}`]: {
          marginRight: 5
        },
        [`& .${chipClasses.deleteIconSmall}`]: {
          marginRight: 3
        }
      }
    }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
      props: {
        variant: "outlined",
        color: color2
      },
      style: {
        color: (theme.vars || theme).palette[color2].main,
        border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.7)` : alpha(theme.palette[color2].main, 0.7)}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.focusOpacity)
        },
        [`& .${chipClasses.deleteIcon}`]: {
          color: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.7)` : alpha(theme.palette[color2].main, 0.7),
          "&:hover, &:active": {
            color: (theme.vars || theme).palette[color2].main
          }
        }
      }
    }))]
  };
}));
const ChipLabel = styled("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size: size2
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize$1(size2)}`]];
  }
})({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      variant: "outlined"
    },
    style: {
      paddingLeft: 11,
      paddingRight: 11
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingLeft: 8,
      paddingRight: 8
    }
  }, {
    props: {
      size: "small",
      variant: "outlined"
    },
    style: {
      paddingLeft: 7,
      paddingRight: 7
    }
  }]
});
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiChip"
  });
  const {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size: size2 = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false,
    // TODO v6: Rename to `focusableWhenDisabled`.
    ...other
  } = props;
  const chipRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(chipRef, ref);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
  const ownerState = {
    ...props,
    component,
    disabled,
    size: size2,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  };
  const classes = useUtilityClasses$S(ownerState);
  const moreProps = component === ButtonBase ? {
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible,
    ...onDelete && {
      disableRipple: true
    }
  } : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: clsx(classes.deleteIcon),
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, {
    as: component,
    className: clsx(classes.root, className),
    disabled: clickable && disabled ? true : void 0,
    onClick,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    ref: handleRef,
    tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
    ownerState,
    ...moreProps,
    ...other,
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
      className: clsx(classes.label),
      ownerState,
      children: label
    }), deleteIcon]
  });
});
const CloseIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
function getAutocompleteUtilityClass(slot) {
  return generateUtilityClass$1("MuiAutocomplete", slot);
}
const autocompleteClasses = generateUtilityClasses$1("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
var _ClearIcon, _ArrowDropDownIcon;
const useUtilityClasses$R = (ownerState) => {
  const {
    classes,
    disablePortal,
    expanded,
    focused,
    fullWidth,
    hasClearIcon,
    hasPopupIcon,
    inputFocused,
    popupOpen,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
    inputRoot: ["inputRoot"],
    input: ["input", inputFocused && "inputFocused"],
    tag: ["tag", `tagSize${capitalize$1(size2)}`],
    endAdornment: ["endAdornment"],
    clearIndicator: ["clearIndicator"],
    popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
    popper: ["popper", disablePortal && "popperDisablePortal"],
    paper: ["paper"],
    listbox: ["listbox"],
    loading: ["loading"],
    noOptions: ["noOptions"],
    option: ["option"],
    groupLabel: ["groupLabel"],
    groupUl: ["groupUl"]
  };
  return composeClasses$1(slots, getAutocompleteUtilityClass, classes);
};
const AutocompleteRoot = styled("div", {
  name: "MuiAutocomplete",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      fullWidth,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      size: size2
    } = ownerState;
    return [{
      [`& .${autocompleteClasses.tag}`]: styles2.tag
    }, {
      [`& .${autocompleteClasses.tag}`]: styles2[`tagSize${capitalize$1(size2)}`]
    }, {
      [`& .${autocompleteClasses.inputRoot}`]: styles2.inputRoot
    }, {
      [`& .${autocompleteClasses.input}`]: styles2.input
    }, {
      [`& .${autocompleteClasses.input}`]: inputFocused && styles2.inputFocused
    }, styles2.root, fullWidth && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
  }
})({
  [`&.${autocompleteClasses.focused} .${autocompleteClasses.clearIndicator}`]: {
    visibility: "visible"
  },
  /* Avoid double tap issue on iOS */
  "@media (pointer: fine)": {
    [`&:hover .${autocompleteClasses.clearIndicator}`]: {
      visibility: "visible"
    }
  },
  [`& .${autocompleteClasses.tag}`]: {
    margin: 3,
    maxWidth: "calc(100% - 6px)"
  },
  [`& .${autocompleteClasses.inputRoot}`]: {
    [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 26 + 4
    },
    [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 52 + 4
    },
    [`& .${autocompleteClasses.input}`]: {
      width: 0,
      minWidth: 30
    }
  },
  [`& .${inputClasses.root}`]: {
    paddingBottom: 1,
    "& .MuiInput-input": {
      padding: "4px 4px 4px 0px"
    }
  },
  [`& .${inputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    [`& .${inputClasses.input}`]: {
      padding: "2px 4px 3px 0"
    }
  },
  [`& .${outlinedInputClasses.root}`]: {
    padding: 9,
    [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${autocompleteClasses.input}`]: {
      padding: "7.5px 4px 7.5px 5px"
    },
    [`& .${autocompleteClasses.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${outlinedInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    // Don't specify paddingRight, as it overrides the default value set when there is only
    // one of the popup or clear icon as the specificity is equal so the latter one wins
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 6,
    [`& .${autocompleteClasses.input}`]: {
      padding: "2.5px 4px 2.5px 8px"
    }
  },
  [`& .${filledInputClasses.root}`]: {
    paddingTop: 19,
    paddingLeft: 8,
    [`.${autocompleteClasses.hasPopupIcon}&, .${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses.hasPopupIcon}.${autocompleteClasses.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${filledInputClasses.input}`]: {
      padding: "7px 4px"
    },
    [`& .${autocompleteClasses.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.sizeSmall}`]: {
    paddingBottom: 1,
    [`& .${filledInputClasses.input}`]: {
      padding: "2.5px 4px"
    }
  },
  [`& .${inputBaseClasses.hiddenLabel}`]: {
    paddingTop: 8
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}`]: {
    paddingTop: 0,
    paddingBottom: 0,
    [`& .${autocompleteClasses.input}`]: {
      paddingTop: 16,
      paddingBottom: 17
    }
  },
  [`& .${filledInputClasses.root}.${inputBaseClasses.hiddenLabel}.${inputBaseClasses.sizeSmall}`]: {
    [`& .${autocompleteClasses.input}`]: {
      paddingTop: 8,
      paddingBottom: 9
    }
  },
  [`& .${autocompleteClasses.input}`]: {
    flexGrow: 1,
    textOverflow: "ellipsis",
    opacity: 0
  },
  variants: [{
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      [`& .${autocompleteClasses.tag}`]: {
        margin: 2,
        maxWidth: "calc(100% - 4px)"
      }
    }
  }, {
    props: {
      inputFocused: true
    },
    style: {
      [`& .${autocompleteClasses.input}`]: {
        opacity: 1
      }
    }
  }, {
    props: {
      multiple: true
    },
    style: {
      [`& .${autocompleteClasses.inputRoot}`]: {
        flexWrap: "wrap"
      }
    }
  }]
});
const AutocompleteEndAdornment = styled("div", {
  name: "MuiAutocomplete",
  slot: "EndAdornment",
  overridesResolver: (props, styles2) => styles2.endAdornment
})({
  // We use a position absolute to support wrapping tags.
  position: "absolute",
  right: 0,
  top: "50%",
  transform: "translate(0, -50%)"
});
const AutocompleteClearIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "ClearIndicator",
  overridesResolver: (props, styles2) => styles2.clearIndicator
})({
  marginRight: -2,
  padding: 4,
  visibility: "hidden"
});
const AutocompletePopupIndicator = styled(IconButton, {
  name: "MuiAutocomplete",
  slot: "PopupIndicator",
  overridesResolver: ({
    ownerState
  }, styles2) => ({
    ...styles2.popupIndicator,
    ...ownerState.popupOpen && styles2.popupIndicatorOpen
  })
})({
  padding: 2,
  marginRight: -2,
  variants: [{
    props: {
      popupOpen: true
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
});
const AutocompletePopper = styled(Popper, {
  name: "MuiAutocomplete",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${autocompleteClasses.option}`]: styles2.option
    }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
  }
})(memoTheme(({
  theme
}) => ({
  zIndex: (theme.vars || theme).zIndex.modal,
  variants: [{
    props: {
      disablePortal: true
    },
    style: {
      position: "absolute"
    }
  }]
})));
const AutocompletePaper = styled(Paper, {
  name: "MuiAutocomplete",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body1,
  overflow: "auto"
})));
const AutocompleteLoading = styled("div", {
  name: "MuiAutocomplete",
  slot: "Loading",
  overridesResolver: (props, styles2) => styles2.loading
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  padding: "14px 16px"
})));
const AutocompleteNoOptions = styled("div", {
  name: "MuiAutocomplete",
  slot: "NoOptions",
  overridesResolver: (props, styles2) => styles2.noOptions
})(memoTheme(({
  theme
}) => ({
  color: (theme.vars || theme).palette.text.secondary,
  padding: "14px 16px"
})));
const AutocompleteListbox = styled("div", {
  name: "MuiAutocomplete",
  slot: "Listbox",
  overridesResolver: (props, styles2) => styles2.listbox
})(memoTheme(({
  theme
}) => ({
  listStyle: "none",
  margin: 0,
  padding: "8px 0",
  maxHeight: "40vh",
  overflow: "auto",
  position: "relative",
  [`& .${autocompleteClasses.option}`]: {
    minHeight: 48,
    display: "flex",
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "center",
    cursor: "pointer",
    paddingTop: 6,
    boxSizing: "border-box",
    outline: "0",
    WebkitTapHighlightColor: "transparent",
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    [theme.breakpoints.up("sm")]: {
      minHeight: "auto"
    },
    [`&.${autocompleteClasses.focused}`]: {
      backgroundColor: (theme.vars || theme).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    '&[aria-disabled="true"]': {
      opacity: (theme.vars || theme).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`&.${autocompleteClasses.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    '&[aria-selected="true"]': {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      [`&.${autocompleteClasses.focused}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme.vars || theme).palette.action.selected
        }
      },
      [`&.${autocompleteClasses.focusVisible}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    }
  }
})));
const AutocompleteGroupLabel = styled(ListSubheader, {
  name: "MuiAutocomplete",
  slot: "GroupLabel",
  overridesResolver: (props, styles2) => styles2.groupLabel
})(memoTheme(({
  theme
}) => ({
  backgroundColor: (theme.vars || theme).palette.background.paper,
  top: -8
})));
const AutocompleteGroupUl = styled("ul", {
  name: "MuiAutocomplete",
  slot: "GroupUl",
  overridesResolver: (props, styles2) => styles2.groupUl
})({
  padding: 0,
  [`& .${autocompleteClasses.option}`]: {
    paddingLeft: 24
  }
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(function Autocomplete2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAutocomplete"
  });
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    ChipProps: ChipPropsProp,
    className,
    clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {
      fontSize: "small"
    })),
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    clearText = "Clear",
    closeText = "Close",
    componentsProps,
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    disablePortal = false,
    filterOptions,
    filterSelectedOptions = false,
    forcePopupIcon = "auto",
    freeSolo = false,
    fullWidth = false,
    getLimitTagsText = (more) => `+${more}`,
    getOptionDisabled,
    getOptionKey,
    getOptionLabel: getOptionLabelProp,
    isOptionEqualToValue,
    groupBy: groupBy2,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    limitTags = -1,
    ListboxComponent: ListboxComponentProp,
    ListboxProps: ListboxPropsProp,
    loading = false,
    loadingText = "Loading…",
    multiple = false,
    noOptionsText = "No options",
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open,
    openOnFocus = false,
    openText = "Open",
    options,
    PaperComponent: PaperComponentProp,
    PopperComponent: PopperComponentProp,
    popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon$1, {})),
    readOnly = false,
    renderGroup: renderGroupProp,
    renderInput,
    renderOption: renderOptionProp,
    renderTags,
    selectOnFocus = !props.freeSolo,
    size: size2 = "medium",
    slots = {},
    slotProps = {},
    value: valueProp,
    ...other
  } = props;
  const {
    getRootProps,
    getInputProps,
    getInputLabelProps,
    getPopupIndicatorProps,
    getClearProps,
    getTagProps,
    getListboxProps,
    getOptionProps,
    value,
    dirty,
    expanded,
    id: id2,
    popupOpen,
    focused,
    focusedTag,
    anchorEl,
    setAnchorEl,
    inputValue,
    groupedOptions
  } = useAutocomplete({
    ...props,
    componentName: "Autocomplete"
  });
  const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
  const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  const {
    onMouseDown: handleInputMouseDown
  } = getInputProps();
  const {
    ref: listboxRef,
    ...otherListboxProps
  } = getListboxProps();
  const defaultGetOptionLabel = (option) => option.label ?? option;
  const getOptionLabel = getOptionLabelProp || defaultGetOptionLabel;
  const ownerState = {
    ...props,
    disablePortal,
    expanded,
    focused,
    fullWidth,
    getOptionLabel,
    hasClearIcon,
    hasPopupIcon,
    inputFocused: focusedTag === -1,
    popupOpen,
    size: size2
  };
  const classes = useUtilityClasses$R(ownerState);
  const externalForwardedProps = {
    slots: {
      listbox: ListboxComponentProp,
      paper: PaperComponentProp,
      popper: PopperComponentProp,
      ...slots
    },
    slotProps: {
      chip: ChipPropsProp,
      listbox: ListboxPropsProp,
      ...componentsProps,
      ...slotProps
    }
  };
  const [ListboxSlot, listboxProps] = useSlot("listbox", {
    elementType: "ul",
    externalForwardedProps,
    ownerState,
    className: classes.listbox,
    additionalProps: otherListboxProps,
    ref: listboxRef
  });
  const [PaperSlot, paperProps] = useSlot("paper", {
    elementType: Paper,
    externalForwardedProps,
    ownerState,
    className: classes.paper
  });
  const [PopperSlot, popperProps] = useSlot("popper", {
    elementType: Popper,
    externalForwardedProps,
    ownerState,
    className: classes.popper,
    additionalProps: {
      disablePortal,
      style: {
        width: anchorEl ? anchorEl.clientWidth : null
      },
      role: "presentation",
      anchorEl,
      open: popupOpen
    }
  });
  let startAdornment;
  if (multiple && value.length > 0) {
    const getCustomizedTagProps = (params) => ({
      className: classes.tag,
      disabled,
      ...getTagProps(params)
    });
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
    } else {
      startAdornment = value.map((option, index) => {
        const {
          key,
          ...customTagProps
        } = getCustomizedTagProps({
          index
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, {
          label: getOptionLabel(option),
          size: size2,
          ...customTagProps,
          ...externalForwardedProps.slotProps.chip
        }, key);
      });
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    const more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.tag,
        children: getLimitTagsText(more)
      }, startAdornment.length));
    }
  }
  const defaultRenderGroup = (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
      className: classes.groupLabel,
      ownerState,
      component: "div",
      children: params.group
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
      className: classes.groupUl,
      ownerState,
      children: params.children
    })]
  }, params.key);
  const renderGroup = renderGroupProp || defaultRenderGroup;
  const defaultRenderOption = (props2, option) => {
    const {
      key,
      ...otherProps
    } = props2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
      ...otherProps,
      children: getOptionLabel(option)
    }, key);
  };
  const renderOption = renderOptionProp || defaultRenderOption;
  const renderListOption = (option, index) => {
    const optionProps = getOptionProps({
      option,
      index
    });
    return renderOption({
      ...optionProps,
      className: classes.option
    }, option, {
      selected: optionProps["aria-selected"],
      index,
      inputValue
    }, ownerState);
  };
  const clearIndicatorSlotProps = externalForwardedProps.slotProps.clearIndicator;
  const popupIndicatorSlotProps = externalForwardedProps.slotProps.popupIndicator;
  const renderAutocompletePopperChildren = (children) => /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopper, {
    as: PopperSlot,
    ...popperProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePaper, {
      as: PaperSlot,
      ...paperProps,
      children
    })
  });
  let autocompletePopper = null;
  if (groupedOptions.length > 0) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteListbox, {
      as: ListboxSlot,
      ...listboxProps,
      children: groupedOptions.map((option, index) => {
        if (groupBy2) {
          return renderGroup({
            key: option.key,
            group: option.group,
            children: option.options.map((option2, index2) => renderListOption(option2, option.index + index2))
          });
        }
        return renderListOption(option, index);
      })
    }));
  } else if (loading && groupedOptions.length === 0) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
      className: classes.loading,
      ownerState,
      children: loadingText
    }));
  } else if (groupedOptions.length === 0 && !freeSolo && !loading) {
    autocompletePopper = renderAutocompletePopperChildren(/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
      className: classes.noOptions,
      ownerState,
      role: "presentation",
      onMouseDown: (event) => {
        event.preventDefault();
      },
      children: noOptionsText
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteRoot, {
      ref,
      className: clsx(classes.root, className),
      ownerState,
      ...getRootProps(other),
      children: renderInput({
        id: id2,
        disabled,
        fullWidth: true,
        size: size2 === "small" ? "small" : void 0,
        InputLabelProps: getInputLabelProps(),
        InputProps: {
          ref: setAnchorEl,
          className: classes.inputRoot,
          startAdornment,
          onClick: (event) => {
            if (event.target === event.currentTarget) {
              handleInputMouseDown(event);
            }
          },
          ...(hasClearIcon || hasPopupIcon) && {
            endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
              className: classes.endAdornment,
              ownerState,
              children: [hasClearIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteClearIndicator, {
                ...getClearProps(),
                "aria-label": clearText,
                title: clearText,
                ownerState,
                ...clearIndicatorSlotProps,
                className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
                children: clearIcon
              }) : null, hasPopupIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopupIndicator, {
                ...getPopupIndicatorProps(),
                disabled,
                "aria-label": popupOpen ? closeText : openText,
                title: popupOpen ? closeText : openText,
                ownerState,
                ...popupIndicatorSlotProps,
                className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
                children: popupIcon
              }) : null]
            })
          }
        },
        inputProps: {
          className: classes.input,
          disabled,
          readOnly,
          ...getInputProps()
        }
      })
    }), anchorEl ? autocompletePopper : null]
  });
});
function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass$1("MuiInputAdornment", slot);
}
const inputAdornmentClasses = generateUtilityClasses$1("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var _span;
const overridesResolver$3 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[`position${capitalize$1(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
};
const useUtilityClasses$Q = (ownerState) => {
  const {
    classes,
    disablePointerEvents,
    hiddenLabel,
    position: position2,
    size: size2,
    variant
  } = ownerState;
  const slots = {
    root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize$1(position2)}`, variant, hiddenLabel && "hiddenLabel", size2 && `size${capitalize$1(size2)}`]
  };
  return composeClasses$1(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: overridesResolver$3
})(memoTheme(({
  theme
}) => ({
  display: "flex",
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (theme.vars || theme).palette.action.active,
  variants: [{
    props: {
      variant: "filled"
    },
    style: {
      [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
        marginTop: 16
      }
    }
  }, {
    props: {
      position: "start"
    },
    style: {
      marginRight: 8
    }
  }, {
    props: {
      position: "end"
    },
    style: {
      marginLeft: 8
    }
  }, {
    props: {
      disablePointerEvents: true
    },
    style: {
      pointerEvents: "none"
    }
  }]
})));
const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputAdornment"
  });
  const {
    children,
    className,
    component = "div",
    disablePointerEvents = false,
    disableTypography = false,
    position: position2,
    variant: variantProp,
    ...other
  } = props;
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant) ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = {
    ...props,
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position: position2,
    variant
  };
  const classes = useUtilityClasses$Q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: null,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, {
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref,
      ...other,
      children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        color: "textSecondary",
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [position2 === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : null, children]
      })
    })
  });
});
function formatMuiErrorMessage(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
const refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue2] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue2(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref = reactExports.useRef(fn2);
  useEnhancedEffect(() => {
    ref.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          const utilityClass = getUtilityClass(key);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$1({}, otherProps, {
    ownerState: _extends$1({}, otherProps.ownerState, ownerState)
  });
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
const _excluded$L = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$L);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$1({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
const areViewsEqual = (views, expectedViews) => {
  if (views.length !== expectedViews.length) {
    return false;
  }
  return expectedViews.every((expectedView) => views.includes(expectedView));
};
const applyDefaultViewProps = ({
  openTo,
  defaultOpenTo,
  views,
  defaultViews
}) => {
  const viewsWithDefault = views ?? defaultViews;
  let openToWithDefault;
  if (openTo != null) {
    openToWithDefault = openTo;
  } else if (viewsWithDefault.includes(defaultOpenTo)) {
    openToWithDefault = defaultOpenTo;
  } else if (viewsWithDefault.length > 0) {
    openToWithDefault = viewsWithDefault[0];
  } else {
    throw new Error("MUI X: The `views` prop must contain at least one view.");
  }
  return {
    views: viewsWithDefault,
    openTo: openToWithDefault
  };
};
const mergeDateAndTime = (utils2, dateParam, timeParam) => {
  let mergedDate = dateParam;
  mergedDate = utils2.setHours(mergedDate, utils2.getHours(timeParam));
  mergedDate = utils2.setMinutes(mergedDate, utils2.getMinutes(timeParam));
  mergedDate = utils2.setSeconds(mergedDate, utils2.getSeconds(timeParam));
  mergedDate = utils2.setMilliseconds(mergedDate, utils2.getMilliseconds(timeParam));
  return mergedDate;
};
const findClosestEnabledDate = ({
  date,
  disableFuture,
  disablePast,
  maxDate,
  minDate,
  isDateDisabled,
  utils: utils2,
  timezone
}) => {
  const today = mergeDateAndTime(utils2, utils2.date(void 0, timezone), date);
  if (disablePast && utils2.isBefore(minDate, today)) {
    minDate = today;
  }
  if (disableFuture && utils2.isAfter(maxDate, today)) {
    maxDate = today;
  }
  let forward = date;
  let backward = date;
  if (utils2.isBefore(date, minDate)) {
    forward = minDate;
    backward = null;
  }
  if (utils2.isAfter(date, maxDate)) {
    if (backward) {
      backward = maxDate;
    }
    forward = null;
  }
  while (forward || backward) {
    if (forward && utils2.isAfter(forward, maxDate)) {
      forward = null;
    }
    if (backward && utils2.isBefore(backward, minDate)) {
      backward = null;
    }
    if (forward) {
      if (!isDateDisabled(forward)) {
        return forward;
      }
      forward = utils2.addDays(forward, 1);
    }
    if (backward) {
      if (!isDateDisabled(backward)) {
        return backward;
      }
      backward = utils2.addDays(backward, -1);
    }
  }
  return null;
};
const replaceInvalidDateByNull = (utils2, value) => value == null || !utils2.isValid(value) ? null : value;
const applyDefaultDate = (utils2, value, defaultValue) => {
  if (value == null || !utils2.isValid(value)) {
    return defaultValue;
  }
  return value;
};
const areDatesEqual = (utils2, a3, b3) => {
  if (!utils2.isValid(a3) && a3 != null && !utils2.isValid(b3) && b3 != null) {
    return true;
  }
  return utils2.isEqual(a3, b3);
};
const getMonthsInYear = (utils2, year) => {
  const firstMonth = utils2.startOfYear(year);
  const months = [firstMonth];
  while (months.length < 12) {
    const prevMonth = months[months.length - 1];
    months.push(utils2.addMonths(prevMonth, 1));
  }
  return months;
};
const getTodayDate = (utils2, timezone, valueType) => valueType === "date" ? utils2.startOfDay(utils2.date(void 0, timezone)) : utils2.date(void 0, timezone);
const formatMeridiem = (utils2, meridiem) => {
  const date = utils2.setHours(utils2.date(), meridiem === "am" ? 2 : 14);
  return utils2.format(date, "meridiem");
};
const dateViews = ["year", "month", "day"];
const isDatePickerView = (view) => dateViews.includes(view);
const resolveDateFormat = (utils2, {
  format: format2,
  views
}, isInToolbar) => {
  if (format2 != null) {
    return format2;
  }
  const formats = utils2.formats;
  if (areViewsEqual(views, ["year"])) {
    return formats.year;
  }
  if (areViewsEqual(views, ["month"])) {
    return formats.month;
  }
  if (areViewsEqual(views, ["day"])) {
    return formats.dayOfMonth;
  }
  if (areViewsEqual(views, ["month", "year"])) {
    return `${formats.month} ${formats.year}`;
  }
  if (areViewsEqual(views, ["day", "month"])) {
    return `${formats.month} ${formats.dayOfMonth}`;
  }
  if (isInToolbar) {
    return /en/.test(utils2.getCurrentLocaleCode()) ? formats.normalDateWithWeekday : formats.normalDate;
  }
  return formats.keyboardDate;
};
const getWeekdays = (utils2, date) => {
  const start2 = utils2.startOfWeek(date);
  return [0, 1, 2, 3, 4, 5, 6].map((diff) => utils2.addDays(start2, diff));
};
const timeViews = ["hours", "minutes", "seconds"];
const isTimeView = (view) => timeViews.includes(view);
const isInternalTimeView = (view) => timeViews.includes(view) || view === "meridiem";
const getMeridiem = (date, utils2) => {
  if (!date) {
    return null;
  }
  return utils2.getHours(date) >= 12 ? "pm" : "am";
};
const convertValueToMeridiem = (value, meridiem, ampm) => {
  if (ampm) {
    const currentMeridiem = value >= 12 ? "pm" : "am";
    if (currentMeridiem !== meridiem) {
      return meridiem === "am" ? value - 12 : value + 12;
    }
  }
  return value;
};
const convertToMeridiem = (time2, meridiem, ampm, utils2) => {
  const newHoursAmount = convertValueToMeridiem(utils2.getHours(time2), meridiem, ampm);
  return utils2.setHours(time2, newHoursAmount);
};
const getSecondsInDay = (date, utils2) => {
  return utils2.getHours(date) * 3600 + utils2.getMinutes(date) * 60 + utils2.getSeconds(date);
};
const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils2) => (dateLeft, dateRight) => {
  if (disableIgnoringDatePartForTimeValidation) {
    return utils2.isAfter(dateLeft, dateRight);
  }
  return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
};
const resolveTimeFormat = (utils2, {
  format: format2,
  views,
  ampm
}) => {
  if (format2 != null) {
    return format2;
  }
  const formats = utils2.formats;
  if (areViewsEqual(views, ["hours"])) {
    return ampm ? `${formats.hours12h} ${formats.meridiem}` : formats.hours24h;
  }
  if (areViewsEqual(views, ["minutes"])) {
    return formats.minutes;
  }
  if (areViewsEqual(views, ["seconds"])) {
    return formats.seconds;
  }
  if (areViewsEqual(views, ["minutes", "seconds"])) {
    return `${formats.minutes}:${formats.seconds}`;
  }
  if (areViewsEqual(views, ["hours", "minutes", "seconds"])) {
    return ampm ? `${formats.hours12h}:${formats.minutes}:${formats.seconds} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}:${formats.seconds}`;
  }
  return ampm ? `${formats.hours12h}:${formats.minutes} ${formats.meridiem}` : `${formats.hours24h}:${formats.minutes}`;
};
const SECTION_TYPE_GRANULARITY = {
  year: 1,
  month: 2,
  day: 3,
  hours: 4,
  minutes: 5,
  seconds: 6,
  milliseconds: 7
};
const getSectionTypeGranularity = (sections) => Math.max(...sections.map((section) => SECTION_TYPE_GRANULARITY[section.type] ?? 1));
const roundDate = (utils2, granularity, date) => {
  if (granularity === SECTION_TYPE_GRANULARITY.year) {
    return utils2.startOfYear(date);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.month) {
    return utils2.startOfMonth(date);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.day) {
    return utils2.startOfDay(date);
  }
  let roundedDate = date;
  if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
    roundedDate = utils2.setMinutes(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
    roundedDate = utils2.setSeconds(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
    roundedDate = utils2.setMilliseconds(roundedDate, 0);
  }
  return roundedDate;
};
const getDefaultReferenceDate = ({
  props,
  utils: utils2,
  granularity,
  timezone,
  getTodayDate: inGetTodayDate
}) => {
  let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils2, granularity, getTodayDate(utils2, timezone));
  if (props.minDate != null && utils2.isAfterDay(props.minDate, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.minDate);
  }
  if (props.maxDate != null && utils2.isBeforeDay(props.maxDate, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.maxDate);
  }
  const isAfter2 = createIsAfterIgnoreDatePart(props.disableIgnoringDatePartForTimeValidation ?? false, utils2);
  if (props.minTime != null && isAfter2(props.minTime, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils2, referenceDate, props.minTime));
  }
  if (props.maxTime != null && isAfter2(referenceDate, props.maxTime)) {
    referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils2, referenceDate, props.maxTime));
  }
  return referenceDate;
};
const getDateSectionConfigFromFormatToken = (utils2, formatToken) => {
  const config2 = utils2.formatTokenMap[formatToken];
  if (config2 == null) {
    throw new Error([`MUI X: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
  }
  if (typeof config2 === "string") {
    return {
      type: config2,
      contentType: config2 === "meridiem" ? "letter" : "digit",
      maxLength: void 0
    };
  }
  return {
    type: config2.sectionType,
    contentType: config2.contentType,
    maxLength: config2.maxLength
  };
};
const getDeltaFromKeyCode = (keyCode) => {
  switch (keyCode) {
    case "ArrowUp":
      return 1;
    case "ArrowDown":
      return -1;
    case "PageUp":
      return 5;
    case "PageDown":
      return -5;
    default:
      return 0;
  }
};
const getDaysInWeekStr = (utils2, timezone, format2) => {
  const elements = [];
  const now2 = utils2.date(void 0, timezone);
  const startDate = utils2.startOfWeek(now2);
  const endDate = utils2.endOfWeek(now2);
  let current = startDate;
  while (utils2.isBefore(current, endDate)) {
    elements.push(current);
    current = utils2.addDays(current, 1);
  }
  return elements.map((weekDay) => utils2.formatByString(weekDay, format2));
};
const getLetterEditingOptions = (utils2, timezone, sectionType, format2) => {
  switch (sectionType) {
    case "month": {
      return getMonthsInYear(utils2, utils2.date(void 0, timezone)).map((month) => utils2.formatByString(month, format2));
    }
    case "weekDay": {
      return getDaysInWeekStr(utils2, timezone, format2);
    }
    case "meridiem": {
      const now2 = utils2.date(void 0, timezone);
      return [utils2.startOfDay(now2), utils2.endOfDay(now2)].map((date) => utils2.formatByString(date, format2));
    }
    default: {
      return [];
    }
  }
};
const FORMAT_SECONDS_NO_LEADING_ZEROS = "s";
const NON_LOCALIZED_DIGITS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
const getLocalizedDigits = (utils2) => {
  const today = utils2.date(void 0);
  const formattedZero = utils2.formatByString(utils2.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);
  if (formattedZero === "0") {
    return NON_LOCALIZED_DIGITS;
  }
  return Array.from({
    length: 10
  }).map((_, index) => utils2.formatByString(utils2.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));
};
const removeLocalizedDigits = (valueStr, localizedDigits) => {
  if (localizedDigits[0] === "0") {
    return valueStr;
  }
  const digits = [];
  let currentFormattedDigit = "";
  for (let i2 = 0; i2 < valueStr.length; i2 += 1) {
    currentFormattedDigit += valueStr[i2];
    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);
    if (matchingDigitIndex > -1) {
      digits.push(matchingDigitIndex.toString());
      currentFormattedDigit = "";
    }
  }
  return digits.join("");
};
const applyLocalizedDigits = (valueStr, localizedDigits) => {
  if (localizedDigits[0] === "0") {
    return valueStr;
  }
  return valueStr.split("").map((char2) => localizedDigits[Number(char2)]).join("");
};
const isStringNumber = (valueStr, localizedDigits) => {
  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);
  return nonLocalizedValueStr !== " " && !Number.isNaN(Number(nonLocalizedValueStr));
};
const cleanLeadingZeros = (valueStr, size2) => {
  let cleanValueStr = valueStr;
  cleanValueStr = Number(cleanValueStr).toString();
  while (cleanValueStr.length < size2) {
    cleanValueStr = `0${cleanValueStr}`;
  }
  return cleanValueStr;
};
const cleanDigitSectionValue = (utils2, value, sectionBoundaries, localizedDigits, section) => {
  if (section.type === "day" && section.contentType === "digit-with-letter") {
    const date = utils2.setDate(sectionBoundaries.longestMonth, value);
    return utils2.formatByString(date, section.format);
  }
  let valueStr = value.toString();
  if (section.hasLeadingZerosInInput) {
    valueStr = cleanLeadingZeros(valueStr, section.maxLength);
  }
  return applyLocalizedDigits(valueStr, localizedDigits);
};
const adjustSectionValue = (utils2, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {
  const delta = getDeltaFromKeyCode(keyCode);
  const isStart = keyCode === "Home";
  const isEnd = keyCode === "End";
  const shouldSetAbsolute = section.value === "" || isStart || isEnd;
  const adjustDigitSection = () => {
    const sectionBoundaries = sectionsValueBoundaries[section.type]({
      currentDate: activeDate,
      format: section.format,
      contentType: section.contentType
    });
    const getCleanValue = (value) => cleanDigitSectionValue(utils2, value, sectionBoundaries, localizedDigits, section);
    const step = section.type === "minutes" && (stepsAttributes == null ? void 0 : stepsAttributes.minutesStep) ? stepsAttributes.minutesStep : 1;
    const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);
    let newSectionValueNumber = currentSectionValue + delta * step;
    if (shouldSetAbsolute) {
      if (section.type === "year" && !isEnd && !isStart) {
        return utils2.formatByString(utils2.date(void 0, timezone), section.format);
      }
      if (delta > 0 || isStart) {
        newSectionValueNumber = sectionBoundaries.minimum;
      } else {
        newSectionValueNumber = sectionBoundaries.maximum;
      }
    }
    if (newSectionValueNumber % step !== 0) {
      if (delta < 0 || isStart) {
        newSectionValueNumber += step - (step + newSectionValueNumber) % step;
      }
      if (delta > 0 || isEnd) {
        newSectionValueNumber -= newSectionValueNumber % step;
      }
    }
    if (newSectionValueNumber > sectionBoundaries.maximum) {
      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    if (newSectionValueNumber < sectionBoundaries.minimum) {
      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    return getCleanValue(newSectionValueNumber);
  };
  const adjustLetterSection = () => {
    const options = getLetterEditingOptions(utils2, timezone, section.type, section.format);
    if (options.length === 0) {
      return section.value;
    }
    if (shouldSetAbsolute) {
      if (delta > 0 || isStart) {
        return options[0];
      }
      return options[options.length - 1];
    }
    const currentOptionIndex = options.indexOf(section.value);
    const newOptionIndex = (currentOptionIndex + delta) % options.length;
    const clampedIndex = (newOptionIndex + options.length) % options.length;
    return options[clampedIndex];
  };
  if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
    return adjustDigitSection();
  }
  return adjustLetterSection();
};
const getSectionVisibleValue = (section, target, localizedDigits) => {
  let value = section.value || section.placeholder;
  const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
  if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();
  }
  const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
  if (shouldAddInvisibleSpace) {
    value = `${value}‎`;
  }
  if (target === "input-rtl") {
    value = `⁨${value}⁩`;
  }
  return value;
};
const changeSectionValueFormat = (utils2, valueStr, currentFormat, newFormat) => {
  return utils2.formatByString(utils2.parse(valueStr, currentFormat), newFormat);
};
const isFourDigitYearFormat = (utils2, timezone, format2) => utils2.formatByString(utils2.date(void 0, timezone), format2).length === 4;
const doesSectionFormatHaveLeadingZeros = (utils2, timezone, contentType, sectionType, format2) => {
  if (contentType !== "digit") {
    return false;
  }
  const now2 = utils2.date(void 0, timezone);
  switch (sectionType) {
    case "year": {
      if (isFourDigitYearFormat(utils2, timezone, format2)) {
        const formatted0001 = utils2.formatByString(utils2.setYear(now2, 1), format2);
        return formatted0001 === "0001";
      }
      const formatted2001 = utils2.formatByString(utils2.setYear(now2, 2001), format2);
      return formatted2001 === "01";
    }
    case "month": {
      return utils2.formatByString(utils2.startOfYear(now2), format2).length > 1;
    }
    case "day": {
      return utils2.formatByString(utils2.startOfMonth(now2), format2).length > 1;
    }
    case "weekDay": {
      return utils2.formatByString(utils2.startOfWeek(now2), format2).length > 1;
    }
    case "hours": {
      return utils2.formatByString(utils2.setHours(now2, 1), format2).length > 1;
    }
    case "minutes": {
      return utils2.formatByString(utils2.setMinutes(now2, 1), format2).length > 1;
    }
    case "seconds": {
      return utils2.formatByString(utils2.setSeconds(now2, 1), format2).length > 1;
    }
    default: {
      throw new Error("Invalid section type");
    }
  }
};
const getDateFromDateSections = (utils2, sections, localizedDigits) => {
  const shouldSkipWeekDays = sections.some((section) => section.type === "day");
  const sectionFormats = [];
  const sectionValues = [];
  for (let i2 = 0; i2 < sections.length; i2 += 1) {
    const section = sections[i2];
    const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
    if (!shouldSkip) {
      sectionFormats.push(section.format);
      sectionValues.push(getSectionVisibleValue(section, "non-input", localizedDigits));
    }
  }
  const formatWithoutSeparator = sectionFormats.join(" ");
  const dateWithoutSeparatorStr = sectionValues.join(" ");
  return utils2.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
};
const createDateStrForV7HiddenInputFromSections = (sections) => sections.map((section) => {
  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;
}).join("");
const createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {
  const formattedSections = sections.map((section) => {
    const dateValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
    return `${section.startSeparator}${dateValue}${section.endSeparator}`;
  });
  const dateStr = formattedSections.join("");
  if (!isRtl) {
    return dateStr;
  }
  return `⁦${dateStr}⁩`;
};
const getSectionsBoundaries = (utils2, localizedDigits, timezone) => {
  const today = utils2.date(void 0, timezone);
  const endOfYear = utils2.endOfYear(today);
  const endOfDay2 = utils2.endOfDay(today);
  const {
    maxDaysInMonth,
    longestMonth
  } = getMonthsInYear(utils2, today).reduce((acc, month) => {
    const daysInMonth = utils2.getDaysInMonth(month);
    if (daysInMonth > acc.maxDaysInMonth) {
      return {
        maxDaysInMonth: daysInMonth,
        longestMonth: month
      };
    }
    return acc;
  }, {
    maxDaysInMonth: 0,
    longestMonth: null
  });
  return {
    year: ({
      format: format2
    }) => ({
      minimum: 0,
      maximum: isFourDigitYearFormat(utils2, timezone, format2) ? 9999 : 99
    }),
    month: () => ({
      minimum: 1,
      // Assumption: All years have the same amount of months
      maximum: utils2.getMonth(endOfYear) + 1
    }),
    day: ({
      currentDate
    }) => ({
      minimum: 1,
      maximum: currentDate != null && utils2.isValid(currentDate) ? utils2.getDaysInMonth(currentDate) : maxDaysInMonth,
      longestMonth
    }),
    weekDay: ({
      format: format2,
      contentType
    }) => {
      if (contentType === "digit") {
        const daysInWeek = getDaysInWeekStr(utils2, timezone, format2).map(Number);
        return {
          minimum: Math.min(...daysInWeek),
          maximum: Math.max(...daysInWeek)
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: ({
      format: format2
    }) => {
      const lastHourInDay = utils2.getHours(endOfDay2);
      const hasMeridiem = removeLocalizedDigits(utils2.formatByString(utils2.endOfDay(today), format2), localizedDigits) !== lastHourInDay.toString();
      if (hasMeridiem) {
        return {
          minimum: 1,
          maximum: Number(removeLocalizedDigits(utils2.formatByString(utils2.startOfDay(today), format2), localizedDigits))
        };
      }
      return {
        minimum: 0,
        maximum: lastHourInDay
      };
    },
    minutes: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of minutes
      maximum: utils2.getMinutes(endOfDay2)
    }),
    seconds: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of seconds
      maximum: utils2.getSeconds(endOfDay2)
    }),
    meridiem: () => ({
      minimum: 0,
      maximum: 1
    }),
    empty: () => ({
      minimum: 0,
      maximum: 0
    })
  };
};
const transferDateSectionValue = (utils2, timezone, section, dateToTransferFrom, dateToTransferTo) => {
  switch (section.type) {
    case "year": {
      return utils2.setYear(dateToTransferTo, utils2.getYear(dateToTransferFrom));
    }
    case "month": {
      return utils2.setMonth(dateToTransferTo, utils2.getMonth(dateToTransferFrom));
    }
    case "weekDay": {
      const formattedDaysInWeek = getDaysInWeekStr(utils2, timezone, section.format);
      const dayInWeekStrOfActiveDate = utils2.formatByString(dateToTransferFrom, section.format);
      const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
      const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
      const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
      return utils2.addDays(dateToTransferFrom, diff);
    }
    case "day": {
      return utils2.setDate(dateToTransferTo, utils2.getDate(dateToTransferFrom));
    }
    case "meridiem": {
      const isAM = utils2.getHours(dateToTransferFrom) < 12;
      const mergedDateHours = utils2.getHours(dateToTransferTo);
      if (isAM && mergedDateHours >= 12) {
        return utils2.addHours(dateToTransferTo, -12);
      }
      if (!isAM && mergedDateHours < 12) {
        return utils2.addHours(dateToTransferTo, 12);
      }
      return dateToTransferTo;
    }
    case "hours": {
      return utils2.setHours(dateToTransferTo, utils2.getHours(dateToTransferFrom));
    }
    case "minutes": {
      return utils2.setMinutes(dateToTransferTo, utils2.getMinutes(dateToTransferFrom));
    }
    case "seconds": {
      return utils2.setSeconds(dateToTransferTo, utils2.getSeconds(dateToTransferFrom));
    }
    default: {
      return dateToTransferTo;
    }
  }
};
const reliableSectionModificationOrder = {
  year: 1,
  month: 2,
  day: 3,
  weekDay: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  meridiem: 8,
  empty: 9
};
const mergeDateIntoReferenceDate = (utils2, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
  // cloning sections before sort to avoid mutating it
  [...sections].sort((a3, b3) => reliableSectionModificationOrder[a3.type] - reliableSectionModificationOrder[b3.type]).reduce((mergedDate, section) => {
    if (!shouldLimitToEditedSections || section.modified) {
      return transferDateSectionValue(utils2, timezone, section, dateToTransferFrom, mergedDate);
    }
    return mergedDate;
  }, referenceDate)
);
const isAndroid2 = () => navigator.userAgent.toLowerCase().includes("android");
const getSectionOrder = (sections, shouldApplyRTL) => {
  const neighbors = {};
  if (!shouldApplyRTL) {
    sections.forEach((_, index) => {
      const leftIndex = index === 0 ? null : index - 1;
      const rightIndex = index === sections.length - 1 ? null : index + 1;
      neighbors[index] = {
        leftIndex,
        rightIndex
      };
    });
    return {
      neighbors,
      startIndex: 0,
      endIndex: sections.length - 1
    };
  }
  const rtl2ltr = {};
  const ltr2rtl = {};
  let groupedSectionsStart = 0;
  let groupedSectionsEnd = 0;
  let RTLIndex = sections.length - 1;
  while (RTLIndex >= 0) {
    groupedSectionsEnd = sections.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-loop-func
      (section, index) => {
        var _a2;
        return index >= groupedSectionsStart && ((_a2 = section.endSeparator) == null ? void 0 : _a2.includes(" ")) && // Special case where the spaces were not there in the initial input
        section.endSeparator !== " / ";
      }
    );
    if (groupedSectionsEnd === -1) {
      groupedSectionsEnd = sections.length - 1;
    }
    for (let i2 = groupedSectionsEnd; i2 >= groupedSectionsStart; i2 -= 1) {
      ltr2rtl[i2] = RTLIndex;
      rtl2ltr[RTLIndex] = i2;
      RTLIndex -= 1;
    }
    groupedSectionsStart = groupedSectionsEnd + 1;
  }
  sections.forEach((_, index) => {
    const rtlIndex = ltr2rtl[index];
    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
    neighbors[index] = {
      leftIndex,
      rightIndex
    };
  });
  return {
    neighbors,
    startIndex: rtl2ltr[0],
    endIndex: rtl2ltr[sections.length - 1]
  };
};
const parseSelectedSections = (selectedSections, sections) => {
  if (selectedSections == null) {
    return null;
  }
  if (selectedSections === "all") {
    return "all";
  }
  if (typeof selectedSections === "string") {
    return sections.findIndex((section) => section.type === selectedSections);
  }
  return selectedSections;
};
const getSectionValueText = (section, utils2) => {
  if (!section.value) {
    return void 0;
  }
  switch (section.type) {
    case "month": {
      if (section.contentType === "digit") {
        return utils2.format(utils2.setMonth(utils2.date(), Number(section.value) - 1), "month");
      }
      const parsedDate = utils2.parse(section.value, section.format);
      return parsedDate ? utils2.format(parsedDate, "month") : void 0;
    }
    case "day":
      return section.contentType === "digit" ? utils2.format(utils2.setDate(utils2.startOfYear(utils2.date()), Number(section.value)), "dayOfMonthFull") : section.value;
    case "weekDay":
      return void 0;
    default:
      return void 0;
  }
};
const getSectionValueNow = (section, utils2) => {
  if (!section.value) {
    return void 0;
  }
  switch (section.type) {
    case "weekDay": {
      if (section.contentType === "letter") {
        return void 0;
      }
      return Number(section.value);
    }
    case "meridiem": {
      const parsedDate = utils2.parse(`01:00 ${section.value}`, `${utils2.formats.hours12h}:${utils2.formats.minutes} ${section.format}`);
      if (parsedDate) {
        return utils2.getHours(parsedDate) >= 12 ? 1 : 0;
      }
      return void 0;
    }
    case "day":
      return section.contentType === "digit-with-letter" ? parseInt(section.value, 10) : Number(section.value);
    case "month": {
      if (section.contentType === "digit") {
        return Number(section.value);
      }
      const parsedDate = utils2.parse(section.value, section.format);
      return parsedDate ? utils2.getMonth(parsedDate) + 1 : void 0;
    }
    default:
      return section.contentType !== "letter" ? Number(section.value) : void 0;
  }
};
const _excluded$K = ["value", "referenceDate"];
const singleItemValueManager = {
  emptyValue: null,
  getTodayValue: getTodayDate,
  getInitialReferenceValue: (_ref) => {
    let {
      value,
      referenceDate
    } = _ref, params = _objectWithoutPropertiesLoose(_ref, _excluded$K);
    if (value != null && params.utils.isValid(value)) {
      return value;
    }
    if (referenceDate != null) {
      return referenceDate;
    }
    return getDefaultReferenceDate(params);
  },
  cleanValue: replaceInvalidDateByNull,
  areValuesEqual: areDatesEqual,
  isSameError: (a3, b3) => a3 === b3,
  hasError: (error) => error != null,
  defaultErrorState: null,
  getTimezone: (utils2, value) => value == null || !utils2.isValid(value) ? null : utils2.getTimezone(value),
  setTimezone: (utils2, timezone, value) => value == null ? null : utils2.setTimezone(value, timezone)
};
const singleItemFieldValueManager = {
  updateReferenceValue: (utils2, value, prevReferenceValue) => value == null || !utils2.isValid(value) ? prevReferenceValue : value,
  getSectionsFromValue: (utils2, date, prevSections, getSectionsFromDate) => {
    const shouldReUsePrevDateSections = !utils2.isValid(date) && !!prevSections;
    if (shouldReUsePrevDateSections) {
      return prevSections;
    }
    return getSectionsFromDate(date);
  },
  getV7HiddenInputValueFromSections: createDateStrForV7HiddenInputFromSections,
  getV6InputValueFromSections: createDateStrForV6InputFromSections,
  getActiveDateManager: (utils2, state) => ({
    date: state.value,
    referenceDate: state.referenceValue,
    getSections: (sections) => sections,
    getNewValuesFromNewActiveDate: (newActiveDate) => ({
      value: newActiveDate,
      referenceValue: newActiveDate == null || !utils2.isValid(newActiveDate) ? state.referenceValue : newActiveDate
    })
  }),
  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
};
const _excluded$J = ["localeText"];
const MuiPickersAdapterContext = /* @__PURE__ */ reactExports.createContext(null);
const LocalizationProvider = function LocalizationProvider2(inProps) {
  const {
    localeText: inLocaleText
  } = inProps, otherInProps = _objectWithoutPropertiesLoose(inProps, _excluded$J);
  const {
    utils: parentUtils,
    localeText: parentLocaleText
  } = reactExports.useContext(MuiPickersAdapterContext) ?? {
    utils: void 0,
    localeText: void 0
  };
  const props = useThemeProps({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: otherInProps,
    name: "MuiLocalizationProvider"
  });
  const {
    children,
    dateAdapter: DateAdapter,
    dateFormats: dateFormats2,
    dateLibInstance,
    adapterLocale,
    localeText: themeLocaleText
  } = props;
  const localeText = reactExports.useMemo(() => _extends$1({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
  const utils2 = reactExports.useMemo(() => {
    if (!DateAdapter) {
      if (parentUtils) {
        return parentUtils;
      }
      return null;
    }
    const adapter = new DateAdapter({
      locale: adapterLocale,
      formats: dateFormats2,
      instance: dateLibInstance
    });
    if (!adapter.isMUIAdapter) {
      throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
    }
    return adapter;
  }, [DateAdapter, adapterLocale, dateFormats2, dateLibInstance, parentUtils]);
  const defaultDates = reactExports.useMemo(() => {
    if (!utils2) {
      return null;
    }
    return {
      minDate: utils2.date("1900-01-01T00:00:00.000"),
      maxDate: utils2.date("2099-12-31T00:00:00.000")
    };
  }, [utils2]);
  const contextValue = reactExports.useMemo(() => {
    return {
      utils: utils2,
      defaultDates,
      localeText
    };
  }, [defaultDates, utils2, localeText]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
    value: contextValue,
    children
  });
};
const getPickersLocalization = (pickersTranslations) => {
  return {
    components: {
      MuiLocalizationProvider: {
        defaultProps: {
          localeText: _extends$1({}, pickersTranslations)
        }
      }
    }
  };
};
const enUSPickers = {
  // Calendar navigation
  previousMonth: "Previous month",
  nextMonth: "Next month",
  // View navigation
  openPreviousView: "Open previous view",
  openNextView: "Open next view",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
  // DateRange labels
  start: "Start",
  end: "End",
  startDate: "Start date",
  startTime: "Start time",
  endDate: "End date",
  endTime: "End time",
  // Action bar
  cancelButtonLabel: "Cancel",
  clearButtonLabel: "Clear",
  okButtonLabel: "OK",
  todayButtonLabel: "Today",
  // Toolbar titles
  datePickerToolbarTitle: "Select date",
  dateTimePickerToolbarTitle: "Select date & time",
  timePickerToolbarTitle: "Select time",
  dateRangePickerToolbarTitle: "Select date range",
  // Clock labels
  clockLabelText: (view, time2, adapter) => `Select ${view}. ${time2 === null ? "No time selected" : `Selected time is ${adapter.format(time2, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} hours`,
  minutesClockNumberText: (minutes) => `${minutes} minutes`,
  secondsClockNumberText: (seconds) => `${seconds} seconds`,
  // Digital clock labels
  selectViewText: (view) => `Select ${view}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Week number",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose date, selected date is ${utils2.format(value, "fullDate")}` : "Choose date",
  openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose time, selected time is ${utils2.format(value, "fullTime")}` : "Choose time",
  fieldClearLabel: "Clear value",
  // Table labels
  timeTableLabel: "pick time",
  dateTableLabel: "pick date",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa",
  // View names
  year: "Year",
  month: "Month",
  day: "Day",
  weekDay: "Week day",
  hours: "Hours",
  minutes: "Minutes",
  seconds: "Seconds",
  meridiem: "Meridiem",
  // Common
  empty: "Empty"
};
const DEFAULT_LOCALE = enUSPickers;
getPickersLocalization(enUSPickers);
const useLocalizationContext = () => {
  const localization = reactExports.useContext(MuiPickersAdapterContext);
  if (localization === null) {
    throw new Error(["MUI X: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));
  }
  if (localization.utils === null) {
    throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));
  }
  const localeText = reactExports.useMemo(() => _extends$1({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
  return reactExports.useMemo(() => _extends$1({}, localization, {
    localeText
  }), [localization, localeText]);
};
const useUtils = () => useLocalizationContext().utils;
const useDefaultDates = () => useLocalizationContext().defaultDates;
const useNow = (timezone) => {
  const utils2 = useUtils();
  const now2 = reactExports.useRef();
  if (now2.current === void 0) {
    now2.current = utils2.date(void 0, timezone);
  }
  return now2.current;
};
function getPickersToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiPickersToolbar", slot);
}
const pickersToolbarClasses = generateUtilityClasses("MuiPickersToolbar", ["root", "content"]);
const _excluded$I = ["children", "className", "toolbarTitle", "hidden", "titleId", "isLandscape", "classes", "landscapeDirection"];
const useUtilityClasses$P = (ownerState) => {
  const {
    classes,
    isLandscape
  } = ownerState;
  const slots = {
    root: ["root"],
    content: ["content"],
    penIconButton: ["penIconButton", isLandscape && "penIconButtonLandscape"]
  };
  return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarRoot = styled("div", {
  name: "MuiPickersToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme
}) => ({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "space-between",
  padding: theme.spacing(2, 3),
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      height: "auto",
      maxWidth: 160,
      padding: 16,
      justifyContent: "flex-start",
      flexWrap: "wrap"
    }
  }]
}));
const PickersToolbarContent = styled("div", {
  name: "MuiPickersToolbar",
  slot: "Content",
  overridesResolver: (props, styles2) => styles2.content
})({
  display: "flex",
  flexWrap: "wrap",
  width: "100%",
  flex: 1,
  justifyContent: "space-between",
  alignItems: "center",
  flexDirection: "row",
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      justifyContent: "flex-start",
      alignItems: "flex-start",
      flexDirection: "column"
    }
  }, {
    props: {
      isLandscape: true,
      landscapeDirection: "row"
    },
    style: {
      flexDirection: "row"
    }
  }]
});
const PickersToolbar = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersToolbar"
  });
  const {
    children,
    className,
    toolbarTitle,
    hidden,
    titleId
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$I);
  const ownerState = props;
  const classes = useUtilityClasses$P(ownerState);
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersToolbarRoot, _extends$1({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
      color: "text.secondary",
      variant: "overline",
      id: titleId,
      children: toolbarTitle
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarContent, {
      className: classes.content,
      ownerState,
      children
    })]
  }));
});
const usePickersTranslations = () => useLocalizationContext().localeText;
function getDatePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDatePickerToolbar", slot);
}
generateUtilityClasses("MuiDatePickerToolbar", ["root", "title"]);
const _excluded$H = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views", "className", "onViewChange", "view"];
const useUtilityClasses$O = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    title: ["title"]
  };
  return composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
};
const DatePickerToolbarRoot = styled(PickersToolbar, {
  name: "MuiDatePickerToolbar",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})({});
const DatePickerToolbarTitle = styled(Typography, {
  name: "MuiDatePickerToolbar",
  slot: "Title",
  overridesResolver: (_, styles2) => styles2.title
})({
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      margin: "auto 16px auto auto"
    }
  }]
});
const DatePickerToolbar = /* @__PURE__ */ reactExports.forwardRef(function DatePickerToolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDatePickerToolbar"
  });
  const {
    value,
    isLandscape,
    toolbarFormat,
    toolbarPlaceholder = "––",
    views,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$H);
  const utils2 = useUtils();
  const translations = usePickersTranslations();
  const classes = useUtilityClasses$O(props);
  const dateText = reactExports.useMemo(() => {
    if (!value) {
      return toolbarPlaceholder;
    }
    const formatFromViews = resolveDateFormat(utils2, {
      format: toolbarFormat,
      views
    }, true);
    return utils2.formatByString(value, formatFromViews);
  }, [value, toolbarFormat, toolbarPlaceholder, utils2, views]);
  const ownerState = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarRoot, _extends$1({
    ref,
    toolbarTitle: translations.datePickerToolbarTitle,
    isLandscape,
    className: clsx(classes.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarTitle, {
      variant: "h4",
      align: isLandscape ? "left" : "center",
      ownerState,
      className: classes.title,
      children: dateText
    })
  }));
});
function useDatePickerDefaultizedProps(props, name) {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const localeText = reactExports.useMemo(() => {
    var _a2;
    if (((_a2 = themeProps.localeText) == null ? void 0 : _a2.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends$1({}, themeProps.localeText, {
      datePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends$1({}, themeProps, {
    localeText
  }, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["year", "day"],
    defaultOpenTo: "day"
  }), {
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate),
    slots: _extends$1({
      toolbar: DatePickerToolbar
    }, themeProps.slots)
  });
}
const validateDate = ({
  props,
  value,
  adapter
}) => {
  if (value === null) {
    return null;
  }
  const {
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    disablePast,
    disableFuture,
    timezone
  } = props;
  const now2 = adapter.utils.date(void 0, timezone);
  const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
  const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
  switch (true) {
    case !adapter.utils.isValid(value):
      return "invalidDate";
    case Boolean(shouldDisableDate && shouldDisableDate(value)):
      return "shouldDisableDate";
    case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
      return "shouldDisableMonth";
    case Boolean(shouldDisableYear && shouldDisableYear(value)):
      return "shouldDisableYear";
    case Boolean(disableFuture && adapter.utils.isAfterDay(value, now2)):
      return "disableFuture";
    case Boolean(disablePast && adapter.utils.isBeforeDay(value, now2)):
      return "disablePast";
    case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
      return "minDate";
    case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
      return "maxDate";
    default:
      return null;
  }
};
function getPickersPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPickersPopper", slot);
}
generateUtilityClasses("MuiPickersPopper", ["root", "paper"]);
function arrayIncludes(array, itemOrItems) {
  if (Array.isArray(itemOrItems)) {
    return itemOrItems.every((item) => array.indexOf(item) !== -1);
  }
  return array.indexOf(itemOrItems) !== -1;
}
const onSpaceOrEnter = (innerFn, externalEvent) => (event) => {
  if (event.key === "Enter" || event.key === " ") {
    innerFn(event);
    event.preventDefault();
    event.stopPropagation();
  }
};
const getActiveElement = (root2 = document) => {
  const activeEl = root2.activeElement;
  if (!activeEl) {
    return null;
  }
  if (activeEl.shadowRoot) {
    return getActiveElement(activeEl.shadowRoot);
  }
  return activeEl;
};
const DEFAULT_DESKTOP_MODE_MEDIA_QUERY = "@media (pointer: fine)";
const PREFERS_REDUCED_MOTION = "@media (prefers-reduced-motion: reduce)";
const mobileVersionMatches = typeof navigator !== "undefined" && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i);
const androidVersion = mobileVersionMatches && mobileVersionMatches[1] ? parseInt(mobileVersionMatches[1], 10) : null;
const iOSVersion = mobileVersionMatches && mobileVersionMatches[2] ? parseInt(mobileVersionMatches[2], 10) : null;
const slowAnimationDevices = androidVersion && androidVersion < 10 || iOSVersion && iOSVersion < 13 || false;
const useDefaultReduceAnimations = () => {
  const prefersReduced = useMediaQuery(PREFERS_REDUCED_MOTION, {
    defaultMatches: false
  });
  return prefersReduced || slowAnimationDevices;
};
const _excluded$G = ["PaperComponent", "popperPlacement", "ownerState", "children", "paperSlotProps", "paperClasses", "onPaperClick", "onPaperTouchStart"];
const useUtilityClasses$N = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPickersPopperUtilityClass, classes);
};
const PickersPopperRoot = styled(Popper, {
  name: "MuiPickersPopper",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})(({
  theme
}) => ({
  zIndex: theme.zIndex.modal
}));
const PickersPopperPaper = styled(Paper, {
  name: "MuiPickersPopper",
  slot: "Paper",
  overridesResolver: (_, styles2) => styles2.paper
})({
  outline: 0,
  transformOrigin: "top center",
  variants: [{
    props: ({
      placement
    }) => ["top", "top-start", "top-end"].includes(placement),
    style: {
      transformOrigin: "bottom center"
    }
  }]
});
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function useClickAwayListener(active, onClickAway) {
  const movedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (!active) {
      return void 0;
    }
    function armClickAwayListener() {
      activatedRef.current = true;
    }
    document.addEventListener("mousedown", armClickAwayListener, true);
    document.addEventListener("touchstart", armClickAwayListener, true);
    return () => {
      document.removeEventListener("mousedown", armClickAwayListener, true);
      document.removeEventListener("touchstart", armClickAwayListener, true);
      activatedRef.current = false;
    };
  }, [active]);
  const handleClickAway = useEventCallback((event) => {
    if (!activatedRef.current) {
      return;
    }
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!nodeRef.current || // is a TouchEvent?
    "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
    }
    if (!insideDOM && !insideReactTree) {
      onClickAway(event);
    }
  });
  const handleSynthetic = () => {
    syntheticEventRef.current = true;
  };
  reactExports.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener("touchstart", handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener("touchstart", handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [active, handleClickAway]);
  reactExports.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener("click", handleClickAway);
      return () => {
        doc.removeEventListener("click", handleClickAway);
        syntheticEventRef.current = false;
      };
    }
    return void 0;
  }, [active, handleClickAway]);
  return [nodeRef, handleSynthetic, handleSynthetic];
}
const PickersPopperPaperWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const {
    PaperComponent,
    popperPlacement,
    ownerState: inOwnerState,
    children,
    paperSlotProps,
    paperClasses,
    onPaperClick,
    onPaperTouchStart
    // picks up the style props provided by `Transition`
    // https://mui.com/material-ui/transitions/#child-requirement
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$G);
  const ownerState = _extends$1({}, inOwnerState, {
    placement: popperPlacement
  });
  const paperProps = useSlotProps({
    elementType: PaperComponent,
    externalSlotProps: paperSlotProps,
    additionalProps: {
      tabIndex: -1,
      elevation: 8,
      ref
    },
    className: paperClasses,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperComponent, _extends$1({}, other, paperProps, {
    onClick: (event) => {
      var _a2;
      onPaperClick(event);
      (_a2 = paperProps.onClick) == null ? void 0 : _a2.call(paperProps, event);
    },
    onTouchStart: (event) => {
      var _a2;
      onPaperTouchStart(event);
      (_a2 = paperProps.onTouchStart) == null ? void 0 : _a2.call(paperProps, event);
    },
    ownerState,
    children
  }));
});
function PickersPopper(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersPopper"
  });
  const {
    anchorEl,
    children,
    containerRef = null,
    shouldRestoreFocus,
    onBlur,
    onDismiss,
    open,
    role,
    placement,
    slots,
    slotProps,
    reduceAnimations: inReduceAnimations
  } = props;
  reactExports.useEffect(() => {
    function handleKeyDown2(nativeEvent) {
      if (open && nativeEvent.key === "Escape") {
        onDismiss();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [onDismiss, open]);
  const lastFocusedElementRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (role === "tooltip" || shouldRestoreFocus && !shouldRestoreFocus()) {
      return;
    }
    if (open) {
      lastFocusedElementRef.current = getActiveElement(document);
    } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
      setTimeout(() => {
        if (lastFocusedElementRef.current instanceof HTMLElement) {
          lastFocusedElementRef.current.focus();
        }
      });
    }
  }, [open, role, shouldRestoreFocus]);
  const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onBlur ?? onDismiss);
  const paperRef = reactExports.useRef(null);
  const handleRef = useForkRef(paperRef, containerRef);
  const handlePaperRef = useForkRef(handleRef, clickAwayRef);
  const ownerState = props;
  const classes = useUtilityClasses$N(ownerState);
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const reduceAnimations = inReduceAnimations ?? defaultReduceAnimations;
  const handleKeyDown = (event) => {
    if (event.key === "Escape") {
      event.stopPropagation();
      onDismiss();
    }
  };
  const Transition2 = (slots == null ? void 0 : slots.desktopTransition) ?? reduceAnimations ? Fade : Grow;
  const FocusTrap$1 = (slots == null ? void 0 : slots.desktopTrapFocus) ?? FocusTrap;
  const Paper3 = (slots == null ? void 0 : slots.desktopPaper) ?? PickersPopperPaper;
  const Popper3 = (slots == null ? void 0 : slots.popper) ?? PickersPopperRoot;
  const popperProps = useSlotProps({
    elementType: Popper3,
    externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
    additionalProps: {
      transition: true,
      role,
      open,
      anchorEl,
      placement,
      onKeyDown: handleKeyDown
    },
    className: classes.root,
    ownerState: props
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Popper3, _extends$1({}, popperProps, {
    children: ({
      TransitionProps,
      placement: popperPlacement
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap$1, _extends$1({
      open,
      disableAutoFocus: true,
      disableRestoreFocus: true,
      disableEnforceFocus: role === "tooltip",
      isEnabled: () => true
    }, slotProps == null ? void 0 : slotProps.desktopTrapFocus, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Transition2, _extends$1({}, TransitionProps, slotProps == null ? void 0 : slotProps.desktopTransition, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopperPaperWrapper, {
          PaperComponent: Paper3,
          ownerState,
          popperPlacement,
          ref: handlePaperRef,
          onPaperClick,
          onPaperTouchStart,
          paperClasses: classes.paper,
          paperSlotProps: slotProps == null ? void 0 : slotProps.desktopPaper,
          children
        })
      }))
    }))
  }));
}
const useOpenState = ({
  open,
  onOpen,
  onClose
}) => {
  const isControllingOpenProp = reactExports.useRef(typeof open === "boolean").current;
  const [openState, setIsOpenState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isControllingOpenProp) {
      if (typeof open !== "boolean") {
        throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
      }
      setIsOpenState(open);
    }
  }, [isControllingOpenProp, open]);
  const setIsOpen = reactExports.useCallback((newIsOpen) => {
    if (!isControllingOpenProp) {
      setIsOpenState(newIsOpen);
    }
    if (newIsOpen && onOpen) {
      onOpen();
    }
    if (!newIsOpen && onClose) {
      onClose();
    }
  }, [isControllingOpenProp, onOpen, onClose]);
  return {
    isOpen: openState,
    setIsOpen
  };
};
function useValidation(props, validate, isSameError, defaultErrorState) {
  const {
    value,
    onError
  } = props;
  const adapter = useLocalizationContext();
  const previousValidationErrorRef = reactExports.useRef(defaultErrorState);
  const validationError = validate({
    adapter,
    value,
    props
  });
  reactExports.useEffect(() => {
    if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
      onError(validationError, value);
    }
    previousValidationErrorRef.current = validationError;
  }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
  return validationError;
}
const useValueWithTimezone = ({
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  onChange,
  valueManager
}) => {
  const utils2 = useUtils();
  const firstDefaultValue = reactExports.useRef(defaultValue);
  const inputValue = valueProp ?? firstDefaultValue.current ?? valueManager.emptyValue;
  const inputTimezone = reactExports.useMemo(() => valueManager.getTimezone(utils2, inputValue), [utils2, valueManager, inputValue]);
  const setInputTimezone = useEventCallback((newValue) => {
    if (inputTimezone == null) {
      return newValue;
    }
    return valueManager.setTimezone(utils2, inputTimezone, newValue);
  });
  const timezoneToRender = timezoneProp ?? inputTimezone ?? "default";
  const valueWithTimezoneToRender = reactExports.useMemo(() => valueManager.setTimezone(utils2, timezoneToRender, inputValue), [valueManager, utils2, timezoneToRender, inputValue]);
  const handleValueChange = useEventCallback((newValue, ...otherParams) => {
    const newValueWithInputTimezone = setInputTimezone(newValue);
    onChange == null ? void 0 : onChange(newValueWithInputTimezone, ...otherParams);
  });
  return {
    value: valueWithTimezoneToRender,
    handleValueChange,
    timezone: timezoneToRender
  };
};
const useControlledValueWithTimezone = ({
  name,
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  onChange: onChangeProp,
  valueManager
}) => {
  const [valueWithInputTimezone, setValue2] = useControlled({
    name,
    state: "value",
    controlled: valueProp,
    default: defaultValue ?? valueManager.emptyValue
  });
  const onChange = useEventCallback((newValue, ...otherParams) => {
    setValue2(newValue);
    onChangeProp == null ? void 0 : onChangeProp(newValue, ...otherParams);
  });
  return useValueWithTimezone({
    timezone: timezoneProp,
    value: valueWithInputTimezone,
    defaultValue: void 0,
    onChange,
    valueManager
  });
};
const shouldPublishValue = (params) => {
  const {
    action,
    hasChanged,
    dateState,
    isControlled
  } = params;
  const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
  if (action.name === "setValueFromField") {
    return true;
  }
  if (action.name === "setValueFromAction") {
    if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  if (action.name === "setValueFromView" && action.selectionState !== "shallow") {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  if (action.name === "setValueFromShortcut") {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  return false;
};
const shouldCommitValue = (params) => {
  const {
    action,
    hasChanged,
    dateState,
    isControlled,
    closeOnSelect
  } = params;
  const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
  if (action.name === "setValueFromAction") {
    if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
      return true;
    }
    return hasChanged(dateState.lastCommittedValue);
  }
  if (action.name === "setValueFromView" && action.selectionState === "finish" && closeOnSelect) {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastCommittedValue);
  }
  if (action.name === "setValueFromShortcut") {
    return action.changeImportance === "accept" && hasChanged(dateState.lastCommittedValue);
  }
  return false;
};
const shouldClosePicker = (params) => {
  const {
    action,
    closeOnSelect
  } = params;
  if (action.name === "setValueFromAction") {
    return true;
  }
  if (action.name === "setValueFromView") {
    return action.selectionState === "finish" && closeOnSelect;
  }
  if (action.name === "setValueFromShortcut") {
    return action.changeImportance === "accept";
  }
  return false;
};
const usePickerValue = ({
  props,
  valueManager,
  valueType,
  wrapperVariant,
  validator
}) => {
  const {
    onAccept,
    onChange,
    value: inValueWithoutRenderTimezone,
    defaultValue: inDefaultValue,
    closeOnSelect = wrapperVariant === "desktop",
    timezone: timezoneProp
  } = props;
  const {
    current: defaultValue
  } = reactExports.useRef(inDefaultValue);
  const {
    current: isControlled
  } = reactExports.useRef(inValueWithoutRenderTimezone !== void 0);
  const utils2 = useUtils();
  const adapter = useLocalizationContext();
  const {
    isOpen,
    setIsOpen
  } = useOpenState(props);
  const {
    timezone,
    value: inValueWithTimezoneToRender,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: inValueWithoutRenderTimezone,
    defaultValue,
    onChange,
    valueManager
  });
  const [dateState, setDateState] = reactExports.useState(() => {
    let initialValue;
    if (inValueWithTimezoneToRender !== void 0) {
      initialValue = inValueWithTimezoneToRender;
    } else if (defaultValue !== void 0) {
      initialValue = defaultValue;
    } else {
      initialValue = valueManager.emptyValue;
    }
    return {
      draft: initialValue,
      lastPublishedValue: initialValue,
      lastCommittedValue: initialValue,
      lastControlledValue: inValueWithTimezoneToRender,
      hasBeenModifiedSinceMount: false
    };
  });
  useValidation(_extends$1({}, props, {
    value: dateState.draft,
    timezone
  }), validator, valueManager.isSameError, valueManager.defaultErrorState);
  const updateDate = useEventCallback((action) => {
    const updaterParams = {
      action,
      dateState,
      hasChanged: (comparison) => !valueManager.areValuesEqual(utils2, action.value, comparison),
      isControlled,
      closeOnSelect
    };
    const shouldPublish = shouldPublishValue(updaterParams);
    const shouldCommit = shouldCommitValue(updaterParams);
    const shouldClose = shouldClosePicker(updaterParams);
    setDateState((prev2) => _extends$1({}, prev2, {
      draft: action.value,
      lastPublishedValue: shouldPublish ? action.value : prev2.lastPublishedValue,
      lastCommittedValue: shouldCommit ? action.value : prev2.lastCommittedValue,
      hasBeenModifiedSinceMount: true
    }));
    let cachedContext = null;
    const getContext = () => {
      if (!cachedContext) {
        const validationError = action.name === "setValueFromField" ? action.context.validationError : validator({
          adapter,
          value: action.value,
          props: _extends$1({}, props, {
            value: action.value,
            timezone
          })
        });
        cachedContext = {
          validationError
        };
        if (action.name === "setValueFromShortcut") {
          cachedContext.shortcut = action.shortcut;
        }
      }
      return cachedContext;
    };
    if (shouldPublish) {
      handleValueChange(action.value, getContext());
    }
    if (shouldCommit && onAccept) {
      onAccept(action.value, getContext());
    }
    if (shouldClose) {
      setIsOpen(false);
    }
  });
  if (inValueWithTimezoneToRender !== void 0 && (dateState.lastControlledValue === void 0 || !valueManager.areValuesEqual(utils2, dateState.lastControlledValue, inValueWithTimezoneToRender))) {
    const isUpdateComingFromPicker = valueManager.areValuesEqual(utils2, dateState.draft, inValueWithTimezoneToRender);
    setDateState((prev2) => _extends$1({}, prev2, {
      lastControlledValue: inValueWithTimezoneToRender
    }, isUpdateComingFromPicker ? {} : {
      lastCommittedValue: inValueWithTimezoneToRender,
      lastPublishedValue: inValueWithTimezoneToRender,
      draft: inValueWithTimezoneToRender,
      hasBeenModifiedSinceMount: true
    }));
  }
  const handleClear = useEventCallback(() => {
    updateDate({
      value: valueManager.emptyValue,
      name: "setValueFromAction",
      pickerAction: "clear"
    });
  });
  const handleAccept = useEventCallback(() => {
    updateDate({
      value: dateState.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "accept"
    });
  });
  const handleDismiss = useEventCallback(() => {
    updateDate({
      value: dateState.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "dismiss"
    });
  });
  const handleCancel = useEventCallback(() => {
    updateDate({
      value: dateState.lastCommittedValue,
      name: "setValueFromAction",
      pickerAction: "cancel"
    });
  });
  const handleSetToday = useEventCallback(() => {
    updateDate({
      value: valueManager.getTodayValue(utils2, timezone, valueType),
      name: "setValueFromAction",
      pickerAction: "today"
    });
  });
  const handleOpen = useEventCallback((event) => {
    event.preventDefault();
    setIsOpen(true);
  });
  const handleClose = useEventCallback((event) => {
    event == null ? void 0 : event.preventDefault();
    setIsOpen(false);
  });
  const handleChange = useEventCallback((newValue, selectionState = "partial") => updateDate({
    name: "setValueFromView",
    value: newValue,
    selectionState
  }));
  const handleSelectShortcut = useEventCallback((newValue, changeImportance, shortcut) => updateDate({
    name: "setValueFromShortcut",
    value: newValue,
    changeImportance,
    shortcut
  }));
  const handleChangeFromField = useEventCallback((newValue, context) => updateDate({
    name: "setValueFromField",
    value: newValue,
    context
  }));
  const actions = {
    onClear: handleClear,
    onAccept: handleAccept,
    onDismiss: handleDismiss,
    onCancel: handleCancel,
    onSetToday: handleSetToday,
    onOpen: handleOpen,
    onClose: handleClose
  };
  const fieldResponse = {
    value: dateState.draft,
    onChange: handleChangeFromField
  };
  const viewValue = reactExports.useMemo(() => valueManager.cleanValue(utils2, dateState.draft), [utils2, valueManager, dateState.draft]);
  const viewResponse = {
    value: viewValue,
    onChange: handleChange,
    onClose: handleClose,
    open: isOpen
  };
  const isValid2 = (testedValue) => {
    const error = validator({
      adapter,
      value: testedValue,
      props: _extends$1({}, props, {
        value: testedValue,
        timezone
      })
    });
    return !valueManager.hasError(error);
  };
  const layoutResponse = _extends$1({}, actions, {
    value: viewValue,
    onChange: handleChange,
    onSelectShortcut: handleSelectShortcut,
    isValid: isValid2
  });
  return {
    open: isOpen,
    fieldProps: fieldResponse,
    viewProps: viewResponse,
    layoutProps: layoutResponse,
    actions
  };
};
function useViews({
  onChange,
  onViewChange,
  openTo,
  view: inView,
  views,
  autoFocus,
  focusedView: inFocusedView,
  onFocusedViewChange
}) {
  const previousOpenTo = reactExports.useRef(openTo);
  const previousViews = reactExports.useRef(views);
  const defaultView = reactExports.useRef(views.includes(openTo) ? openTo : views[0]);
  const [view, setView] = useControlled({
    name: "useViews",
    state: "view",
    controlled: inView,
    default: defaultView.current
  });
  const defaultFocusedView = reactExports.useRef(autoFocus ? view : null);
  const [focusedView, setFocusedView] = useControlled({
    name: "useViews",
    state: "focusedView",
    controlled: inFocusedView,
    default: defaultFocusedView.current
  });
  reactExports.useEffect(() => {
    if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
      setView(views.includes(openTo) ? openTo : views[0]);
      previousViews.current = views;
      previousOpenTo.current = openTo;
    }
  }, [openTo, setView, view, views]);
  const viewIndex = views.indexOf(view);
  const previousView = views[viewIndex - 1] ?? null;
  const nextView = views[viewIndex + 1] ?? null;
  const handleFocusedViewChange = useEventCallback((viewToFocus, hasFocus) => {
    if (hasFocus) {
      setFocusedView(viewToFocus);
    } else {
      setFocusedView(
        (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
        // If false the blur is due to view switching
      );
    }
    onFocusedViewChange == null ? void 0 : onFocusedViewChange(viewToFocus, hasFocus);
  });
  const handleChangeView = useEventCallback((newView) => {
    handleFocusedViewChange(newView, true);
    if (newView === view) {
      return;
    }
    setView(newView);
    if (onViewChange) {
      onViewChange(newView);
    }
  });
  const goToNextView = useEventCallback(() => {
    if (nextView) {
      handleChangeView(nextView);
    }
  });
  const setValueAndGoToNextView = useEventCallback((value, currentViewSelectionState, selectedView) => {
    const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
    const hasMoreViews = selectedView ? (
      // handles case like `DateTimePicker`, where a view might return a `finish` selection state
      // but when it's not the final view given all `views` -> overall selection state should be `partial`.
      views.indexOf(selectedView) < views.length - 1
    ) : Boolean(nextView);
    const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
    onChange(value, globalSelectionState, selectedView);
    if (selectedView && selectedView !== view) {
      const nextViewAfterSelected = views[views.indexOf(selectedView) + 1];
      if (nextViewAfterSelected) {
        handleChangeView(nextViewAfterSelected);
      }
    } else if (isSelectionFinishedOnCurrentView) {
      goToNextView();
    }
  });
  return {
    view,
    setView: handleChangeView,
    focusedView,
    setFocusedView: handleFocusedViewChange,
    nextView,
    previousView,
    // Always return up-to-date default view instead of the initial one (i.e. defaultView.current)
    defaultView: views.includes(openTo) ? openTo : views[0],
    goToNextView,
    setValueAndGoToNextView
  };
}
const _excluded$F = ["className", "sx"];
const usePickerViews = ({
  props,
  propsFromPickerValue,
  additionalViewProps,
  autoFocusView,
  rendererInterceptor: rendererInterceptor3,
  fieldRef
}) => {
  const {
    onChange,
    open,
    onClose
  } = propsFromPickerValue;
  const {
    view: inView,
    views,
    openTo,
    onViewChange,
    viewRenderers,
    timezone
  } = props;
  const propsToForwardToView = _objectWithoutPropertiesLoose(props, _excluded$F);
  const {
    view,
    setView,
    defaultView,
    focusedView,
    setFocusedView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange,
    onViewChange,
    autoFocus: autoFocusView
  });
  const {
    hasUIView,
    viewModeLookup
  } = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
    let viewMode;
    if (viewRenderers[viewForReduce] != null) {
      viewMode = "UI";
    } else {
      viewMode = "field";
    }
    acc.viewModeLookup[viewForReduce] = viewMode;
    if (viewMode === "UI") {
      acc.hasUIView = true;
    }
    return acc;
  }, {
    hasUIView: false,
    viewModeLookup: {}
  }), [viewRenderers, views]);
  const timeViewsCount = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
    if (viewRenderers[viewForReduce] != null && isTimeView(viewForReduce)) {
      return acc + 1;
    }
    return acc;
  }, 0), [viewRenderers, views]);
  const currentViewMode = viewModeLookup[view];
  const shouldRestoreFocus = useEventCallback(() => currentViewMode === "UI");
  const [popperView, setPopperView] = reactExports.useState(currentViewMode === "UI" ? view : null);
  if (popperView !== view && viewModeLookup[view] === "UI") {
    setPopperView(view);
  }
  useEnhancedEffect(() => {
    if (currentViewMode === "field" && open) {
      onClose();
      setTimeout(() => {
        var _a2, _b2;
        (_a2 = fieldRef == null ? void 0 : fieldRef.current) == null ? void 0 : _a2.setSelectedSections(view);
        (_b2 = fieldRef == null ? void 0 : fieldRef.current) == null ? void 0 : _b2.focusField(view);
      });
    }
  }, [view]);
  useEnhancedEffect(() => {
    if (!open) {
      return;
    }
    let newView = view;
    if (currentViewMode === "field" && popperView != null) {
      newView = popperView;
    }
    if (newView !== defaultView && viewModeLookup[newView] === "UI" && viewModeLookup[defaultView] === "UI") {
      newView = defaultView;
    }
    if (newView !== view) {
      setView(newView);
    }
    setFocusedView(newView, true);
  }, [open]);
  const layoutProps = {
    views,
    view: popperView,
    onViewChange: setView
  };
  return {
    hasUIView,
    shouldRestoreFocus,
    layoutProps,
    renderCurrentView: () => {
      if (popperView == null) {
        return null;
      }
      const renderer = viewRenderers[popperView];
      if (renderer == null) {
        return null;
      }
      const rendererProps = _extends$1({}, propsToForwardToView, additionalViewProps, propsFromPickerValue, {
        views,
        timezone,
        onChange: setValueAndGoToNextView,
        view: popperView,
        onViewChange: setView,
        focusedView,
        onFocusedViewChange: setFocusedView,
        showViewSwitcher: timeViewsCount > 1,
        timeViewsCount
      });
      if (rendererInterceptor3) {
        return rendererInterceptor3(viewRenderers, popperView, rendererProps);
      }
      return renderer(rendererProps);
    }
  };
};
function getOrientation() {
  if (typeof window === "undefined") {
    return "portrait";
  }
  if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
    return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
  }
  if (window.orientation) {
    return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
  }
  return "portrait";
}
const useIsLandscape = (views, customOrientation) => {
  const [orientation, setOrientation] = reactExports.useState(getOrientation);
  useEnhancedEffect(() => {
    const eventHandler = () => {
      setOrientation(getOrientation());
    };
    window.addEventListener("orientationchange", eventHandler);
    return () => {
      window.removeEventListener("orientationchange", eventHandler);
    };
  }, []);
  if (arrayIncludes(views, ["hours", "minutes", "seconds"])) {
    return false;
  }
  const orientationToUse = customOrientation || orientation;
  return orientationToUse === "landscape";
};
const usePickerLayoutProps = ({
  props,
  propsFromPickerValue,
  propsFromPickerViews,
  wrapperVariant
}) => {
  const {
    orientation
  } = props;
  const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
  const isRtl = useRtl();
  const layoutProps = _extends$1({}, propsFromPickerViews, propsFromPickerValue, {
    isLandscape,
    isRtl,
    wrapperVariant,
    disabled: props.disabled,
    readOnly: props.readOnly
  });
  return {
    layoutProps
  };
};
const usePicker = ({
  props,
  valueManager,
  valueType,
  wrapperVariant,
  additionalViewProps,
  validator,
  autoFocusView,
  rendererInterceptor: rendererInterceptor3,
  fieldRef
}) => {
  const pickerValueResponse = usePickerValue({
    props,
    valueManager,
    valueType,
    wrapperVariant,
    validator
  });
  const pickerViewsResponse = usePickerViews({
    props,
    additionalViewProps,
    autoFocusView,
    fieldRef,
    propsFromPickerValue: pickerValueResponse.viewProps,
    rendererInterceptor: rendererInterceptor3
  });
  const pickerLayoutResponse = usePickerLayoutProps({
    props,
    wrapperVariant,
    propsFromPickerValue: pickerValueResponse.layoutProps,
    propsFromPickerViews: pickerViewsResponse.layoutProps
  });
  return {
    // Picker value
    open: pickerValueResponse.open,
    actions: pickerValueResponse.actions,
    fieldProps: pickerValueResponse.fieldProps,
    // Picker views
    renderCurrentView: pickerViewsResponse.renderCurrentView,
    hasUIView: pickerViewsResponse.hasUIView,
    shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
    // Picker layout
    layoutProps: pickerLayoutResponse.layoutProps
  };
};
function getPickersLayoutUtilityClass(slot) {
  return generateUtilityClass("MuiPickersLayout", slot);
}
const pickersLayoutClasses = generateUtilityClasses("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "tabs", "shortcuts"]);
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogActions", slot);
}
generateUtilityClasses$1("MuiDialogActions", ["root", "spacing"]);
const useUtilityClasses$M = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses$1(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableSpacing,
    style: {
      "& > :not(style) ~ :not(style)": {
        marginLeft: 8
      }
    }
  }]
});
const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogActions"
  });
  const {
    className,
    disableSpacing = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    disableSpacing
  };
  const classes = useUtilityClasses$M(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, {
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other
  });
});
const _excluded$E = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
function PickersActionBar(props) {
  const {
    onAccept,
    onClear,
    onCancel,
    onSetToday,
    actions
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$E);
  const translations = usePickersTranslations();
  if (actions == null || actions.length === 0) {
    return null;
  }
  const buttons = actions == null ? void 0 : actions.map((actionType) => {
    switch (actionType) {
      case "clear":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
          onClick: onClear,
          children: translations.clearButtonLabel
        }, actionType);
      case "cancel":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
          onClick: onCancel,
          children: translations.cancelButtonLabel
        }, actionType);
      case "accept":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
          onClick: onAccept,
          children: translations.okButtonLabel
        }, actionType);
      case "today":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
          onClick: onSetToday,
          children: translations.todayButtonLabel
        }, actionType);
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions, _extends$1({}, other, {
    children: buttons
  }));
}
function getListItemUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItem", slot);
}
generateUtilityClasses$1("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const listItemButtonClasses = generateUtilityClasses$1("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function getListItemSecondaryActionClassesUtilityClass(slot) {
  return generateUtilityClass$1("MuiListItemSecondaryAction", slot);
}
generateUtilityClasses$1("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const useUtilityClasses$L = (ownerState) => {
  const {
    disableGutters,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disableGutters && "disableGutters"]
  };
  return composeClasses$1(slots, getListItemSecondaryActionClassesUtilityClass, classes);
};
const ListItemSecondaryActionRoot = styled("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
  }
})({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.disableGutters,
    style: {
      right: 0
    }
  }]
});
const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItemSecondaryAction"
  });
  const {
    className,
    ...other
  } = props;
  const context = reactExports.useContext(ListContext);
  const ownerState = {
    ...props,
    disableGutters: context.disableGutters
  };
  const classes = useUtilityClasses$L(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, {
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other
  });
});
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const overridesResolver$2 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.hasSecondaryAction && styles2.secondaryAction];
};
const useUtilityClasses$K = (ownerState) => {
  const {
    alignItems,
    classes,
    dense,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction"],
    container: ["container"]
  };
  return composeClasses$1(slots, getListItemUtilityClass, classes);
};
const ListItemRoot = styled("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: overridesResolver$2
})(memoTheme(({
  theme
}) => ({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && ownerState.dense,
    style: {
      paddingTop: 4,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && !ownerState.disableGutters,
    style: {
      paddingLeft: 16,
      paddingRight: 16
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disablePadding && !!ownerState.secondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.secondaryAction,
    style: {
      [`& > .${listItemButtonClasses.root}`]: {
        paddingRight: 48
      }
    }
  }, {
    props: {
      alignItems: "flex-start"
    },
    style: {
      alignItems: "flex-start"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.divider,
    style: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.button,
    style: {
      transition: theme.transitions.create("background-color", {
        duration: theme.transitions.duration.shortest
      }),
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hasSecondaryAction,
    style: {
      // Add some space to avoid collision as `ListItemSecondaryAction`
      // is absolutely positioned.
      paddingRight: 48
    }
  }]
})));
const ListItemContainer = styled("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (props, styles2) => styles2.container
})({
  position: "relative"
});
const ListItem = /* @__PURE__ */ reactExports.forwardRef(function ListItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiListItem"
  });
  const {
    alignItems = "center",
    children: childrenProp,
    className,
    component: componentProp,
    components = {},
    componentsProps = {},
    ContainerComponent = "li",
    ContainerProps: {
      className: ContainerClassName,
      ...ContainerProps
    } = {},
    dense = false,
    disableGutters = false,
    disablePadding = false,
    divider = false,
    secondaryAction,
    slotProps = {},
    slots = {},
    ...other
  } = props;
  const context = reactExports.useContext(ListContext);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  const children = reactExports.Children.toArray(childrenProp);
  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  const ownerState = {
    ...props,
    alignItems,
    dense: childContext.dense,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction
  };
  const classes = useUtilityClasses$K(ownerState);
  const handleRef = useForkRef$1(listItemRef, ref);
  const Root = slots.root || components.Root || ListItemRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const componentProps = {
    className: clsx(classes.root, rootProps.className, className),
    ...other
  };
  let Component = componentProp || "li";
  if (hasSecondaryAction) {
    Component = !componentProps.component && !componentProp ? "div" : Component;
    if (ContainerComponent === "li") {
      if (Component === "li") {
        Component = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, {
        as: ContainerComponent,
        className: clsx(classes.container, ContainerClassName),
        ref: handleRef,
        ownerState,
        ...ContainerProps,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, {
          ...rootProps,
          ...!isHostComponent$1(Root) && {
            as: Component,
            ownerState: {
              ...ownerState,
              ...rootProps.ownerState
            }
          },
          ...componentProps,
          children
        }), children.pop()]
      })
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, {
      ...rootProps,
      as: Component,
      ref: handleRef,
      ...!isHostComponent$1(Root) && {
        ownerState: {
          ...ownerState,
          ...rootProps.ownerState
        }
      },
      ...componentProps,
      children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction, {
        children: secondaryAction
      })]
    })
  });
});
const DAY_SIZE = 36;
const DAY_MARGIN = 2;
const DIALOG_WIDTH = 320;
const MAX_CALENDAR_HEIGHT = 280;
const VIEW_HEIGHT = 336;
const DIGITAL_CLOCK_VIEW_HEIGHT = 232;
const MULTI_SECTION_CLOCK_SECTION_WIDTH = 48;
const _excluded$D = ["items", "changeImportance", "isLandscape", "onChange", "isValid"], _excluded2$6 = ["getValue"];
function PickersShortcuts(props) {
  const {
    items,
    changeImportance = "accept",
    onChange,
    isValid: isValid2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$D);
  if (items == null || items.length === 0) {
    return null;
  }
  const resolvedItems = items.map((_ref) => {
    let {
      getValue: getValue2
    } = _ref, item = _objectWithoutPropertiesLoose(_ref, _excluded2$6);
    const newValue = getValue2({
      isValid: isValid2
    });
    return _extends$1({}, item, {
      label: item.label,
      onClick: () => {
        onChange(newValue, changeImportance, item);
      },
      disabled: !isValid2(newValue)
    });
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List, _extends$1({
    dense: true,
    sx: [{
      maxHeight: VIEW_HEIGHT,
      maxWidth: 200,
      overflow: "auto"
    }, ...Array.isArray(other.sx) ? other.sx : [other.sx]]
  }, other, {
    children: resolvedItems.map((item) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, _extends$1({}, item))
      }, item.id ?? item.label);
    })
  }));
}
function toolbarHasView(toolbarProps) {
  return toolbarProps.view !== null;
}
const useUtilityClasses$J = (ownerState) => {
  const {
    classes,
    isLandscape
  } = ownerState;
  const slots = {
    root: ["root", isLandscape && "landscape"],
    contentWrapper: ["contentWrapper"],
    toolbar: ["toolbar"],
    actionBar: ["actionBar"],
    tabs: ["tabs"],
    landscape: ["landscape"],
    shortcuts: ["shortcuts"]
  };
  return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const usePickerLayout = (props) => {
  const {
    wrapperVariant,
    onAccept,
    onClear,
    onCancel,
    onSetToday,
    view,
    views,
    onViewChange,
    value,
    onChange,
    onSelectShortcut,
    isValid: isValid2,
    isLandscape,
    disabled,
    readOnly,
    children,
    slots,
    slotProps
    // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
    // The true type should be
    // - For pickers value: TDate | null
    // - For range pickers value: [TDate | null, TDate | null]
  } = props;
  const classes = useUtilityClasses$J(props);
  const ActionBar = (slots == null ? void 0 : slots.actionBar) ?? PickersActionBar;
  const actionBarProps = useSlotProps({
    elementType: ActionBar,
    externalSlotProps: slotProps == null ? void 0 : slotProps.actionBar,
    additionalProps: {
      onAccept,
      onClear,
      onCancel,
      onSetToday,
      actions: wrapperVariant === "desktop" ? [] : ["cancel", "accept"]
    },
    className: classes.actionBar,
    ownerState: _extends$1({}, props, {
      wrapperVariant
    })
  });
  const actionBar = /* @__PURE__ */ jsxRuntimeExports.jsx(ActionBar, _extends$1({}, actionBarProps));
  const Toolbar3 = slots == null ? void 0 : slots.toolbar;
  const toolbarProps = useSlotProps({
    elementType: Toolbar3,
    externalSlotProps: slotProps == null ? void 0 : slotProps.toolbar,
    additionalProps: {
      isLandscape,
      onChange,
      value,
      view,
      onViewChange,
      views,
      disabled,
      readOnly
    },
    className: classes.toolbar,
    ownerState: _extends$1({}, props, {
      wrapperVariant
    })
  });
  const toolbar = toolbarHasView(toolbarProps) && !!Toolbar3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar3, _extends$1({}, toolbarProps)) : null;
  const content = children;
  const Tabs3 = slots == null ? void 0 : slots.tabs;
  const tabs = view && Tabs3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs3, _extends$1({
    view,
    onViewChange,
    className: classes.tabs
  }, slotProps == null ? void 0 : slotProps.tabs)) : null;
  const Shortcuts = (slots == null ? void 0 : slots.shortcuts) ?? PickersShortcuts;
  const shortcutsProps = useSlotProps({
    elementType: Shortcuts,
    externalSlotProps: slotProps == null ? void 0 : slotProps.shortcuts,
    additionalProps: {
      isValid: isValid2,
      isLandscape,
      onChange: onSelectShortcut
    },
    className: classes.shortcuts,
    ownerState: {
      isValid: isValid2,
      isLandscape,
      onChange: onSelectShortcut,
      wrapperVariant
    }
  });
  const shortcuts = view && !!Shortcuts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Shortcuts, _extends$1({}, shortcutsProps)) : null;
  return {
    toolbar,
    content,
    tabs,
    actionBar,
    shortcuts
  };
};
const useUtilityClasses$I = (ownerState) => {
  const {
    isLandscape,
    classes
  } = ownerState;
  const slots = {
    root: ["root", isLandscape && "landscape"],
    contentWrapper: ["contentWrapper"]
  };
  return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const PickersLayoutRoot = styled("div", {
  name: "MuiPickersLayout",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "grid",
  gridAutoColumns: "max-content auto max-content",
  gridAutoRows: "max-content auto max-content",
  [`& .${pickersLayoutClasses.actionBar}`]: {
    gridColumn: "1 / 4",
    gridRow: 3
  },
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      [`& .${pickersLayoutClasses.toolbar}`]: {
        gridColumn: 1,
        gridRow: "2 / 3"
      },
      [`.${pickersLayoutClasses.shortcuts}`]: {
        gridColumn: "2 / 4",
        gridRow: 1
      }
    }
  }, {
    props: {
      isLandscape: true,
      isRtl: true
    },
    style: {
      [`& .${pickersLayoutClasses.toolbar}`]: {
        gridColumn: 3
      }
    }
  }, {
    props: {
      isLandscape: false
    },
    style: {
      [`& .${pickersLayoutClasses.toolbar}`]: {
        gridColumn: "2 / 4",
        gridRow: 1
      },
      [`& .${pickersLayoutClasses.shortcuts}`]: {
        gridColumn: 1,
        gridRow: "2 / 3"
      }
    }
  }, {
    props: {
      isLandscape: false,
      isRtl: true
    },
    style: {
      [`& .${pickersLayoutClasses.shortcuts}`]: {
        gridColumn: 3
      }
    }
  }]
});
const PickersLayoutContentWrapper = styled("div", {
  name: "MuiPickersLayout",
  slot: "ContentWrapper",
  overridesResolver: (props, styles2) => styles2.contentWrapper
})({
  gridColumn: 2,
  gridRow: 2,
  display: "flex",
  flexDirection: "column"
});
const PickersLayout = /* @__PURE__ */ reactExports.forwardRef(function PickersLayout2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersLayout"
  });
  const {
    toolbar,
    content,
    tabs,
    actionBar,
    shortcuts
  } = usePickerLayout(props);
  const {
    sx,
    className,
    isLandscape,
    wrapperVariant
  } = props;
  const classes = useUtilityClasses$I(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
    ref,
    sx,
    className: clsx(className, classes.root),
    ownerState: props,
    children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersLayoutContentWrapper, {
      className: classes.contentWrapper,
      children: wrapperVariant === "desktop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [content, tabs]
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [tabs, content]
      })
    }), actionBar]
  });
});
const _excluded$C = ["props", "getOpenDialogAriaText"], _excluded2$5 = ["ownerState"], _excluded3$2 = ["ownerState"];
const useDesktopPicker = (_ref) => {
  var _a2;
  let {
    props,
    getOpenDialogAriaText
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded$C);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format: format2,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    name,
    label,
    inputRef,
    readOnly,
    disabled,
    autoFocus,
    localeText,
    reduceAnimations
  } = props;
  const utils2 = useUtils();
  const containerRef = reactExports.useRef(null);
  const fieldRef = reactExports.useRef(null);
  const labelId = useId();
  const isToolbarHidden = ((_a2 = innerSlotProps == null ? void 0 : innerSlotProps.toolbar) == null ? void 0 : _a2.hidden) ?? false;
  const {
    open,
    actions,
    hasUIView,
    layoutProps,
    renderCurrentView,
    shouldRestoreFocus,
    fieldProps: pickerFieldProps
  } = usePicker(_extends$1({}, pickerParams, {
    props,
    fieldRef,
    autoFocusView: true,
    additionalViewProps: {},
    wrapperVariant: "desktop"
  }));
  const ownerStateV8 = {
    open
  };
  const InputAdornment$1 = slots.inputAdornment ?? InputAdornment;
  const _useSlotProps = useSlotProps({
    elementType: InputAdornment$1,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.inputAdornment,
    additionalProps: {
      position: "end"
    },
    ownerState: props
  }), inputAdornmentProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$5);
  const OpenPickerButton = slots.openPickerButton ?? IconButton;
  const _useSlotProps2 = useSlotProps({
    elementType: OpenPickerButton,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.openPickerButton,
    additionalProps: {
      disabled: disabled || readOnly,
      onClick: open ? actions.onClose : actions.onOpen,
      "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2),
      edge: inputAdornmentProps.position
    },
    ownerState: props
  }), openPickerButtonProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded3$2);
  const OpenPickerIcon = slots.openPickerIcon;
  const openPickerIconProps = useSlotProps({
    elementType: OpenPickerIcon,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.openPickerIcon,
    ownerState: ownerStateV8
  });
  const Field = slots.field;
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends$1({}, pickerFieldProps, isToolbarHidden && {
      id: labelId
    }, {
      readOnly,
      disabled,
      className,
      sx,
      format: format2,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      label,
      name,
      autoFocus: autoFocus && !props.open,
      focused: open ? true : void 0
    }, inputRef ? {
      inputRef
    } : {}),
    ownerState: props
  });
  if (hasUIView) {
    fieldProps.InputProps = _extends$1({}, fieldProps.InputProps, {
      ref: containerRef
    }, !props.disableOpenPicker && {
      [`${inputAdornmentProps.position}Adornment`]: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment$1, _extends$1({}, inputAdornmentProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerButton, _extends$1({}, openPickerButtonProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerIcon, _extends$1({}, openPickerIconProps))
        }))
      }))
    });
  }
  const slotsForField = _extends$1({
    textField: slots.textField,
    clearIcon: slots.clearIcon,
    clearButton: slots.clearButton
  }, fieldProps.slots);
  const Layout = slots.layout ?? PickersLayout;
  let labelledById = labelId;
  if (isToolbarHidden) {
    if (label) {
      labelledById = `${labelId}-label`;
    } else {
      labelledById = void 0;
    }
  }
  const slotProps = _extends$1({}, innerSlotProps, {
    toolbar: _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId
    }),
    popper: _extends$1({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.popper)
  });
  const handleFieldRef = useForkRef(fieldRef, fieldProps.unstableFieldRef);
  const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
    localeText,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$1({}, fieldProps, {
      slots: slotsForField,
      slotProps,
      unstableFieldRef: handleFieldRef
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopper, _extends$1({
      role: "dialog",
      placement: "bottom-start",
      anchorEl: containerRef.current
    }, actions, {
      open,
      slots,
      slotProps,
      shouldRestoreFocus,
      reduceAnimations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};
const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
const ArrowLeftIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), "ArrowLeft");
const ArrowRightIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "ArrowRight");
const CalendarIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), "Calendar");
const ClockIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Clock");
const DateRangeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), "DateRange");
const TimeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Time");
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
const expandFormat = ({
  utils: utils2,
  format: format2
}) => {
  let formatExpansionOverflow = 10;
  let prevFormat = format2;
  let nextFormat = utils2.expandFormat(format2);
  while (nextFormat !== prevFormat) {
    prevFormat = nextFormat;
    nextFormat = utils2.expandFormat(prevFormat);
    formatExpansionOverflow -= 1;
    if (formatExpansionOverflow < 0) {
      throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");
    }
  }
  return nextFormat;
};
const getEscapedPartsFromFormat = ({
  utils: utils2,
  expandedFormat
}) => {
  const escapedParts = [];
  const {
    start: startChar,
    end: endChar
  } = utils2.escapedCharacters;
  const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, "g");
  let match2 = null;
  while (match2 = regExp.exec(expandedFormat)) {
    escapedParts.push({
      start: match2.index,
      end: regExp.lastIndex - 1
    });
  }
  return escapedParts;
};
const getSectionPlaceholder = (utils2, timezone, localeText, sectionConfig, sectionFormat) => {
  switch (sectionConfig.type) {
    case "year": {
      return localeText.fieldYearPlaceholder({
        digitAmount: utils2.formatByString(utils2.date(void 0, timezone), sectionFormat).length,
        format: sectionFormat
      });
    }
    case "month": {
      return localeText.fieldMonthPlaceholder({
        contentType: sectionConfig.contentType,
        format: sectionFormat
      });
    }
    case "day": {
      return localeText.fieldDayPlaceholder({
        format: sectionFormat
      });
    }
    case "weekDay": {
      return localeText.fieldWeekDayPlaceholder({
        contentType: sectionConfig.contentType,
        format: sectionFormat
      });
    }
    case "hours": {
      return localeText.fieldHoursPlaceholder({
        format: sectionFormat
      });
    }
    case "minutes": {
      return localeText.fieldMinutesPlaceholder({
        format: sectionFormat
      });
    }
    case "seconds": {
      return localeText.fieldSecondsPlaceholder({
        format: sectionFormat
      });
    }
    case "meridiem": {
      return localeText.fieldMeridiemPlaceholder({
        format: sectionFormat
      });
    }
    default: {
      return sectionFormat;
    }
  }
};
const createSection = ({
  utils: utils2,
  timezone,
  date,
  shouldRespectLeadingZeros,
  localeText,
  localizedDigits,
  now: now2,
  token: token2,
  startSeparator
}) => {
  if (token2 === "") {
    throw new Error("MUI X: Should not call `commitToken` with an empty token");
  }
  const sectionConfig = getDateSectionConfigFromFormatToken(utils2, token2);
  const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, sectionConfig.contentType, sectionConfig.type, token2);
  const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === "digit";
  const isValidDate = date != null && utils2.isValid(date);
  let sectionValue = isValidDate ? utils2.formatByString(date, token2) : "";
  let maxLength = null;
  if (hasLeadingZerosInInput) {
    if (hasLeadingZerosInFormat) {
      maxLength = sectionValue === "" ? utils2.formatByString(now2, token2).length : sectionValue.length;
    } else {
      if (sectionConfig.maxLength == null) {
        throw new Error(`MUI X: The token ${token2} should have a 'maxDigitNumber' property on it's adapter`);
      }
      maxLength = sectionConfig.maxLength;
      if (isValidDate) {
        sectionValue = applyLocalizedDigits(cleanLeadingZeros(removeLocalizedDigits(sectionValue, localizedDigits), maxLength), localizedDigits);
      }
    }
  }
  return _extends$1({}, sectionConfig, {
    format: token2,
    maxLength,
    value: sectionValue,
    placeholder: getSectionPlaceholder(utils2, timezone, localeText, sectionConfig, token2),
    hasLeadingZerosInFormat,
    hasLeadingZerosInInput,
    startSeparator,
    endSeparator: "",
    modified: false
  });
};
const buildSections = (params) => {
  var _a2;
  const {
    utils: utils2,
    expandedFormat,
    escapedParts
  } = params;
  const now2 = utils2.date(void 0);
  const sections = [];
  let startSeparator = "";
  const validTokens = Object.keys(utils2.formatTokenMap).sort((a3, b3) => b3.length - a3.length);
  const regExpFirstWordInFormat = /^([a-zA-Z]+)/;
  const regExpWordOnlyComposedOfTokens = new RegExp(`^(${validTokens.join("|")})*$`);
  const regExpFirstTokenInWord = new RegExp(`^(${validTokens.join("|")})`);
  const getEscapedPartOfCurrentChar = (i3) => escapedParts.find((escapeIndex) => escapeIndex.start <= i3 && escapeIndex.end >= i3);
  let i2 = 0;
  while (i2 < expandedFormat.length) {
    const escapedPartOfCurrentChar = getEscapedPartOfCurrentChar(i2);
    const isEscapedChar = escapedPartOfCurrentChar != null;
    const firstWordInFormat = (_a2 = regExpFirstWordInFormat.exec(expandedFormat.slice(i2))) == null ? void 0 : _a2[1];
    if (!isEscapedChar && firstWordInFormat != null && regExpWordOnlyComposedOfTokens.test(firstWordInFormat)) {
      let word = firstWordInFormat;
      while (word.length > 0) {
        const firstWord = regExpFirstTokenInWord.exec(word)[1];
        word = word.slice(firstWord.length);
        sections.push(createSection(_extends$1({}, params, {
          now: now2,
          token: firstWord,
          startSeparator
        })));
        startSeparator = "";
      }
      i2 += firstWordInFormat.length;
    } else {
      const char2 = expandedFormat[i2];
      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i2 || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i2;
      if (!isEscapeBoundary) {
        if (sections.length === 0) {
          startSeparator += char2;
        } else {
          sections[sections.length - 1].endSeparator += char2;
        }
      }
      i2 += 1;
    }
  }
  if (sections.length === 0 && startSeparator.length > 0) {
    sections.push({
      type: "empty",
      contentType: "letter",
      maxLength: null,
      format: "",
      value: "",
      placeholder: "",
      hasLeadingZerosInFormat: false,
      hasLeadingZerosInInput: false,
      startSeparator,
      endSeparator: "",
      modified: false
    });
  }
  return sections;
};
const postProcessSections = ({
  isRtl,
  formatDensity,
  sections
}) => {
  return sections.map((section) => {
    const cleanSeparator = (separator) => {
      let cleanedSeparator = separator;
      if (isRtl && cleanedSeparator !== null && cleanedSeparator.includes(" ")) {
        cleanedSeparator = `⁩${cleanedSeparator}⁦`;
      }
      if (formatDensity === "spacious" && ["/", ".", "-"].includes(cleanedSeparator)) {
        cleanedSeparator = ` ${cleanedSeparator} `;
      }
      return cleanedSeparator;
    };
    section.startSeparator = cleanSeparator(section.startSeparator);
    section.endSeparator = cleanSeparator(section.endSeparator);
    return section;
  });
};
const buildSectionsFromFormat = (params) => {
  let expandedFormat = expandFormat(params);
  if (params.isRtl && params.enableAccessibleFieldDOMStructure) {
    expandedFormat = expandedFormat.split(" ").reverse().join(" ");
  }
  const escapedParts = getEscapedPartsFromFormat(_extends$1({}, params, {
    expandedFormat
  }));
  const sections = buildSections(_extends$1({}, params, {
    expandedFormat,
    escapedParts
  }));
  return postProcessSections(_extends$1({}, params, {
    sections
  }));
};
const useFieldState = (params) => {
  const utils2 = useUtils();
  const translations = usePickersTranslations();
  const adapter = useLocalizationContext();
  const isRtl = useRtl();
  const {
    valueManager,
    fieldValueManager,
    valueType,
    validator,
    internalProps,
    internalProps: {
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      onChange,
      format: format2,
      formatDensity = "dense",
      selectedSections: selectedSectionsProp,
      onSelectedSectionsChange,
      shouldRespectLeadingZeros = false,
      timezone: timezoneProp,
      enableAccessibleFieldDOMStructure = false
    }
  } = params;
  const {
    timezone,
    value: valueFromTheOutside,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager
  });
  const localizedDigits = reactExports.useMemo(() => getLocalizedDigits(utils2), [utils2]);
  const sectionsValueBoundaries = reactExports.useMemo(() => getSectionsBoundaries(utils2, localizedDigits, timezone), [utils2, localizedDigits, timezone]);
  const getSectionsFromValue = reactExports.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils2, value, fallbackSections, (date) => buildSectionsFromFormat({
    utils: utils2,
    timezone,
    localeText: translations,
    localizedDigits,
    format: format2,
    date,
    formatDensity,
    shouldRespectLeadingZeros,
    enableAccessibleFieldDOMStructure,
    isRtl
  })), [fieldValueManager, format2, translations, localizedDigits, isRtl, shouldRespectLeadingZeros, utils2, formatDensity, timezone, enableAccessibleFieldDOMStructure]);
  const [state, setState] = reactExports.useState(() => {
    const sections = getSectionsFromValue(valueFromTheOutside);
    const stateWithoutReferenceDate = {
      sections,
      value: valueFromTheOutside,
      referenceValue: valueManager.emptyValue,
      tempValueStrAndroid: null
    };
    const granularity = getSectionTypeGranularity(sections);
    const referenceValue = valueManager.getInitialReferenceValue({
      referenceDate: referenceDateProp,
      value: valueFromTheOutside,
      utils: utils2,
      props: internalProps,
      granularity,
      timezone
    });
    return _extends$1({}, stateWithoutReferenceDate, {
      referenceValue
    });
  });
  const [selectedSections, innerSetSelectedSections] = useControlled({
    controlled: selectedSectionsProp,
    default: null,
    name: "useField",
    state: "selectedSections"
  });
  const setSelectedSections = (newSelectedSections) => {
    innerSetSelectedSections(newSelectedSections);
    onSelectedSectionsChange == null ? void 0 : onSelectedSectionsChange(newSelectedSections);
  };
  const parsedSelectedSections = reactExports.useMemo(() => parseSelectedSections(selectedSections, state.sections), [selectedSections, state.sections]);
  const activeSectionIndex = parsedSelectedSections === "all" ? 0 : parsedSelectedSections;
  const publishValue = ({
    value,
    referenceValue,
    sections
  }) => {
    setState((prevState) => _extends$1({}, prevState, {
      sections,
      value,
      referenceValue,
      tempValueStrAndroid: null
    }));
    if (valueManager.areValuesEqual(utils2, state.value, value)) {
      return;
    }
    const context = {
      validationError: validator({
        adapter,
        value,
        props: _extends$1({}, internalProps, {
          value,
          timezone
        })
      })
    };
    handleValueChange(value, context);
  };
  const setSectionValue = (sectionIndex, newSectionValue) => {
    const newSections = [...state.sections];
    newSections[sectionIndex] = _extends$1({}, newSections[sectionIndex], {
      value: newSectionValue,
      modified: true
    });
    return newSections;
  };
  const clearValue = () => {
    publishValue({
      value: valueManager.emptyValue,
      referenceValue: state.referenceValue,
      sections: getSectionsFromValue(valueManager.emptyValue)
    });
  };
  const clearActiveSection = () => {
    if (activeSectionIndex == null) {
      return;
    }
    const activeSection = state.sections[activeSectionIndex];
    const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
    const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter((section) => section.value !== "").length;
    const hasNoOtherNonEmptySections = nonEmptySectionCountBefore === (activeSection.value === "" ? 0 : 1);
    const newSections = setSectionValue(activeSectionIndex, "");
    const newActiveDate = hasNoOtherNonEmptySections ? null : utils2.getInvalidDate();
    const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
    publishValue(_extends$1({}, newValues, {
      sections: newSections
    }));
  };
  const updateValueFromValueStr = (valueStr) => {
    const parseDateStr = (dateStr, referenceDate) => {
      const date = utils2.parse(dateStr, format2);
      if (date == null || !utils2.isValid(date)) {
        return null;
      }
      const sections = buildSectionsFromFormat({
        utils: utils2,
        timezone,
        localeText: translations,
        localizedDigits,
        format: format2,
        date,
        formatDensity,
        shouldRespectLeadingZeros,
        enableAccessibleFieldDOMStructure,
        isRtl
      });
      return mergeDateIntoReferenceDate(utils2, timezone, date, sections, referenceDate, false);
    };
    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
    const newReferenceValue = fieldValueManager.updateReferenceValue(utils2, newValue, state.referenceValue);
    publishValue({
      value: newValue,
      referenceValue: newReferenceValue,
      sections: getSectionsFromValue(newValue, state.sections)
    });
  };
  const updateSectionValue = ({
    activeSection,
    newSectionValue,
    shouldGoToNextSection
  }) => {
    if (shouldGoToNextSection && activeSectionIndex < state.sections.length - 1) {
      setSelectedSections(activeSectionIndex + 1);
    }
    const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
    const newSections = setSectionValue(activeSectionIndex, newSectionValue);
    const newActiveDateSections = activeDateManager.getSections(newSections);
    const newActiveDate = getDateFromDateSections(utils2, newActiveDateSections, localizedDigits);
    let values2;
    let shouldPublish;
    if (newActiveDate != null && utils2.isValid(newActiveDate)) {
      const mergedDate = mergeDateIntoReferenceDate(utils2, timezone, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);
      values2 = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);
      shouldPublish = true;
    } else {
      values2 = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
      shouldPublish = (newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date));
    }
    if (shouldPublish) {
      return publishValue(_extends$1({}, values2, {
        sections: newSections
      }));
    }
    return setState((prevState) => _extends$1({}, prevState, values2, {
      sections: newSections,
      tempValueStrAndroid: null
    }));
  };
  const setTempAndroidValueStr = (tempValueStrAndroid) => setState((prev2) => _extends$1({}, prev2, {
    tempValueStrAndroid
  }));
  reactExports.useEffect(() => {
    const sections = getSectionsFromValue(state.value);
    setState((prevState) => _extends$1({}, prevState, {
      sections
    }));
  }, [format2, utils2.locale, isRtl]);
  reactExports.useEffect(() => {
    let shouldUpdate;
    if (!valueManager.areValuesEqual(utils2, state.value, valueFromTheOutside)) {
      shouldUpdate = true;
    } else {
      shouldUpdate = valueManager.getTimezone(utils2, state.value) !== valueManager.getTimezone(utils2, valueFromTheOutside);
    }
    if (shouldUpdate) {
      setState((prevState) => _extends$1({}, prevState, {
        value: valueFromTheOutside,
        referenceValue: fieldValueManager.updateReferenceValue(utils2, valueFromTheOutside, prevState.referenceValue),
        sections: getSectionsFromValue(valueFromTheOutside)
      }));
    }
  }, [valueFromTheOutside]);
  return {
    state,
    activeSectionIndex,
    parsedSelectedSections,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    updateValueFromValueStr,
    setTempAndroidValueStr,
    getSectionsFromValue,
    sectionsValueBoundaries,
    localizedDigits,
    timezone
  };
};
const QUERY_LIFE_DURATION_MS = 5e3;
const isQueryResponseWithoutValue = (response) => response.saveQuery != null;
const useFieldCharacterEditing = ({
  sections,
  updateSectionValue,
  sectionsValueBoundaries,
  localizedDigits,
  setTempAndroidValueStr,
  timezone
}) => {
  const utils2 = useUtils();
  const [query, setQuery] = reactExports.useState(null);
  const resetQuery = useEventCallback(() => setQuery(null));
  reactExports.useEffect(() => {
    var _a2;
    if (query != null && ((_a2 = sections[query.sectionIndex]) == null ? void 0 : _a2.type) !== query.sectionType) {
      resetQuery();
    }
  }, [sections, query, resetQuery]);
  reactExports.useEffect(() => {
    if (query != null) {
      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
      return () => {
        clearTimeout(timeout);
      };
    }
    return () => {
    };
  }, [query, resetQuery]);
  const applyQuery = ({
    keyPressed,
    sectionIndex
  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
    const cleanKeyPressed = keyPressed.toLowerCase();
    const activeSection = sections[sectionIndex];
    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
      const queryResponse2 = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
      if (!isQueryResponseWithoutValue(queryResponse2)) {
        setQuery({
          sectionIndex,
          value: concatenatedQueryValue,
          sectionType: activeSection.type
        });
        return queryResponse2;
      }
    }
    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
      resetQuery();
      return null;
    }
    setQuery({
      sectionIndex,
      value: cleanKeyPressed,
      sectionType: activeSection.type
    });
    if (isQueryResponseWithoutValue(queryResponse)) {
      return null;
    }
    return queryResponse;
  };
  const applyLetterEditing = (params) => {
    const findMatchingOptions = (format2, options, queryValue) => {
      const matchingValues = options.filter((option) => option.toLowerCase().startsWith(queryValue));
      if (matchingValues.length === 0) {
        return {
          saveQuery: false
        };
      }
      return {
        sectionValue: matchingValues[0],
        shouldGoToNextSection: matchingValues.length === 1
      };
    };
    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {
      const getOptions = (format2) => getLetterEditingOptions(utils2, timezone, activeSection.type, format2);
      if (activeSection.contentType === "letter") {
        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);
      }
      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils2, fallbackFormat).contentType === "letter") {
        const fallbackOptions = getOptions(fallbackFormat);
        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
        if (isQueryResponseWithoutValue(response)) {
          return {
            saveQuery: false
          };
        }
        return _extends$1({}, response, {
          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
        });
      }
      return {
        saveQuery: false
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      switch (activeSection.type) {
        case "month": {
          const formatFallbackValue = (fallbackValue) => changeSectionValueFormat(utils2, fallbackValue, utils2.formats.month, activeSection.format);
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.month, formatFallbackValue);
        }
        case "weekDay": {
          const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.weekday, formatFallbackValue);
        }
        case "meridiem": {
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
        }
        default: {
          return {
            saveQuery: false
          };
        }
      }
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery);
  };
  const applyNumericEditing = (params) => {
    const getNewSectionValue = (queryValue, section) => {
      const cleanQueryValue = removeLocalizedDigits(queryValue, localizedDigits);
      const queryValueNumber = Number(cleanQueryValue);
      const sectionBoundaries = sectionsValueBoundaries[section.type]({
        currentDate: null,
        format: section.format,
        contentType: section.contentType
      });
      if (queryValueNumber > sectionBoundaries.maximum) {
        return {
          saveQuery: false
        };
      }
      if (queryValueNumber < sectionBoundaries.minimum) {
        return {
          saveQuery: true
        };
      }
      const shouldGoToNextSection = queryValueNumber * 10 > sectionBoundaries.maximum || cleanQueryValue.length === sectionBoundaries.maximum.toString().length;
      const newSectionValue = cleanDigitSectionValue(utils2, queryValueNumber, sectionBoundaries, localizedDigits, section);
      return {
        sectionValue: newSectionValue,
        shouldGoToNextSection
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      if (activeSection.contentType === "digit" || activeSection.contentType === "digit-with-letter") {
        return getNewSectionValue(queryValue, activeSection);
      }
      if (activeSection.type === "month") {
        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, "digit", "month", "MM");
        const response = getNewSectionValue(queryValue, {
          type: activeSection.type,
          format: "MM",
          hasLeadingZerosInFormat,
          hasLeadingZerosInInput: true,
          contentType: "digit",
          maxLength: 2
        });
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = changeSectionValueFormat(utils2, response.sectionValue, "MM", activeSection.format);
        return _extends$1({}, response, {
          sectionValue: formattedValue
        });
      }
      if (activeSection.type === "weekDay") {
        const response = getNewSectionValue(queryValue, activeSection);
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = getDaysInWeekStr(utils2, timezone, activeSection.format)[Number(response.sectionValue) - 1];
        return _extends$1({}, response, {
          sectionValue: formattedValue
        });
      }
      return {
        saveQuery: false
      };
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery, (queryValue) => isStringNumber(queryValue, localizedDigits));
  };
  const applyCharacterEditing = useEventCallback((params) => {
    const activeSection = sections[params.sectionIndex];
    const isNumericEditing = isStringNumber(params.keyPressed, localizedDigits);
    const response = isNumericEditing ? applyNumericEditing(_extends$1({}, params, {
      keyPressed: applyLocalizedDigits(params.keyPressed, localizedDigits)
    })) : applyLetterEditing(params);
    if (response == null) {
      setTempAndroidValueStr(null);
      return;
    }
    updateSectionValue({
      activeSection,
      newSectionValue: response.sectionValue,
      shouldGoToNextSection: response.shouldGoToNextSection
    });
  });
  return {
    applyCharacterEditing,
    resetCharacterQuery: resetQuery
  };
};
const useFieldV7TextField = (params) => {
  const {
    internalProps: {
      disabled,
      readOnly = false
    },
    forwardedProps: {
      sectionListRef: inSectionListRef,
      onBlur,
      onClick,
      onFocus,
      onInput,
      onPaste,
      focused: focusedProp,
      autoFocus = false
    },
    fieldValueManager,
    applyCharacterEditing,
    resetCharacterQuery,
    setSelectedSections,
    parsedSelectedSections,
    state,
    clearActiveSection,
    clearValue,
    updateSectionValue,
    updateValueFromValueStr,
    sectionOrder,
    areAllSectionsEmpty,
    sectionsValueBoundaries
  } = params;
  const sectionListRef = reactExports.useRef(null);
  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const id2 = useId();
  const [focused, setFocused] = reactExports.useState(false);
  const interactions = reactExports.useMemo(() => ({
    syncSelectionToDOM: () => {
      if (!sectionListRef.current) {
        return;
      }
      const selection = document.getSelection();
      if (!selection) {
        return;
      }
      if (parsedSelectedSections == null) {
        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {
          selection.removeAllRanges();
        }
        if (focused) {
          sectionListRef.current.getRoot().blur();
        }
        return;
      }
      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {
        return;
      }
      const range = new window.Range();
      let target;
      if (parsedSelectedSections === "all") {
        target = sectionListRef.current.getRoot();
      } else {
        const section = state.sections[parsedSelectedSections];
        if (section.type === "empty") {
          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);
        } else {
          target = sectionListRef.current.getSectionContent(parsedSelectedSections);
        }
      }
      range.selectNodeContents(target);
      target.focus();
      selection.removeAllRanges();
      selection.addRange(range);
    },
    getActiveSectionIndexFromDOM: () => {
      const activeElement = getActiveElement(document);
      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {
        return null;
      }
      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);
    },
    focusField: (newSelectedSections = 0) => {
      if (!sectionListRef.current) {
        return;
      }
      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
      setFocused(true);
      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();
    },
    setSelectedSections: (newSelectedSections) => {
      if (!sectionListRef.current) {
        return;
      }
      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);
      const newActiveSectionIndex = newParsedSelectedSections === "all" ? 0 : newParsedSelectedSections;
      setFocused(newActiveSectionIndex !== null);
      setSelectedSections(newSelectedSections);
    },
    isFieldFocused: () => {
      const activeElement = getActiveElement(document);
      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);
    }
  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);
  const revertDOMSectionChange = useEventCallback((sectionIndex) => {
    if (!sectionListRef.current) {
      return;
    }
    const section = state.sections[sectionIndex];
    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;
    interactions.syncSelectionToDOM();
  });
  const handleContainerClick = useEventCallback((event, ...args) => {
    if (event.isDefaultPrevented() || !sectionListRef.current) {
      return;
    }
    setFocused(true);
    onClick == null ? void 0 : onClick(event, ...args);
    if (parsedSelectedSections === "all") {
      setTimeout(() => {
        const cursorPosition2 = document.getSelection().getRangeAt(0).startOffset;
        if (cursorPosition2 === 0) {
          setSelectedSections(sectionOrder.startIndex);
          return;
        }
        let sectionIndex = 0;
        let cursorOnStartOfSection = 0;
        while (cursorOnStartOfSection < cursorPosition2 && sectionIndex < state.sections.length) {
          const section = state.sections[sectionIndex];
          sectionIndex += 1;
          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;
        }
        setSelectedSections(sectionIndex - 1);
      });
    } else if (!focused) {
      setFocused(true);
      setSelectedSections(sectionOrder.startIndex);
    } else {
      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);
      if (!hasClickedOnASection) {
        setSelectedSections(sectionOrder.startIndex);
      }
    }
  });
  const handleContainerInput = useEventCallback((event) => {
    onInput == null ? void 0 : onInput(event);
    if (!sectionListRef.current || parsedSelectedSections !== "all") {
      return;
    }
    const target = event.target;
    const keyPressed = target.textContent ?? "";
    sectionListRef.current.getRoot().innerHTML = state.sections.map((section) => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join("");
    interactions.syncSelectionToDOM();
    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {
      resetCharacterQuery();
      clearValue();
      setSelectedSections("all");
    } else if (keyPressed.length > 1) {
      updateValueFromValueStr(keyPressed);
    } else {
      applyCharacterEditing({
        keyPressed,
        sectionIndex: 0
      });
    }
  });
  const handleContainerPaste = useEventCallback((event) => {
    onPaste == null ? void 0 : onPaste(event);
    if (readOnly || parsedSelectedSections !== "all") {
      event.preventDefault();
      return;
    }
    const pastedValue = event.clipboardData.getData("text");
    event.preventDefault();
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleContainerFocus = useEventCallback((...args) => {
    onFocus == null ? void 0 : onFocus(...args);
    if (focused || !sectionListRef.current) {
      return;
    }
    setFocused(true);
    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;
    if (!isFocusInsideASection) {
      setSelectedSections(sectionOrder.startIndex);
    }
  });
  const handleContainerBlur = useEventCallback((...args) => {
    onBlur == null ? void 0 : onBlur(...args);
    setTimeout(() => {
      if (!sectionListRef.current) {
        return;
      }
      const activeElement = getActiveElement(document);
      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);
      if (shouldBlur) {
        setFocused(false);
        setSelectedSections(null);
      }
    });
  });
  const getInputContainerClickHandler = useEventCallback((sectionIndex) => (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    setSelectedSections(sectionIndex);
  });
  const handleInputContentMouseUp = useEventCallback((event) => {
    event.preventDefault();
  });
  const getInputContentFocusHandler = useEventCallback((sectionIndex) => () => {
    setSelectedSections(sectionIndex);
  });
  const handleInputContentPaste = useEventCallback((event) => {
    event.preventDefault();
    if (readOnly || disabled || typeof parsedSelectedSections !== "number") {
      return;
    }
    const activeSection = state.sections[parsedSelectedSections];
    const pastedValue = event.clipboardData.getData("text");
    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
    const digitsOnly = /^[0-9]+$/.test(pastedValue);
    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
    const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
    if (isValidPastedValue) {
      resetCharacterQuery();
      updateSectionValue({
        activeSection,
        newSectionValue: pastedValue,
        shouldGoToNextSection: true
      });
    } else if (!lettersOnly && !digitsOnly) {
      resetCharacterQuery();
      updateValueFromValueStr(pastedValue);
    }
  });
  const handleInputContentDragOver = useEventCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "none";
  });
  const handleInputContentInput = useEventCallback((event) => {
    if (!sectionListRef.current) {
      return;
    }
    const target = event.target;
    const keyPressed = target.textContent ?? "";
    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);
    const section = state.sections[sectionIndex];
    if (readOnly || !sectionListRef.current) {
      revertDOMSectionChange(sectionIndex);
      return;
    }
    if (keyPressed.length === 0) {
      if (section.value === "") {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      const inputType = event.nativeEvent.inputType;
      if (inputType === "insertParagraph" || inputType === "insertLineBreak") {
        revertDOMSectionChange(sectionIndex);
        return;
      }
      resetCharacterQuery();
      clearActiveSection();
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex
    });
    revertDOMSectionChange(sectionIndex);
  });
  useEnhancedEffect(() => {
    if (!focused || !sectionListRef.current) {
      return;
    }
    if (parsedSelectedSections === "all") {
      sectionListRef.current.getRoot().focus();
    } else if (typeof parsedSelectedSections === "number") {
      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);
      if (domElement) {
        domElement.focus();
      }
    }
  }, [parsedSelectedSections, focused]);
  const sectionBoundaries = reactExports.useMemo(() => {
    return state.sections.reduce((acc, next2) => {
      acc[next2.type] = sectionsValueBoundaries[next2.type]({
        currentDate: null,
        contentType: next2.contentType,
        format: next2.format
      });
      return acc;
    }, {});
  }, [sectionsValueBoundaries, state.sections]);
  const isContainerEditable = parsedSelectedSections === "all";
  const elements = reactExports.useMemo(() => {
    return state.sections.map((section, index) => {
      const isEditable = !isContainerEditable && !disabled && !readOnly;
      return {
        container: {
          "data-sectionindex": index,
          onClick: getInputContainerClickHandler(index)
        },
        content: {
          tabIndex: isContainerEditable || index > 0 ? -1 : 0,
          contentEditable: !isContainerEditable && !disabled && !readOnly,
          role: "spinbutton",
          id: `${id2}-${section.type}`,
          "aria-labelledby": `${id2}-${section.type}`,
          "aria-readonly": readOnly,
          "aria-valuenow": getSectionValueNow(section, utils2),
          "aria-valuemin": sectionBoundaries[section.type].minimum,
          "aria-valuemax": sectionBoundaries[section.type].maximum,
          "aria-valuetext": section.value ? getSectionValueText(section, utils2) : translations.empty,
          "aria-label": translations[section.type],
          "aria-disabled": disabled,
          spellCheck: isEditable ? false : void 0,
          autoCapitalize: isEditable ? "off" : void 0,
          autoCorrect: isEditable ? "off" : void 0,
          [parseInt(reactExports.version, 10) >= 17 ? "enterKeyHint" : "enterkeyhint"]: isEditable ? "next" : void 0,
          children: section.value || section.placeholder,
          onInput: handleInputContentInput,
          onPaste: handleInputContentPaste,
          onFocus: getInputContentFocusHandler(index),
          onDragOver: handleInputContentDragOver,
          onMouseUp: handleInputContentMouseUp,
          inputMode: section.contentType === "letter" ? "text" : "numeric"
        },
        before: {
          children: section.startSeparator
        },
        after: {
          children: section.endSeparator
        }
      };
    });
  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils2, sectionBoundaries, id2]);
  const handleValueStrChange = useEventCallback((event) => {
    updateValueFromValueStr(event.target.value);
  });
  const valueStr = reactExports.useMemo(() => areAllSectionsEmpty ? "" : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);
  reactExports.useEffect(() => {
    if (sectionListRef.current == null) {
      throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`", "You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.", "", "If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:", "", "<DatePicker slots={{ textField: MyCustomTextField }} />", "", "Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join("\n"));
    }
    if (autoFocus && sectionListRef.current) {
      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();
    }
  }, []);
  return {
    interactions,
    returnedValue: {
      // Forwarded
      autoFocus,
      readOnly,
      focused: focusedProp ?? focused,
      sectionListRef: handleSectionListRef,
      onBlur: handleContainerBlur,
      onClick: handleContainerClick,
      onFocus: handleContainerFocus,
      onInput: handleContainerInput,
      onPaste: handleContainerPaste,
      // Additional
      enableAccessibleFieldDOMStructure: true,
      elements,
      // TODO v7: Try to set to undefined when there is a section selected.
      tabIndex: parsedSelectedSections === 0 ? -1 : 0,
      contentEditable: isContainerEditable,
      value: valueStr,
      onChange: handleValueStrChange,
      areAllSectionsEmpty
    }
  };
};
const cleanString = (dirtyString) => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, "");
const addPositionPropertiesToSections = (sections, localizedDigits, isRtl) => {
  let position2 = 0;
  let positionInInput = isRtl ? 1 : 0;
  const newSections = [];
  for (let i2 = 0; i2 < sections.length; i2 += 1) {
    const section = sections[i2];
    const renderedValue = getSectionVisibleValue(section, isRtl ? "input-rtl" : "input-ltr", localizedDigits);
    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
    const sectionLength = cleanString(sectionStr).length;
    const sectionLengthInInput = sectionStr.length;
    const cleanedValue = cleanString(renderedValue);
    const startInInput = positionInInput + (cleanedValue === "" ? 0 : renderedValue.indexOf(cleanedValue[0])) + section.startSeparator.length;
    const endInInput = startInInput + cleanedValue.length;
    newSections.push(_extends$1({}, section, {
      start: position2,
      end: position2 + sectionLength,
      startInInput,
      endInInput
    }));
    position2 += sectionLength;
    positionInInput += sectionLengthInInput;
  }
  return newSections;
};
const useFieldV6TextField = (params) => {
  const isRtl = useRtl();
  const focusTimeoutRef = reactExports.useRef();
  const selectionSyncTimeoutRef = reactExports.useRef();
  const {
    forwardedProps: {
      onFocus,
      onClick,
      onPaste,
      onBlur,
      inputRef: inputRefProp,
      placeholder: inPlaceholder
    },
    internalProps: {
      readOnly = false,
      disabled = false
    },
    parsedSelectedSections,
    activeSectionIndex,
    state,
    fieldValueManager,
    valueManager,
    applyCharacterEditing,
    resetCharacterQuery,
    updateSectionValue,
    updateValueFromValueStr,
    clearActiveSection,
    clearValue,
    setTempAndroidValueStr,
    setSelectedSections,
    getSectionsFromValue,
    areAllSectionsEmpty,
    localizedDigits
  } = params;
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(inputRefProp, inputRef);
  const sections = reactExports.useMemo(() => addPositionPropertiesToSections(state.sections, localizedDigits, isRtl), [state.sections, localizedDigits, isRtl]);
  const interactions = reactExports.useMemo(() => ({
    syncSelectionToDOM: () => {
      if (!inputRef.current) {
        return;
      }
      if (parsedSelectedSections == null) {
        if (inputRef.current.scrollLeft) {
          inputRef.current.scrollLeft = 0;
        }
        return;
      }
      if (inputRef.current !== getActiveElement(document)) {
        return;
      }
      const currentScrollTop = inputRef.current.scrollTop;
      if (parsedSelectedSections === "all") {
        inputRef.current.select();
      } else {
        const selectedSection = sections[parsedSelectedSections];
        const selectionStart = selectedSection.type === "empty" ? selectedSection.startInInput - selectedSection.startSeparator.length : selectedSection.startInInput;
        const selectionEnd = selectedSection.type === "empty" ? selectedSection.endInInput + selectedSection.endSeparator.length : selectedSection.endInInput;
        if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {
          if (inputRef.current === getActiveElement(document)) {
            inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          }
        }
        clearTimeout(selectionSyncTimeoutRef.current);
        selectionSyncTimeoutRef.current = setTimeout(() => {
          if (inputRef.current && inputRef.current === getActiveElement(document) && // The section might loose all selection, where `selectionStart === selectionEnd`
          // https://github.com/mui/mui-x/pull/13652
          inputRef.current.selectionStart === inputRef.current.selectionEnd && (inputRef.current.selectionStart !== selectionStart || inputRef.current.selectionEnd !== selectionEnd)) {
            interactions.syncSelectionToDOM();
          }
        });
      }
      inputRef.current.scrollTop = currentScrollTop;
    },
    getActiveSectionIndexFromDOM: () => {
      const browserStartIndex = inputRef.current.selectionStart ?? 0;
      const browserEndIndex = inputRef.current.selectionEnd ?? 0;
      if (browserStartIndex === 0 && browserEndIndex === 0) {
        return null;
      }
      const nextSectionIndex = browserStartIndex <= sections[0].startInInput ? 1 : sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
      return nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
    },
    focusField: (newSelectedSection = 0) => {
      var _a2;
      (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
      setSelectedSections(newSelectedSection);
    },
    setSelectedSections: (newSelectedSections) => setSelectedSections(newSelectedSections),
    isFieldFocused: () => inputRef.current === getActiveElement(document)
  }), [inputRef, parsedSelectedSections, sections, setSelectedSections]);
  const syncSelectionFromDOM = () => {
    const browserStartIndex = inputRef.current.selectionStart ?? 0;
    let nextSectionIndex;
    if (browserStartIndex <= sections[0].startInInput) {
      nextSectionIndex = 1;
    } else if (browserStartIndex >= sections[sections.length - 1].endInInput) {
      nextSectionIndex = 1;
    } else {
      nextSectionIndex = sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
    }
    const sectionIndex = nextSectionIndex === -1 ? sections.length - 1 : nextSectionIndex - 1;
    setSelectedSections(sectionIndex);
  };
  const handleInputFocus = useEventCallback((...args) => {
    onFocus == null ? void 0 : onFocus(...args);
    const input = inputRef.current;
    clearTimeout(focusTimeoutRef.current);
    focusTimeoutRef.current = setTimeout(() => {
      if (!input || input !== inputRef.current) {
        return;
      }
      if (activeSectionIndex != null) {
        return;
      }
      if (
        // avoid selecting all sections when focusing empty field without value
        input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length
      ) {
        setSelectedSections("all");
      } else {
        syncSelectionFromDOM();
      }
    });
  });
  const handleInputClick = useEventCallback((event, ...args) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    onClick == null ? void 0 : onClick(event, ...args);
    syncSelectionFromDOM();
  });
  const handleInputPaste = useEventCallback((event) => {
    onPaste == null ? void 0 : onPaste(event);
    event.preventDefault();
    if (readOnly || disabled) {
      return;
    }
    const pastedValue = event.clipboardData.getData("text");
    if (typeof parsedSelectedSections === "number") {
      const activeSection = state.sections[parsedSelectedSections];
      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
      const digitsOnly = /^[0-9]+$/.test(pastedValue);
      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
      const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
      if (isValidPastedValue) {
        resetCharacterQuery();
        updateSectionValue({
          activeSection,
          newSectionValue: pastedValue,
          shouldGoToNextSection: true
        });
        return;
      }
      if (lettersOnly || digitsOnly) {
        return;
      }
    }
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleContainerBlur = useEventCallback((...args) => {
    onBlur == null ? void 0 : onBlur(...args);
    setSelectedSections(null);
  });
  const handleInputChange = useEventCallback((event) => {
    if (readOnly) {
      return;
    }
    const targetValue = event.target.value;
    if (targetValue === "") {
      resetCharacterQuery();
      clearValue();
      return;
    }
    const eventData = event.nativeEvent.data;
    const shouldUseEventData = eventData && eventData.length > 1;
    const valueStr2 = shouldUseEventData ? eventData : targetValue;
    const cleanValueStr = cleanString(valueStr2);
    if (activeSectionIndex == null || shouldUseEventData) {
      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);
      return;
    }
    let keyPressed;
    if (parsedSelectedSections === "all" && cleanValueStr.length === 1) {
      keyPressed = cleanValueStr;
    } else {
      const prevValueStr = cleanString(fieldValueManager.getV6InputValueFromSections(sections, localizedDigits, isRtl));
      let startOfDiffIndex = -1;
      let endOfDiffIndex = -1;
      for (let i2 = 0; i2 < prevValueStr.length; i2 += 1) {
        if (startOfDiffIndex === -1 && prevValueStr[i2] !== cleanValueStr[i2]) {
          startOfDiffIndex = i2;
        }
        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i2 - 1] !== cleanValueStr[cleanValueStr.length - i2 - 1]) {
          endOfDiffIndex = i2;
        }
      }
      const activeSection = sections[activeSectionIndex];
      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
      if (hasDiffOutsideOfActiveSection) {
        return;
      }
      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || "").length;
      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || "").length, activeSectionEndRelativeToNewValue);
    }
    if (keyPressed.length === 0) {
      if (isAndroid2()) {
        setTempAndroidValueStr(valueStr2);
      }
      resetCharacterQuery();
      clearActiveSection();
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex: activeSectionIndex
    });
  });
  const placeholder = reactExports.useMemo(() => {
    if (inPlaceholder !== void 0) {
      return inPlaceholder;
    }
    return fieldValueManager.getV6InputValueFromSections(getSectionsFromValue(valueManager.emptyValue), localizedDigits, isRtl);
  }, [inPlaceholder, fieldValueManager, getSectionsFromValue, valueManager.emptyValue, localizedDigits, isRtl]);
  const valueStr = reactExports.useMemo(() => state.tempValueStrAndroid ?? fieldValueManager.getV6InputValueFromSections(state.sections, localizedDigits, isRtl), [state.sections, fieldValueManager, state.tempValueStrAndroid, localizedDigits, isRtl]);
  reactExports.useEffect(() => {
    if (inputRef.current && inputRef.current === getActiveElement(document)) {
      setSelectedSections("all");
    }
    return () => {
      clearTimeout(focusTimeoutRef.current);
      clearTimeout(selectionSyncTimeoutRef.current);
    };
  }, []);
  const inputMode = reactExports.useMemo(() => {
    if (activeSectionIndex == null) {
      return "text";
    }
    if (state.sections[activeSectionIndex].contentType === "letter") {
      return "text";
    }
    return "numeric";
  }, [activeSectionIndex, state.sections]);
  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);
  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;
  return {
    interactions,
    returnedValue: {
      // Forwarded
      readOnly,
      onBlur: handleContainerBlur,
      onClick: handleInputClick,
      onFocus: handleInputFocus,
      onPaste: handleInputPaste,
      inputRef: handleRef,
      // Additional
      enableAccessibleFieldDOMStructure: false,
      placeholder,
      inputMode,
      autoComplete: "off",
      value: shouldShowPlaceholder ? "" : valueStr,
      onChange: handleInputChange
    }
  };
};
const useField = (params) => {
  const utils2 = useUtils();
  const {
    internalProps,
    internalProps: {
      unstableFieldRef,
      minutesStep,
      enableAccessibleFieldDOMStructure = false,
      disabled = false,
      readOnly = false
    },
    forwardedProps: {
      onKeyDown,
      error,
      clearable,
      onClear
    },
    fieldValueManager,
    valueManager,
    validator
  } = params;
  const isRtl = useRtl();
  const stateResponse = useFieldState(params);
  const {
    state,
    activeSectionIndex,
    parsedSelectedSections,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    setTempAndroidValueStr,
    sectionsValueBoundaries,
    localizedDigits,
    timezone
  } = stateResponse;
  const characterEditingResponse = useFieldCharacterEditing({
    sections: state.sections,
    updateSectionValue,
    sectionsValueBoundaries,
    localizedDigits,
    setTempAndroidValueStr,
    timezone
  });
  const {
    resetCharacterQuery
  } = characterEditingResponse;
  const areAllSectionsEmpty = valueManager.areValuesEqual(utils2, state.value, valueManager.emptyValue);
  const useFieldTextField = enableAccessibleFieldDOMStructure ? useFieldV7TextField : useFieldV6TextField;
  const sectionOrder = reactExports.useMemo(() => getSectionOrder(state.sections, isRtl && !enableAccessibleFieldDOMStructure), [state.sections, isRtl, enableAccessibleFieldDOMStructure]);
  const {
    returnedValue,
    interactions
  } = useFieldTextField(_extends$1({}, params, stateResponse, characterEditingResponse, {
    areAllSectionsEmpty,
    sectionOrder
  }));
  const handleContainerKeyDown = useEventCallback((event) => {
    onKeyDown == null ? void 0 : onKeyDown(event);
    if (disabled) {
      return;
    }
    switch (true) {
      case ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "a" && !event.shiftKey && !event.altKey): {
        event.preventDefault();
        setSelectedSections("all");
        break;
      }
      case event.key === "ArrowRight": {
        event.preventDefault();
        if (parsedSelectedSections == null) {
          setSelectedSections(sectionOrder.startIndex);
        } else if (parsedSelectedSections === "all") {
          setSelectedSections(sectionOrder.endIndex);
        } else {
          const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].rightIndex;
          if (nextSectionIndex !== null) {
            setSelectedSections(nextSectionIndex);
          }
        }
        break;
      }
      case event.key === "ArrowLeft": {
        event.preventDefault();
        if (parsedSelectedSections == null) {
          setSelectedSections(sectionOrder.endIndex);
        } else if (parsedSelectedSections === "all") {
          setSelectedSections(sectionOrder.startIndex);
        } else {
          const nextSectionIndex = sectionOrder.neighbors[parsedSelectedSections].leftIndex;
          if (nextSectionIndex !== null) {
            setSelectedSections(nextSectionIndex);
          }
        }
        break;
      }
      case event.key === "Delete": {
        event.preventDefault();
        if (readOnly) {
          break;
        }
        if (parsedSelectedSections == null || parsedSelectedSections === "all") {
          clearValue();
        } else {
          clearActiveSection();
        }
        resetCharacterQuery();
        break;
      }
      case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(event.key): {
        event.preventDefault();
        if (readOnly || activeSectionIndex == null) {
          break;
        }
        const activeSection = state.sections[activeSectionIndex];
        const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
        const newSectionValue = adjustSectionValue(utils2, timezone, activeSection, event.key, sectionsValueBoundaries, localizedDigits, activeDateManager.date, {
          minutesStep
        });
        updateSectionValue({
          activeSection,
          newSectionValue,
          shouldGoToNextSection: false
        });
        break;
      }
    }
  });
  useEnhancedEffect(() => {
    interactions.syncSelectionToDOM();
  });
  const validationError = useValidation(_extends$1({}, internalProps, {
    value: state.value,
    timezone
  }), validator, valueManager.isSameError, valueManager.defaultErrorState);
  const inputError = reactExports.useMemo(() => {
    if (error !== void 0) {
      return error;
    }
    return valueManager.hasError(validationError);
  }, [valueManager, validationError, error]);
  reactExports.useEffect(() => {
    if (!inputError && activeSectionIndex == null) {
      resetCharacterQuery();
    }
  }, [state.referenceValue, activeSectionIndex, inputError]);
  reactExports.useEffect(() => {
    if (state.tempValueStrAndroid != null && activeSectionIndex != null) {
      resetCharacterQuery();
      clearActiveSection();
    }
  }, [state.sections]);
  reactExports.useImperativeHandle(unstableFieldRef, () => ({
    getSections: () => state.sections,
    getActiveSectionIndex: interactions.getActiveSectionIndexFromDOM,
    setSelectedSections: interactions.setSelectedSections,
    focusField: interactions.focusField,
    isFieldFocused: interactions.isFieldFocused
  }));
  const handleClearValue = useEventCallback((event, ...args) => {
    event.preventDefault();
    onClear == null ? void 0 : onClear(event, ...args);
    clearValue();
    if (!interactions.isFieldFocused()) {
      interactions.focusField(0);
    } else {
      setSelectedSections(sectionOrder.startIndex);
    }
  });
  const commonForwardedProps = {
    onKeyDown: handleContainerKeyDown,
    onClear: handleClearValue,
    error: inputError,
    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly && !disabled)
  };
  const commonAdditionalProps = {
    disabled,
    readOnly
  };
  return _extends$1({}, params.forwardedProps, commonForwardedProps, commonAdditionalProps, returnedValue);
};
const DATE_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"];
const TIME_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minTime", "maxTime", "shouldDisableTime", "minutesStep", "ampm", "disableIgnoringDatePartForTimeValidation"];
const DATE_TIME_VALIDATION_PROP_NAMES = ["minDateTime", "maxDateTime"];
const VALIDATION_PROP_NAMES = [...DATE_VALIDATION_PROP_NAMES, ...TIME_VALIDATION_PROP_NAMES, ...DATE_TIME_VALIDATION_PROP_NAMES];
const extractValidationProps = (props) => VALIDATION_PROP_NAMES.reduce((extractedProps, propName) => {
  if (props.hasOwnProperty(propName)) {
    extractedProps[propName] = props[propName];
  }
  return extractedProps;
}, {});
const SHARED_FIELD_INTERNAL_PROP_NAMES = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "timezone", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef", "enableAccessibleFieldDOMStructure", "disabled", "readOnly", "dateSeparator"];
const splitFieldInternalAndForwardedProps = (props, valueType) => {
  const forwardedProps = _extends$1({}, props);
  const internalProps = {};
  const extractProp = (propName) => {
    if (forwardedProps.hasOwnProperty(propName)) {
      internalProps[propName] = forwardedProps[propName];
      delete forwardedProps[propName];
    }
  };
  SHARED_FIELD_INTERNAL_PROP_NAMES.forEach(extractProp);
  if (valueType === "date") {
    DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
  } else if (valueType === "time") {
    TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
  } else if (valueType === "date-time") {
    DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
    TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
    DATE_TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
  }
  return {
    forwardedProps,
    internalProps
  };
};
const useDefaultizedDateField = (props) => {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  return _extends$1({}, props, {
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    format: props.format ?? utils2.formats.keyboardDate,
    minDate: applyDefaultDate(utils2, props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, props.maxDate, defaultDates.maxDate)
  });
};
const useDefaultizedTimeField = (props) => {
  const utils2 = useUtils();
  const ampm = props.ampm ?? utils2.is12HourCycleInCurrentLocale();
  const defaultFormat = ampm ? utils2.formats.fullTime12h : utils2.formats.fullTime24h;
  return _extends$1({}, props, {
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    format: props.format ?? defaultFormat
  });
};
const useDefaultizedDateTimeField = (props) => {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const ampm = props.ampm ?? utils2.is12HourCycleInCurrentLocale();
  const defaultFormat = ampm ? utils2.formats.keyboardDateTime12h : utils2.formats.keyboardDateTime24h;
  return _extends$1({}, props, {
    disablePast: props.disablePast ?? false,
    disableFuture: props.disableFuture ?? false,
    format: props.format ?? defaultFormat,
    disableIgnoringDatePartForTimeValidation: Boolean(props.minDateTime || props.maxDateTime),
    minDate: applyDefaultDate(utils2, props.minDateTime ?? props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, props.maxDateTime ?? props.maxDate, defaultDates.maxDate),
    minTime: props.minDateTime ?? props.minTime,
    maxTime: props.maxDateTime ?? props.maxTime
  });
};
const useDateField2 = (inProps) => {
  const props = useDefaultizedDateField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date");
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDate,
    valueType: "date"
  });
};
const _excluded$B = ["clearable", "onClear", "InputProps", "sx", "slots", "slotProps"], _excluded2$4 = ["ownerState"];
const useClearableField = (props) => {
  const translations = usePickersTranslations();
  const {
    clearable,
    onClear,
    InputProps,
    sx,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$B);
  const IconButton$12 = (slots == null ? void 0 : slots.clearButton) ?? IconButton;
  const _useSlotProps = useSlotProps({
    elementType: IconButton$12,
    externalSlotProps: slotProps == null ? void 0 : slotProps.clearButton,
    ownerState: {},
    className: "clearButton",
    additionalProps: {
      title: translations.fieldClearLabel
    }
  }), iconButtonProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$4);
  const EndClearIcon = (slots == null ? void 0 : slots.clearIcon) ?? ClearIcon;
  const endClearIconProps = useSlotProps({
    elementType: EndClearIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.clearIcon,
    ownerState: {}
  });
  return _extends$1({}, other, {
    InputProps: _extends$1({}, InputProps, {
      endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [clearable && /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, {
          position: "end",
          sx: {
            marginRight: (InputProps == null ? void 0 : InputProps.endAdornment) ? -1 : -1.5
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$12, _extends$1({}, iconButtonProps, {
            onClick: onClear,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(EndClearIcon, _extends$1({
              fontSize: "small"
            }, endClearIconProps))
          }))
        }), InputProps == null ? void 0 : InputProps.endAdornment]
      })
    }),
    sx: [{
      "& .clearButton": {
        opacity: 1
      },
      "@media (pointer: fine)": {
        "& .clearButton": {
          opacity: 0
        },
        "&:hover, &:focus-within": {
          ".clearButton": {
            opacity: 1
          }
        }
      }
    }, ...Array.isArray(sx) ? sx : [sx]]
  });
};
function getPickersTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiPickersTextField", slot);
}
generateUtilityClasses("MuiPickersTextField", ["root", "focused", "disabled", "error", "required"]);
function getPickersInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiPickersInputBase", slot);
}
const pickersInputBaseClasses = generateUtilityClasses("MuiPickersInputBase", ["root", "focused", "disabled", "error", "notchedOutline", "sectionContent", "sectionBefore", "sectionAfter", "adornedStart", "adornedEnd", "input"]);
function getPickersSectionListUtilityClass(slot) {
  return generateUtilityClass("MuiPickersSectionList", slot);
}
const pickersSectionListClasses = generateUtilityClasses("MuiPickersSectionList", ["root", "section", "sectionContent"]);
const _excluded$A = ["slots", "slotProps", "elements", "sectionListRef"];
const PickersSectionListRoot = styled("div", {
  name: "MuiPickersSectionList",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  direction: "ltr /*! @noflip */",
  outline: "none"
});
const PickersSectionListSection = styled("span", {
  name: "MuiPickersSectionList",
  slot: "Section",
  overridesResolver: (props, styles2) => styles2.section
})({});
const PickersSectionListSectionSeparator = styled("span", {
  name: "MuiPickersSectionList",
  slot: "SectionSeparator",
  overridesResolver: (props, styles2) => styles2.sectionSeparator
})({
  whiteSpace: "pre"
});
const PickersSectionListSectionContent = styled("span", {
  name: "MuiPickersSectionList",
  slot: "SectionContent",
  overridesResolver: (props, styles2) => styles2.sectionContent
})({
  outline: "none"
});
const useUtilityClasses$H = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    section: ["section"],
    sectionContent: ["sectionContent"]
  };
  return composeClasses(slots, getPickersSectionListUtilityClass, classes);
};
function PickersSection(props) {
  const {
    slots,
    slotProps,
    element,
    classes
  } = props;
  const Section = (slots == null ? void 0 : slots.section) ?? PickersSectionListSection;
  const sectionProps = useSlotProps({
    elementType: Section,
    externalSlotProps: slotProps == null ? void 0 : slotProps.section,
    externalForwardedProps: element.container,
    className: classes.section,
    ownerState: {}
  });
  const SectionContent = (slots == null ? void 0 : slots.sectionContent) ?? PickersSectionListSectionContent;
  const sectionContentProps = useSlotProps({
    elementType: SectionContent,
    externalSlotProps: slotProps == null ? void 0 : slotProps.sectionContent,
    externalForwardedProps: element.content,
    additionalProps: {
      suppressContentEditableWarning: true
    },
    className: classes.sectionContent,
    ownerState: {}
  });
  const SectionSeparator = (slots == null ? void 0 : slots.sectionSeparator) ?? PickersSectionListSectionSeparator;
  const sectionSeparatorBeforeProps = useSlotProps({
    elementType: SectionSeparator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.sectionSeparator,
    externalForwardedProps: element.before,
    ownerState: {
      position: "before"
    }
  });
  const sectionSeparatorAfterProps = useSlotProps({
    elementType: SectionSeparator,
    externalSlotProps: slotProps == null ? void 0 : slotProps.sectionSeparator,
    externalForwardedProps: element.after,
    ownerState: {
      position: "after"
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, _extends$1({}, sectionProps, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$1({}, sectionSeparatorBeforeProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionContent, _extends$1({}, sectionContentProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(SectionSeparator, _extends$1({}, sectionSeparatorAfterProps))]
  }));
}
const PickersSectionList = /* @__PURE__ */ reactExports.forwardRef(function PickersSectionList2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersSectionList"
  });
  const {
    slots,
    slotProps,
    elements,
    sectionListRef
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$A);
  const classes = useUtilityClasses$H(props);
  const rootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const getRoot = (methodName) => {
    if (!rootRef.current) {
      throw new Error(`MUI X: Cannot call sectionListRef.${methodName} before the mount of the component.`);
    }
    return rootRef.current;
  };
  reactExports.useImperativeHandle(sectionListRef, () => ({
    getRoot() {
      return getRoot("getRoot");
    },
    getSectionContainer(index) {
      const root2 = getRoot("getSectionContainer");
      return root2.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index}"]`);
    },
    getSectionContent(index) {
      const root2 = getRoot("getSectionContent");
      return root2.querySelector(`.${pickersSectionListClasses.section}[data-sectionindex="${index}"] .${pickersSectionListClasses.sectionContent}`);
    },
    getSectionIndexFromDOMElement(element) {
      const root2 = getRoot("getSectionIndexFromDOMElement");
      if (element == null || !root2.contains(element)) {
        return null;
      }
      let sectionContainer = null;
      if (element.classList.contains(pickersSectionListClasses.section)) {
        sectionContainer = element;
      } else if (element.classList.contains(pickersSectionListClasses.sectionContent)) {
        sectionContainer = element.parentElement;
      }
      if (sectionContainer == null) {
        return null;
      }
      return Number(sectionContainer.dataset.sectionindex);
    }
  }));
  const Root = (slots == null ? void 0 : slots.root) ?? PickersSectionListRoot;
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: handleRootRef,
      suppressContentEditableWarning: true
    },
    className: classes.root,
    ownerState: {}
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$1({}, rootProps, {
    children: rootProps.contentEditable ? elements.map(({
      content,
      before: before2,
      after: after2
    }) => `${before2.children}${content.children}${after2.children}`).join("") : /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: elements.map((element, elementIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSection, {
        slots,
        slotProps,
        element,
        classes
      }, elementIndex))
    })
  }));
});
const _excluded$z = ["elements", "areAllSectionsEmpty", "defaultValue", "label", "value", "onChange", "id", "autoFocus", "endAdornment", "startAdornment", "renderSuffix", "slots", "slotProps", "contentEditable", "tabIndex", "onInput", "onPaste", "onKeyDown", "fullWidth", "name", "readOnly", "inputProps", "inputRef", "sectionListRef"];
const round = (value) => Math.round(value * 1e5) / 1e5;
const PickersInputBaseRoot = styled("div", {
  name: "MuiPickersInputBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme
}) => _extends$1({}, theme.typography.body1, {
  color: (theme.vars || theme).palette.text.primary,
  cursor: "text",
  padding: 0,
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  letterSpacing: `${round(0.15 / 16)}em`,
  variants: [{
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
}));
const PickersInputBaseSectionsContainer = styled(PickersSectionListRoot, {
  name: "MuiPickersInputBase",
  slot: "SectionsContainer",
  overridesResolver: (props, styles2) => styles2.sectionsContainer
})(({
  theme
}) => ({
  padding: "4px 0 5px",
  fontFamily: theme.typography.fontFamily,
  fontSize: "inherit",
  lineHeight: "1.4375em",
  // 23px
  flexGrow: 1,
  outline: "none",
  display: "flex",
  flexWrap: "nowrap",
  overflow: "hidden",
  letterSpacing: "inherit",
  // Baseline behavior
  width: "182px",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      textAlign: "right /*! @noflip */"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingTop: 1
    }
  }, {
    props: {
      adornedStart: false,
      focused: false,
      filled: false
    },
    style: {
      color: "currentColor",
      opacity: 0
    }
  }, {
    // Can't use the object notation because label can be null or undefined
    props: ({
      adornedStart,
      focused,
      filled,
      label
    }) => !adornedStart && !focused && !filled && label == null,
    style: theme.vars ? {
      opacity: theme.vars.opacity.inputPlaceholder
    } : {
      opacity: theme.palette.mode === "light" ? 0.42 : 0.5
    }
  }]
}));
const PickersInputBaseSection = styled(PickersSectionListSection, {
  name: "MuiPickersInputBase",
  slot: "Section",
  overridesResolver: (props, styles2) => styles2.section
})(({
  theme
}) => ({
  fontFamily: theme.typography.fontFamily,
  fontSize: "inherit",
  letterSpacing: "inherit",
  lineHeight: "1.4375em",
  // 23px
  display: "flex"
}));
const PickersInputBaseSectionContent = styled(PickersSectionListSectionContent, {
  name: "MuiPickersInputBase",
  slot: "SectionContent",
  overridesResolver: (props, styles2) => styles2.content
})(({
  theme
}) => ({
  fontFamily: theme.typography.fontFamily,
  lineHeight: "1.4375em",
  // 23px
  letterSpacing: "inherit",
  width: "fit-content",
  outline: "none"
}));
const PickersInputBaseSectionSeparator = styled(PickersSectionListSectionSeparator, {
  name: "MuiPickersInputBase",
  slot: "Separator",
  overridesResolver: (props, styles2) => styles2.separator
})(() => ({
  whiteSpace: "pre",
  letterSpacing: "inherit"
}));
const PickersInputBaseInput = styled("input", {
  name: "MuiPickersInputBase",
  slot: "Input",
  overridesResolver: (props, styles2) => styles2.hiddenInput
})(_extends$1({}, visuallyHidden));
const useUtilityClasses$G = (ownerState) => {
  const {
    focused,
    disabled,
    error,
    classes,
    fullWidth,
    readOnly,
    color: color2,
    size: size2,
    endAdornment,
    startAdornment
  } = ownerState;
  const slots = {
    root: ["root", focused && !disabled && "focused", disabled && "disabled", readOnly && "readOnly", error && "error", fullWidth && "fullWidth", `color${capitalize(color2)}`, size2 === "small" && "inputSizeSmall", Boolean(startAdornment) && "adornedStart", Boolean(endAdornment) && "adornedEnd"],
    notchedOutline: ["notchedOutline"],
    input: ["input"],
    sectionsContainer: ["sectionsContainer"],
    sectionContent: ["sectionContent"],
    sectionBefore: ["sectionBefore"],
    sectionAfter: ["sectionAfter"]
  };
  return composeClasses(slots, getPickersInputBaseUtilityClass, classes);
};
const PickersInputBase = /* @__PURE__ */ reactExports.forwardRef(function PickersInputBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersInputBase"
  });
  const {
    elements,
    areAllSectionsEmpty,
    value,
    onChange,
    id: id2,
    endAdornment,
    startAdornment,
    renderSuffix,
    slots,
    slotProps,
    contentEditable,
    tabIndex,
    onInput,
    onPaste,
    onKeyDown,
    name,
    readOnly,
    inputProps,
    inputRef,
    sectionListRef
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$z);
  const rootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const handleInputRef = useForkRef(inputProps == null ? void 0 : inputProps.ref, inputRef);
  const isRtl = useRtl();
  const muiFormControl = useFormControl();
  if (!muiFormControl) {
    throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");
  }
  const handleInputFocus = (event) => {
    var _a2;
    if (muiFormControl.disabled) {
      event.stopPropagation();
      return;
    }
    (_a2 = muiFormControl.onFocus) == null ? void 0 : _a2.call(muiFormControl, event);
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  reactExports.useEffect(() => {
    if (!muiFormControl) {
      return;
    }
    if (areAllSectionsEmpty) {
      muiFormControl.onEmpty();
    } else {
      muiFormControl.onFilled();
    }
  }, [muiFormControl, areAllSectionsEmpty]);
  const ownerState = _extends$1({}, props, muiFormControl, {
    isRtl
  });
  const classes = useUtilityClasses$G(ownerState);
  const InputRoot2 = (slots == null ? void 0 : slots.root) || PickersInputBaseRoot;
  const inputRootProps = useSlotProps({
    elementType: InputRoot2,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      "aria-invalid": muiFormControl.error,
      ref: handleRootRef
    },
    className: classes.root,
    ownerState
  });
  const InputSectionsContainer = (slots == null ? void 0 : slots.input) || PickersInputBaseSectionsContainer;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(InputRoot2, _extends$1({}, inputRootProps, {
    children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSectionList, {
      sectionListRef,
      elements,
      contentEditable,
      tabIndex,
      className: classes.sectionsContainer,
      onFocus: handleInputFocus,
      onBlur: muiFormControl.onBlur,
      onInput,
      onPaste,
      onKeyDown,
      slots: {
        root: InputSectionsContainer,
        section: PickersInputBaseSection,
        sectionContent: PickersInputBaseSectionContent,
        sectionSeparator: PickersInputBaseSectionSeparator
      },
      slotProps: {
        root: {
          ownerState
        },
        sectionContent: {
          className: pickersInputBaseClasses.sectionContent
        },
        sectionSeparator: ({
          position: position2
        }) => ({
          className: position2 === "before" ? pickersInputBaseClasses.sectionBefore : pickersInputBaseClasses.sectionAfter
        })
      }
    }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, muiFormControl)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBaseInput, _extends$1({
      name,
      className: classes.input,
      value,
      onChange,
      id: id2,
      "aria-hidden": "true",
      tabIndex: -1,
      readOnly,
      required: muiFormControl.required,
      disabled: muiFormControl.disabled
    }, inputProps, {
      ref: handleInputRef
    }))]
  }));
});
function getPickersOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiPickersOutlinedInput", slot);
}
const pickersOutlinedInputClasses = _extends$1({}, pickersInputBaseClasses, generateUtilityClasses("MuiPickersOutlinedInput", ["root", "notchedOutline", "input"]));
const _excluded$y = ["children", "className", "label", "notched", "shrink"];
const OutlineRoot = styled("fieldset", {
  name: "MuiPickersOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme
}) => {
  const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%",
    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlineLabel = styled("span")(({
  theme
}) => ({
  fontFamily: theme.typography.fontFamily,
  fontSize: "inherit"
}));
const OutlineLegend = styled("legend")(({
  theme
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: {
      withLabel: false
    },
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme.transitions.create("width", {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      withLabel: true
    },
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme.transitions.create("max-width", {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: {
      withLabel: true,
      notched: true
    },
    style: {
      maxWidth: "100%",
      transition: theme.transitions.create("max-width", {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
}));
function Outline(props) {
  const {
    className,
    label
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$y);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$1({}, props, {
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineRoot, _extends$1({
    "aria-hidden": true,
    className
  }, other, {
    ownerState,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLabel, {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        /* @__PURE__ */ jsxRuntimeExports.jsx(OutlineLabel, {
          className: "notranslate",
          children: "​"
        })
      )
    })
  }));
}
const _excluded$x = ["label", "autoFocus", "ownerState", "notched"];
const PickersOutlinedInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersOutlinedInput",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme
}) => {
  const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    padding: "0 14px",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${pickersOutlinedInputClasses.focused} .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderStyle: "solid",
      borderWidth: 2
    },
    [`&.${pickersOutlinedInputClasses.disabled}`]: {
      [`& .${pickersOutlinedInputClasses.notchedOutline}`]: {
        borderColor: (theme.vars || theme).palette.action.disabled
      },
      "*": {
        color: (theme.vars || theme).palette.action.disabled
      }
    },
    [`&.${pickersOutlinedInputClasses.error} .${pickersOutlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.error.main
    },
    variants: Object.keys((theme.vars ?? theme).palette).filter((key) => {
      var _a2;
      return ((_a2 = (theme.vars ?? theme).palette[key]) == null ? void 0 : _a2.main) ?? false;
    }).map((color2) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${pickersOutlinedInputClasses.focused}:not(.${pickersOutlinedInputClasses.error}) .${pickersOutlinedInputClasses.notchedOutline}`]: {
          // @ts-ignore
          borderColor: (theme.vars || theme).palette[color2].main
        }
      }
    }))
  };
});
const PickersOutlinedInputSectionsContainer = styled(PickersInputBaseSectionsContainer, {
  name: "MuiPickersOutlinedInput",
  slot: "SectionsContainer",
  overridesResolver: (props, styles2) => styles2.sectionsContainer
})({
  padding: "16.5px 0",
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 0"
    }
  }]
});
const useUtilityClasses$F = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersOutlinedInputUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const PickersOutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function PickersOutlinedInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersOutlinedInput"
  });
  const {
    label,
    ownerState: ownerStateProp,
    notched
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$x);
  const muiFormControl = useFormControl();
  const ownerState = _extends$1({}, props, ownerStateProp, muiFormControl, {
    color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
  });
  const classes = useUtilityClasses$F(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$1({
    slots: {
      root: PickersOutlinedInputRoot,
      input: PickersOutlinedInputSectionsContainer
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(Outline, {
      shrink: Boolean(notched || state.adornedStart || state.focused || state.filled),
      notched: Boolean(notched || state.adornedStart || state.focused || state.filled),
      className: classes.notchedOutline,
      label: label != null && label !== "" && (muiFormControl == null ? void 0 : muiFormControl.required) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, " ", "*"]
      }) : label,
      ownerState
    })
  }, other, {
    label,
    classes,
    ref
  }));
});
PickersOutlinedInput.muiName = "Input";
function getPickersFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiPickersFilledInput", slot);
}
const pickersFilledInputClasses = _extends$1({}, pickersInputBaseClasses, generateUtilityClasses("MuiPickersFilledInput", ["root", "underline", "input"]));
const _excluded$w = ["label", "autoFocus", "disableUnderline", "ownerState"];
const PickersFilledInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "disableUnderline"
})(({
  theme
}) => {
  const light2 = theme.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${pickersFilledInputClasses.focused}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${pickersFilledInputClasses.disabled}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [...Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key].main).map((color2) => {
      var _a2;
      return {
        props: {
          color: color2,
          disableUnderline: false
        },
        style: {
          "&::after": {
            // @ts-ignore
            borderBottom: `2px solid ${(_a2 = (theme.vars || theme).palette[color2]) == null ? void 0 : _a2.main}`
          }
        }
      };
    }), {
      props: {
        disableUnderline: false
      },
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${pickersFilledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${pickersFilledInputClasses.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${pickersFilledInputClasses.disabled}, .${pickersFilledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${pickersFilledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, {
      props: ({
        startAdornment
      }) => !!startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        endAdornment
      }) => !!endAdornment,
      style: {
        paddingRight: 12
      }
    }]
  };
});
const PickersFilledSectionsContainer = styled(PickersInputBaseSectionsContainer, {
  name: "MuiPickersFilledInput",
  slot: "sectionsContainer",
  overridesResolver: (props, styles2) => styles2.sectionsContainer
})({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      startAdornment
    }) => !!startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      endAdornment
    }) => !!endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: {
      hiddenLabel: true
    },
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: {
      hiddenLabel: true,
      size: "small"
    },
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }]
});
const useUtilityClasses$E = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersFilledInputUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const PickersFilledInput = /* @__PURE__ */ reactExports.forwardRef(function PickersFilledInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFilledInput"
  });
  const {
    label,
    disableUnderline = false,
    ownerState: ownerStateProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
  const muiFormControl = useFormControl();
  const ownerState = _extends$1({}, props, ownerStateProp, muiFormControl, {
    color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
  });
  const classes = useUtilityClasses$E(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$1({
    slots: {
      root: PickersFilledInputRoot,
      input: PickersFilledSectionsContainer
    },
    slotProps: {
      root: {
        disableUnderline
      }
    }
  }, other, {
    label,
    classes,
    ref
  }));
});
PickersFilledInput.muiName = "Input";
function getPickersInputUtilityClass(slot) {
  return generateUtilityClass("MuiPickersFilledInput", slot);
}
const pickersInputClasses = _extends$1({}, pickersInputBaseClasses, generateUtilityClasses("MuiPickersInput", ["root", "input"]));
const _excluded$v = ["label", "autoFocus", "disableUnderline", "ownerState"];
const PickersInputRoot = styled(PickersInputBaseRoot, {
  name: "MuiPickersInput",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme
}) => {
  const light2 = theme.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme.vars) {
    bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
  }
  return {
    "label + &": {
      marginTop: 16
    },
    variants: [...Object.keys((theme.vars ?? theme).palette).filter((key) => (theme.vars ?? theme).palette[key].main).map((color2) => ({
      props: {
        color: color2
      },
      style: {
        "&::after": {
          // @ts-ignore
          borderBottom: `2px solid ${(theme.vars || theme).palette[color2].main}`
        }
      }
    })), {
      props: {
        disableUnderline: false
      },
      style: {
        "&::after": {
          background: "red",
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${pickersInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${pickersInputClasses.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${pickersInputClasses.disabled}, .${pickersInputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${pickersInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }]
  };
});
const useUtilityClasses$D = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getPickersInputUtilityClass, classes);
  return _extends$1({}, classes, composedClasses);
};
const PickersInput = /* @__PURE__ */ reactExports.forwardRef(function PickersInput2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersInput"
  });
  const {
    label,
    disableUnderline = false,
    ownerState: ownerStateProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$v);
  const muiFormControl = useFormControl();
  const ownerState = _extends$1({}, props, ownerStateProp, muiFormControl, {
    disableUnderline,
    color: (muiFormControl == null ? void 0 : muiFormControl.color) || "primary"
  });
  const classes = useUtilityClasses$D(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputBase, _extends$1({
    slots: {
      root: PickersInputRoot
    }
  }, other, {
    label,
    classes,
    ref
  }));
});
PickersInput.muiName = "Input";
const _excluded$u = ["onFocus", "onBlur", "className", "color", "disabled", "error", "variant", "required", "InputProps", "inputProps", "inputRef", "sectionListRef", "elements", "areAllSectionsEmpty", "onClick", "onKeyDown", "onKeyUp", "onPaste", "onInput", "endAdornment", "startAdornment", "tabIndex", "contentEditable", "focused", "value", "onChange", "fullWidth", "id", "name", "helperText", "FormHelperTextProps", "label", "InputLabelProps"];
const VARIANT_COMPONENT = {
  standard: PickersInput,
  filled: PickersFilledInput,
  outlined: PickersOutlinedInput
};
const PickersTextFieldRoot = styled(FormControl, {
  name: "MuiPickersTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const useUtilityClasses$C = (ownerState) => {
  const {
    focused,
    disabled,
    classes,
    required
  } = ownerState;
  const slots = {
    root: ["root", focused && !disabled && "focused", disabled && "disabled", required && "required"]
  };
  return composeClasses(slots, getPickersTextFieldUtilityClass, classes);
};
const PickersTextField = /* @__PURE__ */ reactExports.forwardRef(function PickersTextField2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersTextField"
  });
  const {
    // Props used by FormControl
    onFocus,
    onBlur,
    className,
    color: color2 = "primary",
    disabled = false,
    error = false,
    variant = "outlined",
    required = false,
    // Props used by PickersInput
    InputProps,
    inputProps,
    inputRef,
    sectionListRef,
    elements,
    areAllSectionsEmpty,
    onClick,
    onKeyDown,
    onKeyUp,
    onPaste,
    onInput,
    endAdornment,
    startAdornment,
    tabIndex,
    contentEditable,
    focused,
    value,
    onChange,
    fullWidth,
    id: idProp,
    name,
    // Props used by FormHelperText
    helperText,
    FormHelperTextProps,
    // Props used by InputLabel
    label,
    InputLabelProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$u);
  const rootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef(ref, rootRef);
  const id2 = useId(idProp);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const ownerState = _extends$1({}, props, {
    color: color2,
    disabled,
    error,
    focused,
    required,
    variant
  });
  const classes = useUtilityClasses$C(ownerState);
  const PickersInputComponent = VARIANT_COMPONENT[variant];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersTextFieldRoot, _extends$1({
    className: clsx(classes.root, className),
    ref: handleRootRef,
    focused,
    onFocus,
    onBlur,
    disabled,
    variant,
    error,
    color: color2,
    fullWidth,
    required,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputLabel, _extends$1({
      htmlFor: id2,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersInputComponent, _extends$1({
      elements,
      areAllSectionsEmpty,
      onClick,
      onKeyDown,
      onKeyUp,
      onInput,
      onPaste,
      endAdornment,
      startAdornment,
      tabIndex,
      contentEditable,
      value,
      onChange,
      id: id2,
      fullWidth,
      inputProps,
      inputRef,
      sectionListRef,
      label,
      name,
      role: "group",
      "aria-labelledby": inputLabelId
    }, InputProps)), helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText, _extends$1({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
const _excluded$t = ["enableAccessibleFieldDOMStructure"], _excluded2$3 = ["InputProps", "readOnly"], _excluded3$1 = ["onPaste", "onKeyDown", "inputMode", "readOnly", "InputProps", "inputProps", "inputRef"];
const convertFieldResponseIntoMuiTextFieldProps = (_ref) => {
  let {
    enableAccessibleFieldDOMStructure
  } = _ref, fieldResponse = _objectWithoutPropertiesLoose(_ref, _excluded$t);
  if (enableAccessibleFieldDOMStructure) {
    const {
      InputProps: InputProps2,
      readOnly: readOnly2
    } = fieldResponse, other2 = _objectWithoutPropertiesLoose(fieldResponse, _excluded2$3);
    return _extends$1({}, other2, {
      InputProps: _extends$1({}, InputProps2 ?? {}, {
        readOnly: readOnly2
      })
    });
  }
  const {
    onPaste,
    onKeyDown,
    inputMode,
    readOnly,
    InputProps,
    inputProps,
    inputRef
  } = fieldResponse, other = _objectWithoutPropertiesLoose(fieldResponse, _excluded3$1);
  return _extends$1({}, other, {
    InputProps: _extends$1({}, InputProps ?? {}, {
      readOnly
    }),
    inputProps: _extends$1({}, inputProps ?? {}, {
      inputMode,
      onPaste,
      onKeyDown,
      ref: inputRef
    })
  });
};
const _excluded$s = ["slots", "slotProps", "InputProps", "inputProps"];
const DateField = /* @__PURE__ */ reactExports.forwardRef(function DateField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$s);
  const ownerState = themeProps;
  const TextField$1 = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField);
  const textFieldProps = useSlotProps({
    elementType: TextField$1,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    additionalProps: {
      ref: inRef
    },
    ownerState
  });
  textFieldProps.inputProps = _extends$1({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$1({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useDateField2(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends$1({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, _extends$1({}, processedFieldProps));
});
const useIsDateDisabled = ({
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  minDate,
  maxDate,
  disableFuture,
  disablePast,
  timezone
}) => {
  const adapter = useLocalizationContext();
  return reactExports.useCallback((day) => validateDate({
    adapter,
    value: day,
    props: {
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      minDate,
      maxDate,
      disableFuture,
      disablePast,
      timezone
    }
  }) !== null, [adapter, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, timezone]);
};
const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils2) => (state, action) => {
  switch (action.type) {
    case "changeMonth":
      return _extends$1({}, state, {
        slideDirection: action.direction,
        currentMonth: action.newMonth,
        isMonthSwitchingAnimating: !reduceAnimations
      });
    case "finishMonthSwitchingAnimation":
      return _extends$1({}, state, {
        isMonthSwitchingAnimating: false
      });
    case "changeFocusedDay": {
      if (state.focusedDay != null && action.focusedDay != null && utils2.isSameDay(action.focusedDay, state.focusedDay)) {
        return state;
      }
      const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils2.isSameMonth(state.currentMonth, action.focusedDay);
      return _extends$1({}, state, {
        focusedDay: action.focusedDay,
        isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
        currentMonth: needMonthSwitch ? utils2.startOfMonth(action.focusedDay) : state.currentMonth,
        slideDirection: action.focusedDay != null && utils2.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
      });
    }
    default:
      throw new Error("missing support");
  }
};
const useCalendarState2 = (params) => {
  const {
    value,
    referenceDate: referenceDateProp,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus = false,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate,
    timezone
  } = params;
  const utils2 = useUtils();
  const reducerFn = reactExports.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils2)).current;
  const referenceDate = reactExports.useMemo(
    () => {
      return singleItemValueManager.getInitialReferenceValue({
        value,
        utils: utils2,
        timezone,
        props: params,
        referenceDate: referenceDateProp,
        granularity: SECTION_TYPE_GRANULARITY.day
      });
    },
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const [calendarState, dispatch] = reactExports.useReducer(reducerFn, {
    isMonthSwitchingAnimating: false,
    focusedDay: referenceDate,
    currentMonth: utils2.startOfMonth(referenceDate),
    slideDirection: "left"
  });
  const handleChangeMonth = reactExports.useCallback((payload) => {
    dispatch(_extends$1({
      type: "changeMonth"
    }, payload));
    if (onMonthChange) {
      onMonthChange(payload.newMonth);
    }
  }, [onMonthChange]);
  const changeMonth = reactExports.useCallback((newDate) => {
    const newDateRequested = newDate;
    if (utils2.isSameMonth(newDateRequested, calendarState.currentMonth)) {
      return;
    }
    handleChangeMonth({
      newMonth: utils2.startOfMonth(newDateRequested),
      direction: utils2.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
    });
  }, [calendarState.currentMonth, handleChangeMonth, utils2]);
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    minDate,
    maxDate,
    disableFuture,
    disablePast,
    timezone
  });
  const onMonthSwitchingAnimationEnd = reactExports.useCallback(() => {
    dispatch({
      type: "finishMonthSwitchingAnimation"
    });
  }, []);
  const changeFocusedDay = useEventCallback((newFocusedDate, withoutMonthSwitchingAnimation) => {
    if (!isDateDisabled(newFocusedDate)) {
      dispatch({
        type: "changeFocusedDay",
        focusedDay: newFocusedDate,
        withoutMonthSwitchingAnimation
      });
    }
  });
  return {
    referenceDate,
    calendarState,
    changeMonth,
    changeFocusedDay,
    isDateDisabled,
    onMonthSwitchingAnimationEnd,
    handleChangeMonth
  };
};
const getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);
const useUtilityClasses$B = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
};
const PickersFadeTransitionGroupRoot = styled(TransitionGroup, {
  name: "MuiPickersFadeTransitionGroup",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})({
  display: "block",
  position: "relative"
});
function PickersFadeTransitionGroup(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFadeTransitionGroup"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
  } = props;
  const classes = useUtilityClasses$B(props);
  const theme = useTheme();
  if (reduceAnimations) {
    return children;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroupRoot, {
    className: clsx(classes.root, className),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, {
      appear: false,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        appear: theme.transitions.duration.enteringScreen,
        enter: theme.transitions.duration.enteringScreen,
        exit: 0
      },
      children
    }, transKey)
  });
}
function getPickersDayUtilityClass(slot) {
  return generateUtilityClass("MuiPickersDay", slot);
}
const pickersDayClasses = generateUtilityClasses("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]);
const _excluded$r = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"];
const useUtilityClasses$A = (ownerState) => {
  const {
    selected,
    disableMargin,
    disableHighlightToday,
    today,
    disabled,
    outsideCurrentMonth,
    showDaysOutsideCurrentMonth,
    classes
  } = ownerState;
  const isHiddenDaySpacingFiller = outsideCurrentMonth && !showDaysOutsideCurrentMonth;
  const slots = {
    root: ["root", selected && !isHiddenDaySpacingFiller && "selected", disabled && "disabled", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth", isHiddenDaySpacingFiller && "hiddenDaySpacingFiller"],
    hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
  };
  return composeClasses(slots, getPickersDayUtilityClass, classes);
};
const styleArg = ({
  theme
}) => _extends$1({}, theme.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  borderRadius: "50%",
  padding: 0,
  // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
  backgroundColor: "transparent",
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.short
  }),
  color: (theme.vars || theme).palette.text.primary,
  "@media (pointer: fine)": {
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
    }
  },
  "&:focus": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity),
    [`&.${pickersDayClasses.selected}`]: {
      willChange: "background-color",
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    fontWeight: theme.typography.fontWeightMedium,
    "&:hover": {
      willChange: "background-color",
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.disabled}:not(.${pickersDayClasses.selected})`]: {
    color: (theme.vars || theme).palette.text.disabled
  },
  [`&.${pickersDayClasses.disabled}&.${pickersDayClasses.selected}`]: {
    opacity: 0.6
  },
  variants: [{
    props: {
      disableMargin: false
    },
    style: {
      margin: `0 ${DAY_MARGIN}px`
    }
  }, {
    props: {
      outsideCurrentMonth: true,
      showDaysOutsideCurrentMonth: true
    },
    style: {
      color: (theme.vars || theme).palette.text.secondary
    }
  }, {
    props: {
      disableHighlightToday: false,
      today: true
    },
    style: {
      [`&:not(.${pickersDayClasses.selected})`]: {
        border: `1px solid ${(theme.vars || theme).palette.text.secondary}`
      }
    }
  }]
});
const overridesResolver$1 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, !ownerState.disableMargin && styles2.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles2.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles2.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles2.hiddenDaySpacingFiller];
};
const PickersDayRoot = styled(ButtonBase, {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(styleArg);
const PickersDayFiller = styled("div", {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(({
  theme
}) => _extends$1({}, styleArg({
  theme
}), {
  // visibility: 'hidden' does not work here as it hides the element from screen readers as well
  opacity: 0,
  pointerEvents: "none"
}));
const noop = () => {
};
const PickersDayRaw = /* @__PURE__ */ reactExports.forwardRef(function PickersDay2(inProps, forwardedRef) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersDay"
  });
  const {
    autoFocus = false,
    className,
    day,
    disabled = false,
    disableHighlightToday = false,
    disableMargin = false,
    isAnimating,
    onClick,
    onDaySelect,
    onFocus = noop,
    onBlur = noop,
    onKeyDown = noop,
    onMouseDown = noop,
    onMouseEnter = noop,
    outsideCurrentMonth,
    selected = false,
    showDaysOutsideCurrentMonth = false,
    children,
    today: isToday = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$r);
  const ownerState = _extends$1({}, props, {
    autoFocus,
    disabled,
    disableHighlightToday,
    disableMargin,
    selected,
    showDaysOutsideCurrentMonth,
    today: isToday
  });
  const classes = useUtilityClasses$A(ownerState);
  const utils2 = useUtils();
  const ref = reactExports.useRef(null);
  const handleRef = useForkRef(ref, forwardedRef);
  useEnhancedEffect(() => {
    if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
      ref.current.focus();
    }
  }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
  const handleMouseDown = (event) => {
    onMouseDown(event);
    if (outsideCurrentMonth) {
      event.preventDefault();
    }
  };
  const handleClick = (event) => {
    if (!disabled) {
      onDaySelect(day);
    }
    if (outsideCurrentMonth) {
      event.currentTarget.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayFiller, {
      className: clsx(classes.root, classes.hiddenDaySpacingFiller, className),
      ownerState,
      role: other.role
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayRoot, _extends$1({
    className: clsx(classes.root, className),
    ref: handleRef,
    centerRipple: true,
    disabled,
    tabIndex: selected ? 0 : -1,
    onKeyDown: (event) => onKeyDown(event, day),
    onFocus: (event) => onFocus(event, day),
    onBlur: (event) => onBlur(event, day),
    onMouseEnter: (event) => onMouseEnter(event, day),
    onClick: handleClick,
    onMouseDown: handleMouseDown
  }, other, {
    ownerState,
    children: !children ? utils2.format(day, "dayOfMonth") : children
  }));
});
const PickersDay = /* @__PURE__ */ reactExports.memo(PickersDayRaw);
const getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass("MuiPickersSlideTransition", slot);
const pickersSlideTransitionClasses = generateUtilityClasses("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]);
const _excluded$q = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"];
const useUtilityClasses$z = (ownerState) => {
  const {
    classes,
    slideDirection
  } = ownerState;
  const slots = {
    root: ["root"],
    exit: ["slideExit"],
    enterActive: ["slideEnterActive"],
    enter: [`slideEnter-${slideDirection}`],
    exitActive: [`slideExitActiveLeft-${slideDirection}`]
  };
  return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
};
const PickersSlideTransitionRoot = styled(TransitionGroup, {
  name: "MuiPickersSlideTransition",
  slot: "Root",
  overridesResolver: (_, styles2) => [styles2.root, {
    [`.${pickersSlideTransitionClasses["slideEnter-left"]}`]: styles2["slideEnter-left"]
  }, {
    [`.${pickersSlideTransitionClasses["slideEnter-right"]}`]: styles2["slideEnter-right"]
  }, {
    [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles2.slideEnterActive
  }, {
    [`.${pickersSlideTransitionClasses.slideExit}`]: styles2.slideExit
  }, {
    [`.${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: styles2["slideExitActiveLeft-left"]
  }, {
    [`.${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: styles2["slideExitActiveLeft-right"]
  }]
})(({
  theme
}) => {
  const slideTransition = theme.transitions.create("transform", {
    duration: theme.transitions.duration.complex,
    easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
  });
  return {
    display: "block",
    position: "relative",
    overflowX: "hidden",
    "& > *": {
      position: "absolute",
      top: 0,
      right: 0,
      left: 0
    },
    [`& .${pickersSlideTransitionClasses["slideEnter-left"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      zIndex: 1
    },
    [`& .${pickersSlideTransitionClasses["slideEnter-right"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      zIndex: 1
    },
    [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
      transform: "translate(0%)",
      transition: slideTransition
    },
    [`& .${pickersSlideTransitionClasses.slideExit}`]: {
      transform: "translate(0%)"
    },
    [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      transition: slideTransition,
      zIndex: 0
    },
    [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      transition: slideTransition,
      zIndex: 0
    }
  };
});
function PickersSlideTransition(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersSlideTransition"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
    // extracting `classes` from `other`
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
  const classes = useUtilityClasses$z(props);
  const theme = useTheme();
  if (reduceAnimations) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: clsx(classes.root, className),
      children
    });
  }
  const transitionClasses = {
    exit: classes.exit,
    enterActive: classes.enterActive,
    enter: classes.enter,
    exitActive: classes.exitActive
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSlideTransitionRoot, {
    className: clsx(classes.root, className),
    childFactory: (element) => /* @__PURE__ */ reactExports.cloneElement(element, {
      classNames: transitionClasses
    }),
    role: "presentation",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransition, _extends$1({
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: theme.transitions.duration.complex,
      classNames: transitionClasses
    }, other, {
      children
    }), transKey)
  });
}
const getDayCalendarUtilityClass = (slot) => generateUtilityClass("MuiDayCalendar", slot);
generateUtilityClasses("MuiDayCalendar", ["root", "header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
const _excluded$p = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"], _excluded2$2 = ["ownerState"];
const useUtilityClasses$y = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    header: ["header"],
    weekDayLabel: ["weekDayLabel"],
    loadingContainer: ["loadingContainer"],
    slideTransition: ["slideTransition"],
    monthContainer: ["monthContainer"],
    weekContainer: ["weekContainer"],
    weekNumberLabel: ["weekNumberLabel"],
    weekNumber: ["weekNumber"]
  };
  return composeClasses(slots, getDayCalendarUtilityClass, classes);
};
const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
const PickersCalendarDayRoot = styled("div", {
  name: "MuiDayCalendar",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})({});
const PickersCalendarDayHeader = styled("div", {
  name: "MuiDayCalendar",
  slot: "Header",
  overridesResolver: (_, styles2) => styles2.header
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
const PickersCalendarWeekDayLabel = styled(Typography, {
  name: "MuiDayCalendar",
  slot: "WeekDayLabel",
  overridesResolver: (_, styles2) => styles2.weekDayLabel
})(({
  theme
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: (theme.vars || theme).palette.text.secondary
}));
const PickersCalendarWeekNumberLabel = styled(Typography, {
  name: "MuiDayCalendar",
  slot: "WeekNumberLabel",
  overridesResolver: (_, styles2) => styles2.weekNumberLabel
})(({
  theme
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: theme.palette.text.disabled
}));
const PickersCalendarWeekNumber = styled(Typography, {
  name: "MuiDayCalendar",
  slot: "WeekNumber",
  overridesResolver: (_, styles2) => styles2.weekNumber
})(({
  theme
}) => _extends$1({}, theme.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  padding: 0,
  margin: `0 ${DAY_MARGIN}px`,
  color: theme.palette.text.disabled,
  fontSize: "0.75rem",
  alignItems: "center",
  justifyContent: "center",
  display: "inline-flex"
}));
const PickersCalendarLoadingContainer = styled("div", {
  name: "MuiDayCalendar",
  slot: "LoadingContainer",
  overridesResolver: (_, styles2) => styles2.loadingContainer
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  minHeight: weeksContainerHeight
});
const PickersCalendarSlideTransition = styled(PickersSlideTransition, {
  name: "MuiDayCalendar",
  slot: "SlideTransition",
  overridesResolver: (_, styles2) => styles2.slideTransition
})({
  minHeight: weeksContainerHeight
});
const PickersCalendarWeekContainer = styled("div", {
  name: "MuiDayCalendar",
  slot: "MonthContainer",
  overridesResolver: (_, styles2) => styles2.monthContainer
})({
  overflow: "hidden"
});
const PickersCalendarWeek = styled("div", {
  name: "MuiDayCalendar",
  slot: "WeekContainer",
  overridesResolver: (_, styles2) => styles2.weekContainer
})({
  margin: `${DAY_MARGIN}px 0`,
  display: "flex",
  justifyContent: "center"
});
function WrappedDay(_ref) {
  let {
    parentProps,
    day,
    focusableDay,
    selectedDays,
    isDateDisabled,
    currentMonthNumber,
    isViewFocused
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$p);
  const {
    disabled,
    disableHighlightToday,
    isMonthSwitchingAnimating,
    showDaysOutsideCurrentMonth,
    slots,
    slotProps,
    timezone
  } = parentProps;
  const utils2 = useUtils();
  const now2 = useNow(timezone);
  const isFocusableDay = focusableDay !== null && utils2.isSameDay(day, focusableDay);
  const isSelected = selectedDays.some((selectedDay) => utils2.isSameDay(selectedDay, day));
  const isToday = utils2.isSameDay(day, now2);
  const Day = (slots == null ? void 0 : slots.day) ?? PickersDay;
  const _useSlotProps = useSlotProps({
    elementType: Day,
    externalSlotProps: slotProps == null ? void 0 : slotProps.day,
    additionalProps: _extends$1({
      disableHighlightToday,
      showDaysOutsideCurrentMonth,
      role: "gridcell",
      isAnimating: isMonthSwitchingAnimating,
      // it is used in date range dragging logic by accessing `dataset.timestamp`
      "data-timestamp": utils2.toJsDate(day).valueOf()
    }, other),
    ownerState: _extends$1({}, parentProps, {
      day,
      selected: isSelected
    })
  }), dayProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$2);
  const isDisabled = reactExports.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
  const outsideCurrentMonth = reactExports.useMemo(() => utils2.getMonth(day) !== currentMonthNumber, [utils2, day, currentMonthNumber]);
  const isFirstVisibleCell = reactExports.useMemo(() => {
    const startOfMonth2 = utils2.startOfMonth(utils2.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils2.isSameDay(day, startOfMonth2);
    }
    return utils2.isSameDay(day, utils2.startOfWeek(startOfMonth2));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
  const isLastVisibleCell = reactExports.useMemo(() => {
    const endOfMonth2 = utils2.endOfMonth(utils2.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils2.isSameDay(day, endOfMonth2);
    }
    return utils2.isSameDay(day, utils2.endOfWeek(endOfMonth2));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Day, _extends$1({}, dayProps, {
    day,
    disabled: isDisabled,
    autoFocus: isViewFocused && isFocusableDay,
    today: isToday,
    outsideCurrentMonth,
    isFirstVisibleCell,
    isLastVisibleCell,
    selected: isSelected,
    tabIndex: isFocusableDay ? 0 : -1,
    "aria-selected": isSelected,
    "aria-current": isToday ? "date" : void 0
  }));
}
function DayCalendar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDayCalendar"
  });
  const utils2 = useUtils();
  const {
    onFocusedDayChange,
    className,
    currentMonth,
    selectedDays,
    focusedDay,
    loading,
    onSelectedDaysChange,
    onMonthSwitchingAnimationEnd,
    readOnly,
    reduceAnimations,
    renderLoading = () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      children: "..."
    }),
    slideDirection,
    TransitionProps,
    disablePast,
    disableFuture,
    minDate,
    maxDate,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    dayOfWeekFormatter = (date) => utils2.format(date, "weekdayShort").charAt(0).toUpperCase(),
    hasFocus,
    onFocusedViewChange,
    gridLabelId,
    displayWeekNumber,
    fixedWeekNumber,
    autoFocus,
    timezone
  } = props;
  const now2 = useNow(timezone);
  const classes = useUtilityClasses$y(props);
  const isRtl = useRtl();
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    minDate,
    maxDate,
    disablePast,
    disableFuture,
    timezone
  });
  const translations = usePickersTranslations();
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "DayCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const [internalFocusedDay, setInternalFocusedDay] = reactExports.useState(() => focusedDay || now2);
  const handleDaySelect = useEventCallback((day) => {
    if (readOnly) {
      return;
    }
    onSelectedDaysChange(day);
  });
  const focusDay = (day) => {
    if (!isDateDisabled(day)) {
      onFocusedDayChange(day);
      setInternalFocusedDay(day);
      onFocusedViewChange == null ? void 0 : onFocusedViewChange(true);
      setInternalHasFocus(true);
    }
  };
  const handleKeyDown = useEventCallback((event, day) => {
    switch (event.key) {
      case "ArrowUp":
        focusDay(utils2.addDays(day, -7));
        event.preventDefault();
        break;
      case "ArrowDown":
        focusDay(utils2.addDays(day, 7));
        event.preventDefault();
        break;
      case "ArrowLeft": {
        const newFocusedDayDefault = utils2.addDays(day, isRtl ? 1 : -1);
        const nextAvailableMonth = utils2.addMonths(day, isRtl ? 1 : -1);
        const closestDayToFocus = findClosestEnabledDate({
          utils: utils2,
          date: newFocusedDayDefault,
          minDate: isRtl ? newFocusedDayDefault : utils2.startOfMonth(nextAvailableMonth),
          maxDate: isRtl ? utils2.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
          isDateDisabled,
          timezone
        });
        focusDay(closestDayToFocus || newFocusedDayDefault);
        event.preventDefault();
        break;
      }
      case "ArrowRight": {
        const newFocusedDayDefault = utils2.addDays(day, isRtl ? -1 : 1);
        const nextAvailableMonth = utils2.addMonths(day, isRtl ? -1 : 1);
        const closestDayToFocus = findClosestEnabledDate({
          utils: utils2,
          date: newFocusedDayDefault,
          minDate: isRtl ? utils2.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
          maxDate: isRtl ? newFocusedDayDefault : utils2.endOfMonth(nextAvailableMonth),
          isDateDisabled,
          timezone
        });
        focusDay(closestDayToFocus || newFocusedDayDefault);
        event.preventDefault();
        break;
      }
      case "Home":
        focusDay(utils2.startOfWeek(day));
        event.preventDefault();
        break;
      case "End":
        focusDay(utils2.endOfWeek(day));
        event.preventDefault();
        break;
      case "PageUp":
        focusDay(utils2.addMonths(day, 1));
        event.preventDefault();
        break;
      case "PageDown":
        focusDay(utils2.addMonths(day, -1));
        event.preventDefault();
        break;
    }
  });
  const handleFocus = useEventCallback((event, day) => focusDay(day));
  const handleBlur = useEventCallback((event, day) => {
    if (internalHasFocus && utils2.isSameDay(internalFocusedDay, day)) {
      onFocusedViewChange == null ? void 0 : onFocusedViewChange(false);
    }
  });
  const currentMonthNumber = utils2.getMonth(currentMonth);
  const currentYearNumber = utils2.getYear(currentMonth);
  const validSelectedDays = reactExports.useMemo(() => selectedDays.filter((day) => !!day).map((day) => utils2.startOfDay(day)), [utils2, selectedDays]);
  const transitionKey = `${currentYearNumber}-${currentMonthNumber}`;
  const slideNodeRef = reactExports.useMemo(() => /* @__PURE__ */ reactExports.createRef(), [transitionKey]);
  const focusableDay = reactExports.useMemo(() => {
    const startOfMonth2 = utils2.startOfMonth(currentMonth);
    const endOfMonth2 = utils2.endOfMonth(currentMonth);
    if (isDateDisabled(internalFocusedDay) || utils2.isAfterDay(internalFocusedDay, endOfMonth2) || utils2.isBeforeDay(internalFocusedDay, startOfMonth2)) {
      return findClosestEnabledDate({
        utils: utils2,
        date: internalFocusedDay,
        minDate: startOfMonth2,
        maxDate: endOfMonth2,
        disablePast,
        disableFuture,
        isDateDisabled,
        timezone
      });
    }
    return internalFocusedDay;
  }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils2, timezone]);
  const weeksToDisplay = reactExports.useMemo(() => {
    const currentMonthWithTimezone = utils2.setTimezone(currentMonth, timezone);
    const toDisplay = utils2.getWeekArray(currentMonthWithTimezone);
    let nextMonth = utils2.addMonths(currentMonthWithTimezone, 1);
    while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
      const additionalWeeks = utils2.getWeekArray(nextMonth);
      const hasCommonWeek = utils2.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
      additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach((week) => {
        if (toDisplay.length < fixedWeekNumber) {
          toDisplay.push(week);
        }
      });
      nextMonth = utils2.addMonths(nextMonth, 1);
    }
    return toDisplay;
  }, [currentMonth, fixedWeekNumber, utils2, timezone]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayRoot, {
    role: "grid",
    "aria-labelledby": gridLabelId,
    className: classes.root,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayHeader, {
      role: "row",
      className: classes.header,
      children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumberLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": translations.calendarWeekNumberHeaderLabel,
        className: classes.weekNumberLabel,
        children: translations.calendarWeekNumberHeaderText
      }), getWeekdays(utils2, now2).map((weekday, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekDayLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": utils2.format(weekday, "weekday"),
        className: classes.weekDayLabel,
        children: dayOfWeekFormatter(weekday)
      }, i2.toString()))]
    }), loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarLoadingContainer, {
      className: classes.loadingContainer,
      children: renderLoading()
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarSlideTransition, _extends$1({
      transKey: transitionKey,
      onExited: onMonthSwitchingAnimationEnd,
      reduceAnimations,
      slideDirection,
      className: clsx(className, classes.slideTransition)
    }, TransitionProps, {
      nodeRef: slideNodeRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekContainer, {
        ref: slideNodeRef,
        role: "rowgroup",
        className: classes.monthContainer,
        children: weeksToDisplay.map((week, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarWeek, {
          role: "row",
          className: classes.weekContainer,
          "aria-rowindex": index + 1,
          children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumber, {
            className: classes.weekNumber,
            role: "rowheader",
            "aria-label": translations.calendarWeekNumberAriaLabelText(utils2.getWeekNumber(week[0])),
            children: translations.calendarWeekNumberText(utils2.getWeekNumber(week[0]))
          }), week.map((day, dayIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedDay, {
            parentProps: props,
            day,
            selectedDays: validSelectedDays,
            focusableDay,
            onKeyDown: handleKeyDown,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onDaySelect: handleDaySelect,
            isDateDisabled,
            currentMonthNumber,
            isViewFocused: internalHasFocus,
            "aria-colindex": dayIndex + 1
          }, day.toString()))]
        }, `week-${week[0]}`))
      })
    }))]
  });
}
function getPickersMonthUtilityClass(slot) {
  return generateUtilityClass("MuiPickersMonth", slot);
}
const pickersMonthClasses = generateUtilityClasses("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]);
const _excluded$o = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "aria-label", "monthsPerRow", "slots", "slotProps"];
const useUtilityClasses$x = (ownerState) => {
  const {
    disabled,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    monthButton: ["monthButton", disabled && "disabled", selected && "selected"]
  };
  return composeClasses(slots, getPickersMonthUtilityClass, classes);
};
const PickersMonthRoot = styled("div", {
  name: "MuiPickersMonth",
  slot: "Root",
  overridesResolver: (_, styles2) => [styles2.root]
})({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexBasis: "33.3%",
  variants: [{
    props: {
      monthsPerRow: 4
    },
    style: {
      flexBasis: "25%"
    }
  }]
});
const MonthCalendarButton = styled("button", {
  name: "MuiPickersMonth",
  slot: "MonthButton",
  overridesResolver: (_, styles2) => [styles2.monthButton, {
    [`&.${pickersMonthClasses.disabled}`]: styles2.disabled
  }, {
    [`&.${pickersMonthClasses.selected}`]: styles2.selected
  }]
})(({
  theme
}) => _extends$1({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, theme.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${pickersMonthClasses.disabled}`]: {
    color: (theme.vars || theme).palette.text.secondary
  },
  [`&.${pickersMonthClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  }
}));
const PickersMonth = /* @__PURE__ */ reactExports.memo(function PickersMonth2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersMonth"
  });
  const {
    autoFocus,
    className,
    children,
    disabled,
    selected,
    value,
    tabIndex,
    onClick,
    onKeyDown,
    onFocus,
    onBlur,
    "aria-current": ariaCurrent,
    "aria-label": ariaLabel,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
  const ref = reactExports.useRef(null);
  const classes = useUtilityClasses$x(props);
  useEnhancedEffect(() => {
    var _a2;
    if (autoFocus) {
      (_a2 = ref.current) == null ? void 0 : _a2.focus();
    }
  }, [autoFocus]);
  const MonthButton = (slots == null ? void 0 : slots.monthButton) ?? MonthCalendarButton;
  const monthButtonProps = useSlotProps({
    elementType: MonthButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.monthButton,
    additionalProps: {
      children,
      disabled,
      tabIndex,
      ref,
      type: "button",
      role: "radio",
      "aria-current": ariaCurrent,
      "aria-checked": selected,
      "aria-label": ariaLabel,
      onClick: (event) => onClick(event, value),
      onKeyDown: (event) => onKeyDown(event, value),
      onFocus: (event) => onFocus(event, value),
      onBlur: (event) => onBlur(event, value)
    },
    ownerState: props,
    className: classes.monthButton
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonthRoot, _extends$1({
    className: clsx(classes.root, className),
    ownerState: props
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MonthButton, _extends$1({}, monthButtonProps))
  }));
});
function getMonthCalendarUtilityClass(slot) {
  return generateUtilityClass("MuiMonthCalendar", slot);
}
generateUtilityClasses("MuiMonthCalendar", ["root"]);
const _excluded$n = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
const useUtilityClasses$w = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMonthCalendarUtilityClass, classes);
};
function useMonthCalendarDefaultizedProps(props, name) {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$1({
    disableFuture: false,
    disablePast: false
  }, themeProps, {
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
  });
}
const MonthCalendarRoot = styled("div", {
  name: "MuiMonthCalendar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexWrap: "wrap",
  alignContent: "stretch",
  padding: "0 4px",
  width: DIALOG_WIDTH,
  // avoid padding increasing width over defined
  boxSizing: "border-box"
});
const MonthCalendar = /* @__PURE__ */ reactExports.forwardRef(function MonthCalendar2(inProps, ref) {
  const props = useMonthCalendarDefaultizedProps(inProps, "MuiMonthCalendar");
  const {
    className,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    shouldDisableMonth,
    readOnly,
    autoFocus = false,
    onMonthFocus,
    hasFocus,
    onFocusedViewChange,
    monthsPerRow = 3,
    timezone: timezoneProp,
    gridLabelId,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$n);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "MonthCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const now2 = useNow(timezone);
  const isRtl = useRtl();
  const utils2 = useUtils();
  const referenceDate = reactExports.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils: utils2,
      props,
      timezone,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.month
    }),
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const ownerState = props;
  const classes = useUtilityClasses$w(ownerState);
  const todayMonth = reactExports.useMemo(() => utils2.getMonth(now2), [utils2, now2]);
  const selectedMonth = reactExports.useMemo(() => {
    if (value != null) {
      return utils2.getMonth(value);
    }
    return null;
  }, [value, utils2]);
  const [focusedMonth, setFocusedMonth] = reactExports.useState(() => selectedMonth || utils2.getMonth(referenceDate));
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "MonthCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const changeHasFocus = useEventCallback((newHasFocus) => {
    setInternalHasFocus(newHasFocus);
    if (onFocusedViewChange) {
      onFocusedViewChange(newHasFocus);
    }
  });
  const isMonthDisabled = reactExports.useCallback((dateToValidate) => {
    const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now2, minDate) ? now2 : minDate);
    const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now2, maxDate) ? now2 : maxDate);
    const monthToValidate = utils2.startOfMonth(dateToValidate);
    if (utils2.isBefore(monthToValidate, firstEnabledMonth)) {
      return true;
    }
    if (utils2.isAfter(monthToValidate, lastEnabledMonth)) {
      return true;
    }
    if (!shouldDisableMonth) {
      return false;
    }
    return shouldDisableMonth(monthToValidate);
  }, [disableFuture, disablePast, maxDate, minDate, now2, shouldDisableMonth, utils2]);
  const handleMonthSelection = useEventCallback((event, month) => {
    if (readOnly) {
      return;
    }
    const newDate = utils2.setMonth(value ?? referenceDate, month);
    handleValueChange(newDate);
  });
  const focusMonth = useEventCallback((month) => {
    if (!isMonthDisabled(utils2.setMonth(value ?? referenceDate, month))) {
      setFocusedMonth(month);
      changeHasFocus(true);
      if (onMonthFocus) {
        onMonthFocus(month);
      }
    }
  });
  reactExports.useEffect(() => {
    setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
  }, [selectedMonth]);
  const handleKeyDown = useEventCallback((event, month) => {
    const monthsInYear = 12;
    const monthsInRow = 3;
    switch (event.key) {
      case "ArrowUp":
        focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusMonth((monthsInYear + month + (isRtl ? 1 : -1)) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowRight":
        focusMonth((monthsInYear + month + (isRtl ? -1 : 1)) % monthsInYear);
        event.preventDefault();
        break;
    }
  });
  const handleMonthFocus = useEventCallback((event, month) => {
    focusMonth(month);
  });
  const handleMonthBlur = useEventCallback((event, month) => {
    if (focusedMonth === month) {
      changeHasFocus(false);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendarRoot, _extends$1({
    ref,
    className: clsx(classes.root, className),
    ownerState,
    role: "radiogroup",
    "aria-labelledby": gridLabelId
  }, other, {
    children: getMonthsInYear(utils2, value ?? referenceDate).map((month) => {
      const monthNumber = utils2.getMonth(month);
      const monthText = utils2.format(month, "monthShort");
      const monthLabel = utils2.format(month, "month");
      const isSelected = monthNumber === selectedMonth;
      const isDisabled = disabled || isMonthDisabled(month);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonth, {
        selected: isSelected,
        value: monthNumber,
        onClick: handleMonthSelection,
        onKeyDown: handleKeyDown,
        autoFocus: internalHasFocus && monthNumber === focusedMonth,
        disabled: isDisabled,
        tabIndex: monthNumber === focusedMonth && !isDisabled ? 0 : -1,
        onFocus: handleMonthFocus,
        onBlur: handleMonthBlur,
        "aria-current": todayMonth === monthNumber ? "date" : void 0,
        "aria-label": monthLabel,
        monthsPerRow,
        slots,
        slotProps,
        children: monthText
      }, monthText);
    })
  }));
});
function getPickersYearUtilityClass(slot) {
  return generateUtilityClass("MuiPickersYear", slot);
}
const pickersYearClasses = generateUtilityClasses("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]);
const _excluded$m = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow", "slots", "slotProps"];
const useUtilityClasses$v = (ownerState) => {
  const {
    disabled,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
  };
  return composeClasses(slots, getPickersYearUtilityClass, classes);
};
const PickersYearRoot = styled("div", {
  name: "MuiPickersYear",
  slot: "Root",
  overridesResolver: (_, styles2) => [styles2.root]
})({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexBasis: "33.3%",
  variants: [{
    props: {
      yearsPerRow: 4
    },
    style: {
      flexBasis: "25%"
    }
  }]
});
const YearCalendarButton = styled("button", {
  name: "MuiPickersYear",
  slot: "YearButton",
  overridesResolver: (_, styles2) => [styles2.yearButton, {
    [`&.${pickersYearClasses.disabled}`]: styles2.disabled
  }, {
    [`&.${pickersYearClasses.selected}`]: styles2.selected
  }]
})(({
  theme
}) => _extends$1({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, theme.typography.subtitle1, {
  margin: "6px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.action.active, theme.palette.action.focusOpacity)
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${pickersYearClasses.disabled}`]: {
    color: (theme.vars || theme).palette.text.secondary
  },
  [`&.${pickersYearClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText,
    backgroundColor: (theme.vars || theme).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  }
}));
const PickersYear = /* @__PURE__ */ reactExports.memo(function PickersYear2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersYear"
  });
  const {
    autoFocus,
    className,
    children,
    disabled,
    selected,
    value,
    tabIndex,
    onClick,
    onKeyDown,
    onFocus,
    onBlur,
    "aria-current": ariaCurrent,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
  const ref = reactExports.useRef(null);
  const classes = useUtilityClasses$v(props);
  useEnhancedEffect(() => {
    var _a2;
    if (autoFocus) {
      (_a2 = ref.current) == null ? void 0 : _a2.focus();
    }
  }, [autoFocus]);
  const YearButton = (slots == null ? void 0 : slots.yearButton) ?? YearCalendarButton;
  const yearButtonProps = useSlotProps({
    elementType: YearButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.yearButton,
    additionalProps: {
      children,
      disabled,
      tabIndex,
      ref,
      type: "button",
      role: "radio",
      "aria-current": ariaCurrent,
      "aria-checked": selected,
      onClick: (event) => onClick(event, value),
      onKeyDown: (event) => onKeyDown(event, value),
      onFocus: (event) => onFocus(event, value),
      onBlur: (event) => onBlur(event, value)
    },
    ownerState: props,
    className: classes.yearButton
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYearRoot, _extends$1({
    className: clsx(classes.root, className),
    ownerState: props
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(YearButton, _extends$1({}, yearButtonProps))
  }));
});
function getYearCalendarUtilityClass(slot) {
  return generateUtilityClass("MuiYearCalendar", slot);
}
generateUtilityClasses("MuiYearCalendar", ["root"]);
const _excluded$l = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow", "timezone", "gridLabelId", "slots", "slotProps"];
const useUtilityClasses$u = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getYearCalendarUtilityClass, classes);
};
function useYearCalendarDefaultizedProps(props, name) {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$1({
    disablePast: false,
    disableFuture: false
  }, themeProps, {
    yearsPerRow: themeProps.yearsPerRow ?? 3,
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
  });
}
const YearCalendarRoot = styled("div", {
  name: "MuiYearCalendar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  overflowY: "auto",
  height: "100%",
  padding: "0 4px",
  width: DIALOG_WIDTH,
  maxHeight: MAX_CALENDAR_HEIGHT,
  // avoid padding increasing width over defined
  boxSizing: "border-box",
  position: "relative"
});
const YearCalendar = /* @__PURE__ */ reactExports.forwardRef(function YearCalendar2(inProps, ref) {
  const props = useYearCalendarDefaultizedProps(inProps, "MuiYearCalendar");
  const {
    autoFocus,
    className,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    readOnly,
    shouldDisableYear,
    onYearFocus,
    hasFocus,
    onFocusedViewChange,
    yearsPerRow,
    timezone: timezoneProp,
    gridLabelId,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "YearCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const now2 = useNow(timezone);
  const isRtl = useRtl();
  const utils2 = useUtils();
  const referenceDate = reactExports.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils: utils2,
      props,
      timezone,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.year
    }),
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const ownerState = props;
  const classes = useUtilityClasses$u(ownerState);
  const todayYear = reactExports.useMemo(() => utils2.getYear(now2), [utils2, now2]);
  const selectedYear = reactExports.useMemo(() => {
    if (value != null) {
      return utils2.getYear(value);
    }
    return null;
  }, [value, utils2]);
  const [focusedYear, setFocusedYear] = reactExports.useState(() => selectedYear || utils2.getYear(referenceDate));
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "YearCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus ?? false
  });
  const changeHasFocus = useEventCallback((newHasFocus) => {
    setInternalHasFocus(newHasFocus);
    if (onFocusedViewChange) {
      onFocusedViewChange(newHasFocus);
    }
  });
  const isYearDisabled = reactExports.useCallback((dateToValidate) => {
    if (disablePast && utils2.isBeforeYear(dateToValidate, now2)) {
      return true;
    }
    if (disableFuture && utils2.isAfterYear(dateToValidate, now2)) {
      return true;
    }
    if (minDate && utils2.isBeforeYear(dateToValidate, minDate)) {
      return true;
    }
    if (maxDate && utils2.isAfterYear(dateToValidate, maxDate)) {
      return true;
    }
    if (!shouldDisableYear) {
      return false;
    }
    const yearToValidate = utils2.startOfYear(dateToValidate);
    return shouldDisableYear(yearToValidate);
  }, [disableFuture, disablePast, maxDate, minDate, now2, shouldDisableYear, utils2]);
  const handleYearSelection = useEventCallback((event, year) => {
    if (readOnly) {
      return;
    }
    const newDate = utils2.setYear(value ?? referenceDate, year);
    handleValueChange(newDate);
  });
  const focusYear = useEventCallback((year) => {
    if (!isYearDisabled(utils2.setYear(value ?? referenceDate, year))) {
      setFocusedYear(year);
      changeHasFocus(true);
      onYearFocus == null ? void 0 : onYearFocus(year);
    }
  });
  reactExports.useEffect(() => {
    setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
  }, [selectedYear]);
  const handleKeyDown = useEventCallback((event, year) => {
    switch (event.key) {
      case "ArrowUp":
        focusYear(year - yearsPerRow);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusYear(year + yearsPerRow);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusYear(year + (isRtl ? 1 : -1));
        event.preventDefault();
        break;
      case "ArrowRight":
        focusYear(year + (isRtl ? -1 : 1));
        event.preventDefault();
        break;
    }
  });
  const handleYearFocus = useEventCallback((event, year) => {
    focusYear(year);
  });
  const handleYearBlur = useEventCallback((event, year) => {
    if (focusedYear === year) {
      changeHasFocus(false);
    }
  });
  const scrollerRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, scrollerRef);
  reactExports.useEffect(() => {
    if (autoFocus || scrollerRef.current === null) {
      return;
    }
    const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
    if (!tabbableButton) {
      return;
    }
    const offsetHeight = tabbableButton.offsetHeight;
    const offsetTop = tabbableButton.offsetTop;
    const clientHeight = scrollerRef.current.clientHeight;
    const scrollTop2 = scrollerRef.current.scrollTop;
    const elementBottom = offsetTop + offsetHeight;
    if (offsetHeight > clientHeight || offsetTop < scrollTop2) {
      return;
    }
    scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
  }, [autoFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendarRoot, _extends$1({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState,
    role: "radiogroup",
    "aria-labelledby": gridLabelId
  }, other, {
    children: utils2.getYearRange([minDate, maxDate]).map((year) => {
      const yearNumber = utils2.getYear(year);
      const isSelected = yearNumber === selectedYear;
      const isDisabled = disabled || isYearDisabled(year);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYear, {
        selected: isSelected,
        value: yearNumber,
        onClick: handleYearSelection,
        onKeyDown: handleKeyDown,
        autoFocus: internalHasFocus && yearNumber === focusedYear,
        disabled: isDisabled,
        tabIndex: yearNumber === focusedYear && !isDisabled ? 0 : -1,
        onFocus: handleYearFocus,
        onBlur: handleYearBlur,
        "aria-current": todayYear === yearNumber ? "date" : void 0,
        yearsPerRow,
        slots,
        slotProps,
        children: utils2.format(year, "year")
      }, utils2.format(year, "year"));
    })
  }));
});
const getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
const pickersCalendarHeaderClasses = generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);
function getPickersArrowSwitcherUtilityClass(slot) {
  return generateUtilityClass("MuiPickersArrowSwitcher", slot);
}
generateUtilityClasses("MuiPickersArrowSwitcher", ["root", "spacer", "button", "previousIconButton", "nextIconButton", "leftArrowIcon", "rightArrowIcon"]);
const _excluded$k = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel", "labelId"], _excluded2$1 = ["ownerState"], _excluded3 = ["ownerState"];
const PickersArrowSwitcherRoot = styled("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex"
});
const PickersArrowSwitcherSpacer = styled("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Spacer",
  overridesResolver: (props, styles2) => styles2.spacer
})(({
  theme
}) => ({
  width: theme.spacing(3)
}));
const PickersArrowSwitcherButton = styled(IconButton, {
  name: "MuiPickersArrowSwitcher",
  slot: "Button",
  overridesResolver: (props, styles2) => styles2.button
})({
  variants: [{
    props: {
      hidden: true
    },
    style: {
      visibility: "hidden"
    }
  }]
});
const useUtilityClasses$t = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    spacer: ["spacer"],
    button: ["button"],
    previousIconButton: ["previousIconButton"],
    nextIconButton: ["nextIconButton"],
    leftArrowIcon: ["leftArrowIcon"],
    rightArrowIcon: ["rightArrowIcon"]
  };
  return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
};
const PickersArrowSwitcher = /* @__PURE__ */ reactExports.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
  const isRtl = useRtl();
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersArrowSwitcher"
  });
  const {
    children,
    className,
    slots,
    slotProps,
    isNextDisabled,
    isNextHidden,
    onGoToNext,
    nextLabel,
    isPreviousDisabled,
    isPreviousHidden,
    onGoToPrevious,
    previousLabel,
    labelId
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const ownerState = props;
  const classes = useUtilityClasses$t(ownerState);
  const nextProps = {
    isDisabled: isNextDisabled,
    isHidden: isNextHidden,
    goTo: onGoToNext,
    label: nextLabel
  };
  const previousProps = {
    isDisabled: isPreviousDisabled,
    isHidden: isPreviousHidden,
    goTo: onGoToPrevious,
    label: previousLabel
  };
  const PreviousIconButton = (slots == null ? void 0 : slots.previousIconButton) ?? PickersArrowSwitcherButton;
  const previousIconButtonProps = useSlotProps({
    elementType: PreviousIconButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.previousIconButton,
    additionalProps: {
      size: "medium",
      title: previousProps.label,
      "aria-label": previousProps.label,
      disabled: previousProps.isDisabled,
      edge: "end",
      onClick: previousProps.goTo
    },
    ownerState: _extends$1({}, ownerState, {
      hidden: previousProps.isHidden
    }),
    className: clsx(classes.button, classes.previousIconButton)
  });
  const NextIconButton = (slots == null ? void 0 : slots.nextIconButton) ?? PickersArrowSwitcherButton;
  const nextIconButtonProps = useSlotProps({
    elementType: NextIconButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.nextIconButton,
    additionalProps: {
      size: "medium",
      title: nextProps.label,
      "aria-label": nextProps.label,
      disabled: nextProps.isDisabled,
      edge: "start",
      onClick: nextProps.goTo
    },
    ownerState: _extends$1({}, ownerState, {
      hidden: nextProps.isHidden
    }),
    className: clsx(classes.button, classes.nextIconButton)
  });
  const LeftArrowIcon = (slots == null ? void 0 : slots.leftArrowIcon) ?? ArrowLeftIcon;
  const _useSlotProps = useSlotProps({
    elementType: LeftArrowIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.leftArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState,
    className: classes.leftArrowIcon
  }), leftArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2$1);
  const RightArrowIcon = (slots == null ? void 0 : slots.rightArrowIcon) ?? ArrowRightIcon;
  const _useSlotProps2 = useSlotProps({
    elementType: RightArrowIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.rightArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState,
    className: classes.rightArrowIcon
  }), rightArrowIconProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded3);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersArrowSwitcherRoot, _extends$1({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PreviousIconButton, _extends$1({}, previousIconButtonProps, {
      children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps))
    })), children ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
      variant: "subtitle1",
      component: "span",
      id: labelId,
      children
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcherSpacer, {
      className: classes.spacer,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(NextIconButton, _extends$1({}, nextIconButtonProps, {
      children: isRtl ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$1({}, leftArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$1({}, rightArrowIconProps))
    }))]
  }));
});
function useNextMonthDisabled(month, {
  disableFuture,
  maxDate,
  timezone
}) {
  const utils2 = useUtils();
  return reactExports.useMemo(() => {
    const now2 = utils2.date(void 0, timezone);
    const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now2, maxDate) ? now2 : maxDate);
    return !utils2.isAfter(lastEnabledMonth, month);
  }, [disableFuture, maxDate, month, utils2, timezone]);
}
function usePreviousMonthDisabled(month, {
  disablePast,
  minDate,
  timezone
}) {
  const utils2 = useUtils();
  return reactExports.useMemo(() => {
    const now2 = utils2.date(void 0, timezone);
    const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now2, minDate) ? now2 : minDate);
    return !utils2.isBefore(firstEnabledMonth, month);
  }, [disablePast, minDate, month, utils2, timezone]);
}
function useMeridiemMode(date, ampm, onChange, selectionState) {
  const utils2 = useUtils();
  const meridiemMode = getMeridiem(date, utils2);
  const handleMeridiemChange = reactExports.useCallback((mode) => {
    const timeWithMeridiem = date == null ? null : convertToMeridiem(date, mode, Boolean(ampm), utils2);
    onChange(timeWithMeridiem, selectionState ?? "partial");
  }, [ampm, date, onChange, selectionState, utils2]);
  return {
    meridiemMode,
    handleMeridiemChange
  };
}
const _excluded$j = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone", "format"], _excluded2 = ["ownerState"];
const useUtilityClasses$s = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    labelContainer: ["labelContainer"],
    label: ["label"],
    switchViewButton: ["switchViewButton"],
    switchViewIcon: ["switchViewIcon"]
  };
  return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
};
const PickersCalendarHeaderRoot = styled("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})({
  display: "flex",
  alignItems: "center",
  marginTop: 12,
  marginBottom: 4,
  paddingLeft: 24,
  paddingRight: 12,
  // prevent jumping in safari
  maxHeight: 40,
  minHeight: 40
});
const PickersCalendarHeaderLabelContainer = styled("div", {
  name: "MuiPickersCalendarHeader",
  slot: "LabelContainer",
  overridesResolver: (_, styles2) => styles2.labelContainer
})(({
  theme
}) => _extends$1({
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, theme.typography.body1, {
  fontWeight: theme.typography.fontWeightMedium
}));
const PickersCalendarHeaderLabel = styled("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Label",
  overridesResolver: (_, styles2) => styles2.label
})({
  marginRight: 6
});
const PickersCalendarHeaderSwitchViewButton = styled(IconButton, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewButton",
  overridesResolver: (_, styles2) => styles2.switchViewButton
})({
  marginRight: "auto",
  variants: [{
    props: {
      view: "year"
    },
    style: {
      [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
        transform: "rotate(180deg)"
      }
    }
  }]
});
const PickersCalendarHeaderSwitchViewIcon = styled(ArrowDropDownIcon, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewIcon",
  overridesResolver: (_, styles2) => styles2.switchViewIcon
})(({
  theme
}) => ({
  willChange: "transform",
  transition: theme.transitions.create("transform"),
  transform: "rotate(0deg)"
}));
const PickersCalendarHeader = /* @__PURE__ */ reactExports.forwardRef(function PickersCalendarHeader2(inProps, ref) {
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersCalendarHeader"
  });
  const {
    slots,
    slotProps,
    currentMonth: month,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onMonthChange,
    onViewChange,
    view,
    reduceAnimations,
    views,
    labelId,
    className,
    timezone,
    format: format2 = `${utils2.formats.month} ${utils2.formats.year}`
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const ownerState = props;
  const classes = useUtilityClasses$s(props);
  const SwitchViewButton = (slots == null ? void 0 : slots.switchViewButton) ?? PickersCalendarHeaderSwitchViewButton;
  const switchViewButtonProps = useSlotProps({
    elementType: SwitchViewButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewButton,
    additionalProps: {
      size: "small",
      "aria-label": translations.calendarViewSwitchingButtonAriaLabel(view)
    },
    ownerState,
    className: classes.switchViewButton
  });
  const SwitchViewIcon = (slots == null ? void 0 : slots.switchViewIcon) ?? PickersCalendarHeaderSwitchViewIcon;
  const _useSlotProps = useSlotProps({
    elementType: SwitchViewIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewIcon,
    ownerState,
    className: classes.switchViewIcon
  }), switchViewIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2);
  const selectNextMonth = () => onMonthChange(utils2.addMonths(month, 1), "left");
  const selectPreviousMonth = () => onMonthChange(utils2.addMonths(month, -1), "right");
  const isNextMonthDisabled = useNextMonthDisabled(month, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
    disablePast,
    minDate,
    timezone
  });
  const handleToggleView = () => {
    if (views.length === 1 || !onViewChange || disabled) {
      return;
    }
    if (views.length === 2) {
      onViewChange(views.find((el2) => el2 !== view) || views[0]);
    } else {
      const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
      onViewChange(views[nextIndexToOpen]);
    }
  };
  if (views.length === 1 && views[0] === "year") {
    return null;
  }
  const label = utils2.formatByString(month, format2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderRoot, _extends$1({}, other, {
    ownerState,
    className: clsx(className, classes.root),
    ref,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderLabelContainer, {
      role: "presentation",
      onClick: handleToggleView,
      ownerState,
      "aria-live": "polite",
      className: classes.labelContainer,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroup, {
        reduceAnimations,
        transKey: label,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarHeaderLabel, {
          id: labelId,
          ownerState,
          className: classes.label,
          children: label
        })
      }), views.length > 1 && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewButton, _extends$1({}, switchViewButtonProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewIcon, _extends$1({}, switchViewIconProps))
      }))]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, {
      in: view === "day",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcher, {
        slots,
        slotProps,
        onGoToPrevious: selectPreviousMonth,
        isPreviousDisabled: isPreviousMonthDisabled,
        previousLabel: translations.previousMonth,
        onGoToNext: selectNextMonth,
        isNextDisabled: isNextMonthDisabled,
        nextLabel: translations.nextMonth
      })
    })]
  }));
});
const PickerViewRoot = styled("div")({
  overflow: "hidden",
  width: DIALOG_WIDTH,
  maxHeight: VIEW_HEIGHT,
  display: "flex",
  flexDirection: "column",
  margin: "0 auto"
});
const getDateCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateCalendar", slot);
generateUtilityClasses("MuiDateCalendar", ["root", "viewTransitionContainer"]);
const _excluded$i = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow", "timezone"];
const useUtilityClasses$r = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    viewTransitionContainer: ["viewTransitionContainer"]
  };
  return composeClasses(slots, getDateCalendarUtilityClass, classes);
};
function useDateCalendarDefaultizedProps(props, name) {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$1({}, themeProps, {
    loading: themeProps.loading ?? false,
    disablePast: themeProps.disablePast ?? false,
    disableFuture: themeProps.disableFuture ?? false,
    openTo: themeProps.openTo ?? "day",
    views: themeProps.views ?? ["year", "day"],
    reduceAnimations: themeProps.reduceAnimations ?? defaultReduceAnimations,
    renderLoading: themeProps.renderLoading ?? (() => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      children: "..."
    })),
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
  });
}
const DateCalendarRoot = styled(PickerViewRoot, {
  name: "MuiDateCalendar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexDirection: "column",
  height: VIEW_HEIGHT
});
const DateCalendarViewTransitionContainer = styled(PickersFadeTransitionGroup, {
  name: "MuiDateCalendar",
  slot: "ViewTransitionContainer",
  overridesResolver: (props, styles2) => styles2.viewTransitionContainer
})({});
const DateCalendar = /* @__PURE__ */ reactExports.forwardRef(function DateCalendar2(inProps, ref) {
  const utils2 = useUtils();
  const id2 = useId();
  const props = useDateCalendarDefaultizedProps(inProps, "MuiDateCalendar");
  const {
    autoFocus,
    onViewChange,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableFuture,
    disablePast,
    onChange,
    onYearChange,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    view: inView,
    views,
    openTo,
    className,
    disabled,
    readOnly,
    minDate,
    maxDate,
    disableHighlightToday,
    focusedView: inFocusedView,
    onFocusedViewChange,
    showDaysOutsideCurrentMonth,
    fixedWeekNumber,
    dayOfWeekFormatter,
    slots,
    slotProps,
    loading,
    renderLoading,
    displayWeekNumber,
    yearsPerRow,
    monthsPerRow,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DateCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const {
    view,
    setView,
    focusedView,
    setFocusedView,
    goToNextView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange: handleValueChange,
    onViewChange,
    autoFocus,
    focusedView: inFocusedView,
    onFocusedViewChange
  });
  const {
    referenceDate,
    calendarState,
    changeFocusedDay,
    changeMonth,
    handleChangeMonth,
    isDateDisabled,
    onMonthSwitchingAnimationEnd
  } = useCalendarState2({
    value,
    referenceDate: referenceDateProp,
    reduceAnimations,
    onMonthChange,
    minDate,
    maxDate,
    shouldDisableDate,
    disablePast,
    disableFuture,
    timezone
  });
  const minDateWithDisabled = disabled && value || minDate;
  const maxDateWithDisabled = disabled && value || maxDate;
  const gridLabelId = `${id2}-grid-label`;
  const hasFocus = focusedView !== null;
  const CalendarHeader2 = (slots == null ? void 0 : slots.calendarHeader) ?? PickersCalendarHeader;
  const calendarHeaderProps = useSlotProps({
    elementType: CalendarHeader2,
    externalSlotProps: slotProps == null ? void 0 : slotProps.calendarHeader,
    additionalProps: {
      views,
      view,
      currentMonth: calendarState.currentMonth,
      onViewChange: setView,
      onMonthChange: (newMonth, direction) => handleChangeMonth({
        newMonth,
        direction
      }),
      minDate: minDateWithDisabled,
      maxDate: maxDateWithDisabled,
      disabled,
      disablePast,
      disableFuture,
      reduceAnimations,
      timezone,
      labelId: gridLabelId
    },
    ownerState: props
  });
  const handleDateMonthChange = useEventCallback((newDate) => {
    const startOfMonth2 = utils2.startOfMonth(newDate);
    const endOfMonth2 = utils2.endOfMonth(newDate);
    const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
      utils: utils2,
      date: newDate,
      minDate: utils2.isBefore(minDate, startOfMonth2) ? startOfMonth2 : minDate,
      maxDate: utils2.isAfter(maxDate, endOfMonth2) ? endOfMonth2 : maxDate,
      disablePast,
      disableFuture,
      isDateDisabled,
      timezone
    }) : newDate;
    if (closestEnabledDate) {
      setValueAndGoToNextView(closestEnabledDate, "finish");
      onMonthChange == null ? void 0 : onMonthChange(startOfMonth2);
    } else {
      goToNextView();
      changeMonth(startOfMonth2);
    }
    changeFocusedDay(closestEnabledDate, true);
  });
  const handleDateYearChange = useEventCallback((newDate) => {
    const startOfYear = utils2.startOfYear(newDate);
    const endOfYear = utils2.endOfYear(newDate);
    const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
      utils: utils2,
      date: newDate,
      minDate: utils2.isBefore(minDate, startOfYear) ? startOfYear : minDate,
      maxDate: utils2.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
      disablePast,
      disableFuture,
      isDateDisabled,
      timezone
    }) : newDate;
    if (closestEnabledDate) {
      setValueAndGoToNextView(closestEnabledDate, "finish");
      onYearChange == null ? void 0 : onYearChange(closestEnabledDate);
    } else {
      goToNextView();
      changeMonth(startOfYear);
    }
    changeFocusedDay(closestEnabledDate, true);
  });
  const handleSelectedDayChange = useEventCallback((day) => {
    if (day) {
      return handleValueChange(mergeDateAndTime(utils2, day, value ?? referenceDate), "finish", view);
    }
    return handleValueChange(day, "finish", view);
  });
  reactExports.useEffect(() => {
    if (value != null && utils2.isValid(value)) {
      changeMonth(value);
    }
  }, [value]);
  const ownerState = props;
  const classes = useUtilityClasses$r(ownerState);
  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled,
    timezone,
    gridLabelId,
    slots,
    slotProps
  };
  const prevOpenViewRef = reactExports.useRef(view);
  reactExports.useEffect(() => {
    if (prevOpenViewRef.current === view) {
      return;
    }
    if (focusedView === prevOpenViewRef.current) {
      setFocusedView(view, true);
    }
    prevOpenViewRef.current = view;
  }, [focusedView, setFocusedView, view]);
  const selectedDays = reactExports.useMemo(() => [value], [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateCalendarRoot, _extends$1({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(CalendarHeader2, _extends$1({}, calendarHeaderProps, {
      slots,
      slotProps
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendarViewTransitionContainer, {
      reduceAnimations,
      className: classes.viewTransitionContainer,
      transKey: view,
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        children: [view === "year" && /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendar, _extends$1({}, baseDateValidationProps, commonViewProps, {
          value,
          onChange: handleDateYearChange,
          shouldDisableYear,
          hasFocus,
          onFocusedViewChange: (isViewFocused) => setFocusedView("year", isViewFocused),
          yearsPerRow,
          referenceDate
        })), view === "month" && /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendar, _extends$1({}, baseDateValidationProps, commonViewProps, {
          hasFocus,
          className,
          value,
          onChange: handleDateMonthChange,
          shouldDisableMonth,
          onFocusedViewChange: (isViewFocused) => setFocusedView("month", isViewFocused),
          monthsPerRow,
          referenceDate
        })), view === "day" && /* @__PURE__ */ jsxRuntimeExports.jsx(DayCalendar, _extends$1({}, calendarState, baseDateValidationProps, commonViewProps, {
          onMonthSwitchingAnimationEnd,
          onFocusedDayChange: changeFocusedDay,
          reduceAnimations,
          selectedDays,
          onSelectedDaysChange: handleSelectedDayChange,
          shouldDisableDate,
          shouldDisableMonth,
          shouldDisableYear,
          hasFocus,
          onFocusedViewChange: (isViewFocused) => setFocusedView("day", isViewFocused),
          showDaysOutsideCurrentMonth,
          fixedWeekNumber,
          dayOfWeekFormatter,
          displayWeekNumber,
          loading,
          renderLoading
        }))]
      })
    })]
  }));
});
const renderDateViewCalendar = ({
  view,
  onViewChange,
  views,
  focusedView,
  onFocusedViewChange,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  reduceAnimations,
  onMonthChange,
  monthsPerRow,
  onYearChange,
  yearsPerRow,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  sx,
  autoFocus,
  fixedWeekNumber,
  displayWeekNumber,
  timezone
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendar, {
  view,
  onViewChange,
  views: views.filter(isDatePickerView),
  focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
  onFocusedViewChange,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  reduceAnimations,
  onMonthChange,
  monthsPerRow,
  onYearChange,
  yearsPerRow,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  sx,
  autoFocus,
  fixedWeekNumber,
  displayWeekNumber,
  timezone
});
const DesktopDatePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopDatePicker2(inProps, ref) {
  var _a2, _b2;
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const defaultizedProps = useDatePickerDefaultizedProps(inProps, "MuiDesktopDatePicker");
  const viewRenderers = _extends$1({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends$1({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateFormat(utils2, defaultizedProps, false),
    yearsPerRow: defaultizedProps.yearsPerRow ?? 4,
    slots: _extends$1({
      openPickerIcon: CalendarIcon,
      field: DateField
    }, defaultizedProps.slots),
    slotProps: _extends$1({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a3;
        return _extends$1({}, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$1({
        hidden: true
      }, (_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.toolbar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date",
    getOpenDialogAriaText: ((_b2 = props.localeText) == null ? void 0 : _b2.openDatePickerDialogue) ?? translations.openDatePickerDialogue,
    validator: validateDate
  });
  return renderPicker();
});
DesktopDatePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes.func,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: PropTypes.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: PropTypes.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: PropTypes.object,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.object,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: PropTypes.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes.shape({
    day: PropTypes.func,
    month: PropTypes.func,
    year: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: PropTypes.oneOf([3, 4])
};
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogContent", slot);
}
generateUtilityClasses$1("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialogTitle", slot);
}
const dialogTitleClasses = generateUtilityClasses$1("MuiDialogTitle", ["root"]);
const useUtilityClasses$q = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses$1(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(memoTheme(({
  theme
}) => ({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.dividers,
    style: {
      padding: "16px 24px",
      borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.dividers,
    style: {
      [`.${dialogTitleClasses.root} + &`]: {
        paddingTop: 0
      }
    }
  }]
})));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const {
    className,
    dividers = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    dividers
  };
  const classes = useUtilityClasses$q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, {
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other
  });
});
function getDialogUtilityClass(slot) {
  return generateUtilityClass$1("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses$1("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const DialogBackdrop = styled(Backdrop, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$p = (ownerState) => {
  const {
    classes,
    scroll,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize$1(scroll)}`],
    paper: ["paper", `paperScroll${capitalize$1(scroll)}`, `paperWidth${capitalize$1(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses$1(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled(Modal, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize$1(ownerState.scroll)}`]];
  }
})({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  variants: [{
    props: {
      scroll: "paper"
    },
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center"
    }
  }, {
    props: {
      scroll: "body"
    },
    style: {
      overflowY: "auto",
      overflowX: "hidden",
      textAlign: "center",
      "&::after": {
        content: '""',
        display: "inline-block",
        verticalAlign: "middle",
        height: "100%",
        width: "0"
      }
    }
  }]
});
const DialogPaper = styled(Paper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize$1(ownerState.scroll)}`], styles2[`paperWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(memoTheme(({
  theme
}) => ({
  margin: 32,
  position: "relative",
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  },
  variants: [{
    props: {
      scroll: "paper"
    },
    style: {
      display: "flex",
      flexDirection: "column",
      maxHeight: "calc(100% - 64px)"
    }
  }, {
    props: {
      scroll: "body"
    },
    style: {
      display: "inline-block",
      verticalAlign: "middle",
      textAlign: "initial"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.maxWidth,
    style: {
      maxWidth: "calc(100% - 64px)"
    }
  }, {
    props: {
      maxWidth: "xs"
    },
    style: {
      maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
      [`&.${dialogClasses.paperScrollBody}`]: {
        [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }
  }, ...Object.keys(theme.breakpoints.values).filter((maxWidth2) => maxWidth2 !== "xs").map((maxWidth2) => ({
    props: {
      maxWidth: maxWidth2
    },
    style: {
      maxWidth: `${theme.breakpoints.values[maxWidth2]}${theme.breakpoints.unit}`,
      [`&.${dialogClasses.paperScrollBody}`]: {
        [theme.breakpoints.down(theme.breakpoints.values[maxWidth2] + 32 * 2)]: {
          maxWidth: "calc(100% - 64px)"
        }
      }
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "calc(100% - 64px)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullScreen,
    style: {
      margin: 0,
      width: "100%",
      maxWidth: "100%",
      height: "100%",
      maxHeight: "none",
      borderRadius: 0,
      [`&.${dialogClasses.paperScrollBody}`]: {
        margin: 0,
        maxWidth: "100%"
      }
    }
  }]
})));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onBackdropClick,
    onClick,
    onClose,
    open,
    PaperComponent = Paper,
    PaperProps = {},
    scroll = "paper",
    TransitionComponent = Fade,
    transitionDuration = defaultTransitionDuration,
    TransitionProps,
    ...other
  } = props;
  const ownerState = {
    ...props,
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll
  };
  const classes = useUtilityClasses$p(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (onClick) {
      onClick(event);
    }
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId$1(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, {
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: {
        transitionDuration,
        as: BackdropComponent,
        ...BackdropProps
      }
    },
    disableEscapeKeyDown,
    onClose,
    open,
    ref,
    onClick: handleBackdropClick,
    ownerState,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation",
      ...TransitionProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, {
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby,
          ...PaperProps,
          className: clsx(classes.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext.Provider, {
            value: dialogContextValue,
            children
          })
        })
      })
    })
  });
});
const PickersModalDialogRoot = styled(Dialog)({
  [`& .${dialogClasses.container}`]: {
    outline: 0
  },
  [`& .${dialogClasses.paper}`]: {
    outline: 0,
    minWidth: DIALOG_WIDTH
  }
});
const PickersModalDialogContent = styled(DialogContent)({
  "&:first-of-type": {
    padding: 0
  }
});
function PickersModalDialog(props) {
  const {
    children,
    onDismiss,
    open,
    slots,
    slotProps
  } = props;
  const Dialog3 = (slots == null ? void 0 : slots.dialog) ?? PickersModalDialogRoot;
  const Transition2 = (slots == null ? void 0 : slots.mobileTransition) ?? Fade;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog3, _extends$1({
    open,
    onClose: onDismiss
  }, slotProps == null ? void 0 : slotProps.dialog, {
    TransitionComponent: Transition2,
    TransitionProps: slotProps == null ? void 0 : slotProps.mobileTransition,
    PaperComponent: slots == null ? void 0 : slots.mobilePaper,
    PaperProps: slotProps == null ? void 0 : slotProps.mobilePaper,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialogContent, {
      children
    })
  }));
}
const _excluded$h = ["props", "getOpenDialogAriaText"];
const useMobilePicker = (_ref) => {
  var _a2;
  let {
    props,
    getOpenDialogAriaText
  } = _ref, pickerParams = _objectWithoutPropertiesLoose(_ref, _excluded$h);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format: format2,
    formatDensity,
    enableAccessibleFieldDOMStructure,
    selectedSections,
    onSelectedSectionsChange,
    timezone,
    name,
    label,
    inputRef,
    readOnly,
    disabled,
    localeText
  } = props;
  const utils2 = useUtils();
  const fieldRef = reactExports.useRef(null);
  const labelId = useId();
  const isToolbarHidden = ((_a2 = innerSlotProps == null ? void 0 : innerSlotProps.toolbar) == null ? void 0 : _a2.hidden) ?? false;
  const {
    open,
    actions,
    layoutProps,
    renderCurrentView,
    fieldProps: pickerFieldProps
  } = usePicker(_extends$1({}, pickerParams, {
    props,
    fieldRef,
    autoFocusView: true,
    additionalViewProps: {},
    wrapperVariant: "mobile"
  }));
  const Field = slots.field;
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends$1({}, pickerFieldProps, isToolbarHidden && {
      id: labelId
    }, !(disabled || readOnly) && {
      onClick: actions.onOpen,
      onKeyDown: onSpaceOrEnter(actions.onOpen)
    }, {
      readOnly: readOnly ?? true,
      disabled,
      className,
      sx,
      format: format2,
      formatDensity,
      enableAccessibleFieldDOMStructure,
      selectedSections,
      onSelectedSectionsChange,
      timezone,
      label,
      name
    }, inputRef ? {
      inputRef
    } : {}),
    ownerState: props
  });
  fieldProps.inputProps = _extends$1({}, fieldProps.inputProps, {
    "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2)
  });
  const slotsForField = _extends$1({
    textField: slots.textField
  }, fieldProps.slots);
  const Layout = slots.layout ?? PickersLayout;
  let labelledById = labelId;
  if (isToolbarHidden) {
    if (label) {
      labelledById = `${labelId}-label`;
    } else {
      labelledById = void 0;
    }
  }
  const slotProps = _extends$1({}, innerSlotProps, {
    toolbar: _extends$1({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId
    }),
    mobilePaper: _extends$1({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
  });
  const handleFieldRef = useForkRef(fieldRef, fieldProps.unstableFieldRef);
  const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
    localeText,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$1({}, fieldProps, {
      slots: slotsForField,
      slotProps,
      unstableFieldRef: handleFieldRef
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialog, _extends$1({}, actions, {
      open,
      slots,
      slotProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$1({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};
const MobileDatePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileDatePicker2(inProps, ref) {
  var _a2, _b2;
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const defaultizedProps = useDatePickerDefaultizedProps(inProps, "MuiMobileDatePicker");
  const viewRenderers = _extends$1({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends$1({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateFormat(utils2, defaultizedProps, false),
    slots: _extends$1({
      field: DateField
    }, defaultizedProps.slots),
    slotProps: _extends$1({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a3;
        return _extends$1({}, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$1({
        hidden: false
      }, (_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date",
    getOpenDialogAriaText: ((_b2 = props.localeText) == null ? void 0 : _b2.openDatePickerDialogue) ?? translations.openDatePickerDialogue,
    validator: validateDate
  });
  return renderPicker();
});
MobileDatePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes.func,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: PropTypes.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: PropTypes.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: PropTypes.object,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.object,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: PropTypes.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes.shape({
    day: PropTypes.func,
    month: PropTypes.func,
    year: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: PropTypes.oneOf([3, 4])
};
const _excluded$g = ["desktopModeMediaQuery"];
const DatePicker = /* @__PURE__ */ reactExports.forwardRef(function DatePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDatePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopDatePicker, _extends$1({
      ref
    }, other));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDatePicker, _extends$1({
    ref
  }, other));
});
const validateTime = ({
  adapter,
  value,
  props
}) => {
  if (value === null) {
    return null;
  }
  const {
    minTime,
    maxTime,
    minutesStep,
    shouldDisableTime,
    disableIgnoringDatePartForTimeValidation = false,
    disablePast,
    disableFuture,
    timezone
  } = props;
  const now2 = adapter.utils.date(void 0, timezone);
  const isAfter2 = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, adapter.utils);
  switch (true) {
    case !adapter.utils.isValid(value):
      return "invalidDate";
    case Boolean(minTime && isAfter2(minTime, value)):
      return "minTime";
    case Boolean(maxTime && isAfter2(value, maxTime)):
      return "maxTime";
    case Boolean(disableFuture && adapter.utils.isAfter(value, now2)):
      return "disableFuture";
    case Boolean(disablePast && adapter.utils.isBefore(value, now2)):
      return "disablePast";
    case Boolean(shouldDisableTime && shouldDisableTime(value, "hours")):
      return "shouldDisableTime-hours";
    case Boolean(shouldDisableTime && shouldDisableTime(value, "minutes")):
      return "shouldDisableTime-minutes";
    case Boolean(shouldDisableTime && shouldDisableTime(value, "seconds")):
      return "shouldDisableTime-seconds";
    case Boolean(minutesStep && adapter.utils.getMinutes(value) % minutesStep !== 0):
      return "minutesStep";
    default:
      return null;
  }
};
const validateDateTime = ({
  props,
  value,
  adapter
}) => {
  const dateValidationResult = validateDate({
    adapter,
    value,
    props
  });
  if (dateValidationResult !== null) {
    return dateValidationResult;
  }
  return validateTime({
    adapter,
    value,
    props
  });
};
const useDateTimeField = (inProps) => {
  const props = useDefaultizedDateTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date-time");
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDateTime,
    valueType: "date-time"
  });
};
const _excluded$f = ["slots", "slotProps", "InputProps", "inputProps"];
const DateTimeField = /* @__PURE__ */ reactExports.forwardRef(function DateTimeField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateTimeField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$f);
  const ownerState = themeProps;
  const TextField$1 = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField);
  const textFieldProps = useSlotProps({
    elementType: TextField$1,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: inRef
    }
  });
  textFieldProps.inputProps = _extends$1({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$1({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useDateTimeField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends$1({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, _extends$1({}, processedFieldProps));
});
function getTabUtilityClass(slot) {
  return generateUtilityClass$1("MuiTab", slot);
}
const tabClasses = generateUtilityClasses$1("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"]);
const useUtilityClasses$o = (ownerState) => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", icon && label && "labelIcon", `textColor${capitalize$1(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
    icon: ["iconWrapper", "icon"]
  };
  return composeClasses$1(slots, getTabUtilityClass, classes);
};
const TabRoot = styled(ButtonBase, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize$1(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped, {
      [`& .${tabClasses.iconWrapper}`]: styles2.iconWrapper
    }, {
      [`& .${tabClasses.icon}`]: styles2.icon
    }];
  }
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.button,
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center",
  lineHeight: 1.25,
  variants: [{
    props: ({
      ownerState
    }) => ownerState.label && (ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom"),
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.label && ownerState.iconPosition !== "top" && ownerState.iconPosition !== "bottom",
    style: {
      flexDirection: "row"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.icon && ownerState.label,
    style: {
      minHeight: 72,
      paddingTop: 9,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "top",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginBottom: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "bottom",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginTop: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "start",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginRight: theme.spacing(1)
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "end",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginLeft: theme.spacing(1)
      }
    }
  }, {
    props: {
      textColor: "inherit"
    },
    style: {
      color: "inherit",
      opacity: 0.6,
      // same opacity as theme.palette.text.secondary
      [`&.${tabClasses.selected}`]: {
        opacity: 1
      },
      [`&.${tabClasses.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      }
    }
  }, {
    props: {
      textColor: "primary"
    },
    style: {
      color: (theme.vars || theme).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      }
    }
  }, {
    props: {
      textColor: "secondary"
    },
    style: {
      color: (theme.vars || theme).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme.vars || theme).palette.secondary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      flexShrink: 1,
      flexGrow: 1,
      flexBasis: 0,
      maxWidth: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.wrapped,
    style: {
      fontSize: theme.typography.pxToRem(12)
    }
  }]
})));
const Tab2 = /* @__PURE__ */ reactExports.forwardRef(function Tab22(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTab"
  });
  const {
    className,
    disabled = false,
    disableFocusRipple = false,
    // eslint-disable-next-line react/prop-types
    fullWidth,
    icon: iconProp,
    iconPosition = "top",
    // eslint-disable-next-line react/prop-types
    indicator,
    label,
    onChange,
    onClick,
    onFocus,
    // eslint-disable-next-line react/prop-types
    selected,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus,
    // eslint-disable-next-line react/prop-types
    textColor = "inherit",
    value,
    wrapped = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  };
  const classes = useUtilityClasses$o(ownerState);
  const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
    className: clsx(classes.icon, iconProp.props.className)
  }) : iconProp;
  const handleClick = (event) => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = (event) => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, {
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref,
    role: "tab",
    "aria-selected": selected,
    disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState,
    tabIndex: selected ? 0 : -1,
    ...other,
    children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [icon, label]
    }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [label, icon]
    }), indicator]
  });
});
function easeInOutSin(time2) {
  return (1 + Math.sin(Math.PI * time2 - Math.PI / 2)) / 2;
}
function animate(property2, element, to, options = {}, cb2 = () => {
}) {
  const {
    ease = easeInOutSin,
    duration: duration2 = 300
    // standard
  } = options;
  let start2 = null;
  const from2 = element[property2];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb2(new Error("Animation cancelled"));
      return;
    }
    if (start2 === null) {
      start2 = timestamp;
    }
    const time2 = Math.min(1, (timestamp - start2) / duration2);
    element[property2] = ease(time2) * (to - from2) + from2;
    if (time2 >= 1) {
      requestAnimationFrame(() => {
        cb2(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from2 === to) {
    cb2(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
const styles = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function ScrollbarSize(props) {
  const {
    onChange,
    ...other
  } = props;
  const scrollbarHeight = reactExports.useRef();
  const nodeRef = reactExports.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  useEnhancedEffect$1(() => {
    const handleResize = debounce$2(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  reactExports.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    style: styles,
    ref: nodeRef,
    ...other
  });
}
const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft");
const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass$1("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses$1("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const useUtilityClasses$n = (ownerState) => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, disabled && "disabled"]
  };
  return composeClasses$1(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled(ButtonBase, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
  }
})({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses.disabled}`]: {
    opacity: 0
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      width: "100%",
      height: 40,
      "& svg": {
        transform: "var(--TabScrollButton-svgRotate)"
      }
    }
  }]
});
const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabScrollButton"
  });
  const {
    className,
    slots = {},
    slotProps = {},
    direction,
    orientation,
    disabled,
    ...other
  } = props;
  const isRtl = useRtl();
  const ownerState = {
    isRtl,
    ...props
  };
  const classes = useUtilityClasses$n(ownerState);
  const StartButtonIcon = slots.StartScrollButtonIcon ?? KeyboardArrowLeft;
  const EndButtonIcon = slots.EndScrollButtonIcon ?? KeyboardArrowRight;
  const startButtonIconProps = useSlotProps$1({
    elementType: StartButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  const endButtonIconProps = useSlotProps$1({
    elementType: EndButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, {
    component: "div",
    className: clsx(classes.root, className),
    ref,
    role: null,
    ownerState,
    tabIndex: null,
    ...other,
    style: {
      ...other.style,
      ...orientation === "vertical" && {
        "--TabScrollButton-svgRotate": `rotate(${isRtl ? -90 : 90}deg)`
      }
    },
    children: direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, {
      ...startButtonIconProps
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, {
      ...endButtonIconProps
    })
  });
});
function getTabsUtilityClass(slot) {
  return generateUtilityClass$1("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses$1("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
const nextItem = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$m = (ownerState) => {
  const {
    vertical,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ["root", vertical && "vertical"],
    scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
    flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
    scrollableX: [scrollableX && "scrollableX"],
    hideScrollbar: [hideScrollbar && "hideScrollbar"]
  };
  return composeClasses$1(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses.scrollButtons}`]: styles2.scrollButtons
    }, {
      [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
    }, styles2.root, ownerState.vertical && styles2.vertical];
  }
})(memoTheme(({
  theme
}) => ({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollButtonsHideMobile,
    style: {
      [`& .${tabsClasses.scrollButtons}`]: {
        [theme.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }
  }]
})));
const TabsScroller = styled("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
  }
})({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.fixed,
    style: {
      overflowX: "hidden",
      width: "100%"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hideScrollbar,
    style: {
      // Hide dimensionless scrollbar on macOS
      scrollbarWidth: "none",
      // Firefox
      "&::-webkit-scrollbar": {
        display: "none"
        // Safari + Chrome
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableX,
    style: {
      overflowX: "auto",
      overflowY: "hidden"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableY,
    style: {
      overflowY: "auto",
      overflowX: "hidden"
    }
  }]
});
const FlexContainer = styled("div", {
  name: "MuiTabs",
  slot: "FlexContainer",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
  }
})({
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.centered,
    style: {
      justifyContent: "center"
    }
  }]
});
const TabsIndicator = styled("span", {
  name: "MuiTabs",
  slot: "Indicator",
  overridesResolver: (props, styles2) => styles2.indicator
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: theme.transitions.create(),
  variants: [{
    props: {
      indicatorColor: "primary"
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.primary.main
    }
  }, {
    props: {
      indicatorColor: "secondary"
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.secondary.main
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      height: "100%",
      width: 2,
      right: 0
    }
  }]
})));
const TabsScrollbarSize = styled(ScrollbarSize)({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabs"
  });
  const theme = useTheme();
  const isRtl = useRtl();
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    action,
    centered = false,
    children: childrenProp,
    className,
    component = "div",
    allowScrollButtonsMobile = false,
    indicatorColor = "primary",
    onChange,
    orientation = "horizontal",
    ScrollButtonComponent = TabScrollButton,
    scrollButtons = "auto",
    selectionFollowsFocus,
    slots = {},
    slotProps = {},
    TabIndicatorProps = {},
    TabScrollButtonProps = {},
    textColor = "primary",
    value,
    variant = "standard",
    visibleScrollbar = false,
    ...other
  } = props;
  const scrollable = variant === "scrollable";
  const vertical = orientation === "vertical";
  const scrollStart = vertical ? "scrollTop" : "scrollLeft";
  const start2 = vertical ? "top" : "left";
  const end2 = vertical ? "bottom" : "right";
  const clientSize = vertical ? "clientHeight" : "clientWidth";
  const size2 = vertical ? "height" : "width";
  const ownerState = {
    ...props,
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical,
    scrollableY: scrollable && vertical,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  };
  const classes = useUtilityClasses$m(ownerState);
  const startScrollButtonIconProps = useSlotProps$1({
    elementType: slots.StartScrollButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    ownerState
  });
  const endScrollButtonIconProps = useSlotProps$1({
    elementType: slots.EndScrollButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    ownerState
  });
  const [mounted, setMounted] = reactExports.useState(false);
  const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
  const [displayStartScroll, setDisplayStartScroll] = reactExports.useState(false);
  const [displayEndScroll, setDisplayEndScroll] = reactExports.useState(false);
  const [updateScrollObserver, setUpdateScrollObserver] = reactExports.useState(false);
  const [scrollerStyle, setScrollerStyle] = reactExports.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  });
  const valueToIndex = /* @__PURE__ */ new Map();
  const tabsRef = reactExports.useRef(null);
  const tabListRef = reactExports.useRef(null);
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children2 = tabListRef.current.children;
      if (children2.length > 0) {
        const tab = children2[valueToIndex.get(value)];
        tabMeta = tab ? tab.getBoundingClientRect() : null;
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback$1(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical) {
      startIndicator = "top";
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? "right" : "left";
      if (tabMeta && tabsMeta) {
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + tabsMeta.scrollLeft);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size2]: tabMeta ? tabMeta[size2] : 0
    };
    if (typeof indicatorStyle[startIndicator] !== "number" || typeof indicatorStyle[size2] !== "number") {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size2] - newIndicatorStyle[size2]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = (delta) => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
    }
    scroll(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children2 = Array.from(tabListRef.current.children);
    for (let i2 = 0; i2 < children2.length; i2 += 1) {
      const tab = children2[i2];
      if (totalSize + tab[clientSize] > containerSize) {
        if (i2 === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };
  const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, []);
  const getConditionalElements = () => {
    const conditionalElements2 = {};
    conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(TabsScrollbarSize, {
      onChange: handleScrollbarSizeChange,
      className: clsx(classes.scrollableX, classes.hideScrollbar)
    }) : null;
    const scrollButtonsActive = displayStartScroll || displayEndScroll;
    const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
    conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, {
      slots: {
        StartScrollButtonIcon: slots.StartScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: startScrollButtonIconProps
      },
      orientation,
      direction: isRtl ? "right" : "left",
      onClick: handleStartScrollClick,
      disabled: !displayStartScroll,
      ...TabScrollButtonProps,
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    }) : null;
    conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, {
      slots: {
        EndScrollButtonIcon: slots.EndScrollButtonIcon
      },
      slotProps: {
        endScrollButtonIcon: endScrollButtonIconProps
      },
      orientation,
      direction: isRtl ? "left" : "right",
      onClick: handleEndScrollClick,
      disabled: !displayEndScroll,
      ...TabScrollButtonProps,
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    }) : null;
    return conditionalElements2;
  };
  const scrollSelectedIntoView = useEventCallback$1((animation) => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start2] < tabsMeta[start2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
      scroll(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end2] > tabsMeta[end2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
      scroll(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback$1(() => {
    if (scrollable && scrollButtons !== false) {
      setUpdateScrollObserver(!updateScrollObserver);
    }
  });
  reactExports.useEffect(() => {
    const handleResize = debounce$2(() => {
      if (tabsRef.current) {
        updateIndicatorState();
      }
    });
    let resizeObserver;
    const handleMutation = (records) => {
      records.forEach((record) => {
        record.removedNodes.forEach((item) => {
          resizeObserver == null ? void 0 : resizeObserver.unobserve(item);
        });
        record.addedNodes.forEach((item) => {
          resizeObserver == null ? void 0 : resizeObserver.observe(item);
        });
      });
      handleResize();
      updateScrollButtonState();
    };
    const win = ownerWindow(tabsRef.current);
    win.addEventListener("resize", handleResize);
    let mutationObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach((child) => {
        resizeObserver.observe(child);
      });
    }
    if (typeof MutationObserver !== "undefined") {
      mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(tabListRef.current, {
        childList: true
      });
    }
    return () => {
      handleResize.clear();
      win.removeEventListener("resize", handleResize);
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
    };
  }, [updateIndicatorState, updateScrollButtonState]);
  reactExports.useEffect(() => {
    const tabListChildren = Array.from(tabListRef.current.children);
    const length2 = tabListChildren.length;
    if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
      const firstTab = tabListChildren[0];
      const lastTab = tabListChildren[length2 - 1];
      const observerOptions = {
        root: tabsRef.current,
        threshold: 0.99
      };
      const handleScrollButtonStart = (entries) => {
        setDisplayStartScroll(!entries[0].isIntersecting);
      };
      const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
      firstObserver.observe(firstTab);
      const handleScrollButtonEnd = (entries) => {
        setDisplayEndScroll(!entries[0].isIntersecting);
      };
      const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
      lastObserver.observe(lastTab);
      return () => {
        firstObserver.disconnect();
        lastObserver.disconnect();
      };
    }
    return void 0;
  }, [scrollable, scrollButtons, updateScrollObserver, childrenProp == null ? void 0 : childrenProp.length]);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  reactExports.useEffect(() => {
    updateIndicatorState();
  });
  reactExports.useEffect(() => {
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  reactExports.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(TabsIndicator, {
    ...TabIndicatorProps,
    className: clsx(classes.indicator, TabIndicatorProps.className),
    ownerState,
    style: {
      ...indicatorStyle,
      ...TabIndicatorProps.style
    }
  });
  let childIndex = 0;
  const children = reactExports.Children.map(childrenProp, (child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    const childValue = child.props.value === void 0 ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      fullWidth: variant === "fullWidth",
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue,
      ...childIndex === 1 && value === false && !child.props.tabIndex ? {
        tabIndex: 0
      } : {}
    });
  });
  const handleKeyDown = (event) => {
    const list = tabListRef.current;
    const currentFocus = ownerDocument$1(list).activeElement;
    const role = currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsRoot, {
    className: clsx(classes.root, className),
    ownerState,
    ref,
    as: component,
    ...other,
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsScroller, {
      className: classes.scroller,
      ownerState,
      style: {
        overflow: scrollerStyle.overflow,
        [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
      },
      ref: tabsRef,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FlexContainer, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === "vertical" ? "vertical" : null,
        className: classes.flexContainer,
        ownerState,
        onKeyDown: handleKeyDown,
        ref: tabListRef,
        role: "tablist",
        children
      }), mounted && indicator]
    }), conditionalElements.scrollButtonEnd]
  });
});
function getDateTimePickerTabsUtilityClass(slot) {
  return generateUtilityClass("MuiDateTimePickerTabs", slot);
}
generateUtilityClasses("MuiDateTimePickerTabs", ["root"]);
const viewToTab = (view) => {
  if (isDatePickerView(view)) {
    return "date";
  }
  return "time";
};
const tabToView = (tab) => {
  if (tab === "date") {
    return "day";
  }
  return "hours";
};
const useUtilityClasses$l = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDateTimePickerTabsUtilityClass, classes);
};
const DateTimePickerTabsRoot = styled(Tabs, {
  name: "MuiDateTimePickerTabs",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})(({
  theme
}) => ({
  boxShadow: `0 -1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
  "&:last-child": {
    boxShadow: `0 1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
    [`& .${tabsClasses.indicator}`]: {
      bottom: "auto",
      top: 0
    }
  }
}));
const DateTimePickerTabs = function DateTimePickerTabs2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePickerTabs"
  });
  const {
    dateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(DateRangeIcon, {}),
    onViewChange,
    timeIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(TimeIcon, {}),
    view,
    hidden = typeof window === "undefined" || window.innerHeight < 667,
    className,
    sx
  } = props;
  const translations = usePickersTranslations();
  const classes = useUtilityClasses$l(props);
  const handleChange = (event, value) => {
    onViewChange(tabToView(value));
  };
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerTabsRoot, {
    ownerState: props,
    variant: "fullWidth",
    value: viewToTab(view),
    onChange: handleChange,
    className: clsx(className, classes.root),
    sx,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Tab2, {
      value: "date",
      "aria-label": translations.dateTableLabel,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: dateIcon
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Tab2, {
      value: "time",
      "aria-label": translations.timeTableLabel,
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: timeIcon
      })
    })]
  });
};
function getPickersToolbarTextUtilityClass(slot) {
  return generateUtilityClass("MuiPickersToolbarText", slot);
}
const pickersToolbarTextClasses = generateUtilityClasses("MuiPickersToolbarText", ["root", "selected"]);
const _excluded$e = ["className", "selected", "value"];
const useUtilityClasses$k = (ownerState) => {
  const {
    classes,
    selected
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected"]
  };
  return composeClasses(slots, getPickersToolbarTextUtilityClass, classes);
};
const PickersToolbarTextRoot = styled(Typography, {
  name: "MuiPickersToolbarText",
  slot: "Root",
  overridesResolver: (_, styles2) => [styles2.root, {
    [`&.${pickersToolbarTextClasses.selected}`]: styles2.selected
  }]
})(({
  theme
}) => ({
  transition: theme.transitions.create("color"),
  color: (theme.vars || theme).palette.text.secondary,
  [`&.${pickersToolbarTextClasses.selected}`]: {
    color: (theme.vars || theme).palette.text.primary
  }
}));
const PickersToolbarText = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbarText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersToolbarText"
  });
  const {
    className,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const classes = useUtilityClasses$k(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarTextRoot, _extends$1({
    ref,
    className: clsx(className, classes.root),
    component: "span"
  }, other, {
    children: value
  }));
});
const _excluded$d = ["align", "className", "selected", "typographyClassName", "value", "variant", "width"];
const useUtilityClasses$j = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarButtonRoot = styled(Button, {
  name: "MuiPickersToolbarButton",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})({
  padding: 0,
  minWidth: 16,
  textTransform: "none"
});
const PickersToolbarButton = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbarButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersToolbarButton"
  });
  const {
    align,
    className,
    selected,
    typographyClassName,
    value,
    variant,
    width: width2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const classes = useUtilityClasses$j(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButtonRoot, _extends$1({
    variant: "text",
    ref,
    className: clsx(className, classes.root)
  }, width2 ? {
    sx: {
      width: width2
    }
  } : {}, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarText, {
      align,
      className: typographyClassName,
      variant,
      value,
      selected
    })
  }));
});
function getDateTimePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDateTimePickerToolbar", slot);
}
const dateTimePickerToolbarClasses = generateUtilityClasses("MuiDateTimePickerToolbar", ["root", "dateContainer", "timeContainer", "timeDigitsContainer", "separator", "timeLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);
const _excluded$c = ["ampm", "ampmInClock", "value", "onChange", "view", "isLandscape", "onViewChange", "toolbarFormat", "toolbarPlaceholder", "views", "disabled", "readOnly", "toolbarVariant", "toolbarTitle", "className"];
const useUtilityClasses$i = (ownerState) => {
  const {
    classes,
    isLandscape,
    isRtl
  } = ownerState;
  const slots = {
    root: ["root"],
    dateContainer: ["dateContainer"],
    timeContainer: ["timeContainer", isRtl && "timeLabelReverse"],
    timeDigitsContainer: ["timeDigitsContainer", isRtl && "timeLabelReverse"],
    separator: ["separator"],
    ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return composeClasses(slots, getDateTimePickerToolbarUtilityClass, classes);
};
const DateTimePickerToolbarRoot = styled(PickersToolbar, {
  name: "MuiDateTimePickerToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme
}) => ({
  paddingLeft: 16,
  paddingRight: 16,
  justifyContent: "space-around",
  position: "relative",
  variants: [{
    props: {
      toolbarVariant: "desktop"
    },
    style: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      [`& .${pickersToolbarClasses.content} .${pickersToolbarTextClasses.selected}`]: {
        color: (theme.vars || theme).palette.primary.main,
        fontWeight: theme.typography.fontWeightBold
      }
    }
  }, {
    props: {
      toolbarVariant: "desktop",
      isLandscape: true
    },
    style: {
      borderRight: `1px solid ${(theme.vars || theme).palette.divider}`
    }
  }, {
    props: {
      toolbarVariant: "desktop",
      isLandscape: false
    },
    style: {
      paddingLeft: 24,
      paddingRight: 0
    }
  }]
}));
const DateTimePickerToolbarDateContainer = styled("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "DateContainer",
  overridesResolver: (props, styles2) => styles2.dateContainer
})({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start"
});
const DateTimePickerToolbarTimeContainer = styled("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeContainer",
  overridesResolver: (props, styles2) => styles2.timeContainer
})({
  display: "flex",
  flexDirection: "row",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      toolbarVariant: "desktop",
      isLandscape: false
    },
    style: {
      gap: 9,
      marginRight: 4,
      alignSelf: "flex-end"
    }
  }, {
    props: ({
      isLandscape,
      toolbarVariant
    }) => isLandscape && toolbarVariant !== "desktop",
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      isLandscape,
      toolbarVariant,
      isRtl
    }) => isLandscape && toolbarVariant !== "desktop" && isRtl,
    style: {
      flexDirection: "column-reverse"
    }
  }]
});
const DateTimePickerToolbarTimeDigitsContainer = styled("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeDigitsContainer",
  overridesResolver: (props, styles2) => styles2.timeDigitsContainer
})({
  display: "flex",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      toolbarVariant: "desktop"
    },
    style: {
      gap: 1.5
    }
  }]
});
const DateTimePickerToolbarSeparator = styled(PickersToolbarText, {
  name: "MuiDateTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (props, styles2) => styles2.separator
})({
  margin: "0 4px 0 2px",
  cursor: "default",
  variants: [{
    props: {
      toolbarVariant: "desktop"
    },
    style: {
      margin: 0
    }
  }]
});
const DateTimePickerToolbarAmPmSelection = styled("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (props, styles2) => [{
    [`.${dateTimePickerToolbarClasses.ampmLabel}`]: styles2.ampmLabel
  }, {
    [`&.${dateTimePickerToolbarClasses.ampmLandscape}`]: styles2.ampmLandscape
  }, styles2.ampmSelection]
})({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12,
  [`& .${dateTimePickerToolbarClasses.ampmLabel}`]: {
    fontSize: 17
  },
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      margin: "4px 0 auto",
      flexDirection: "row",
      justifyContent: "space-around",
      width: "100%"
    }
  }]
});
function DateTimePickerToolbar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePickerToolbar"
  });
  const {
    ampm,
    ampmInClock,
    value,
    onChange,
    view,
    isLandscape,
    onViewChange,
    toolbarFormat,
    toolbarPlaceholder = "––",
    views,
    disabled,
    readOnly,
    toolbarVariant = "mobile",
    toolbarTitle: inToolbarTitle,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const isRtl = useRtl();
  const ownerState = _extends$1({}, props, {
    isRtl
  });
  const utils2 = useUtils();
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(value, ampm, onChange);
  const showAmPmControl = Boolean(ampm && !ampmInClock);
  const isDesktop = toolbarVariant === "desktop";
  const translations = usePickersTranslations();
  const classes = useUtilityClasses$i(ownerState);
  const toolbarTitle = inToolbarTitle ?? translations.dateTimePickerToolbarTitle;
  const formatHours = (time2) => ampm ? utils2.format(time2, "hours12h") : utils2.format(time2, "hours24h");
  const dateText = reactExports.useMemo(() => {
    if (!value) {
      return toolbarPlaceholder;
    }
    if (toolbarFormat) {
      return utils2.formatByString(value, toolbarFormat);
    }
    return utils2.format(value, "shortDate");
  }, [value, toolbarFormat, toolbarPlaceholder, utils2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarRoot, _extends$1({
    isLandscape,
    className: clsx(classes.root, className),
    toolbarTitle
  }, other, {
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarDateContainer, {
      className: classes.dateContainer,
      ownerState,
      children: [views.includes("year") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        tabIndex: -1,
        variant: "subtitle1",
        onClick: () => onViewChange("year"),
        selected: view === "year",
        value: value ? utils2.format(value, "year") : "–"
      }), views.includes("day") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        tabIndex: -1,
        variant: isDesktop ? "h5" : "h4",
        onClick: () => onViewChange("day"),
        selected: view === "day",
        value: dateText
      })]
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarTimeContainer, {
      className: classes.timeContainer,
      ownerState,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarTimeDigitsContainer, {
        className: classes.timeDigitsContainer,
        ownerState,
        children: [views.includes("hours") && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            variant: isDesktop ? "h5" : "h3",
            width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
            onClick: () => onViewChange("hours"),
            selected: view === "hours",
            value: value ? formatHours(value) : "--"
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(DateTimePickerToolbarSeparator, {
            variant: isDesktop ? "h5" : "h3",
            value: ":",
            className: classes.separator,
            ownerState
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            variant: isDesktop ? "h5" : "h3",
            width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
            onClick: () => onViewChange("minutes"),
            selected: view === "minutes" || !views.includes("minutes") && view === "hours",
            value: value ? utils2.format(value, "minutes") : "--",
            disabled: !views.includes("minutes")
          })]
        }), views.includes("seconds") && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(DateTimePickerToolbarSeparator, {
            variant: isDesktop ? "h5" : "h3",
            value: ":",
            className: classes.separator,
            ownerState
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
            variant: isDesktop ? "h5" : "h3",
            width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
            onClick: () => onViewChange("seconds"),
            selected: view === "seconds",
            value: value ? utils2.format(value, "seconds") : "--"
          })]
        })]
      }), showAmPmControl && !isDesktop && /* @__PURE__ */ jsxRuntimeExports.jsxs(DateTimePickerToolbarAmPmSelection, {
        className: classes.ampmSelection,
        ownerState,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          variant: "subtitle2",
          selected: meridiemMode === "am",
          typographyClassName: classes.ampmLabel,
          value: formatMeridiem(utils2, "am"),
          onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
          disabled
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
          variant: "subtitle2",
          selected: meridiemMode === "pm",
          typographyClassName: classes.ampmLabel,
          value: formatMeridiem(utils2, "pm"),
          onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
          disabled
        })]
      }), ampm && isDesktop && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        variant: "h5",
        onClick: () => onViewChange("meridiem"),
        selected: view === "meridiem",
        value: value && meridiemMode ? formatMeridiem(utils2, meridiemMode) : "--",
        width: MULTI_SECTION_CLOCK_SECTION_WIDTH
      })]
    })]
  }));
}
function useDateTimePickerDefaultizedProps(props, name) {
  var _a2;
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const ampm = themeProps.ampm ?? utils2.is12HourCycleInCurrentLocale();
  const localeText = reactExports.useMemo(() => {
    var _a3;
    if (((_a3 = themeProps.localeText) == null ? void 0 : _a3.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends$1({}, themeProps.localeText, {
      dateTimePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends$1({}, themeProps, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["year", "day", "hours", "minutes"],
    defaultOpenTo: "day"
  }), {
    ampm,
    localeText,
    orientation: themeProps.orientation ?? "portrait",
    // TODO: Remove from public API
    disableIgnoringDatePartForTimeValidation: themeProps.disableIgnoringDatePartForTimeValidation ?? Boolean(themeProps.minDateTime || themeProps.maxDateTime || // allow time clock to correctly check time validity: https://github.com/mui/mui-x/issues/8520
    themeProps.disablePast || themeProps.disableFuture),
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    minDate: applyDefaultDate(utils2, themeProps.minDateTime ?? themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDateTime ?? themeProps.maxDate, defaultDates.maxDate),
    minTime: themeProps.minDateTime ?? themeProps.minTime,
    maxTime: themeProps.maxDateTime ?? themeProps.maxTime,
    slots: _extends$1({
      toolbar: DateTimePickerToolbar,
      tabs: DateTimePickerTabs
    }, themeProps.slots),
    slotProps: _extends$1({}, themeProps.slotProps, {
      toolbar: _extends$1({
        ampm
      }, (_a2 = themeProps.slotProps) == null ? void 0 : _a2.toolbar)
    })
  });
}
const _excluded$b = ["views", "format"];
const resolveDateTimeFormat = (utils2, _ref, ignoreDateResolving) => {
  let {
    views,
    format: format2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$b);
  if (format2) {
    return format2;
  }
  const dateViews2 = [];
  const timeViews2 = [];
  views.forEach((view) => {
    if (isTimeView(view)) {
      timeViews2.push(view);
    } else if (isDatePickerView(view)) {
      dateViews2.push(view);
    }
  });
  if (timeViews2.length === 0) {
    return resolveDateFormat(utils2, _extends$1({
      views: dateViews2
    }, other), false);
  }
  if (dateViews2.length === 0) {
    return resolveTimeFormat(utils2, _extends$1({
      views: timeViews2
    }, other));
  }
  const timeFormat = resolveTimeFormat(utils2, _extends$1({
    views: timeViews2
  }, other));
  const dateFormat = resolveDateFormat(utils2, _extends$1({
    views: dateViews2
  }, other), false);
  return `${dateFormat} ${timeFormat}`;
};
const resolveViews = (ampm, views, shouldUseSingleColumn) => {
  if (shouldUseSingleColumn) {
    return views.filter((view) => !isInternalTimeView(view) || view === "hours");
  }
  return ampm ? [...views, "meridiem"] : views;
};
const resolveShouldRenderTimeInASingleColumn = (timeSteps, threshold) => 24 * 60 / ((timeSteps.hours ?? 1) * (timeSteps.minutes ?? 5)) <= threshold;
function resolveTimeViewsResponse({
  thresholdToRenderTimeInASingleColumn: inThreshold,
  ampm,
  timeSteps: inTimeSteps,
  views
}) {
  const thresholdToRenderTimeInASingleColumn = inThreshold ?? 24;
  const timeSteps = _extends$1({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, inTimeSteps);
  const shouldRenderTimeInASingleColumn = resolveShouldRenderTimeInASingleColumn(timeSteps, thresholdToRenderTimeInASingleColumn);
  return {
    thresholdToRenderTimeInASingleColumn,
    timeSteps,
    shouldRenderTimeInASingleColumn,
    views: resolveViews(ampm, views, shouldRenderTimeInASingleColumn)
  };
}
function getTimeClockUtilityClass(slot) {
  return generateUtilityClass("MuiTimeClock", slot);
}
generateUtilityClasses("MuiTimeClock", ["root", "arrowSwitcher"]);
const CLOCK_WIDTH = 220;
const CLOCK_HOUR_WIDTH = 36;
const clockCenter = {
  x: CLOCK_WIDTH / 2,
  y: CLOCK_WIDTH / 2
};
const baseClockPoint = {
  x: clockCenter.x,
  y: 0
};
const cx = baseClockPoint.x - clockCenter.x;
const cy = baseClockPoint.y - clockCenter.y;
const rad2deg = (rad) => rad * (180 / Math.PI);
const getAngleValue = (step, offsetX, offsetY) => {
  const x3 = offsetX - clockCenter.x;
  const y4 = offsetY - clockCenter.y;
  const atan = Math.atan2(cx, cy) - Math.atan2(x3, y4);
  let deg = rad2deg(atan);
  deg = Math.round(deg / step) * step;
  deg %= 360;
  const value = Math.floor(deg / step) || 0;
  const delta = x3 ** 2 + y4 ** 2;
  const distance = Math.sqrt(delta);
  return {
    value,
    distance
  };
};
const getMinutes = (offsetX, offsetY, step = 1) => {
  const angleStep = step * 6;
  let {
    value
  } = getAngleValue(angleStep, offsetX, offsetY);
  value = value * step % 60;
  return value;
};
const getHours = (offsetX, offsetY, ampm) => {
  const {
    value,
    distance
  } = getAngleValue(30, offsetX, offsetY);
  let hour = value || 12;
  if (!ampm) {
    if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
      hour += 12;
      hour %= 24;
    }
  } else {
    hour %= 12;
  }
  return hour;
};
function getClockPointerUtilityClass(slot) {
  return generateUtilityClass("MuiClockPointer", slot);
}
generateUtilityClasses("MuiClockPointer", ["root", "thumb"]);
const _excluded$a = ["className", "hasSelected", "isInner", "type", "viewValue"];
const useUtilityClasses$h = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    thumb: ["thumb"]
  };
  return composeClasses(slots, getClockPointerUtilityClass, classes);
};
const ClockPointerRoot = styled("div", {
  name: "MuiClockPointer",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})(({
  theme
}) => ({
  width: 2,
  backgroundColor: (theme.vars || theme).palette.primary.main,
  position: "absolute",
  left: "calc(50% - 1px)",
  bottom: "50%",
  transformOrigin: "center bottom 0px",
  variants: [{
    props: {
      shouldAnimate: true
    },
    style: {
      transition: theme.transitions.create(["transform", "height"])
    }
  }]
}));
const ClockPointerThumb = styled("div", {
  name: "MuiClockPointer",
  slot: "Thumb",
  overridesResolver: (_, styles2) => styles2.thumb
})(({
  theme
}) => ({
  width: 4,
  height: 4,
  backgroundColor: (theme.vars || theme).palette.primary.contrastText,
  borderRadius: "50%",
  position: "absolute",
  top: -21,
  left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
  border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${(theme.vars || theme).palette.primary.main}`,
  boxSizing: "content-box",
  variants: [{
    props: {
      hasSelected: true
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.primary.main
    }
  }]
}));
function ClockPointer(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClockPointer"
  });
  const {
    className,
    isInner,
    type,
    viewValue
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const previousType = reactExports.useRef(type);
  reactExports.useEffect(() => {
    previousType.current = type;
  }, [type]);
  const ownerState = _extends$1({}, props, {
    shouldAnimate: previousType.current !== type
  });
  const classes = useUtilityClasses$h(ownerState);
  const getAngleStyle = () => {
    const max2 = type === "hours" ? 12 : 60;
    let angle = 360 / max2 * viewValue;
    if (type === "hours" && viewValue > 12) {
      angle -= 360;
    }
    return {
      height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
      transform: `rotateZ(${angle}deg)`
    };
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointerRoot, _extends$1({
    style: getAngleStyle(),
    className: clsx(className, classes.root),
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointerThumb, {
      ownerState,
      className: classes.thumb
    })
  }));
}
function getClockUtilityClass(slot) {
  return generateUtilityClass("MuiClock", slot);
}
generateUtilityClasses("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton", "meridiemText", "selected"]);
const useUtilityClasses$g = (ownerState) => {
  const {
    classes,
    meridiemMode
  } = ownerState;
  const slots = {
    root: ["root"],
    clock: ["clock"],
    wrapper: ["wrapper"],
    squareMask: ["squareMask"],
    pin: ["pin"],
    amButton: ["amButton", meridiemMode === "am" && "selected"],
    pmButton: ["pmButton", meridiemMode === "pm" && "selected"],
    meridiemText: ["meridiemText"]
  };
  return composeClasses(slots, getClockUtilityClass, classes);
};
const ClockRoot = styled("div", {
  name: "MuiClock",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})(({
  theme
}) => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  margin: theme.spacing(2)
}));
const ClockClock = styled("div", {
  name: "MuiClock",
  slot: "Clock",
  overridesResolver: (_, styles2) => styles2.clock
})({
  backgroundColor: "rgba(0,0,0,.07)",
  borderRadius: "50%",
  height: 220,
  width: 220,
  flexShrink: 0,
  position: "relative",
  pointerEvents: "none"
});
const ClockWrapper = styled("div", {
  name: "MuiClock",
  slot: "Wrapper",
  overridesResolver: (_, styles2) => styles2.wrapper
})({
  "&:focus": {
    outline: "none"
  }
});
const ClockSquareMask = styled("div", {
  name: "MuiClock",
  slot: "SquareMask",
  overridesResolver: (_, styles2) => styles2.squareMask
})({
  width: "100%",
  height: "100%",
  position: "absolute",
  pointerEvents: "auto",
  outline: 0,
  // Disable scroll capabilities.
  touchAction: "none",
  userSelect: "none",
  variants: [{
    props: {
      disabled: false
    },
    style: {
      "@media (pointer: fine)": {
        cursor: "pointer",
        borderRadius: "50%"
      },
      "&:active": {
        cursor: "move"
      }
    }
  }]
});
const ClockPin = styled("div", {
  name: "MuiClock",
  slot: "Pin",
  overridesResolver: (_, styles2) => styles2.pin
})(({
  theme
}) => ({
  width: 6,
  height: 6,
  borderRadius: "50%",
  backgroundColor: (theme.vars || theme).palette.primary.main,
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)"
}));
const meridiemButtonCommonStyles = (theme, meridiemMode) => ({
  zIndex: 1,
  bottom: 8,
  paddingLeft: 4,
  paddingRight: 4,
  width: CLOCK_HOUR_WIDTH,
  variants: [{
    props: {
      meridiemMode
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.primary.main,
      color: (theme.vars || theme).palette.primary.contrastText,
      "&:hover": {
        backgroundColor: (theme.vars || theme).palette.primary.light
      }
    }
  }]
});
const ClockAmButton = styled(IconButton, {
  name: "MuiClock",
  slot: "AmButton",
  overridesResolver: (_, styles2) => styles2.amButton
})(({
  theme
}) => _extends$1({}, meridiemButtonCommonStyles(theme, "am"), {
  // keeping it here to make TS happy
  position: "absolute",
  left: 8
}));
const ClockPmButton = styled(IconButton, {
  name: "MuiClock",
  slot: "PmButton",
  overridesResolver: (_, styles2) => styles2.pmButton
})(({
  theme
}) => _extends$1({}, meridiemButtonCommonStyles(theme, "pm"), {
  // keeping it here to make TS happy
  position: "absolute",
  right: 8
}));
const ClockMeridiemText = styled(Typography, {
  name: "MuiClock",
  slot: "meridiemText",
  overridesResolver: (_, styles2) => styles2.meridiemText
})({
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
});
function Clock(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClock"
  });
  const {
    ampm,
    ampmInClock,
    autoFocus,
    children,
    value,
    handleMeridiemChange,
    isTimeDisabled,
    meridiemMode,
    minutesStep = 1,
    onChange,
    selectedId,
    type,
    viewValue,
    disabled = false,
    readOnly,
    className
  } = props;
  const ownerState = props;
  const utils2 = useUtils();
  const translations = usePickersTranslations();
  const isMoving = reactExports.useRef(false);
  const classes = useUtilityClasses$g(ownerState);
  const isSelectedTimeDisabled = isTimeDisabled(viewValue, type);
  const isPointerInner = !ampm && type === "hours" && (viewValue < 1 || viewValue > 12);
  const handleValueChange = (newValue, isFinish) => {
    if (disabled || readOnly) {
      return;
    }
    if (isTimeDisabled(newValue, type)) {
      return;
    }
    onChange(newValue, isFinish);
  };
  const setTime = (event, isFinish) => {
    let {
      offsetX,
      offsetY
    } = event;
    if (offsetX === void 0) {
      const rect = event.target.getBoundingClientRect();
      offsetX = event.changedTouches[0].clientX - rect.left;
      offsetY = event.changedTouches[0].clientY - rect.top;
    }
    const newSelectedValue = type === "seconds" || type === "minutes" ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
    handleValueChange(newSelectedValue, isFinish);
  };
  const handleTouchSelection = (event) => {
    isMoving.current = true;
    setTime(event, "shallow");
  };
  const handleTouchEnd = (event) => {
    if (isMoving.current) {
      setTime(event, "finish");
      isMoving.current = false;
    }
  };
  const handleMouseMove = (event) => {
    if (event.buttons > 0) {
      setTime(event.nativeEvent, "shallow");
    }
  };
  const handleMouseUp = (event) => {
    if (isMoving.current) {
      isMoving.current = false;
    }
    setTime(event.nativeEvent, "finish");
  };
  const hasSelected = reactExports.useMemo(() => {
    if (type === "hours") {
      return true;
    }
    return viewValue % 5 === 0;
  }, [type, viewValue]);
  const keyboardControlStep = type === "minutes" ? minutesStep : 1;
  const listboxRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      listboxRef.current.focus();
    }
  }, [autoFocus]);
  const handleKeyDown = (event) => {
    if (isMoving.current) {
      return;
    }
    switch (event.key) {
      case "Home":
        handleValueChange(0, "partial");
        event.preventDefault();
        break;
      case "End":
        handleValueChange(type === "minutes" ? 59 : 23, "partial");
        event.preventDefault();
        break;
      case "ArrowUp":
        handleValueChange(viewValue + keyboardControlStep, "partial");
        event.preventDefault();
        break;
      case "ArrowDown":
        handleValueChange(viewValue - keyboardControlStep, "partial");
        event.preventDefault();
        break;
      case "Enter":
      case " ":
        handleValueChange(viewValue, "finish");
        event.preventDefault();
        break;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ClockRoot, {
    className: clsx(className, classes.root),
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(ClockClock, {
      className: classes.clock,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockSquareMask, {
        onTouchMove: handleTouchSelection,
        onTouchStart: handleTouchSelection,
        onTouchEnd: handleTouchEnd,
        onMouseUp: handleMouseUp,
        onMouseMove: handleMouseMove,
        ownerState: {
          disabled
        },
        className: classes.squareMask
      }), !isSelectedTimeDisabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockPin, {
          className: classes.pin
        }), value != null && /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPointer, {
          type,
          viewValue,
          isInner: isPointerInner,
          hasSelected
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ClockWrapper, {
        "aria-activedescendant": selectedId,
        "aria-label": translations.clockLabelText(type, value, utils2),
        ref: listboxRef,
        role: "listbox",
        onKeyDown: handleKeyDown,
        tabIndex: 0,
        className: classes.wrapper,
        children
      })]
    }), ampm && ampmInClock && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ClockAmButton, {
        onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
        disabled: disabled || meridiemMode === null,
        ownerState,
        className: classes.amButton,
        title: formatMeridiem(utils2, "am"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockMeridiemText, {
          variant: "caption",
          className: classes.meridiemText,
          children: formatMeridiem(utils2, "am")
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ClockPmButton, {
        disabled: disabled || meridiemMode === null,
        onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
        ownerState,
        className: classes.pmButton,
        title: formatMeridiem(utils2, "pm"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockMeridiemText, {
          variant: "caption",
          className: classes.meridiemText,
          children: formatMeridiem(utils2, "pm")
        })
      })]
    })]
  });
}
function getClockNumberUtilityClass(slot) {
  return generateUtilityClass("MuiClockNumber", slot);
}
const clockNumberClasses = generateUtilityClasses("MuiClockNumber", ["root", "selected", "disabled"]);
const _excluded$9 = ["className", "disabled", "index", "inner", "label", "selected"];
const useUtilityClasses$f = (ownerState) => {
  const {
    classes,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", disabled && "disabled"]
  };
  return composeClasses(slots, getClockNumberUtilityClass, classes);
};
const ClockNumberRoot = styled("span", {
  name: "MuiClockNumber",
  slot: "Root",
  overridesResolver: (_, styles2) => [styles2.root, {
    [`&.${clockNumberClasses.disabled}`]: styles2.disabled
  }, {
    [`&.${clockNumberClasses.selected}`]: styles2.selected
  }]
})(({
  theme
}) => ({
  height: CLOCK_HOUR_WIDTH,
  width: CLOCK_HOUR_WIDTH,
  position: "absolute",
  left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "50%",
  color: (theme.vars || theme).palette.text.primary,
  fontFamily: theme.typography.fontFamily,
  "&:focused": {
    backgroundColor: (theme.vars || theme).palette.background.paper
  },
  [`&.${clockNumberClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText
  },
  [`&.${clockNumberClasses.disabled}`]: {
    pointerEvents: "none",
    color: (theme.vars || theme).palette.text.disabled
  },
  variants: [{
    props: {
      inner: true
    },
    style: _extends$1({}, theme.typography.body2, {
      color: (theme.vars || theme).palette.text.secondary
    })
  }]
}));
function ClockNumber(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClockNumber"
  });
  const {
    className,
    disabled,
    index,
    inner,
    label,
    selected
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
  const ownerState = props;
  const classes = useUtilityClasses$f(ownerState);
  const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
  const length2 = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
  const x3 = Math.round(Math.cos(angle) * length2);
  const y4 = Math.round(Math.sin(angle) * length2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumberRoot, _extends$1({
    className: clsx(className, classes.root),
    "aria-disabled": disabled ? true : void 0,
    "aria-selected": selected ? true : void 0,
    role: "option",
    style: {
      transform: `translate(${x3}px, ${y4 + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
    },
    ownerState
  }, other, {
    children: label
  }));
}
const getHourNumbers = ({
  ampm,
  value,
  getClockNumberText,
  isDisabled,
  selectedId,
  utils: utils2
}) => {
  const currentHours = value ? utils2.getHours(value) : null;
  const hourNumbers = [];
  const startHour = ampm ? 1 : 0;
  const endHour = ampm ? 12 : 23;
  const isSelected = (hour) => {
    if (currentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return currentHours === 12 || currentHours === 0;
      }
      return currentHours === hour || currentHours - 12 === hour;
    }
    return currentHours === hour;
  };
  for (let hour = startHour; hour <= endHour; hour += 1) {
    let label = hour.toString();
    if (hour === 0) {
      label = "00";
    }
    const inner = !ampm && (hour === 0 || hour > 12);
    label = utils2.formatNumber(label);
    const selected = isSelected(hour);
    hourNumbers.push(/* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumber, {
      id: selected ? selectedId : void 0,
      index: hour,
      inner,
      selected,
      disabled: isDisabled(hour),
      label,
      "aria-label": getClockNumberText(label)
    }, hour));
  }
  return hourNumbers;
};
const getMinutesNumbers = ({
  utils: utils2,
  value,
  isDisabled,
  getClockNumberText,
  selectedId
}) => {
  const f2 = utils2.formatNumber;
  return [[5, f2("05")], [10, f2("10")], [15, f2("15")], [20, f2("20")], [25, f2("25")], [30, f2("30")], [35, f2("35")], [40, f2("40")], [45, f2("45")], [50, f2("50")], [55, f2("55")], [0, f2("00")]].map(([numberValue, label], index) => {
    const selected = numberValue === value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockNumber, {
      label,
      id: selected ? selectedId : void 0,
      index: index + 1,
      inner: false,
      disabled: isDisabled(numberValue),
      selected,
      "aria-label": getClockNumberText(label)
    }, numberValue);
  });
};
const useClockReferenceDate = ({
  value,
  referenceDate: referenceDateProp,
  utils: utils2,
  props,
  timezone
}) => {
  const referenceDate = reactExports.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils: utils2,
      props,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.day,
      timezone,
      getTodayDate: () => getTodayDate(utils2, timezone, "date")
    }),
    // We only want to compute the reference date on mount.
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return value ?? referenceDate;
};
const _excluded$8 = ["ampm", "ampmInClock", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "showViewSwitcher", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "timezone"];
const useUtilityClasses$e = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    arrowSwitcher: ["arrowSwitcher"]
  };
  return composeClasses(slots, getTimeClockUtilityClass, classes);
};
const TimeClockRoot = styled(PickerViewRoot, {
  name: "MuiTimeClock",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexDirection: "column",
  position: "relative"
});
const TimeClockArrowSwitcher = styled(PickersArrowSwitcher, {
  name: "MuiTimeClock",
  slot: "ArrowSwitcher",
  overridesResolver: (props, styles2) => styles2.arrowSwitcher
})({
  position: "absolute",
  right: 12,
  top: 15
});
const TIME_CLOCK_DEFAULT_VIEWS = ["hours", "minutes"];
const TimeClock = /* @__PURE__ */ reactExports.forwardRef(function TimeClock2(inProps, ref) {
  const utils2 = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimeClock"
  });
  const {
    ampm = utils2.is12HourCycleInCurrentLocale(),
    ampmInClock = false,
    autoFocus,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableTime,
    showViewSwitcher,
    onChange,
    view: inView,
    views = TIME_CLOCK_DEFAULT_VIEWS,
    openTo,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "TimeClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils: utils2,
    props,
    timezone
  });
  const translations = usePickersTranslations();
  const now2 = useNow(timezone);
  const {
    view,
    setView,
    previousView,
    nextView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView,
    onFocusedViewChange
  });
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(valueOrReferenceDate, ampm, setValueAndGoToNextView);
  const isTimeDisabled = reactExports.useCallback((rawValue, viewType) => {
    const isAfter2 = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
    const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
    const containsValidTime = ({
      start: start2,
      end: end2
    }) => {
      if (minTime && isAfter2(minTime, end2)) {
        return false;
      }
      if (maxTime && isAfter2(start2, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter2(start2, now2)) {
        return false;
      }
      if (disablePast && isAfter2(now2, shouldCheckPastEnd ? end2 : start2)) {
        return false;
      }
      return true;
    };
    const isValidValue = (timeValue, step = 1) => {
      if (timeValue % step !== 0) {
        return false;
      }
      if (shouldDisableTime) {
        switch (viewType) {
          case "hours":
            return !shouldDisableTime(utils2.setHours(valueOrReferenceDate, timeValue), "hours");
          case "minutes":
            return !shouldDisableTime(utils2.setMinutes(valueOrReferenceDate, timeValue), "minutes");
          case "seconds":
            return !shouldDisableTime(utils2.setSeconds(valueOrReferenceDate, timeValue), "seconds");
          default:
            return false;
        }
      }
      return true;
    };
    switch (viewType) {
      case "hours": {
        const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        const dateWithNewHours = utils2.setHours(valueOrReferenceDate, valueWithMeridiem);
        const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
        const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
        return !containsValidTime({
          start: start2,
          end: end2
        }) || !isValidValue(valueWithMeridiem);
      }
      case "minutes": {
        const dateWithNewMinutes = utils2.setMinutes(valueOrReferenceDate, rawValue);
        const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
        const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
        return !containsValidTime({
          start: start2,
          end: end2
        }) || !isValidValue(rawValue, minutesStep);
      }
      case "seconds": {
        const dateWithNewSeconds = utils2.setSeconds(valueOrReferenceDate, rawValue);
        const start2 = dateWithNewSeconds;
        const end2 = dateWithNewSeconds;
        return !containsValidTime({
          start: start2,
          end: end2
        }) || !isValidValue(rawValue);
      }
      default:
        throw new Error("not supported");
    }
  }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils2, disableFuture, disablePast, now2, views]);
  const selectedId = useId();
  const viewProps = reactExports.useMemo(() => {
    switch (view) {
      case "hours": {
        const handleHoursChange = (hourValue, isFinish) => {
          const valueWithMeridiem = convertValueToMeridiem(hourValue, meridiemMode, ampm);
          setValueAndGoToNextView(utils2.setHours(valueOrReferenceDate, valueWithMeridiem), isFinish, "hours");
        };
        return {
          onChange: handleHoursChange,
          viewValue: utils2.getHours(valueOrReferenceDate),
          children: getHourNumbers({
            value,
            utils: utils2,
            ampm,
            onChange: handleHoursChange,
            getClockNumberText: translations.hoursClockNumberText,
            isDisabled: (hourValue) => disabled || isTimeDisabled(hourValue, "hours"),
            selectedId
          })
        };
      }
      case "minutes": {
        const minutesValue = utils2.getMinutes(valueOrReferenceDate);
        const handleMinutesChange = (minuteValue, isFinish) => {
          setValueAndGoToNextView(utils2.setMinutes(valueOrReferenceDate, minuteValue), isFinish, "minutes");
        };
        return {
          viewValue: minutesValue,
          onChange: handleMinutesChange,
          children: getMinutesNumbers({
            utils: utils2,
            value: minutesValue,
            onChange: handleMinutesChange,
            getClockNumberText: translations.minutesClockNumberText,
            isDisabled: (minuteValue) => disabled || isTimeDisabled(minuteValue, "minutes"),
            selectedId
          })
        };
      }
      case "seconds": {
        const secondsValue = utils2.getSeconds(valueOrReferenceDate);
        const handleSecondsChange = (secondValue, isFinish) => {
          setValueAndGoToNextView(utils2.setSeconds(valueOrReferenceDate, secondValue), isFinish, "seconds");
        };
        return {
          viewValue: secondsValue,
          onChange: handleSecondsChange,
          children: getMinutesNumbers({
            utils: utils2,
            value: secondsValue,
            onChange: handleSecondsChange,
            getClockNumberText: translations.secondsClockNumberText,
            isDisabled: (secondValue) => disabled || isTimeDisabled(secondValue, "seconds"),
            selectedId
          })
        };
      }
      default:
        throw new Error("You must provide the type for ClockView");
    }
  }, [view, utils2, value, ampm, translations.hoursClockNumberText, translations.minutesClockNumberText, translations.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, selectedId, disabled]);
  const ownerState = props;
  const classes = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimeClockRoot, _extends$1({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Clock, _extends$1({
      autoFocus: autoFocus ?? !!focusedView,
      ampmInClock: ampmInClock && views.includes("hours"),
      value,
      type: view,
      ampm,
      minutesStep,
      isTimeDisabled,
      meridiemMode,
      handleMeridiemChange,
      selectedId,
      disabled,
      readOnly
    }, viewProps)), showViewSwitcher && /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClockArrowSwitcher, {
      className: classes.arrowSwitcher,
      slots,
      slotProps,
      onGoToPrevious: () => setView(previousView),
      isPreviousDisabled: !previousView,
      previousLabel: translations.openPreviousView,
      onGoToNext: () => setView(nextView),
      isNextDisabled: !nextView,
      nextLabel: translations.openNextView,
      ownerState
    })]
  }));
});
function getDigitalClockUtilityClass(slot) {
  return generateUtilityClass("MuiDigitalClock", slot);
}
const digitalClockClasses = generateUtilityClasses("MuiDigitalClock", ["root", "list", "item"]);
const _excluded$7 = ["ampm", "timeStep", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "onChange", "view", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "views", "skipDisabled", "timezone"];
const useUtilityClasses$d = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    list: ["list"],
    item: ["item"]
  };
  return composeClasses(slots, getDigitalClockUtilityClass, classes);
};
const DigitalClockRoot = styled(PickerViewRoot, {
  name: "MuiDigitalClock",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  overflowY: "auto",
  width: "100%",
  "@media (prefers-reduced-motion: no-preference)": {
    scrollBehavior: "auto"
  },
  maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
  variants: [{
    props: {
      alreadyRendered: true
    },
    style: {
      "@media (prefers-reduced-motion: no-preference)": {
        scrollBehavior: "smooth"
      }
    }
  }]
});
const DigitalClockList = styled(MenuList, {
  name: "MuiDigitalClock",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  padding: 0
});
const DigitalClockItem = styled(MenuItem, {
  name: "MuiDigitalClock",
  slot: "Item",
  overridesResolver: (props, styles2) => styles2.item
})(({
  theme
}) => ({
  padding: "8px 16px",
  margin: "2px 4px",
  "&:first-of-type": {
    marginTop: 4
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
  },
  "&.Mui-selected": {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    "&:focus-visible, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  "&.Mui-focusVisible": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
  }
}));
const DigitalClock = /* @__PURE__ */ reactExports.forwardRef(function DigitalClock2(inProps, ref) {
  const utils2 = useUtils();
  const containerRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, containerRef);
  const props = useThemeProps({
    props: inProps,
    name: "MuiDigitalClock"
  });
  const {
    ampm = utils2.is12HourCycleInCurrentLocale(),
    timeStep = 30,
    autoFocus,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableTime,
    onChange,
    view: inView,
    openTo,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    views = ["hours"],
    skipDisabled = false,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
  const {
    value,
    handleValueChange: handleRawValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DigitalClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const translations = usePickersTranslations();
  const now2 = useNow(timezone);
  const ownerState = reactExports.useMemo(() => _extends$1({}, props, {
    alreadyRendered: !!containerRef.current
  }), [props]);
  const classes = useUtilityClasses$d(ownerState);
  const ClockItem = (slots == null ? void 0 : slots.digitalClockItem) ?? DigitalClockItem;
  const clockItemProps = useSlotProps({
    elementType: ClockItem,
    externalSlotProps: slotProps == null ? void 0 : slotProps.digitalClockItem,
    ownerState: {},
    className: classes.item
  });
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils: utils2,
    props,
    timezone
  });
  const handleValueChange = useEventCallback((newValue) => handleRawValueChange(newValue, "finish", "hours"));
  const {
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView,
    onFocusedViewChange
  });
  const handleItemSelect = useEventCallback((newValue) => {
    setValueAndGoToNextView(newValue, "finish");
  });
  reactExports.useEffect(() => {
    if (containerRef.current === null) {
      return;
    }
    const activeItem = containerRef.current.querySelector('[role="listbox"] [role="option"][tabindex="0"], [role="listbox"] [role="option"][aria-selected="true"]');
    if (!activeItem) {
      return;
    }
    const offsetTop = activeItem.offsetTop;
    if (autoFocus || !!focusedView) {
      activeItem.focus();
    }
    containerRef.current.scrollTop = offsetTop - 4;
  });
  const isTimeDisabled = reactExports.useCallback((valueToCheck) => {
    const isAfter2 = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
    const containsValidTime = () => {
      if (minTime && isAfter2(minTime, valueToCheck)) {
        return false;
      }
      if (maxTime && isAfter2(valueToCheck, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter2(valueToCheck, now2)) {
        return false;
      }
      if (disablePast && isAfter2(now2, valueToCheck)) {
        return false;
      }
      return true;
    };
    const isValidValue = () => {
      if (utils2.getMinutes(valueToCheck) % minutesStep !== 0) {
        return false;
      }
      if (shouldDisableTime) {
        return !shouldDisableTime(valueToCheck, "hours");
      }
      return true;
    };
    return !containsValidTime() || !isValidValue();
  }, [disableIgnoringDatePartForTimeValidation, utils2, minTime, maxTime, disableFuture, now2, disablePast, minutesStep, shouldDisableTime]);
  const timeOptions = reactExports.useMemo(() => {
    const startOfDay2 = utils2.startOfDay(valueOrReferenceDate);
    return [startOfDay2, ...Array.from({
      length: Math.ceil(24 * 60 / timeStep) - 1
    }, (_, index) => utils2.addMinutes(startOfDay2, timeStep * (index + 1)))];
  }, [valueOrReferenceDate, timeStep, utils2]);
  const focusedOptionIndex = timeOptions.findIndex((option) => utils2.isEqual(option, valueOrReferenceDate));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockRoot, _extends$1({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockList, {
      role: "listbox",
      "aria-label": translations.timePickerToolbarTitle,
      className: classes.list,
      children: timeOptions.map((option, index) => {
        if (skipDisabled && isTimeDisabled(option)) {
          return null;
        }
        const isSelected = utils2.isEqual(option, value);
        const formattedValue = utils2.format(option, ampm ? "fullTime12h" : "fullTime24h");
        const tabIndex = focusedOptionIndex === index || focusedOptionIndex === -1 && index === 0 ? 0 : -1;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ClockItem, _extends$1({
          onClick: () => !readOnly && handleItemSelect(option),
          selected: isSelected,
          disabled: disabled || isTimeDisabled(option),
          disableRipple: readOnly,
          role: "option",
          "aria-disabled": readOnly,
          "aria-selected": isSelected,
          tabIndex
        }, clockItemProps, {
          children: formattedValue
        }), formattedValue);
      })
    })
  }));
});
function getMultiSectionDigitalClockUtilityClass(slot) {
  return generateUtilityClass("MuiMultiSectionDigitalClock", slot);
}
const multiSectionDigitalClockClasses = generateUtilityClasses("MuiMultiSectionDigitalClock", ["root"]);
function getMultiSectionDigitalClockSectionUtilityClass(slot) {
  return generateUtilityClass("MuiMultiSectionDigitalClockSection", slot);
}
const multiSectionDigitalClockSectionClasses = generateUtilityClasses("MuiMultiSectionDigitalClockSection", ["root", "item"]);
const _excluded$6 = ["autoFocus", "onChange", "className", "disabled", "readOnly", "items", "active", "slots", "slotProps", "skipDisabled"];
const useUtilityClasses$c = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    item: ["item"]
  };
  return composeClasses(slots, getMultiSectionDigitalClockSectionUtilityClass, classes);
};
const MultiSectionDigitalClockSectionRoot = styled(MenuList, {
  name: "MuiMultiSectionDigitalClockSection",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})(({
  theme
}) => ({
  maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
  width: 56,
  padding: 0,
  overflow: "hidden",
  "@media (prefers-reduced-motion: no-preference)": {
    scrollBehavior: "auto"
  },
  "@media (pointer: fine)": {
    "&:hover": {
      overflowY: "auto"
    }
  },
  "@media (pointer: none), (pointer: coarse)": {
    overflowY: "auto"
  },
  "&:not(:first-of-type)": {
    borderLeft: `1px solid ${(theme.vars || theme).palette.divider}`
  },
  "&::after": {
    display: "block",
    content: '""',
    // subtracting the height of one item, extra margin and borders to make sure the max height is correct
    height: "calc(100% - 40px - 6px)"
  },
  variants: [{
    props: {
      alreadyRendered: true
    },
    style: {
      "@media (prefers-reduced-motion: no-preference)": {
        scrollBehavior: "smooth"
      }
    }
  }]
}));
const MultiSectionDigitalClockSectionItem = styled(MenuItem, {
  name: "MuiMultiSectionDigitalClockSection",
  slot: "Item",
  overridesResolver: (_, styles2) => styles2.item
})(({
  theme
}) => ({
  padding: 8,
  margin: "2px 4px",
  width: MULTI_SECTION_CLOCK_SECTION_WIDTH,
  justifyContent: "center",
  "&:first-of-type": {
    marginTop: 4
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
  },
  "&.Mui-selected": {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    "&:focus-visible, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  "&.Mui-focusVisible": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
  }
}));
const MultiSectionDigitalClockSection = /* @__PURE__ */ reactExports.forwardRef(function MultiSectionDigitalClockSection2(inProps, ref) {
  const containerRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, containerRef);
  const previousActive = reactExports.useRef(null);
  const props = useThemeProps({
    props: inProps,
    name: "MuiMultiSectionDigitalClockSection"
  });
  const {
    autoFocus,
    onChange,
    className,
    disabled,
    readOnly,
    items,
    active,
    slots,
    slotProps,
    skipDisabled
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
  const ownerState = reactExports.useMemo(() => _extends$1({}, props, {
    alreadyRendered: !!containerRef.current
  }), [props]);
  const classes = useUtilityClasses$c(ownerState);
  const DigitalClockSectionItem = (slots == null ? void 0 : slots.digitalClockSectionItem) ?? MultiSectionDigitalClockSectionItem;
  reactExports.useEffect(() => {
    if (containerRef.current === null) {
      return;
    }
    const activeItem = containerRef.current.querySelector('[role="option"][tabindex="0"], [role="option"][aria-selected="true"]');
    if (active && autoFocus && activeItem) {
      activeItem.focus();
    }
    if (!activeItem || previousActive.current === activeItem) {
      return;
    }
    previousActive.current = activeItem;
    const offsetTop = activeItem.offsetTop;
    containerRef.current.scrollTop = offsetTop - 4;
  });
  const focusedOptionIndex = items.findIndex((item) => item.isFocused(item.value));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSectionRoot, _extends$1({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState,
    autoFocusItem: autoFocus && active,
    role: "listbox"
  }, other, {
    children: items.map((option, index) => {
      var _a2;
      const isItemDisabled = (_a2 = option.isDisabled) == null ? void 0 : _a2.call(option, option.value);
      const isDisabled = disabled || isItemDisabled;
      if (skipDisabled && isDisabled) {
        return null;
      }
      const isSelected = option.isSelected(option.value);
      const tabIndex = focusedOptionIndex === index || focusedOptionIndex === -1 && index === 0 ? 0 : -1;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClockSectionItem, _extends$1({
        onClick: () => !readOnly && onChange(option.value),
        selected: isSelected,
        disabled: isDisabled,
        disableRipple: readOnly,
        role: "option",
        "aria-disabled": readOnly || isDisabled || void 0,
        "aria-label": option.ariaLabel,
        "aria-selected": isSelected,
        tabIndex,
        className: classes.item
      }, slotProps == null ? void 0 : slotProps.digitalClockSectionItem, {
        children: option.label
      }), option.label);
    })
  }));
});
const getHourSectionOptions = ({
  now: now2,
  value,
  utils: utils2,
  ampm,
  isDisabled,
  resolveAriaLabel,
  timeStep,
  valueOrReferenceDate
}) => {
  const currentHours = value ? utils2.getHours(value) : null;
  const result = [];
  const isSelected = (hour, overriddenCurrentHours) => {
    const resolvedCurrentHours = overriddenCurrentHours ?? currentHours;
    if (resolvedCurrentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return resolvedCurrentHours === 12 || resolvedCurrentHours === 0;
      }
      return resolvedCurrentHours === hour || resolvedCurrentHours - 12 === hour;
    }
    return resolvedCurrentHours === hour;
  };
  const isFocused = (hour) => {
    return isSelected(hour, utils2.getHours(valueOrReferenceDate));
  };
  const endHour = ampm ? 11 : 23;
  for (let hour = 0; hour <= endHour; hour += timeStep) {
    let label = utils2.format(utils2.setHours(now2, hour), ampm ? "hours12h" : "hours24h");
    const ariaLabel = resolveAriaLabel(parseInt(label, 10).toString());
    label = utils2.formatNumber(label);
    result.push({
      value: hour,
      label,
      isSelected,
      isDisabled,
      isFocused,
      ariaLabel
    });
  }
  return result;
};
const getTimeSectionOptions = ({
  value,
  utils: utils2,
  isDisabled,
  timeStep,
  resolveLabel,
  resolveAriaLabel,
  hasValue: hasValue2 = true
}) => {
  const isSelected = (timeValue) => {
    if (value === null) {
      return false;
    }
    return hasValue2 && value === timeValue;
  };
  const isFocused = (timeValue) => {
    return value === timeValue;
  };
  return [...Array.from({
    length: Math.ceil(60 / timeStep)
  }, (_, index) => {
    const timeValue = timeStep * index;
    return {
      value: timeValue,
      label: utils2.formatNumber(resolveLabel(timeValue)),
      isDisabled,
      isSelected,
      isFocused,
      ariaLabel: resolveAriaLabel(timeValue.toString())
    };
  })];
};
const _excluded$5 = ["ampm", "timeSteps", "autoFocus", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableTime", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "skipDisabled", "timezone"];
const useUtilityClasses$b = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMultiSectionDigitalClockUtilityClass, classes);
};
const MultiSectionDigitalClockRoot = styled(PickerViewRoot, {
  name: "MuiMultiSectionDigitalClock",
  slot: "Root",
  overridesResolver: (_, styles2) => styles2.root
})(({
  theme
}) => ({
  display: "flex",
  flexDirection: "row",
  width: "100%",
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
}));
const MultiSectionDigitalClock = /* @__PURE__ */ reactExports.forwardRef(function MultiSectionDigitalClock2(inProps, ref) {
  const utils2 = useUtils();
  const isRtl = useRtl();
  const props = useThemeProps({
    props: inProps,
    name: "MuiMultiSectionDigitalClock"
  });
  const {
    ampm = utils2.is12HourCycleInCurrentLocale(),
    timeSteps: inTimeSteps,
    autoFocus,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableTime,
    onChange,
    view: inView,
    views: inViews = ["hours", "minutes"],
    openTo,
    onViewChange,
    focusedView: inFocusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    skipDisabled = false,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
  const {
    value,
    handleValueChange: handleRawValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "MultiSectionDigitalClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const translations = usePickersTranslations();
  const now2 = useNow(timezone);
  const timeSteps = reactExports.useMemo(() => _extends$1({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, inTimeSteps), [inTimeSteps]);
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils: utils2,
    props,
    timezone
  });
  const handleValueChange = useEventCallback((newValue, selectionState, selectedView) => handleRawValueChange(newValue, selectionState, selectedView));
  const views = reactExports.useMemo(() => {
    if (!ampm || !inViews.includes("hours")) {
      return inViews;
    }
    return inViews.includes("meridiem") ? inViews : [...inViews, "meridiem"];
  }, [ampm, inViews]);
  const {
    view,
    setValueAndGoToNextView,
    focusedView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView: inFocusedView,
    onFocusedViewChange
  });
  const handleMeridiemValueChange = useEventCallback((newValue) => {
    setValueAndGoToNextView(newValue, "finish", "meridiem");
  });
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(valueOrReferenceDate, ampm, handleMeridiemValueChange, "finish");
  const isTimeDisabled = reactExports.useCallback((rawValue, viewType) => {
    const isAfter2 = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils2);
    const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
    const containsValidTime = ({
      start: start2,
      end: end2
    }) => {
      if (minTime && isAfter2(minTime, end2)) {
        return false;
      }
      if (maxTime && isAfter2(start2, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter2(start2, now2)) {
        return false;
      }
      if (disablePast && isAfter2(now2, shouldCheckPastEnd ? end2 : start2)) {
        return false;
      }
      return true;
    };
    const isValidValue = (timeValue, step = 1) => {
      if (timeValue % step !== 0) {
        return false;
      }
      if (shouldDisableTime) {
        switch (viewType) {
          case "hours":
            return !shouldDisableTime(utils2.setHours(valueOrReferenceDate, timeValue), "hours");
          case "minutes":
            return !shouldDisableTime(utils2.setMinutes(valueOrReferenceDate, timeValue), "minutes");
          case "seconds":
            return !shouldDisableTime(utils2.setSeconds(valueOrReferenceDate, timeValue), "seconds");
          default:
            return false;
        }
      }
      return true;
    };
    switch (viewType) {
      case "hours": {
        const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        const dateWithNewHours = utils2.setHours(valueOrReferenceDate, valueWithMeridiem);
        const start2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 0), 0);
        const end2 = utils2.setSeconds(utils2.setMinutes(dateWithNewHours, 59), 59);
        return !containsValidTime({
          start: start2,
          end: end2
        }) || !isValidValue(valueWithMeridiem);
      }
      case "minutes": {
        const dateWithNewMinutes = utils2.setMinutes(valueOrReferenceDate, rawValue);
        const start2 = utils2.setSeconds(dateWithNewMinutes, 0);
        const end2 = utils2.setSeconds(dateWithNewMinutes, 59);
        return !containsValidTime({
          start: start2,
          end: end2
        }) || !isValidValue(rawValue, minutesStep);
      }
      case "seconds": {
        const dateWithNewSeconds = utils2.setSeconds(valueOrReferenceDate, rawValue);
        const start2 = dateWithNewSeconds;
        const end2 = dateWithNewSeconds;
        return !containsValidTime({
          start: start2,
          end: end2
        }) || !isValidValue(rawValue);
      }
      default:
        throw new Error("not supported");
    }
  }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableTime, utils2, disableFuture, disablePast, now2, views]);
  const buildViewProps = reactExports.useCallback((viewToBuild) => {
    switch (viewToBuild) {
      case "hours": {
        return {
          onChange: (hours) => {
            const valueWithMeridiem = convertValueToMeridiem(hours, meridiemMode, ampm);
            setValueAndGoToNextView(utils2.setHours(valueOrReferenceDate, valueWithMeridiem), "finish", "hours");
          },
          items: getHourSectionOptions({
            now: now2,
            value,
            ampm,
            utils: utils2,
            isDisabled: (hours) => isTimeDisabled(hours, "hours"),
            timeStep: timeSteps.hours,
            resolveAriaLabel: translations.hoursClockNumberText,
            valueOrReferenceDate
          })
        };
      }
      case "minutes": {
        return {
          onChange: (minutes) => {
            setValueAndGoToNextView(utils2.setMinutes(valueOrReferenceDate, minutes), "finish", "minutes");
          },
          items: getTimeSectionOptions({
            value: utils2.getMinutes(valueOrReferenceDate),
            utils: utils2,
            isDisabled: (minutes) => isTimeDisabled(minutes, "minutes"),
            resolveLabel: (minutes) => utils2.format(utils2.setMinutes(now2, minutes), "minutes"),
            timeStep: timeSteps.minutes,
            hasValue: !!value,
            resolveAriaLabel: translations.minutesClockNumberText
          })
        };
      }
      case "seconds": {
        return {
          onChange: (seconds) => {
            setValueAndGoToNextView(utils2.setSeconds(valueOrReferenceDate, seconds), "finish", "seconds");
          },
          items: getTimeSectionOptions({
            value: utils2.getSeconds(valueOrReferenceDate),
            utils: utils2,
            isDisabled: (seconds) => isTimeDisabled(seconds, "seconds"),
            resolveLabel: (seconds) => utils2.format(utils2.setSeconds(now2, seconds), "seconds"),
            timeStep: timeSteps.seconds,
            hasValue: !!value,
            resolveAriaLabel: translations.secondsClockNumberText
          })
        };
      }
      case "meridiem": {
        const amLabel = formatMeridiem(utils2, "am");
        const pmLabel = formatMeridiem(utils2, "pm");
        return {
          onChange: handleMeridiemChange,
          items: [{
            value: "am",
            label: amLabel,
            isSelected: () => !!value && meridiemMode === "am",
            isFocused: () => !!valueOrReferenceDate && meridiemMode === "am",
            ariaLabel: amLabel
          }, {
            value: "pm",
            label: pmLabel,
            isSelected: () => !!value && meridiemMode === "pm",
            isFocused: () => !!valueOrReferenceDate && meridiemMode === "pm",
            ariaLabel: pmLabel
          }]
        };
      }
      default:
        throw new Error(`Unknown view: ${viewToBuild} found.`);
    }
  }, [now2, value, ampm, utils2, timeSteps.hours, timeSteps.minutes, timeSteps.seconds, translations.hoursClockNumberText, translations.minutesClockNumberText, translations.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, handleMeridiemChange]);
  const viewsToRender = reactExports.useMemo(() => {
    if (!isRtl) {
      return views;
    }
    const digitViews = views.filter((v2) => v2 !== "meridiem");
    digitViews.reverse();
    if (views.includes("meridiem")) {
      digitViews.push("meridiem");
    }
    return digitViews;
  }, [isRtl, views]);
  const viewTimeOptions = reactExports.useMemo(() => {
    return views.reduce((result, currentView) => {
      return _extends$1({}, result, {
        [currentView]: buildViewProps(currentView)
      });
    }, {});
  }, [views, buildViewProps]);
  const ownerState = props;
  const classes = useUtilityClasses$b(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockRoot, _extends$1({
    ref,
    className: clsx(classes.root, className),
    ownerState,
    role: "group"
  }, other, {
    children: viewsToRender.map((timeView) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClockSection, {
      items: viewTimeOptions[timeView].items,
      onChange: viewTimeOptions[timeView].onChange,
      active: view === timeView,
      autoFocus: autoFocus ?? focusedView === timeView,
      disabled,
      readOnly,
      slots,
      slotProps,
      skipDisabled,
      "aria-label": translations.selectViewText(timeView)
    }, timeView))
  }));
});
const renderTimeViewClock = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  ampmInClock,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  showViewSwitcher,
  disableIgnoringDatePartForTimeValidation,
  timezone
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(TimeClock, {
  view,
  onViewChange,
  focusedView: focusedView && isTimeView(focusedView) ? focusedView : null,
  onFocusedViewChange,
  views: views.filter(isTimeView),
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  ampmInClock,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  showViewSwitcher,
  disableIgnoringDatePartForTimeValidation,
  timezone
});
const renderDigitalClockTimeView = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalClock, {
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views: views.filter(isTimeView),
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeStep: timeSteps == null ? void 0 : timeSteps.minutes,
  skipDisabled,
  timezone
});
const renderMultiSectionDigitalClockTimeView = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(MultiSectionDigitalClock, {
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views: views.filter(isTimeView),
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  minutesStep,
  ampm,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
});
const DesktopDateTimePickerLayout = /* @__PURE__ */ reactExports.forwardRef(function DesktopDateTimePickerLayout2(props, ref) {
  var _a2;
  const isRtl = useRtl();
  const {
    toolbar,
    tabs,
    content,
    actionBar,
    shortcuts
  } = usePickerLayout(props);
  const {
    sx,
    className,
    isLandscape,
    classes
  } = props;
  const isActionBarVisible = actionBar && (((_a2 = actionBar.props.actions) == null ? void 0 : _a2.length) ?? 0) > 0;
  const ownerState = _extends$1({}, props, {
    isRtl
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
    ref,
    className: clsx(className, pickersLayoutClasses.root, classes == null ? void 0 : classes.root),
    sx: [{
      [`& .${pickersLayoutClasses.tabs}`]: {
        gridRow: 4,
        gridColumn: "1 / 4"
      },
      [`& .${pickersLayoutClasses.actionBar}`]: {
        gridRow: 5
      }
    }, ...Array.isArray(sx) ? sx : [sx]],
    ownerState,
    children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutContentWrapper, {
      className: clsx(pickersLayoutClasses.contentWrapper, classes == null ? void 0 : classes.contentWrapper),
      sx: {
        display: "grid"
      },
      children: [content, tabs, isActionBarVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {
        sx: {
          gridRow: 3,
          gridColumn: "1 / 4"
        }
      })]
    }), actionBar]
  });
});
const _excluded$4 = ["openTo", "focusedView", "timeViewsCount"];
const rendererInterceptor = function rendererInterceptor2(inViewRenderers, popperView, rendererProps) {
  var _a2, _b2;
  const {
    openTo,
    focusedView,
    timeViewsCount
  } = rendererProps, otherProps = _objectWithoutPropertiesLoose(rendererProps, _excluded$4);
  const finalProps = _extends$1({}, otherProps, {
    focusedView: null,
    sx: [{
      [`&.${multiSectionDigitalClockClasses.root}`]: {
        borderBottom: 0
      },
      [`&.${multiSectionDigitalClockClasses.root}, .${multiSectionDigitalClockSectionClasses.root}, &.${digitalClockClasses.root}`]: {
        maxHeight: VIEW_HEIGHT
      }
    }]
  });
  const isTimeViewActive = isInternalTimeView(popperView);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [(_a2 = inViewRenderers[!isTimeViewActive ? popperView : "day"]) == null ? void 0 : _a2.call(inViewRenderers, _extends$1({}, rendererProps, {
      view: !isTimeViewActive ? popperView : "day",
      focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
      views: rendererProps.views.filter(isDatePickerView),
      sx: [{
        gridColumn: 1
      }, ...finalProps.sx]
    })), timeViewsCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {
        orientation: "vertical",
        sx: {
          gridColumn: 2
        }
      }), (_b2 = inViewRenderers[isTimeViewActive ? popperView : "hours"]) == null ? void 0 : _b2.call(inViewRenderers, _extends$1({}, finalProps, {
        view: isTimeViewActive ? popperView : "hours",
        focusedView: focusedView && isInternalTimeView(focusedView) ? focusedView : null,
        openTo: isInternalTimeView(openTo) ? openTo : "hours",
        views: rendererProps.views.filter(isInternalTimeView),
        sx: [{
          gridColumn: 3
        }, ...finalProps.sx]
      }))]
    })]
  });
};
const DesktopDateTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopDateTimePicker2(inProps, ref) {
  var _a2, _b2, _c2, _d2;
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const defaultizedProps = useDateTimePickerDefaultizedProps(inProps, "MuiDesktopDateTimePicker");
  const {
    shouldRenderTimeInASingleColumn,
    thresholdToRenderTimeInASingleColumn,
    views: resolvedViews,
    timeSteps
  } = resolveTimeViewsResponse(defaultizedProps);
  const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
  const viewRenderers = _extends$1({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar,
    hours: renderTimeView,
    minutes: renderTimeView,
    seconds: renderTimeView,
    meridiem: renderTimeView
  }, defaultizedProps.viewRenderers);
  const ampmInClock = defaultizedProps.ampmInClock ?? true;
  const shouldHoursRendererContainMeridiemView = ((_a2 = viewRenderers.hours) == null ? void 0 : _a2.name) === renderMultiSectionDigitalClockTimeView.name;
  const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter((view) => view !== "meridiem") : resolvedViews;
  const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ["accept"];
  const props = _extends$1({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateTimeFormat(utils2, defaultizedProps),
    views,
    yearsPerRow: defaultizedProps.yearsPerRow ?? 4,
    ampmInClock,
    timeSteps,
    thresholdToRenderTimeInASingleColumn,
    shouldRenderTimeInASingleColumn,
    slots: _extends$1({
      field: DateTimeField,
      layout: DesktopDateTimePickerLayout,
      openPickerIcon: CalendarIcon
    }, defaultizedProps.slots),
    slotProps: _extends$1({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a3;
        return _extends$1({}, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$1({
        hidden: true,
        ampmInClock,
        toolbarVariant: "desktop"
      }, (_b2 = defaultizedProps.slotProps) == null ? void 0 : _b2.toolbar),
      tabs: _extends$1({
        hidden: true
      }, (_c2 = defaultizedProps.slotProps) == null ? void 0 : _c2.tabs),
      actionBar: (ownerState) => {
        var _a3;
        return _extends$1({
          actions: actionBarActions
        }, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.actionBar, ownerState));
      }
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date-time",
    getOpenDialogAriaText: ((_d2 = props.localeText) == null ? void 0 : _d2.openDatePickerDialogue) ?? translations.openDatePickerDialogue,
    validator: validateDateTime,
    rendererInterceptor
  });
  return renderPicker();
});
DesktopDateTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: PropTypes.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: PropTypes.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes.func,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: PropTypes.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: PropTypes.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: PropTypes.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: PropTypes.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: PropTypes.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: PropTypes.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: PropTypes.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: PropTypes.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.object,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: PropTypes.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: PropTypes.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: PropTypes.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: PropTypes.shape({
    hours: PropTypes.number,
    minutes: PropTypes.number,
    seconds: PropTypes.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes.shape({
    day: PropTypes.func,
    hours: PropTypes.func,
    meridiem: PropTypes.func,
    minutes: PropTypes.func,
    month: PropTypes.func,
    seconds: PropTypes.func,
    year: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: PropTypes.oneOf([3, 4])
};
const MobileDateTimePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileDateTimePicker2(inProps, ref) {
  var _a2, _b2, _c2;
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const defaultizedProps = useDateTimePickerDefaultizedProps(inProps, "MuiMobileDateTimePicker");
  const viewRenderers = _extends$1({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar,
    hours: renderTimeViewClock,
    minutes: renderTimeViewClock,
    seconds: renderTimeViewClock
  }, defaultizedProps.viewRenderers);
  const ampmInClock = defaultizedProps.ampmInClock ?? false;
  const props = _extends$1({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateTimeFormat(utils2, defaultizedProps),
    ampmInClock,
    slots: _extends$1({
      field: DateTimeField
    }, defaultizedProps.slots),
    slotProps: _extends$1({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a3;
        return _extends$1({}, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$1({
        hidden: false,
        ampmInClock
      }, (_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.toolbar),
      tabs: _extends$1({
        hidden: false
      }, (_b2 = defaultizedProps.slotProps) == null ? void 0 : _b2.tabs)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date-time",
    getOpenDialogAriaText: ((_c2 = props.localeText) == null ? void 0 : _c2.openDatePickerDialogue) ?? translations.openDatePickerDialogue,
    validator: validateDateTime
  });
  return renderPicker();
});
MobileDateTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: PropTypes.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: PropTypes.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes.func,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes.any,
  /**
   * The day view will show as many weeks as needed after the end of the current month to match this value.
   * Put it to 6 to have a fixed number of weeks in Gregorian calendars
   */
  fixedWeekNumber: PropTypes.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable date.
   * @default 2099-12-31
   */
  maxDate: PropTypes.object,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: PropTypes.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: PropTypes.object,
  /**
   * Minimal selectable date.
   * @default 1900-01-01
   */
  minDate: PropTypes.object,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: PropTypes.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: PropTypes.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: PropTypes.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.object,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: PropTypes.func,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (for example when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: PropTypes.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes.shape({
    day: PropTypes.func,
    hours: PropTypes.func,
    minutes: PropTypes.func,
    month: PropTypes.func,
    seconds: PropTypes.func,
    year: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: PropTypes.oneOf([3, 4])
};
const _excluded$3 = ["desktopModeMediaQuery"];
const DateTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DateTimePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopDateTimePicker, _extends$1({
      ref
    }, other));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDateTimePicker, _extends$1({
    ref
  }, other));
});
const useTimeField = (inProps) => {
  const props = useDefaultizedTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "time");
  return useField({
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateTime,
    valueType: "time"
  });
};
const _excluded$2 = ["slots", "slotProps", "InputProps", "inputProps"];
const TimeField = /* @__PURE__ */ reactExports.forwardRef(function TimeField2(inProps, inRef) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTimeField"
  });
  const {
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded$2);
  const ownerState = themeProps;
  const TextField$1 = (slots == null ? void 0 : slots.textField) ?? (inProps.enableAccessibleFieldDOMStructure ? PickersTextField : TextField);
  const textFieldProps = useSlotProps({
    elementType: TextField$1,
    externalSlotProps: slotProps == null ? void 0 : slotProps.textField,
    externalForwardedProps: other,
    ownerState,
    additionalProps: {
      ref: inRef
    }
  });
  textFieldProps.inputProps = _extends$1({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$1({}, InputProps, textFieldProps.InputProps);
  const fieldResponse = useTimeField(textFieldProps);
  const convertedFieldResponse = convertFieldResponseIntoMuiTextFieldProps(fieldResponse);
  const processedFieldProps = useClearableField(_extends$1({}, convertedFieldResponse, {
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField$1, _extends$1({}, processedFieldProps));
});
function getTimePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiTimePickerToolbar", slot);
}
const timePickerToolbarClasses = generateUtilityClasses("MuiTimePickerToolbar", ["root", "separator", "hourMinuteLabel", "hourMinuteLabelLandscape", "hourMinuteLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);
const _excluded$1 = ["ampm", "ampmInClock", "value", "isLandscape", "onChange", "view", "onViewChange", "views", "disabled", "readOnly", "className"];
const useUtilityClasses$a = (ownerState) => {
  const {
    isLandscape,
    classes,
    isRtl
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"],
    hourMinuteLabel: ["hourMinuteLabel", isLandscape && "hourMinuteLabelLandscape", isRtl && "hourMinuteLabelReverse"],
    ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return composeClasses(slots, getTimePickerToolbarUtilityClass, classes);
};
const TimePickerToolbarRoot = styled(PickersToolbar, {
  name: "MuiTimePickerToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const TimePickerToolbarSeparator = styled(PickersToolbarText, {
  name: "MuiTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (props, styles2) => styles2.separator
})({
  outline: 0,
  margin: "0 4px 0 2px",
  cursor: "default"
});
const TimePickerToolbarHourMinuteLabel = styled("div", {
  name: "MuiTimePickerToolbar",
  slot: "HourMinuteLabel",
  overridesResolver: (props, styles2) => [{
    [`&.${timePickerToolbarClasses.hourMinuteLabelLandscape}`]: styles2.hourMinuteLabelLandscape,
    [`&.${timePickerToolbarClasses.hourMinuteLabelReverse}`]: styles2.hourMinuteLabelReverse
  }, styles2.hourMinuteLabel]
})({
  display: "flex",
  justifyContent: "flex-end",
  alignItems: "flex-end",
  variants: [{
    props: {
      isRtl: true
    },
    style: {
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      isLandscape: true
    },
    style: {
      marginTop: "auto"
    }
  }]
});
const TimePickerToolbarAmPmSelection = styled("div", {
  name: "MuiTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (props, styles2) => [{
    [`.${timePickerToolbarClasses.ampmLabel}`]: styles2.ampmLabel
  }, {
    [`&.${timePickerToolbarClasses.ampmLandscape}`]: styles2.ampmLandscape
  }, styles2.ampmSelection]
})({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12,
  [`& .${timePickerToolbarClasses.ampmLabel}`]: {
    fontSize: 17
  },
  variants: [{
    props: {
      isLandscape: true
    },
    style: {
      margin: "4px 0 auto",
      flexDirection: "row",
      justifyContent: "space-around",
      flexBasis: "100%"
    }
  }]
});
function TimePickerToolbar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimePickerToolbar"
  });
  const {
    ampm,
    ampmInClock,
    value,
    isLandscape,
    onChange,
    view,
    onViewChange,
    views,
    disabled,
    readOnly,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const utils2 = useUtils();
  const translations = usePickersTranslations();
  const isRtl = useRtl();
  const showAmPmControl = Boolean(ampm && !ampmInClock && views.includes("hours"));
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(value, ampm, onChange);
  const formatHours = (time2) => ampm ? utils2.format(time2, "hours12h") : utils2.format(time2, "hours24h");
  const ownerState = _extends$1({}, props, {
    isRtl
  });
  const classes = useUtilityClasses$a(ownerState);
  const separator = /* @__PURE__ */ jsxRuntimeExports.jsx(TimePickerToolbarSeparator, {
    tabIndex: -1,
    value: ":",
    variant: "h3",
    selected: false,
    className: classes.separator
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarRoot, _extends$1({
    landscapeDirection: "row",
    toolbarTitle: translations.timePickerToolbarTitle,
    isLandscape,
    ownerState,
    className: clsx(classes.root, className)
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarHourMinuteLabel, {
      className: classes.hourMinuteLabel,
      ownerState,
      children: [arrayIncludes(views, "hours") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        tabIndex: -1,
        variant: "h3",
        onClick: () => onViewChange("hours"),
        selected: view === "hours",
        value: value ? formatHours(value) : "--"
      }), arrayIncludes(views, ["hours", "minutes"]) && separator, arrayIncludes(views, "minutes") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        tabIndex: -1,
        variant: "h3",
        onClick: () => onViewChange("minutes"),
        selected: view === "minutes",
        value: value ? utils2.format(value, "minutes") : "--"
      }), arrayIncludes(views, ["minutes", "seconds"]) && separator, arrayIncludes(views, "seconds") && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        variant: "h3",
        onClick: () => onViewChange("seconds"),
        selected: view === "seconds",
        value: value ? utils2.format(value, "seconds") : "--"
      })]
    }), showAmPmControl && /* @__PURE__ */ jsxRuntimeExports.jsxs(TimePickerToolbarAmPmSelection, {
      className: classes.ampmSelection,
      ownerState,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        disableRipple: true,
        variant: "subtitle2",
        selected: meridiemMode === "am",
        typographyClassName: classes.ampmLabel,
        value: formatMeridiem(utils2, "am"),
        onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
        disabled
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarButton, {
        disableRipple: true,
        variant: "subtitle2",
        selected: meridiemMode === "pm",
        typographyClassName: classes.ampmLabel,
        value: formatMeridiem(utils2, "pm"),
        onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
        disabled
      })]
    })]
  }));
}
function useTimePickerDefaultizedProps(props, name) {
  var _a2;
  const utils2 = useUtils();
  const themeProps = useThemeProps({
    props,
    name
  });
  const ampm = themeProps.ampm ?? utils2.is12HourCycleInCurrentLocale();
  const localeText = reactExports.useMemo(() => {
    var _a3;
    if (((_a3 = themeProps.localeText) == null ? void 0 : _a3.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends$1({}, themeProps.localeText, {
      timePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  return _extends$1({}, themeProps, {
    ampm,
    localeText
  }, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["hours", "minutes"],
    defaultOpenTo: "hours"
  }), {
    disableFuture: themeProps.disableFuture ?? false,
    disablePast: themeProps.disablePast ?? false,
    slots: _extends$1({
      toolbar: TimePickerToolbar
    }, themeProps.slots),
    slotProps: _extends$1({}, themeProps.slotProps, {
      toolbar: _extends$1({
        ampm,
        ampmInClock: themeProps.ampmInClock
      }, (_a2 = themeProps.slotProps) == null ? void 0 : _a2.toolbar)
    })
  });
}
const DesktopTimePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopTimePicker2(inProps, ref) {
  var _a2, _b2, _c2, _d2;
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiDesktopTimePicker");
  const {
    shouldRenderTimeInASingleColumn,
    views: resolvedViews,
    timeSteps
  } = resolveTimeViewsResponse(defaultizedProps);
  const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
  const viewRenderers = _extends$1({
    hours: renderTimeView,
    minutes: renderTimeView,
    seconds: renderTimeView,
    meridiem: renderTimeView
  }, defaultizedProps.viewRenderers);
  const ampmInClock = defaultizedProps.ampmInClock ?? true;
  const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ["accept"];
  const shouldHoursRendererContainMeridiemView = ((_a2 = viewRenderers.hours) == null ? void 0 : _a2.name) === renderMultiSectionDigitalClockTimeView.name;
  const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter((view) => view !== "meridiem") : resolvedViews;
  const props = _extends$1({}, defaultizedProps, {
    ampmInClock,
    timeSteps,
    viewRenderers,
    format: resolveTimeFormat(utils2, defaultizedProps),
    // Setting only `hours` time view in case of single column time picker
    // Allows for easy view lifecycle management
    views: shouldRenderTimeInASingleColumn ? ["hours"] : views,
    slots: _extends$1({
      field: TimeField,
      openPickerIcon: ClockIcon
    }, defaultizedProps.slots),
    slotProps: _extends$1({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a3;
        return _extends$1({}, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$1({
        hidden: true,
        ampmInClock
      }, (_b2 = defaultizedProps.slotProps) == null ? void 0 : _b2.toolbar),
      actionBar: _extends$1({
        actions: actionBarActions
      }, (_c2 = defaultizedProps.slotProps) == null ? void 0 : _c2.actionBar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "time",
    getOpenDialogAriaText: ((_d2 = props.localeText) == null ? void 0 : _d2.openTimePickerDialogue) ?? translations.openTimePickerDialogue,
    validator: validateTime
  });
  return renderPicker();
});
DesktopTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: PropTypes.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: PropTypes.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes.any,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: PropTypes.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: PropTypes.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: PropTypes.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: PropTypes.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: PropTypes.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: PropTypes.shape({
    hours: PropTypes.number,
    minutes: PropTypes.number,
    seconds: PropTypes.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes.shape({
    hours: PropTypes.func,
    meridiem: PropTypes.func,
    minutes: PropTypes.func,
    seconds: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["hours", "minutes", "seconds"]).isRequired)
};
const MobileTimePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileTimePicker2(inProps, ref) {
  var _a2, _b2;
  const translations = usePickersTranslations();
  const utils2 = useUtils();
  const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiMobileTimePicker");
  const viewRenderers = _extends$1({
    hours: renderTimeViewClock,
    minutes: renderTimeViewClock,
    seconds: renderTimeViewClock
  }, defaultizedProps.viewRenderers);
  const ampmInClock = defaultizedProps.ampmInClock ?? false;
  const props = _extends$1({}, defaultizedProps, {
    ampmInClock,
    viewRenderers,
    format: resolveTimeFormat(utils2, defaultizedProps),
    slots: _extends$1({
      field: TimeField
    }, defaultizedProps.slots),
    slotProps: _extends$1({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _a3;
        return _extends$1({}, resolveComponentProps((_a3 = defaultizedProps.slotProps) == null ? void 0 : _a3.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$1({
        hidden: false,
        ampmInClock
      }, (_a2 = defaultizedProps.slotProps) == null ? void 0 : _a2.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "time",
    getOpenDialogAriaText: ((_b2 = props.localeText) == null ? void 0 : _b2.openTimePickerDialogue) ?? translations.openTimePickerDialogue,
    validator: validateTime
  });
  return renderPicker();
});
MobileTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default utils.is12HourCycleInCurrentLocale()
   */
  ampm: PropTypes.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: PropTypes.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.object,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * @default false
   */
  enableAccessibleFieldDOMStructure: PropTypes.any,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: PropTypes.object,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: PropTypes.object,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: PropTypes.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated with the current value changes.
   * When a validation error is detected, the `error` parameter contains a non-null value.
   * This can be used to render an appropriate form error.
   * @template TError The validation error type. It will be either `string` or a `null`. It can be in `[start, end]` format in case of range value.
   * @template TValue The value type. It will be the same type as `value` or `null`. It can be in `[start, end]` format in case of range value.
   * @param {TError} error The reason why the current value is not valid.
   * @param {TValue} value The value associated with the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.object,
  /**
   * The currently selected sections.
   * This prop accepts four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 3. If `"all"` is provided, all the sections will be selected.
   * 4. If `null` is provided, no section will be selected.
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "empty", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number]),
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: PropTypes.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documentation} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.object,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be used.
   */
  viewRenderers: PropTypes.shape({
    hours: PropTypes.func,
    minutes: PropTypes.func,
    seconds: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["hours", "minutes", "seconds"]).isRequired)
};
const _excluded = ["desktopModeMediaQuery"];
const TimePicker = /* @__PURE__ */ reactExports.forwardRef(function TimePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopTimePicker, _extends$1({
      ref
    }, other));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileTimePicker, _extends$1({
    ref
  }, other));
});
function areArraysEqual(array1, array2, itemComparer = (a3, b3) => a3 === b3) {
  return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function asc(a3, b3) {
  return a3 - b3;
}
function findClosest(values2, currentValue) {
  const {
    index: closestIndex
  } = values2.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null) ?? {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i2 = 0; i2 < touchEvent.changedTouches.length; i2 += 1) {
      const touch = touchEvent.changedTouches[i2];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min2, max2) {
  return (value - min2) * 100 / (max2 - min2);
}
function percentToValue(percent, min2, max2) {
  return (max2 - min2) * percent + min2;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values: values2,
  newValue,
  index
}) {
  const output = values2.slice();
  output[index] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _a2, _b2, _c2;
  const doc = ownerDocument$1(sliderRef.current);
  if (!((_a2 = sliderRef.current) == null ? void 0 : _a2.contains(doc.activeElement)) || Number((_b2 = doc == null ? void 0 : doc.activeElement) == null ? void 0 : _b2.getAttribute("data-index")) !== activeIndex) {
    (_c2 = sliderRef.current) == null ? void 0 : _c2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: `${percent}%`
    }),
    leap: (percent) => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = (x3) => x3;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    rootRef: ref,
    scale = Identity$1,
    step = 1,
    shiftStep = 10,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = reactExports.useRef(void 0);
  const [active, setActive] = reactExports.useState(-1);
  const [open, setOpen] = reactExports.useState(-1);
  const [dragging, setDragging] = reactExports.useState(false);
  const moveCount = reactExports.useRef(0);
  const [valueDerived, setValueState] = useControlled$1({
    controlled: valueProp,
    default: defaultValue ?? min2,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values2 = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values2 = values2.map((value) => value == null ? min2 : clamp(value, min2, max2));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max2 - min2) / step) + 1)].map((_, index) => ({
    value: min2 + step * index
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
  const sliderRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(ref, sliderRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _a2;
    const index = Number(event.currentTarget.getAttribute("data-index"));
    if (isFocusVisible(event.target)) {
      setFocusedThumbIndex(index);
    }
    setOpen(index);
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onFocus) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _a2;
    if (!isFocusVisible(event.target)) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onBlur) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  const changeValue = (event, valueInput) => {
    const index = Number(event.currentTarget.getAttribute("data-index"));
    const value = values2[index];
    const marksIndex = marksValues.indexOf(value);
    let newValue = valueInput;
    if (marks && step == null) {
      const maxMarksValue = marksValues[marksValues.length - 1];
      if (newValue > maxMarksValue) {
        newValue = maxMarksValue;
      } else if (newValue < marksValues[0]) {
        newValue = marksValues[0];
      } else {
        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
    }
    newValue = clamp(newValue, min2, max2);
    if (range) {
      if (disableSwap) {
        newValue = clamp(newValue, values2[index - 1] || -Infinity, values2[index + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index
      });
      let activeIndex = index;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };
  const createHandleHiddenInputKeyDown = (otherHandlers) => (event) => {
    var _a2;
    if (step !== null) {
      const index = Number(event.currentTarget.getAttribute("data-index"));
      const value = values2[index];
      let newValue = null;
      if ((event.key === "ArrowLeft" || event.key === "ArrowDown") && event.shiftKey || event.key === "PageDown") {
        newValue = Math.max(value - shiftStep, min2);
      } else if ((event.key === "ArrowRight" || event.key === "ArrowUp") && event.shiftKey || event.key === "PageUp") {
        newValue = Math.min(value + shiftStep, max2);
      }
      if (newValue !== null) {
        changeValue(event, newValue);
        event.preventDefault();
      }
    }
    (_a2 = otherHandlers == null ? void 0 : otherHandlers.onKeyDown) == null ? void 0 : _a2.call(otherHandlers, event);
  };
  useEnhancedEffect$1(() => {
    var _a2;
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      (_a2 = document.activeElement) == null ? void 0 : _a2.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onChange) == null ? void 0 : _a2.call(otherHandlers, event);
    changeValue(event, event.target.valueAsNumber);
  };
  const previousIndex = reactExports.useRef(void 0);
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width: width2,
      height: height2,
      bottom: bottom2,
      left: left2
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.indexOf("vertical") === 0) {
      percent = (bottom2 - finger.y) / height2;
    } else {
      percent = (finger.x - left2) / width2;
    }
    if (axis.indexOf("-reverse") !== -1) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min2, max2);
    if (step) {
      newValue = roundValueToStep(newValue, step, min2);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min2, max2);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback$1((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback$1((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback$1((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument$1(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("touchend", handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument$1(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  reactExports.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart);
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  reactExports.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseDown) == null ? void 0 : _a2.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument$1(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove, {
      passive: true
    });
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values2[0] : min2, min2, max2);
  const trackLeap = valueToPercent(values2[values2.length - 1], min2, max2) - trackOffset;
  const getRootProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers$1(externalProps);
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(externalHandlers || {})
    };
    const mergedEventHandlers = {
      ...externalHandlers,
      ...ownEventHandlers
    };
    return {
      ...externalProps,
      ref: handleRef,
      ...mergedEventHandlers
    };
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseOver) == null ? void 0 : _a2.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _a2;
    (_a2 = otherHandlers.onMouseLeave) == null ? void 0 : _a2.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers$1(externalProps);
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(externalHandlers || {}),
      onMouseLeave: createHandleMouseLeave(externalHandlers || {})
    };
    return {
      ...externalProps,
      ...externalHandlers,
      ...ownEventHandlers
    };
  };
  const getThumbStyle = (index) => {
    return {
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: active !== -1 && active !== index ? "none" : void 0
    };
  };
  const getHiddenInputProps = (externalProps = {}) => {
    const externalHandlers = extractEventHandlers$1(externalProps);
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(externalHandlers || {}),
      onFocus: createHandleHiddenInputFocus(externalHandlers || {}),
      onBlur: createHandleHiddenInputBlur(externalHandlers || {}),
      onKeyDown: createHandleHiddenInputKeyDown(externalHandlers || {})
    };
    const mergedEventHandlers = {
      ...externalHandlers,
      ...ownEventHandlers
    };
    return {
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max2),
      "aria-valuemin": scale(min2),
      name,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: parameters.step === null && parameters.marks ? "any" : parameters.step ?? void 0,
      disabled,
      ...externalProps,
      ...mergedEventHandlers,
      style: {
        ...visuallyHidden$1,
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%"
      }
    };
  };
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range,
    rootRef: handleRef,
    trackLeap,
    trackOffset,
    values: values2,
    getThumbStyle
  };
}
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent$1(Slot);
};
function getSliderUtilityClass(slot) {
  return generateUtilityClass$1("MuiSlider", slot);
}
const sliderClasses = generateUtilityClasses$1("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]);
const useValueLabelClasses = (props) => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: clsx(open && sliderClasses.valueLabelOpen),
    circle: sliderClasses.valueLabelCircle,
    label: sliderClasses.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel$1(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    className: clsx(children.props.className)
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
function Identity(x3) {
  return x3;
}
const SliderRoot = styled("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize$1(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize$1(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(memoTheme(({
  theme
}) => ({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  WebkitTapHighlightColor: "transparent",
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme.vars || theme).palette.grey[400]
  },
  [`&.${sliderClasses.dragging}`]: {
    [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
      transition: "none"
    }
  },
  variants: [...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme.vars || theme).palette[color2].main
    }
  })), {
    props: {
      orientation: "horizontal"
    },
    style: {
      height: 4,
      width: "100%",
      padding: "13px 0",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "20px 0"
      }
    }
  }, {
    props: {
      orientation: "horizontal",
      size: "small"
    },
    style: {
      height: 2
    }
  }, {
    props: {
      orientation: "horizontal",
      marked: true
    },
    style: {
      marginBottom: 20
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: 4,
      padding: "0 13px",
      // The primary input mechanism of the device includes a pointing device of limited accuracy.
      "@media (pointer: coarse)": {
        // Reach 42px touch target, about ~8mm on screen.
        padding: "0 20px"
      }
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      width: 2
    }
  }, {
    props: {
      orientation: "vertical",
      marked: true
    },
    style: {
      marginRight: 44
    }
  }]
})));
const SliderRail = styled("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (props, styles2) => styles2.rail
})({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38,
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      width: "100%",
      height: "inherit",
      top: "50%",
      transform: "translateY(-50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      width: "inherit",
      left: "50%",
      transform: "translateX(-50%)"
    }
  }, {
    props: {
      track: "inverted"
    },
    style: {
      opacity: 1
    }
  }]
});
const SliderTrack = styled("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(memoTheme(({
  theme
}) => {
  return {
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: false
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
      props: {
        color: color2,
        track: "inverted"
      },
      style: {
        ...theme.vars ? {
          backgroundColor: theme.vars.palette.Slider[`${color2}Track`],
          borderColor: theme.vars.palette.Slider[`${color2}Track`]
        } : {
          backgroundColor: lighten(theme.palette[color2].main, 0.62),
          borderColor: lighten(theme.palette[color2].main, 0.62),
          ...theme.applyStyles("dark", {
            backgroundColor: darken(theme.palette[color2].main, 0.5)
          }),
          ...theme.applyStyles("dark", {
            borderColor: darken(theme.palette[color2].main, 0.5)
          })
        }
      }
    }))]
  };
}));
const SliderThumb = styled("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize$1(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize$1(ownerState.size)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme.transitions.duration.shortest
  }),
  "&::before": {
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme.vars || theme).shadows[2]
  },
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&.${sliderClasses.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      width: 12,
      height: 12,
      "&::before": {
        boxShadow: "none"
      }
    }
  }, {
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-50%, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 50%)"
    }
  }, ...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&:hover, &.${sliderClasses.focusVisible}`]: {
        ...theme.vars ? {
          boxShadow: `0px 0px 0px 8px rgba(${theme.vars.palette[color2].mainChannel} / 0.16)`
        } : {
          boxShadow: `0px 0px 0px 8px ${alpha(theme.palette[color2].main, 0.16)}`
        },
        "@media (hover: none)": {
          boxShadow: "none"
        }
      },
      [`&.${sliderClasses.active}`]: {
        ...theme.vars ? {
          boxShadow: `0px 0px 0px 14px rgba(${theme.vars.palette[color2].mainChannel} / 0.16)`
        } : {
          boxShadow: `0px 0px 0px 14px ${alpha(theme.palette[color2].main, 0.16)}`
        }
      }
    }
  }))]
})));
const SliderValueLabel = styled(SliderValueLabel$1, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (props, styles2) => styles2.valueLabel
})(memoTheme(({
  theme
}) => ({
  zIndex: 1,
  whiteSpace: "nowrap",
  ...theme.typography.body2,
  fontWeight: 500,
  transition: theme.transitions.create(["transform"], {
    duration: theme.transitions.duration.shortest
  }),
  position: "absolute",
  backgroundColor: (theme.vars || theme).palette.grey[600],
  borderRadius: 2,
  color: (theme.vars || theme).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      transform: "translateY(-100%) scale(0)",
      top: "-10px",
      transformOrigin: "bottom center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, 50%) rotate(45deg)",
        backgroundColor: "inherit",
        bottom: 0,
        left: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-100%) scale(1)"
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      transform: "translateY(-50%) scale(0)",
      right: "30px",
      top: "50%",
      transformOrigin: "right center",
      "&::before": {
        position: "absolute",
        content: '""',
        width: 8,
        height: 8,
        transform: "translate(-50%, -50%) rotate(45deg)",
        backgroundColor: "inherit",
        right: -8,
        top: "50%"
      },
      [`&.${sliderClasses.valueLabelOpen}`]: {
        transform: "translateY(-50%) scale(1)"
      }
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      fontSize: theme.typography.pxToRem(12),
      padding: "0.25rem 0.5rem"
    }
  }, {
    props: {
      orientation: "vertical",
      size: "small"
    },
    style: {
      right: "20px"
    }
  }]
})));
const SliderMark = styled("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: "50%",
      transform: "translate(-1px, -50%)"
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: "50%",
      transform: "translate(-50%, 1px)"
    }
  }, {
    props: {
      markActive: true
    },
    style: {
      backgroundColor: (theme.vars || theme).palette.background.paper,
      opacity: 0.8
    }
  }]
})));
const SliderMarkLabel = styled("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive",
  overridesResolver: (props, styles2) => styles2.markLabel
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body2,
  color: (theme.vars || theme).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "horizontal"
    },
    style: {
      top: 30,
      transform: "translateX(-50%)",
      "@media (pointer: coarse)": {
        top: 40
      }
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      left: 36,
      transform: "translateY(50%)",
      "@media (pointer: coarse)": {
        left: 44
      }
    }
  }, {
    props: {
      markLabelActive: true
    },
    style: {
      color: (theme.vars || theme).palette.text.primary
    }
  }]
})));
const useUtilityClasses$9 = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color: color2,
    size: size2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color2 && `color${capitalize$1(color2)}`, size2 && `size${capitalize$1(size2)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size2 && `thumbSize${capitalize$1(size2)}`, color2 && `thumbColor${capitalize$1(color2)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses$1(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider = /* @__PURE__ */ reactExports.forwardRef(function Slider2(inputProps, ref) {
  const props = useDefaultProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const isRtl = useRtl();
  const {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    // eslint-disable-next-line react/prop-types
    component = "span",
    components = {},
    componentsProps = {},
    color: color2 = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel: getAriaLabel2,
    getAriaValueText,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    shiftStep = 10,
    size: size2 = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    tabIndex,
    track = "normal",
    value: valueProp,
    valueLabelDisplay = "off",
    valueLabelFormat = Identity,
    ...other
  } = props;
  const ownerState = {
    ...props,
    isRtl,
    max: max2,
    min: min2,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color: color2,
    size: size2,
    step,
    shiftStep,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  };
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active,
    axis,
    focusedThumbIndex,
    range,
    dragging,
    marks,
    values: values2,
    trackOffset,
    trackLeap,
    getThumbStyle
  } = useSlider({
    ...ownerState,
    rootRef: ref
  });
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$9(ownerState);
  const RootSlot = (slots == null ? void 0 : slots.root) ?? components.Root ?? SliderRoot;
  const RailSlot = (slots == null ? void 0 : slots.rail) ?? components.Rail ?? SliderRail;
  const TrackSlot = (slots == null ? void 0 : slots.track) ?? components.Track ?? SliderTrack;
  const ThumbSlot = (slots == null ? void 0 : slots.thumb) ?? components.Thumb ?? SliderThumb;
  const ValueLabelSlot = (slots == null ? void 0 : slots.valueLabel) ?? components.ValueLabel ?? SliderValueLabel;
  const MarkSlot = (slots == null ? void 0 : slots.mark) ?? components.Mark ?? SliderMark;
  const MarkLabelSlot = (slots == null ? void 0 : slots.markLabel) ?? components.MarkLabel ?? SliderMarkLabel;
  const InputSlot = (slots == null ? void 0 : slots.input) ?? components.Input ?? "input";
  const rootSlotProps = (slotProps == null ? void 0 : slotProps.root) ?? componentsProps.root;
  const railSlotProps = (slotProps == null ? void 0 : slotProps.rail) ?? componentsProps.rail;
  const trackSlotProps = (slotProps == null ? void 0 : slotProps.track) ?? componentsProps.track;
  const thumbSlotProps = (slotProps == null ? void 0 : slotProps.thumb) ?? componentsProps.thumb;
  const valueLabelSlotProps = (slotProps == null ? void 0 : slotProps.valueLabel) ?? componentsProps.valueLabel;
  const markSlotProps = (slotProps == null ? void 0 : slotProps.mark) ?? componentsProps.mark;
  const markLabelSlotProps = (slotProps == null ? void 0 : slotProps.markLabel) ?? componentsProps.markLabel;
  const inputSlotProps = (slotProps == null ? void 0 : slotProps.input) ?? componentsProps.input;
  const rootProps = useSlotProps$1({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ...shouldSpreadAdditionalProps(RootSlot) && {
        as: component
      }
    },
    ownerState: {
      ...ownerState,
      ...rootSlotProps == null ? void 0 : rootSlotProps.ownerState
    },
    className: [classes.root, className]
  });
  const railProps = useSlotProps$1({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps$1({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: {
        ...axisProps2[axis].offset(trackOffset),
        ...axisProps2[axis].leap(trackLeap)
      }
    },
    ownerState: {
      ...ownerState,
      ...trackSlotProps == null ? void 0 : trackSlotProps.ownerState
    },
    className: classes.track
  });
  const thumbProps = useSlotProps$1({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: {
      ...ownerState,
      ...thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState
    },
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps$1({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: {
      ...ownerState,
      ...valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState
    },
    className: classes.valueLabel
  });
  const markProps = useSlotProps$1({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps$1({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps$1({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, {
      ...railProps
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, {
      ...trackProps
    }), marks.filter((mark) => mark.value >= min2 && mark.value <= max2).map((mark, index) => {
      const percent = valueToPercent(mark.value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values2.includes(mark.value);
      } else {
        markActive = track === "normal" && (range ? mark.value >= values2[0] && mark.value <= values2[values2.length - 1] : mark.value <= values2[0]) || track === "inverted" && (range ? mark.value <= values2[0] || mark.value >= values2[values2.length - 1] : mark.value >= values2[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, {
          "data-index": index,
          ...markProps,
          ...!isHostComponent$1(MarkSlot) && {
            markActive
          },
          style: {
            ...style2,
            ...markProps.style
          },
          className: clsx(markProps.className, markActive && classes.markActive)
        }), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, {
          "aria-hidden": true,
          "data-index": index,
          ...markLabelProps,
          ...!isHostComponent$1(MarkLabelSlot) && {
            markLabelActive: markActive
          },
          style: {
            ...style2,
            ...markLabelProps.style
          },
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        }) : null]
      }, index);
    }), values2.map((value, index) => {
      const percent = valueToPercent(value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, {
          ...!isHostComponent$1(ValueLabelComponent) && {
            valueLabelFormat,
            valueLabelDisplay,
            value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index) : valueLabelFormat,
            index,
            open: open === index || active === index || valueLabelDisplay === "on",
            disabled
          },
          ...valueLabelProps,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, {
            "data-index": index,
            ...thumbProps,
            className: clsx(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
            style: {
              ...style2,
              ...getThumbStyle(index),
              ...thumbProps.style
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, {
              "data-index": index,
              "aria-label": getAriaLabel2 ? getAriaLabel2(index) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
              value: values2[index],
              ...inputSliderProps
            })
          })
        }, index)
      );
    })]
  });
});
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max: max2 = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max2 ? `${max2}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max: max2,
    displayValue
  };
}
function getBadgeUtilityClass(slot) {
  return generateUtilityClass$1("MuiBadge", slot);
}
const badgeClasses = generateUtilityClasses$1("MuiBadge", [
  "root",
  "badge",
  "dot",
  "standard",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
  "invisible",
  "colorError",
  "colorInfo",
  "colorPrimary",
  "colorSecondary",
  "colorSuccess",
  "colorWarning",
  "overlapRectangular",
  "overlapCircular",
  // TODO: v6 remove the overlap value from these class keys
  "anchorOriginTopLeftCircular",
  "anchorOriginTopLeftRectangular",
  "anchorOriginTopRightCircular",
  "anchorOriginTopRightRectangular",
  "anchorOriginBottomLeftCircular",
  "anchorOriginBottomLeftRectangular",
  "anchorOriginBottomRightCircular",
  "anchorOriginBottomRightRectangular"
]);
const RADIUS_STANDARD = 10;
const RADIUS_DOT = 4;
const useUtilityClasses$8 = (ownerState) => {
  const {
    color: color2,
    anchorOrigin,
    invisible,
    overlap,
    variant,
    classes = {}
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize$1(anchorOrigin.vertical)}${capitalize$1(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize$1(anchorOrigin.vertical)}${capitalize$1(anchorOrigin.horizontal)}${capitalize$1(overlap)}`, `overlap${capitalize$1(overlap)}`, color2 !== "default" && `color${capitalize$1(color2)}`]
  };
  return composeClasses$1(slots, getBadgeUtilityClass, classes);
};
const BadgeRoot = styled("span", {
  name: "MuiBadge",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
});
const BadgeBadge = styled("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize$1(ownerState.anchorOrigin.vertical)}${capitalize$1(ownerState.anchorOrigin.horizontal)}${capitalize$1(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.invisible && styles2.invisible];
  }
})(memoTheme(({
  theme
}) => ({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "center",
  alignContent: "center",
  alignItems: "center",
  position: "absolute",
  boxSizing: "border-box",
  fontFamily: theme.typography.fontFamily,
  fontWeight: theme.typography.fontWeightMedium,
  fontSize: theme.typography.pxToRem(12),
  minWidth: RADIUS_STANDARD * 2,
  lineHeight: 1,
  padding: "0 6px",
  height: RADIUS_STANDARD * 2,
  borderRadius: RADIUS_STANDARD,
  zIndex: 1,
  // Render the badge on top of potential ripples.
  transition: theme.transitions.create("transform", {
    easing: theme.transitions.easing.easeInOut,
    duration: theme.transitions.duration.enteringScreen
  }),
  variants: [...Object.entries(theme.palette).filter(([, palette]) => palette && palette.main && palette.contrastText).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme.vars || theme).palette[color2].main,
      color: (theme.vars || theme).palette[color2].contrastText
    }
  })), {
    props: {
      variant: "dot"
    },
    style: {
      borderRadius: RADIUS_DOT,
      height: RADIUS_DOT * 2,
      minWidth: RADIUS_DOT * 2,
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    style: {
      top: 0,
      right: 0,
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
    style: {
      bottom: 0,
      right: 0,
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    style: {
      top: 0,
      left: 0,
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
    style: {
      bottom: 0,
      left: 0,
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    style: {
      top: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, -50%)",
      transformOrigin: "100% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
    style: {
      bottom: "14%",
      right: "14%",
      transform: "scale(1) translate(50%, 50%)",
      transformOrigin: "100% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(50%, 50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    style: {
      top: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, -50%)",
      transformOrigin: "0% 0%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, -50%)"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
    style: {
      bottom: "14%",
      left: "14%",
      transform: "scale(1) translate(-50%, 50%)",
      transformOrigin: "0% 100%",
      [`&.${badgeClasses.invisible}`]: {
        transform: "scale(0) translate(-50%, 50%)"
      }
    }
  }, {
    props: {
      invisible: true
    },
    style: {
      transition: theme.transitions.create("transform", {
        easing: theme.transitions.easing.easeInOut,
        duration: theme.transitions.duration.leavingScreen
      })
    }
  }]
})));
const Badge = /* @__PURE__ */ reactExports.forwardRef(function Badge2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBadge"
  });
  const {
    anchorOrigin: anchorOriginProp = {
      vertical: "top",
      horizontal: "right"
    },
    className,
    classes: classesProp,
    component,
    components = {},
    componentsProps = {},
    children,
    overlap: overlapProp = "rectangular",
    color: colorProp = "default",
    invisible: invisibleProp = false,
    max: maxProp = 99,
    badgeContent: badgeContentProp,
    slots,
    slotProps,
    showZero = false,
    variant: variantProp = "standard",
    ...other
  } = props;
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max: max2,
    displayValue: displayValueFromHook
  } = useBadge({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = usePreviousProps({
    anchorOrigin: anchorOriginProp,
    color: colorProp,
    overlap: overlapProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
  const {
    color: color2 = colorProp,
    overlap = overlapProp,
    anchorOrigin = anchorOriginProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
  const ownerState = {
    ...props,
    badgeContent,
    invisible,
    max: max2,
    displayValue,
    showZero,
    anchorOrigin,
    color: color2,
    overlap,
    variant
  };
  const classes = useUtilityClasses$8(ownerState);
  const RootSlot = (slots == null ? void 0 : slots.root) ?? components.Root ?? BadgeRoot;
  const BadgeSlot = (slots == null ? void 0 : slots.badge) ?? components.Badge ?? BadgeBadge;
  const rootSlotProps = (slotProps == null ? void 0 : slotProps.root) ?? componentsProps.root;
  const badgeSlotProps = (slotProps == null ? void 0 : slotProps.badge) ?? componentsProps.badge;
  const rootProps = useSlotProps$1({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
  });
  const badgeProps = useSlotProps$1({
    elementType: BadgeSlot,
    externalSlotProps: badgeSlotProps,
    ownerState,
    className: clsx(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, {
      ...badgeProps,
      children: displayValue
    })]
  });
});
const ArrowDownwardIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
function getTableSortLabelUtilityClass(slot) {
  return generateUtilityClass$1("MuiTableSortLabel", slot);
}
const tableSortLabelClasses = generateUtilityClasses$1("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes,
    direction,
    active
  } = ownerState;
  const slots = {
    root: ["root", active && "active", `direction${capitalize$1(direction)}`],
    icon: ["icon", `iconDirection${capitalize$1(direction)}`]
  };
  return composeClasses$1(slots, getTableSortLabelUtilityClass, classes);
};
const TableSortLabelRoot = styled(ButtonBase, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.active && styles2.active];
  }
})(memoTheme(({
  theme
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (theme.vars || theme).palette.text.secondary
  },
  "&:hover": {
    color: (theme.vars || theme).palette.text.secondary,
    [`& .${tableSortLabelClasses.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${tableSortLabelClasses.active}`]: {
    color: (theme.vars || theme).palette.text.primary,
    [`& .${tableSortLabelClasses.icon}`]: {
      opacity: 1,
      color: (theme.vars || theme).palette.text.secondary
    }
  }
})));
const TableSortLabelIcon = styled("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, styles2[`iconDirection${capitalize$1(ownerState.direction)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: theme.transitions.create(["opacity", "transform"], {
    duration: theme.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
})));
const TableSortLabel = /* @__PURE__ */ reactExports.forwardRef(function TableSortLabel2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableSortLabel"
  });
  const {
    active = false,
    children,
    className,
    direction = "asc",
    hideSortIcon = false,
    IconComponent = ArrowDownwardIcon,
    ...other
  } = props;
  const ownerState = {
    ...props,
    active,
    direction,
    hideSortIcon,
    IconComponent
  };
  const classes = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableSortLabelRoot, {
    className: clsx(classes.root, className),
    component: "span",
    disableRipple: true,
    ownerState,
    ref,
    ...other,
    children: [children, hideSortIcon && !active ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TableSortLabelIcon, {
      as: IconComponent,
      className: clsx(classes.icon),
      ownerState
    })]
  });
});
function getAlertUtilityClass(slot) {
  return generateUtilityClass$1("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses$1("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");
const useUtilityClasses$6 = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2 || severity)}`, `${variant}${capitalize$1(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses$1(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color || ownerState.severity)}`]];
  }
})(memoTheme(({
  theme
}) => {
  const getColor = theme.palette.mode === "light" ? darken : lighten;
  const getBackgroundColor = theme.palette.mode === "light" ? lighten : darken;
  return {
    ...theme.typography.body2,
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.light).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        backgroundColor: theme.vars ? theme.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }
    })), ...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.light).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme.vars ? theme.vars.palette.Alert[`${color2}Color`] : getColor(theme.palette[color2].light, 0.6),
        border: `1px solid ${(theme.vars || theme).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme.palette[color2].main
        }
      }
    })), ...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.dark).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: {
        fontWeight: theme.typography.fontWeightMedium,
        ...theme.vars ? {
          color: theme.vars.palette.Alert[`${color2}FilledColor`],
          backgroundColor: theme.vars.palette.Alert[`${color2}FilledBg`]
        } : {
          backgroundColor: theme.palette.mode === "dark" ? theme.palette[color2].dark : theme.palette[color2].main,
          color: theme.palette.getContrastText(theme.palette[color2].main)
        }
      }
    }))]
  };
}));
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon",
  overridesResolver: (props, styles2) => styles2.icon
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  };
  const classes = useUtilityClasses$6(ownerState);
  const externalForwardedProps = {
    slots: {
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon,
      ...slots
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: CloseIcon,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertRoot, {
    role,
    elevation: 0,
    ownerState,
    className: clsx(classes.root, className),
    ref,
    ...other,
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, {
      ownerState,
      className: classes.icon,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(AlertMessage, {
      ownerState,
      className: classes.message,
      children
    }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
      ownerState,
      className: classes.action,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(AlertAction, {
      ownerState,
      className: classes.action,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, {
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose,
        ...closeButtonProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, {
          fontSize: "small",
          ...closeIconProps
        })
      })
    }) : null]
  });
});
function getAlertTitleUtilityClass(slot) {
  return generateUtilityClass$1("MuiAlertTitle", slot);
}
generateUtilityClasses$1("MuiAlertTitle", ["root"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getAlertTitleUtilityClass, classes);
};
const AlertTitleRoot = styled(Typography, {
  name: "MuiAlertTitle",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(memoTheme(({
  theme
}) => {
  return {
    fontWeight: theme.typography.fontWeightMedium,
    marginTop: -2
  };
}));
const AlertTitle = /* @__PURE__ */ reactExports.forwardRef(function AlertTitle2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlertTitle"
  });
  const {
    className,
    ...other
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitleRoot, {
    gutterBottom: true,
    component: "div",
    ownerState,
    ref,
    className: clsx(classes.root, className),
    ...other
  });
});
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getDialogTitleUtilityClass, classes);
};
const DialogTitleRoot = styled(Typography, {
  name: "MuiDialogTitle",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  padding: "16px 24px",
  flex: "0 0 auto"
});
const DialogTitle = /* @__PURE__ */ reactExports.forwardRef(function DialogTitle2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDialogTitle"
  });
  const {
    className,
    id: idProp,
    ...other
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$4(ownerState);
  const {
    titleId = idProp
  } = reactExports.useContext(DialogContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleRoot, {
    component: "h2",
    className: clsx(classes.root, className),
    ownerState,
    ref,
    variant: "h6",
    id: idProp ?? titleId,
    ...other
  });
});
function getLinearProgressUtilityClass(slot) {
  return generateUtilityClass$1("MuiLinearProgress", slot);
}
generateUtilityClasses$1("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const TRANSITION_DURATION = 4;
const indeterminate1Keyframe = keyframes`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`;
const indeterminate1Animation = typeof indeterminate1Keyframe !== "string" ? css`
        animation: ${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
      ` : null;
const indeterminate2Keyframe = keyframes`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`;
const indeterminate2Animation = typeof indeterminate2Keyframe !== "string" ? css`
        animation: ${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
      ` : null;
const bufferKeyframe = keyframes`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`;
const bufferAnimation = typeof bufferKeyframe !== "string" ? css`
        animation: ${bufferKeyframe} 3s infinite linear;
      ` : null;
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    variant,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, variant],
    dashed: ["dashed", `dashedColor${capitalize$1(color2)}`],
    bar1: ["bar", `barColor${capitalize$1(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
    bar2: ["bar", variant !== "buffer" && `barColor${capitalize$1(color2)}`, variant === "buffer" && `color${capitalize$1(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
  };
  return composeClasses$1(slots, getLinearProgressUtilityClass, classes);
};
const getColorShade = (theme, color2) => {
  if (theme.vars) {
    return theme.vars.palette.LinearProgress[`${color2}Bg`];
  }
  return theme.palette.mode === "light" ? lighten(theme.palette[color2].main, 0.62) : darken(theme.palette[color2].main, 0.5);
};
const LinearProgressRoot = styled("span", {
  name: "MuiLinearProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize$1(ownerState.color)}`], styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme
}) => ({
  position: "relative",
  overflow: "hidden",
  display: "block",
  height: 4,
  // Fix Safari's bug during composition of different paint.
  zIndex: 0,
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: getColorShade(theme, color2)
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.color === "inherit" && ownerState.variant !== "buffer",
    style: {
      "&::before": {
        content: '""',
        position: "absolute",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "currentColor",
        opacity: 0.3
      }
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      backgroundColor: "transparent"
    }
  }, {
    props: {
      variant: "query"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
})));
const LinearProgressDashed = styled("span", {
  name: "MuiLinearProgress",
  slot: "Dashed",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.dashed, styles2[`dashedColor${capitalize$1(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  marginTop: 0,
  height: "100%",
  width: "100%",
  backgroundSize: "10px 10px",
  backgroundPosition: "0 -23px",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3,
      backgroundImage: `radial-gradient(currentColor 0%, currentColor 16%, transparent 42%)`
    }
  }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => {
    const backgroundColor2 = getColorShade(theme, color2);
    return {
      props: {
        color: color2
      },
      style: {
        backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`
      }
    };
  })]
})), bufferAnimation || {
  // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
  animation: `${bufferKeyframe} 3s infinite linear`
});
const LinearProgressBar1 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar1",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2[`barColor${capitalize$1(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
  }
})(memoTheme(({
  theme
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      backgroundColor: "currentColor"
    }
  }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme.vars || theme).palette[color2].main
    }
  })), {
    props: {
      variant: "determinate"
    },
    style: {
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      zIndex: 1,
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate1Animation || {
      animation: `${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite`
    }
  }]
})));
const LinearProgressBar2 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar2",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2[`barColor${capitalize$1(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
  }
})(memoTheme(({
  theme
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--LinearProgressBar2-barColor": (theme.vars || theme).palette[color2].main
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color !== "inherit",
    style: {
      backgroundColor: "var(--LinearProgressBar2-barColor, currentColor)"
    }
  }, {
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3
    }
  }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main).map(([color2]) => ({
    props: {
      color: color2,
      variant: "buffer"
    },
    style: {
      backgroundColor: getColorShade(theme, color2),
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate2Animation || {
      animation: `${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite`
    }
  }]
})));
const LinearProgress = /* @__PURE__ */ reactExports.forwardRef(function LinearProgress2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLinearProgress"
  });
  const {
    className,
    color: color2 = "primary",
    value,
    valueBuffer,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    variant
  };
  const classes = useUtilityClasses$3(ownerState);
  const isRtl = useRtl();
  const rootProps = {};
  const inlineStyles = {
    bar1: {},
    bar2: {}
  };
  if (variant === "determinate" || variant === "buffer") {
    if (value !== void 0) {
      rootProps["aria-valuenow"] = Math.round(value);
      rootProps["aria-valuemin"] = 0;
      rootProps["aria-valuemax"] = 100;
      let transform = value - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar1.transform = `translateX(${transform}%)`;
    }
  }
  if (variant === "buffer") {
    if (valueBuffer !== void 0) {
      let transform = (valueBuffer || 0) - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar2.transform = `translateX(${transform}%)`;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(LinearProgressRoot, {
    className: clsx(classes.root, className),
    ownerState,
    role: "progressbar",
    ...rootProps,
    ref,
    ...other,
    children: [variant === "buffer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressDashed, {
      className: classes.dashed,
      ownerState
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar1, {
      className: classes.bar1,
      ownerState,
      style: inlineStyles.bar1
    }), variant === "determinate" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar2, {
      className: classes.bar2,
      ownerState,
      style: inlineStyles.bar2
    })]
  });
});
function getPaginationUtilityClass(slot) {
  return generateUtilityClass$1("MuiPagination", slot);
}
generateUtilityClasses$1("MuiPagination", ["root", "ul", "outlined", "text"]);
function usePagination(props = {}) {
  const {
    boundaryCount = 1,
    componentName = "usePagination",
    count: count2 = 1,
    defaultPage = 1,
    disabled = false,
    hideNextButton = false,
    hidePrevButton = false,
    onChange: handleChange,
    page: pageProp,
    showFirstButton = false,
    showLastButton = false,
    siblingCount = 1,
    ...other
  } = props;
  const [page, setPageState] = useControlled$1({
    controlled: pageProp,
    default: defaultPage,
    name: componentName,
    state: "page"
  });
  const handleClick = (event, value) => {
    if (!pageProp) {
      setPageState(value);
    }
    if (handleChange) {
      handleChange(event, value);
    }
  };
  const range = (start2, end2) => {
    const length2 = end2 - start2 + 1;
    return Array.from({
      length: length2
    }, (_, i2) => start2 + i2);
  };
  const startPages = range(1, Math.min(boundaryCount, count2));
  const endPages = range(Math.max(count2 - boundaryCount + 1, boundaryCount + 1), count2);
  const siblingsStart = Math.max(
    Math.min(
      // Natural start
      page - siblingCount,
      // Lower boundary when page is high
      count2 - boundaryCount - siblingCount * 2 - 1
    ),
    // Greater than startPages
    boundaryCount + 2
  );
  const siblingsEnd = Math.min(
    Math.max(
      // Natural end
      page + siblingCount,
      // Upper boundary when page is low
      boundaryCount + siblingCount * 2 + 2
    ),
    // Less than endPages
    count2 - boundaryCount - 1
  );
  const itemList = [
    ...showFirstButton ? ["first"] : [],
    ...hidePrevButton ? [] : ["previous"],
    ...startPages,
    // Start ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsStart > boundaryCount + 2 ? ["start-ellipsis"] : boundaryCount + 1 < count2 - boundaryCount ? [boundaryCount + 1] : [],
    // Sibling pages
    ...range(siblingsStart, siblingsEnd),
    // End ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsEnd < count2 - boundaryCount - 1 ? ["end-ellipsis"] : count2 - boundaryCount > boundaryCount ? [count2 - boundaryCount] : [],
    ...endPages,
    ...hideNextButton ? [] : ["next"],
    ...showLastButton ? ["last"] : []
  ];
  const buttonPage = (type) => {
    switch (type) {
      case "first":
        return 1;
      case "previous":
        return page - 1;
      case "next":
        return page + 1;
      case "last":
        return count2;
      default:
        return null;
    }
  };
  const items = itemList.map((item) => {
    return typeof item === "number" ? {
      onClick: (event) => {
        handleClick(event, item);
      },
      type: "page",
      page: item,
      selected: item === page,
      disabled,
      "aria-current": item === page ? "true" : void 0
    } : {
      onClick: (event) => {
        handleClick(event, buttonPage(item));
      },
      type: item,
      page: buttonPage(item),
      selected: false,
      disabled: disabled || !item.includes("ellipsis") && (item === "next" || item === "last" ? page >= count2 : page <= 1)
    };
  });
  return {
    items,
    ...other
  };
}
function getPaginationItemUtilityClass(slot) {
  return generateUtilityClass$1("MuiPaginationItem", slot);
}
const paginationItemClasses = generateUtilityClasses$1("MuiPaginationItem", ["root", "page", "sizeSmall", "sizeLarge", "text", "textPrimary", "textSecondary", "outlined", "outlinedPrimary", "outlinedSecondary", "rounded", "ellipsis", "firstLast", "previousNext", "focusVisible", "disabled", "selected", "icon", "colorPrimary", "colorSecondary"]);
const FirstPageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");
const LastPageIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
const NavigateBeforeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"
}), "NavigateBefore");
const NavigateNextIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "NavigateNext");
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize$1(ownerState.size)}`], ownerState.variant === "text" && styles2[`text${capitalize$1(ownerState.color)}`], ownerState.variant === "outlined" && styles2[`outlined${capitalize$1(ownerState.color)}`], ownerState.shape === "rounded" && styles2.rounded, ownerState.type === "page" && styles2.page, (ownerState.type === "start-ellipsis" || ownerState.type === "end-ellipsis") && styles2.ellipsis, (ownerState.type === "previous" || ownerState.type === "next") && styles2.previousNext, (ownerState.type === "first" || ownerState.type === "last") && styles2.firstLast];
};
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    selected,
    size: size2,
    shape: shape2,
    type,
    variant
  } = ownerState;
  const slots = {
    root: ["root", `size${capitalize$1(size2)}`, variant, shape2, color2 !== "standard" && `color${capitalize$1(color2)}`, color2 !== "standard" && `${variant}${capitalize$1(color2)}`, disabled && "disabled", selected && "selected", {
      page: "page",
      first: "firstLast",
      last: "firstLast",
      "start-ellipsis": "ellipsis",
      "end-ellipsis": "ellipsis",
      previous: "previousNext",
      next: "previousNext"
    }[type]],
    icon: ["icon"]
  };
  return composeClasses$1(slots, getPaginationItemUtilityClass, classes);
};
const PaginationItemEllipsis = styled("div", {
  name: "MuiPaginationItem",
  slot: "Root",
  overridesResolver
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body2,
  borderRadius: 32 / 2,
  textAlign: "center",
  boxSizing: "border-box",
  minWidth: 32,
  padding: "0 6px",
  margin: "0 3px",
  color: (theme.vars || theme).palette.text.primary,
  height: "auto",
  [`&.${paginationItemClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      minWidth: 26,
      borderRadius: 26 / 2,
      margin: "0 1px",
      padding: "0 4px"
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      minWidth: 40,
      borderRadius: 40 / 2,
      padding: "0 10px",
      fontSize: theme.typography.pxToRem(15)
    }
  }]
})));
const PaginationItemPage = styled(ButtonBase, {
  name: "MuiPaginationItem",
  slot: "Root",
  overridesResolver
})(memoTheme(({
  theme
}) => ({
  ...theme.typography.body2,
  borderRadius: 32 / 2,
  textAlign: "center",
  boxSizing: "border-box",
  minWidth: 32,
  height: 32,
  padding: "0 6px",
  margin: "0 3px",
  color: (theme.vars || theme).palette.text.primary,
  [`&.${paginationItemClasses.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${paginationItemClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  transition: theme.transitions.create(["color", "background-color"], {
    duration: theme.transitions.duration.short
  }),
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${paginationItemClasses.selected}`]: {
    backgroundColor: (theme.vars || theme).palette.action.selected,
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette.action.selected
      }
    },
    [`&.${paginationItemClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    },
    [`&.${paginationItemClasses.disabled}`]: {
      opacity: 1,
      color: (theme.vars || theme).palette.action.disabled,
      backgroundColor: (theme.vars || theme).palette.action.selected
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      minWidth: 26,
      height: 26,
      borderRadius: 26 / 2,
      margin: "0 1px",
      padding: "0 4px"
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      minWidth: 40,
      height: 40,
      borderRadius: 40 / 2,
      padding: "0 10px",
      fontSize: theme.typography.pxToRem(15)
    }
  }, {
    props: {
      shape: "rounded"
    },
    style: {
      borderRadius: (theme.vars || theme).shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
      [`&.${paginationItemClasses.selected}`]: {
        [`&.${paginationItemClasses.disabled}`]: {
          borderColor: (theme.vars || theme).palette.action.disabledBackground,
          color: (theme.vars || theme).palette.action.disabled
        }
      }
    }
  }, {
    props: {
      variant: "text"
    },
    style: {
      [`&.${paginationItemClasses.selected}`]: {
        [`&.${paginationItemClasses.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled
        }
      }
    }
  }, ...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.dark && value.contrastText).map(([color2]) => ({
    props: {
      variant: "text",
      color: color2
    },
    style: {
      [`&.${paginationItemClasses.selected}`]: {
        color: (theme.vars || theme).palette[color2].contrastText,
        backgroundColor: (theme.vars || theme).palette[color2].main,
        "&:hover": {
          backgroundColor: (theme.vars || theme).palette[color2].dark,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette[color2].main
          }
        },
        [`&.${paginationItemClasses.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette[color2].dark
        },
        [`&.${paginationItemClasses.disabled}`]: {
          color: (theme.vars || theme).palette.action.disabled
        }
      }
    }
  })), ...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.light).map(([color2]) => ({
    props: {
      variant: "outlined",
      color: color2
    },
    style: {
      [`&.${paginationItemClasses.selected}`]: {
        color: (theme.vars || theme).palette[color2].main,
        border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / 0.5)` : alpha(theme.palette[color2].main, 0.5)}`,
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.activatedOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.activatedOpacity),
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / calc(${theme.vars.palette.action.activatedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette[color2].main, theme.palette.action.activatedOpacity + theme.palette.action.focusOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${paginationItemClasses.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / calc(${theme.vars.palette.action.activatedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette[color2].main, theme.palette.action.activatedOpacity + theme.palette.action.focusOpacity)
        }
      }
    }
  }))]
})));
const PaginationItemPageIcon = styled("div", {
  name: "MuiPaginationItem",
  slot: "Icon",
  overridesResolver: (props, styles2) => styles2.icon
})(memoTheme(({
  theme
}) => ({
  fontSize: theme.typography.pxToRem(20),
  margin: "0 -8px",
  variants: [{
    props: {
      size: "small"
    },
    style: {
      fontSize: theme.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      fontSize: theme.typography.pxToRem(22)
    }
  }]
})));
const PaginationItem = /* @__PURE__ */ reactExports.forwardRef(function PaginationItem2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaginationItem"
  });
  const {
    className,
    color: color2 = "standard",
    component,
    components = {},
    disabled = false,
    page,
    selected = false,
    shape: shape2 = "circular",
    size: size2 = "medium",
    slots = {},
    slotProps = {},
    type = "page",
    variant = "text",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    disabled,
    selected,
    shape: shape2,
    size: size2,
    type,
    variant
  };
  const isRtl = useRtl();
  const classes = useUtilityClasses$2(ownerState);
  const externalForwardedProps = {
    slots: {
      previous: slots.previous ?? components.previous,
      next: slots.next ?? components.next,
      first: slots.first ?? components.first,
      last: slots.last ?? components.last
    },
    slotProps
  };
  const [PreviousSlot, previousSlotProps] = useSlot("previous", {
    elementType: NavigateBeforeIcon,
    externalForwardedProps,
    ownerState
  });
  const [NextSlot, nextSlotProps] = useSlot("next", {
    elementType: NavigateNextIcon,
    externalForwardedProps,
    ownerState
  });
  const [FirstSlot, firstSlotProps] = useSlot("first", {
    elementType: FirstPageIcon,
    externalForwardedProps,
    ownerState
  });
  const [LastSlot, lastSlotProps] = useSlot("last", {
    elementType: LastPageIcon,
    externalForwardedProps,
    ownerState
  });
  const rtlAwareType = isRtl ? {
    previous: "next",
    next: "previous",
    first: "last",
    last: "first"
  }[type] : type;
  const IconSlot = {
    previous: PreviousSlot,
    next: NextSlot,
    first: FirstSlot,
    last: LastSlot
  }[rtlAwareType];
  const iconSlotProps = {
    previous: previousSlotProps,
    next: nextSlotProps,
    first: firstSlotProps,
    last: lastSlotProps
  }[rtlAwareType];
  return type === "start-ellipsis" || type === "end-ellipsis" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItemEllipsis, {
    ref,
    ownerState,
    className: clsx(classes.root, className),
    children: "…"
  }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(PaginationItemPage, {
    ref,
    ownerState,
    component,
    disabled,
    className: clsx(classes.root, className),
    ...other,
    children: [type === "page" && page, IconSlot ? /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItemPageIcon, {
      ...iconSlotProps,
      className: classes.icon,
      as: IconSlot
    }) : null]
  });
});
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant],
    ul: ["ul"]
  };
  return composeClasses$1(slots, getPaginationUtilityClass, classes);
};
const PaginationRoot = styled("nav", {
  name: "MuiPagination",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant]];
  }
})({});
const PaginationUl = styled("ul", {
  name: "MuiPagination",
  slot: "Ul",
  overridesResolver: (props, styles2) => styles2.ul
})({
  display: "flex",
  flexWrap: "wrap",
  alignItems: "center",
  padding: 0,
  margin: 0,
  listStyle: "none"
});
function defaultGetAriaLabel(type, page, selected) {
  if (type === "page") {
    return `${selected ? "" : "Go to "}page ${page}`;
  }
  return `Go to ${type} page`;
}
const Pagination = /* @__PURE__ */ reactExports.forwardRef(function Pagination2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPagination"
  });
  const {
    boundaryCount = 1,
    className,
    color: color2 = "standard",
    count: count2 = 1,
    defaultPage = 1,
    disabled = false,
    getItemAriaLabel = defaultGetAriaLabel,
    hideNextButton = false,
    hidePrevButton = false,
    onChange,
    page,
    renderItem = (item) => /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItem, {
      ...item
    }),
    shape: shape2 = "circular",
    showFirstButton = false,
    showLastButton = false,
    siblingCount = 1,
    size: size2 = "medium",
    variant = "text",
    ...other
  } = props;
  const {
    items
  } = usePagination({
    ...props,
    componentName: "Pagination"
  });
  const ownerState = {
    ...props,
    boundaryCount,
    color: color2,
    count: count2,
    defaultPage,
    disabled,
    getItemAriaLabel,
    hideNextButton,
    hidePrevButton,
    renderItem,
    shape: shape2,
    showFirstButton,
    showLastButton,
    siblingCount,
    size: size2,
    variant
  };
  const classes = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationRoot, {
    "aria-label": "pagination navigation",
    className: clsx(classes.root, className),
    ownerState,
    ref,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationUl, {
      className: classes.ul,
      ownerState,
      children: items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
        children: renderItem({
          ...item,
          color: color2,
          "aria-label": getItemAriaLabel(item.type, item.page, item.selected),
          shape: shape2,
          size: size2,
          variant
        })
      }, index))
    })
  });
});
function getSwitchUtilityClass(slot) {
  return generateUtilityClass$1("MuiSwitch", slot);
}
const switchClasses = generateUtilityClasses$1("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
const useUtilityClasses = (ownerState) => {
  const {
    classes,
    edge,
    size: size2,
    color: color2,
    checked,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size2)}`],
    switchBase: ["switchBase", `color${capitalize$1(color2)}`, checked && "checked", disabled && "disabled"],
    thumb: ["thumb"],
    track: ["track"],
    input: ["input"]
  };
  const composedClasses = composeClasses$1(slots, getSwitchUtilityClass, classes);
  return {
    ...classes,
    // forward the disabled and checked classes to the SwitchBase
    ...composedClasses
  };
};
const SwitchRoot = styled("span", {
  name: "MuiSwitch",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})({
  display: "inline-flex",
  width: 34 + 12 * 2,
  height: 14 + 12 * 2,
  overflow: "hidden",
  padding: 12,
  boxSizing: "border-box",
  position: "relative",
  flexShrink: 0,
  zIndex: 0,
  // Reset the stacking context.
  verticalAlign: "middle",
  // For correct alignment with the text.
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [{
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -8
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -8
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      width: 40,
      height: 24,
      padding: 7,
      [`& .${switchClasses.thumb}`]: {
        width: 16,
        height: 16
      },
      [`& .${switchClasses.switchBase}`]: {
        padding: 4,
        [`&.${switchClasses.checked}`]: {
          transform: "translateX(16px)"
        }
      }
    }
  }]
});
const SwitchSwitchBase = styled(SwitchBase, {
  name: "MuiSwitch",
  slot: "SwitchBase",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.switchBase, {
      [`& .${switchClasses.input}`]: styles2.input
    }, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(memoTheme(({
  theme
}) => ({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  // Render above the focus ripple.
  color: theme.vars ? theme.vars.palette.Switch.defaultColor : `${theme.palette.mode === "light" ? theme.palette.common.white : theme.palette.grey[300]}`,
  transition: theme.transitions.create(["left", "transform"], {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${switchClasses.checked}`]: {
    transform: "translateX(20px)"
  },
  [`&.${switchClasses.disabled}`]: {
    color: theme.vars ? theme.vars.palette.Switch.defaultDisabledColor : `${theme.palette.mode === "light" ? theme.palette.grey[100] : theme.palette.grey[600]}`
  },
  [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
    opacity: 0.5
  },
  [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
    opacity: theme.vars ? theme.vars.opacity.switchTrackDisabled : `${theme.palette.mode === "light" ? 0.12 : 0.2}`
  },
  [`& .${switchClasses.input}`]: {
    left: "-100%",
    width: "300%"
  }
})), memoTheme(({
  theme
}) => ({
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [...Object.entries(theme.palette).filter(([, value]) => value && value.main && value.light).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${switchClasses.checked}`]: {
        color: (theme.vars || theme).palette[color2].main,
        "&:hover": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[color2].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color2].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        },
        [`&.${switchClasses.disabled}`]: {
          color: theme.vars ? theme.vars.palette.Switch[`${color2}DisabledColor`] : `${theme.palette.mode === "light" ? lighten(theme.palette[color2].main, 0.62) : darken(theme.palette[color2].main, 0.55)}`
        }
      },
      [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
        backgroundColor: (theme.vars || theme).palette[color2].main
      }
    }
  }))]
})));
const SwitchTrack = styled("span", {
  name: "MuiSwitch",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(memoTheme(({
  theme
}) => ({
  height: "100%",
  width: "100%",
  borderRadius: 14 / 2,
  zIndex: -1,
  transition: theme.transitions.create(["opacity", "background-color"], {
    duration: theme.transitions.duration.shortest
  }),
  backgroundColor: theme.vars ? theme.vars.palette.common.onBackground : `${theme.palette.mode === "light" ? theme.palette.common.black : theme.palette.common.white}`,
  opacity: theme.vars ? theme.vars.opacity.switchTrack : `${theme.palette.mode === "light" ? 0.38 : 0.3}`
})));
const SwitchThumb = styled("span", {
  name: "MuiSwitch",
  slot: "Thumb",
  overridesResolver: (props, styles2) => styles2.thumb
})(memoTheme(({
  theme
}) => ({
  boxShadow: (theme.vars || theme).shadows[1],
  backgroundColor: "currentColor",
  width: 20,
  height: 20,
  borderRadius: "50%"
})));
const Switch = /* @__PURE__ */ reactExports.forwardRef(function Switch2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSwitch"
  });
  const {
    className,
    color: color2 = "primary",
    edge = false,
    size: size2 = "medium",
    sx,
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    edge,
    size: size2
  };
  const classes = useUtilityClasses(ownerState);
  const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
    className: classes.thumb,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, {
    className: clsx(classes.root, className),
    sx,
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, {
      type: "checkbox",
      icon,
      checkedIcon: icon,
      ref,
      ownerState,
      ...other,
      classes: {
        ...classes,
        root: classes.switchBase
      }
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchTrack, {
      className: classes.track,
      ownerState
    })]
  });
});
const getColumnId = (columnDef) => {
  var _a2, _b2, _c2, _d2;
  return (_d2 = (_a2 = columnDef.id) !== null && _a2 !== void 0 ? _a2 : (_c2 = (_b2 = columnDef.accessorKey) === null || _b2 === void 0 ? void 0 : _b2.toString) === null || _c2 === void 0 ? void 0 : _c2.call(_b2)) !== null && _d2 !== void 0 ? _d2 : columnDef.header;
};
const getAllLeafColumnDefs = (columns) => {
  const allLeafColumnDefs = [];
  const getLeafColumns = (cols) => {
    cols.forEach((col) => {
      if (col.columns) {
        getLeafColumns(col.columns);
      } else {
        allLeafColumnDefs.push(col);
      }
    });
  };
  getLeafColumns(columns);
  return allLeafColumnDefs;
};
const prepareColumns = ({ columnDefs, tableOptions }) => {
  const { aggregationFns: aggregationFns2 = {}, defaultDisplayColumn, filterFns: filterFns2 = {}, sortingFns: sortingFns2 = {}, state: { columnFilterFns = {} } = {} } = tableOptions;
  return columnDefs.map((columnDef) => {
    var _a2, _b2;
    if (!columnDef.id)
      columnDef.id = getColumnId(columnDef);
    if (!columnDef.columnDefType)
      columnDef.columnDefType = "data";
    if ((_a2 = columnDef.columns) === null || _a2 === void 0 ? void 0 : _a2.length) {
      columnDef.columnDefType = "group";
      columnDef.columns = prepareColumns({
        columnDefs: columnDef.columns,
        tableOptions
      });
    } else if (columnDef.columnDefType === "data") {
      if (Array.isArray(columnDef.aggregationFn)) {
        const aggFns = columnDef.aggregationFn;
        columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn2) => {
          var _a3;
          return (_a3 = aggregationFns2[fn2]) === null || _a3 === void 0 ? void 0 : _a3.call(aggregationFns2, columnId, leafRows, childRows);
        });
      }
      if (Object.keys(filterFns2).includes(columnFilterFns[columnDef.id])) {
        columnDef.filterFn = (_b2 = filterFns2[columnFilterFns[columnDef.id]]) !== null && _b2 !== void 0 ? _b2 : filterFns2.fuzzy;
        columnDef._filterFn = columnFilterFns[columnDef.id];
      }
      if (Object.keys(sortingFns2).includes(columnDef.sortingFn)) {
        columnDef.sortingFn = sortingFns2[columnDef.sortingFn];
      }
    } else if (columnDef.columnDefType === "display") {
      columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
    }
    return columnDef;
  });
};
const reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
  if (draggedColumn.getCanPin()) {
    draggedColumn.pin(targetColumn.getIsPinned());
  }
  const newColumnOrder = [...columnOrder];
  newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);
  return newColumnOrder;
};
const getDefaultColumnFilterFn = (columnDef) => {
  const { filterVariant } = columnDef;
  if (filterVariant === "multi-select")
    return "arrIncludesSome";
  if (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes("range"))
    return "betweenInclusive";
  if (filterVariant === "select" || filterVariant === "checkbox")
    return "equals";
  return "fuzzy";
};
const getColumnFilterInfo = ({ header, table }) => {
  var _a2;
  const { options: { columnFilterModeOptions } } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { filterVariant } = columnDef;
  const isDateFilter = !!((filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("date")) || (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("time")));
  const isAutocompleteFilter = filterVariant === "autocomplete";
  const isRangeFilter = (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes("range")) || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn);
  const isSelectFilter = filterVariant === "select";
  const isMultiSelectFilter = filterVariant === "multi-select";
  const isTextboxFilter = ["autocomplete", "text"].includes(filterVariant) || !isSelectFilter && !isMultiSelectFilter;
  const currentFilterOption = columnDef._filterFn;
  const allowedColumnFilterOptions = (_a2 = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _a2 !== void 0 ? _a2 : columnFilterModeOptions;
  const facetedUniqueValues = column2.getFacetedUniqueValues();
  return {
    allowedColumnFilterOptions,
    currentFilterOption,
    facetedUniqueValues,
    isAutocompleteFilter,
    isDateFilter,
    isMultiSelectFilter,
    isRangeFilter,
    isSelectFilter,
    isTextboxFilter
  };
};
const useDropdownOptions = ({ header, table }) => {
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { facetedUniqueValues, isAutocompleteFilter, isMultiSelectFilter, isSelectFilter } = getColumnFilterInfo({ header, table });
  return reactExports.useMemo(() => {
    var _a2;
    return (_a2 = columnDef.filterSelectOptions) !== null && _a2 !== void 0 ? _a2 : (isSelectFilter || isMultiSelectFilter || isAutocompleteFilter) && facetedUniqueValues ? Array.from(facetedUniqueValues.keys()).filter((value) => value !== null && value !== void 0).sort((a3, b3) => a3.localeCompare(b3)) : void 0;
  }, [
    columnDef.filterSelectOptions,
    facetedUniqueValues,
    isMultiSelectFilter,
    isSelectFilter
  ]);
};
const createRow = (table, originalRow, rowIndex = -1, depth = 0, subRows, parentId) => createRow$1(table, "mrt-row-create", Object.assign({}, ...getAllLeafColumnDefs(table.options.columns).map((col) => ({
  [getColumnId(col)]: ""
}))), rowIndex, depth, subRows, parentId);
const fuzzy$1 = (rowA, rowB, columnId) => {
  let dir = 0;
  if (rowA.columnFiltersMeta[columnId]) {
    dir = compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
  }
  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;
};
const MRT_SortingFns = Object.assign(Object.assign({}, sortingFns), { fuzzy: fuzzy$1 });
const rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v2) => v2.rank)) - Math.max(...Object.values(rowA.columnFiltersMeta).map((v2) => v2.rank));
const parseFromValuesOrFunc = (fn2, arg2) => fn2 instanceof Function ? fn2(arg2) : fn2;
const getValueAndLabel = (option) => {
  var _a2, _b2;
  let label = "";
  let value = "";
  if (option) {
    if (typeof option !== "object") {
      label = option;
      value = option;
    } else {
      label = (_a2 = option.label) !== null && _a2 !== void 0 ? _a2 : option.value;
      value = (_b2 = option.value) !== null && _b2 !== void 0 ? _b2 : label;
    }
  }
  return { label, value };
};
const getMRT_Rows = (table, all) => {
  const { getCenterRows, getPrePaginationRowModel, getRowModel, getState, getTopRows, options: { createDisplayMode, enablePagination, enableRowPinning, manualPagination, positionCreatingRow, rowPinningDisplayMode } } = table;
  const { creatingRow, pagination } = getState();
  const isRankingRows = getIsRankingRows(table);
  let rows = [];
  if (!isRankingRows) {
    rows = !enableRowPinning || (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) ? all ? getPrePaginationRowModel().rows : getRowModel().rows : getCenterRows();
  } else {
    rows = getPrePaginationRowModel().rows.sort((a3, b3) => rankGlobalFuzzy(a3, b3));
    if (enablePagination && !manualPagination && !all) {
      const start2 = pagination.pageIndex * pagination.pageSize;
      rows = rows.slice(start2, start2 + pagination.pageSize);
    }
    if (enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky"))) {
      rows = rows.filter((row) => !row.getIsPinned());
    }
  }
  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky"))) {
    const centerPinnedRowIds = rows.filter((row) => row.getIsPinned()).map((r2) => r2.id);
    rows = [
      ...getTopRows().filter((row) => !centerPinnedRowIds.includes(row.id)),
      ...rows
    ];
  }
  if (positionCreatingRow !== void 0 && creatingRow && createDisplayMode === "row") {
    const creatingRowIndex = !isNaN(+positionCreatingRow) ? +positionCreatingRow : positionCreatingRow === "top" ? 0 : rows.length;
    rows = [
      ...rows.slice(0, creatingRowIndex),
      creatingRow,
      ...rows.slice(creatingRowIndex)
    ];
  }
  return rows;
};
const getCanRankRows = (table) => {
  const { getState, options: { enableGlobalFilterRankedResults, manualExpanding, manualFiltering, manualGrouping, manualSorting } } = table;
  const { expanded, globalFilterFn } = getState();
  return !manualExpanding && !manualFiltering && !manualGrouping && !manualSorting && enableGlobalFilterRankedResults && globalFilterFn === "fuzzy" && expanded !== true && !Object.values(expanded).some(Boolean);
};
const getIsRankingRows = (table) => {
  const { globalFilter, sorting } = table.getState();
  return getCanRankRows(table) && globalFilter && !Object.values(sorting).some(Boolean);
};
const getIsRowSelected = ({ row, table }) => {
  const { options: { enableRowSelection } } = table;
  return row.getIsSelected() || parseFromValuesOrFunc(enableRowSelection, row) && row.getCanSelectSubRows() && row.getIsAllSubRowsSelected();
};
const getMRT_RowSelectionHandler = ({ row, staticRowIndex = 0, table }) => (event, value) => {
  var _a2;
  const { getState, options: { enableBatchRowSelection, enableMultiRowSelection, enableRowPinning, manualPagination, rowPinningDisplayMode }, refs: { lastSelectedRowId } } = table;
  const { pagination: { pageIndex, pageSize: pageSize2 } } = getState();
  const paginationOffset = manualPagination ? 0 : pageSize2 * pageIndex;
  const wasCurrentRowChecked = getIsRowSelected({ row, table });
  row.toggleSelected(value !== null && value !== void 0 ? value : !wasCurrentRowChecked);
  const changedRowIds = /* @__PURE__ */ new Set([row.id]);
  if (enableBatchRowSelection && enableMultiRowSelection && event.nativeEvent.shiftKey && lastSelectedRowId.current !== null) {
    const rows = getMRT_Rows(table, true);
    const lastIndex = rows.findIndex((r2) => r2.id === lastSelectedRowId.current);
    if (lastIndex !== -1) {
      const isLastIndexChecked = getIsRowSelected({
        row: rows === null || rows === void 0 ? void 0 : rows[lastIndex],
        table
      });
      const currentIndex = staticRowIndex + paginationOffset;
      const [start2, end2] = lastIndex < currentIndex ? [lastIndex, currentIndex] : [currentIndex, lastIndex];
      if (wasCurrentRowChecked !== isLastIndexChecked) {
        for (let i2 = start2; i2 <= end2; i2++) {
          rows[i2].toggleSelected(!wasCurrentRowChecked);
          changedRowIds.add(rows[i2].id);
        }
      }
    }
  }
  lastSelectedRowId.current = row.id;
  if (row.getCanSelectSubRows() && row.getIsAllSubRowsSelected()) {
    (_a2 = row.subRows) === null || _a2 === void 0 ? void 0 : _a2.forEach((r2) => r2.toggleSelected(false));
  }
  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("select"))) {
    changedRowIds.forEach((rowId) => {
      const rowToTogglePin = table.getRow(rowId);
      rowToTogglePin.pin(!wasCurrentRowChecked ? (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("bottom")) ? "bottom" : "top" : false);
    });
  }
};
const getMRT_SelectAllHandler = ({ table }) => (event, value, forceAll) => {
  const { options: { enableRowPinning, rowPinningDisplayMode, selectAllMode }, refs: { lastSelectedRowId } } = table;
  selectAllMode === "all" || forceAll ? table.toggleAllRowsSelected(value !== null && value !== void 0 ? value : event.target.checked) : table.toggleAllPageRowsSelected(value !== null && value !== void 0 ? value : event.target.checked);
  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("select"))) {
    table.setRowPinning({ bottom: [], top: [] });
  }
  lastSelectedRowId.current = null;
};
const isWinCtrlMacMeta = (event) => {
  return event.ctrlKey && navigator.platform.toLowerCase().includes("win") || event.metaKey && navigator.platform.toLowerCase().includes("mac");
};
const isCellEditable = ({ cell, table }) => {
  const { enableEditing } = table.options;
  const { column: { columnDef }, row } = cell;
  return !cell.getIsPlaceholder() && parseFromValuesOrFunc(enableEditing, row) && parseFromValuesOrFunc(columnDef.enableEditing, row) !== false;
};
const openEditingCell = ({ cell, table }) => {
  const { options: { editDisplayMode }, refs: { editInputRefs } } = table;
  const { column: column2 } = cell;
  if (isCellEditable({ cell, table }) && editDisplayMode === "cell") {
    table.setEditingCell(cell);
    queueMicrotask(() => {
      var _a2;
      const textField = editInputRefs.current[column2.id];
      if (textField) {
        textField.focus();
        (_a2 = textField.select) === null || _a2 === void 0 ? void 0 : _a2.call(textField);
      }
    });
  }
};
const cellKeyboardShortcuts = ({ cell, cellElements, cellValue, containerElement, event, header, parentElement, table }) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
  if (!table.options.enableKeyboardShortcuts)
    return;
  const currentCell = event.currentTarget;
  if (cellValue && isWinCtrlMacMeta(event) && event.key === "c") {
    navigator.clipboard.writeText(cellValue);
  } else if (["Enter", " "].includes(event.key)) {
    if (((_a2 = cell === null || cell === void 0 ? void 0 : cell.column) === null || _a2 === void 0 ? void 0 : _a2.id) === "mrt-row-select") {
      event.preventDefault();
      getMRT_RowSelectionHandler({
        row: cell.row,
        table,
        //@ts-ignore
        staticRowIndex: +event.target.getAttribute("data-index")
      })(event);
    } else if (((_b2 = header === null || header === void 0 ? void 0 : header.column) === null || _b2 === void 0 ? void 0 : _b2.id) === "mrt-row-select" && table.options.enableSelectAll) {
      event.preventDefault();
      getMRT_SelectAllHandler({
        table
      })(event);
    } else if (((_c2 = cell === null || cell === void 0 ? void 0 : cell.column) === null || _c2 === void 0 ? void 0 : _c2.id) === "mrt-row-expand" && (cell.row.getCanExpand() || ((_e2 = (_d2 = table.options).renderDetailPanel) === null || _e2 === void 0 ? void 0 : _e2.call(_d2, { row: cell.row, table })))) {
      event.preventDefault();
      cell.row.toggleExpanded();
    } else if (((_f2 = header === null || header === void 0 ? void 0 : header.column) === null || _f2 === void 0 ? void 0 : _f2.id) === "mrt-row-expand" && table.options.enableExpandAll) {
      event.preventDefault();
      table.toggleAllRowsExpanded();
    } else if ((cell === null || cell === void 0 ? void 0 : cell.column.id) === "mrt-row-pin") {
      event.preventDefault();
      cell.row.getIsPinned() ? cell.row.pin(false) : cell.row.pin(((_g2 = table.options.rowPinningDisplayMode) === null || _g2 === void 0 ? void 0 : _g2.includes("bottom")) ? "bottom" : "top");
    } else if (header && isWinCtrlMacMeta(event)) {
      const actionsButton = currentCell.querySelector(`button[aria-label="${table.options.localization.columnActions}"]`);
      if (actionsButton) {
        actionsButton.click();
      }
    } else if ((_h2 = header === null || header === void 0 ? void 0 : header.column) === null || _h2 === void 0 ? void 0 : _h2.getCanSort()) {
      event.preventDefault();
      header.column.toggleSorting();
    }
  } else if ([
    "ArrowRight",
    "ArrowLeft",
    "ArrowUp",
    "ArrowDown",
    "Home",
    "End",
    "PageUp",
    "PageDown"
  ].includes(event.key)) {
    event.preventDefault();
    const currentRow = parentElement || currentCell.closest("tr");
    const tableElement = containerElement || currentCell.closest("table");
    const allCells = cellElements || Array.from((tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelectorAll("th, td")) || []);
    const currentCellIndex = allCells.indexOf(currentCell);
    const currentIndex = parseInt(currentCell.getAttribute("data-index") || "0");
    let nextCell = void 0;
    const findEdgeCell = (rowIndex, edge) => {
      var _a3;
      const row = rowIndex === "c" ? currentRow : rowIndex === "f" ? tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelector("tr") : (_a3 = tableElement === null || tableElement === void 0 ? void 0 : tableElement.lastElementChild) === null || _a3 === void 0 ? void 0 : _a3.lastElementChild;
      const rowCells = Array.from((row === null || row === void 0 ? void 0 : row.children) || []);
      const targetCell = edge === "f" ? rowCells[0] : rowCells[rowCells.length - 1];
      return targetCell;
    };
    const findBottomTopCell = (columnIndex, edge) => {
      var _a3;
      const row = edge === "t" ? tableElement === null || tableElement === void 0 ? void 0 : tableElement.querySelector("tr") : (_a3 = tableElement === null || tableElement === void 0 ? void 0 : tableElement.lastElementChild) === null || _a3 === void 0 ? void 0 : _a3.lastElementChild;
      const rowCells = Array.from((row === null || row === void 0 ? void 0 : row.children) || []);
      const targetCell = rowCells[columnIndex];
      return targetCell;
    };
    const findAdjacentCell = (columnIndex, searchDirection) => {
      const searchArray = searchDirection === "f" ? allCells.slice(currentCellIndex + 1) : allCells.slice(0, currentCellIndex).reverse();
      return searchArray.find((cell2) => cell2.matches(`[data-index="${columnIndex}"]`));
    };
    switch (event.key) {
      case "ArrowRight":
        nextCell = findAdjacentCell(currentIndex + 1, "f");
        break;
      case "ArrowLeft":
        nextCell = findAdjacentCell(currentIndex - 1, "b");
        break;
      case "ArrowUp":
        nextCell = findAdjacentCell(currentIndex, "b");
        break;
      case "ArrowDown":
        nextCell = findAdjacentCell(currentIndex, "f");
        break;
      case "Home":
        nextCell = findEdgeCell(isWinCtrlMacMeta(event) ? "f" : "c", "f");
        break;
      case "End":
        nextCell = findEdgeCell(isWinCtrlMacMeta(event) ? "l" : "c", "l");
        break;
      case "PageUp":
        nextCell = findBottomTopCell(currentIndex, "t");
        break;
      case "PageDown":
        nextCell = findBottomTopCell(currentIndex, "b");
        break;
    }
    if (nextCell) {
      nextCell.focus();
    }
  }
};
function defaultDisplayColumnProps({ header, id: id2, size: size2, tableOptions }) {
  const { defaultDisplayColumn, displayColumnDefOptions, localization } = tableOptions;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumn), { header: header ? localization[header] : "", size: size2 }), displayColumnDefOptions === null || displayColumnDefOptions === void 0 ? void 0 : displayColumnDefOptions[id2]), { id: id2 });
}
const showRowPinningColumn = (tableOptions) => {
  const { enableRowPinning, rowPinningDisplayMode } = tableOptions;
  return !!(enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.startsWith("select")));
};
const showRowDragColumn = (tableOptions) => {
  const { enableRowDragging, enableRowOrdering } = tableOptions;
  return !!(enableRowDragging || enableRowOrdering);
};
const showRowExpandColumn = (tableOptions) => {
  const { enableExpanding, enableGrouping, renderDetailPanel, state: { grouping } } = tableOptions;
  return !!(enableExpanding || enableGrouping && (grouping === null || grouping === void 0 ? void 0 : grouping.length) || renderDetailPanel);
};
const showRowActionsColumn = (tableOptions) => {
  const { createDisplayMode, editDisplayMode, enableEditing, enableRowActions, state: { creatingRow } } = tableOptions;
  return !!(enableRowActions || creatingRow && createDisplayMode === "row" || enableEditing && ["modal", "row"].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : ""));
};
const showRowSelectionColumn = (tableOptions) => !!tableOptions.enableRowSelection;
const showRowNumbersColumn = (tableOptions) => !!tableOptions.enableRowNumbers;
const showRowSpacerColumn = (tableOptions) => tableOptions.layoutMode === "grid-no-grow";
const getLeadingDisplayColumnIds = (tableOptions) => [
  showRowPinningColumn(tableOptions) && "mrt-row-pin",
  showRowDragColumn(tableOptions) && "mrt-row-drag",
  tableOptions.positionActionsColumn === "first" && showRowActionsColumn(tableOptions) && "mrt-row-actions",
  tableOptions.positionExpandColumn === "first" && showRowExpandColumn(tableOptions) && "mrt-row-expand",
  showRowSelectionColumn(tableOptions) && "mrt-row-select",
  showRowNumbersColumn(tableOptions) && "mrt-row-numbers"
].filter(Boolean);
const getTrailingDisplayColumnIds = (tableOptions) => [
  tableOptions.positionActionsColumn === "last" && showRowActionsColumn(tableOptions) && "mrt-row-actions",
  tableOptions.positionExpandColumn === "last" && showRowExpandColumn(tableOptions) && "mrt-row-expand",
  showRowSpacerColumn(tableOptions) && "mrt-row-spacer"
].filter(Boolean);
const getDefaultColumnOrderIds = (tableOptions, reset = false) => {
  const { state: { columnOrder: currentColumnOrderIds = [] } } = tableOptions;
  const leadingDisplayColIds = getLeadingDisplayColumnIds(tableOptions);
  const trailingDisplayColIds = getTrailingDisplayColumnIds(tableOptions);
  const defaultColumnDefIds = getAllLeafColumnDefs(tableOptions.columns).map((columnDef) => getColumnId(columnDef));
  let allLeafColumnDefIds = reset ? defaultColumnDefIds : Array.from(/* @__PURE__ */ new Set([...currentColumnOrderIds, ...defaultColumnDefIds]));
  allLeafColumnDefIds = allLeafColumnDefIds.filter((colId) => !leadingDisplayColIds.includes(colId) && !trailingDisplayColIds.includes(colId));
  return [
    ...leadingDisplayColIds,
    ...allLeafColumnDefIds,
    ...trailingDisplayColIds
  ];
};
const MRT_AggregationFns = Object.assign({}, aggregationFns);
const fuzzy = (row, columnId, filterValue, addMeta) => {
  const itemRank = rankItem(row.getValue(columnId), filterValue, {
    threshold: rankings.MATCHES
  });
  addMeta(itemRank);
  return itemRank.passed;
};
fuzzy.autoRemove = (val) => !val;
const contains2 = (row, id2, filterValue) => {
  var _a2;
  return !!((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().toLowerCase().trim().includes(filterValue.toString().toLowerCase().trim()));
};
contains2.autoRemove = (val) => !val;
const startsWith = (row, id2, filterValue) => {
  var _a2;
  return !!((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().toLowerCase().trim().startsWith(filterValue.toString().toLowerCase().trim()));
};
startsWith.autoRemove = (val) => !val;
const endsWith = (row, id2, filterValue) => {
  var _a2;
  return !!((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().toLowerCase().trim().endsWith(filterValue.toString().toLowerCase().trim()));
};
endsWith.autoRemove = (val) => !val;
const equals = (row, id2, filterValue) => {
  var _a2;
  return ((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().toLowerCase().trim()) === filterValue.toString().toLowerCase().trim();
};
equals.autoRemove = (val) => !val;
const notEquals = (row, id2, filterValue) => {
  var _a2;
  return ((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().toLowerCase().trim()) !== filterValue.toString().toLowerCase().trim();
};
notEquals.autoRemove = (val) => !val;
const greaterThan = (row, id2, filterValue) => {
  var _a2, _b2, _c2;
  return !isNaN(+filterValue) && !isNaN(+row.getValue(id2)) ? +((_a2 = row.getValue(id2)) !== null && _a2 !== void 0 ? _a2 : 0) > +filterValue : ((_c2 = (_b2 = row.getValue(id2)) !== null && _b2 !== void 0 ? _b2 : "") === null || _c2 === void 0 ? void 0 : _c2.toString().toLowerCase().trim()) > filterValue.toString().toLowerCase().trim();
};
greaterThan.autoRemove = (val) => !val;
const greaterThanOrEqualTo = (row, id2, filterValue) => equals(row, id2, filterValue) || greaterThan(row, id2, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
const lessThan = (row, id2, filterValue) => {
  var _a2, _b2, _c2;
  return !isNaN(+filterValue) && !isNaN(+row.getValue(id2)) ? +((_a2 = row.getValue(id2)) !== null && _a2 !== void 0 ? _a2 : 0) < +filterValue : ((_c2 = (_b2 = row.getValue(id2)) !== null && _b2 !== void 0 ? _b2 : "") === null || _c2 === void 0 ? void 0 : _c2.toString().toLowerCase().trim()) < filterValue.toString().toLowerCase().trim();
};
lessThan.autoRemove = (val) => !val;
const lessThanOrEqualTo = (row, id2, filterValue) => equals(row, id2, filterValue) || lessThan(row, id2, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
const between = (row, id2, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThan(row, id2, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThan(row, id2, filterValues[1]));
between.autoRemove = (val) => !val;
const betweenInclusive = (row, id2, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThanOrEqualTo(row, id2, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThanOrEqualTo(row, id2, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
const empty = (row, id2, _filterValue) => {
  var _a2;
  return !((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().trim());
};
empty.autoRemove = (val) => !val;
const notEmpty = (row, id2, _filterValue) => {
  var _a2;
  return !!((_a2 = row.getValue(id2)) === null || _a2 === void 0 ? void 0 : _a2.toString().trim());
};
notEmpty.autoRemove = (val) => !val;
const MRT_FilterFns = Object.assign(Object.assign({}, filterFns), {
  between,
  betweenInclusive,
  contains: contains2,
  empty,
  endsWith,
  equals,
  fuzzy,
  greaterThan,
  greaterThanOrEqualTo,
  lessThan,
  lessThanOrEqualTo,
  notEmpty,
  notEquals,
  startsWith
});
function __rest(s3, e3) {
  var t3 = {};
  for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e3 = new Error(message);
  return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
};
const MRT_EditActionButtons = (_a2) => {
  var { row, table, variant = "icon" } = _a2, rest = __rest(_a2, ["row", "table", "variant"]);
  const { getState, options: { icons: { CancelIcon: CancelIcon2, SaveIcon }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowCancel, onEditingRowSave }, refs: { editInputRefs }, setCreatingRow, setEditingRow } = table;
  const { creatingRow, editingRow, isSaving } = getState();
  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
  const handleCancel = () => {
    if (isCreating) {
      onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
      setCreatingRow(null);
    } else if (isEditing) {
      onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
      setEditingRow(null);
    }
    row._valuesCache = {};
  };
  const handleSubmitRow = () => {
    var _a3;
    (_a3 = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current).filter((inputRef) => {
      var _a4, _b2;
      return row.id === ((_b2 = (_a4 = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a4 === void 0 ? void 0 : _a4.split("_")) === null || _b2 === void 0 ? void 0 : _b2[0]);
    })) === null || _a3 === void 0 ? void 0 : _a3.forEach((input) => {
      if (input.value !== void 0 && Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {
        row._valuesCache[input.name] = input.value;
      }
    });
    if (isCreating)
      onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({
        exitCreatingMode: () => setCreatingRow(null),
        row,
        table,
        values: row._valuesCache
      });
    else if (isEditing) {
      onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
        exitEditingMode: () => setEditingRow(null),
        row,
        table,
        values: row === null || row === void 0 ? void 0 : row._valuesCache
      });
    }
  };
  return jsxRuntimeExports.jsx(Box, { onClick: (e3) => e3.stopPropagation(), sx: (theme) => Object.assign({ display: "flex", gap: "0.75rem" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: variant === "icon" ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, { title: localization.cancel, children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.cancel, onClick: handleCancel, children: jsxRuntimeExports.jsx(CancelIcon2, {}) }) }), (isCreating && onCreatingRowSave || isEditing && onEditingRowSave) && jsxRuntimeExports.jsx(Tooltip, { title: localization.save, children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.save, color: "info", disabled: isSaving, onClick: handleSubmitRow, children: isSaving ? jsxRuntimeExports.jsx(CircularProgress, { size: 18 }) : jsxRuntimeExports.jsx(SaveIcon, {}) }) })] }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Button, { onClick: handleCancel, sx: { minWidth: "100px" }, children: localization.cancel }), jsxRuntimeExports.jsxs(Button, { disabled: isSaving, onClick: handleSubmitRow, sx: { minWidth: "100px" }, variant: "contained", children: [isSaving && jsxRuntimeExports.jsx(CircularProgress, { color: "inherit", size: 18 }), localization.save] })] }) });
};
const parseCSSVarId = (id2) => id2.replace(/[^a-zA-Z0-9]/g, "_");
const getMRTTheme = (mrtTheme, muiTheme) => {
  var _a2;
  const mrtThemeOverrides = parseFromValuesOrFunc(mrtTheme, muiTheme);
  const baseBackgroundColor = (_a2 = mrtThemeOverrides === null || mrtThemeOverrides === void 0 ? void 0 : mrtThemeOverrides.baseBackgroundColor) !== null && _a2 !== void 0 ? _a2 : muiTheme.palette.mode === "dark" ? lighten(muiTheme.palette.background.default, 0.05) : muiTheme.palette.background.default;
  return Object.assign({ baseBackgroundColor, cellNavigationOutlineColor: muiTheme.palette.primary.main, draggingBorderColor: muiTheme.palette.primary.main, matchHighlightColor: muiTheme.palette.mode === "dark" ? darken(muiTheme.palette.warning.dark, 0.25) : lighten(muiTheme.palette.warning.light, 0.5), menuBackgroundColor: lighten(baseBackgroundColor, 0.07), pinnedRowBackgroundColor: alpha(muiTheme.palette.primary.main, 0.1), selectedRowBackgroundColor: alpha(muiTheme.palette.primary.main, 0.2) }, mrtThemeOverrides);
};
const commonCellBeforeAfterStyles = {
  content: '""',
  height: "100%",
  left: 0,
  position: "absolute",
  top: 0,
  width: "100%",
  zIndex: -1
};
const getCommonPinnedCellStyles = ({ column: column2, table, theme }) => {
  const { baseBackgroundColor } = table.options.mrtTheme;
  const isPinned = column2 === null || column2 === void 0 ? void 0 : column2.getIsPinned();
  return {
    '&[data-pinned="true"]': {
      "&:before": Object.assign({ backgroundColor: alpha(darken(baseBackgroundColor, theme.palette.mode === "dark" ? 0.05 : 0.01), 0.97), boxShadow: column2 ? isPinned === "left" && column2.getIsLastColumn(isPinned) ? `-4px 0 4px -4px ${alpha(theme.palette.grey[700], 0.5)} inset` : isPinned === "right" && column2.getIsFirstColumn(isPinned) ? `4px 0 4px -4px ${alpha(theme.palette.grey[700], 0.5)} inset` : void 0 : void 0 }, commonCellBeforeAfterStyles)
    }
  };
};
const getCommonMRTCellStyles = ({ column: column2, header, table, tableCellProps, theme }) => {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const { getState, options: { enableColumnVirtualization, layoutMode } } = table;
  const { draggingColumn } = getState();
  const { columnDef } = column2;
  const { columnDefType } = columnDef;
  const isColumnPinned = columnDef.columnDefType !== "group" && column2.getIsPinned();
  const widthStyles = {
    minWidth: `max(calc(var(--${header ? "header" : "col"}-${parseCSSVarId((_a2 = header === null || header === void 0 ? void 0 : header.id) !== null && _a2 !== void 0 ? _a2 : column2.id)}-size) * 1px), ${(_b2 = columnDef.minSize) !== null && _b2 !== void 0 ? _b2 : 30}px)`,
    width: `calc(var(--${header ? "header" : "col"}-${parseCSSVarId((_c2 = header === null || header === void 0 ? void 0 : header.id) !== null && _c2 !== void 0 ? _c2 : column2.id)}-size) * 1px)`
  };
  if (layoutMode === "grid") {
    widthStyles.flex = `${[0, false].includes(columnDef.grow) ? 0 : `var(--${header ? "header" : "col"}-${parseCSSVarId((_d2 = header === null || header === void 0 ? void 0 : header.id) !== null && _d2 !== void 0 ? _d2 : column2.id)}-size)`} 0 auto`;
  } else if (layoutMode === "grid-no-grow") {
    widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;
  }
  const pinnedStyles = isColumnPinned ? Object.assign(Object.assign({}, getCommonPinnedCellStyles({ column: column2, table, theme })), { left: isColumnPinned === "left" ? `${column2.getStart("left")}px` : void 0, opacity: 0.97, position: "sticky", right: isColumnPinned === "right" ? `${column2.getAfter("right")}px` : void 0 }) : {};
  return Object.assign(Object.assign(Object.assign({ backgroundColor: "inherit", backgroundImage: "inherit", display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, justifyContent: columnDefType === "group" ? "center" : (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? tableCellProps.align : void 0, opacity: ((_e2 = table.getState().draggingColumn) === null || _e2 === void 0 ? void 0 : _e2.id) === column2.id || ((_f2 = table.getState().hoveredColumn) === null || _f2 === void 0 ? void 0 : _f2.id) === column2.id ? 0.5 : 1, position: "relative", transition: enableColumnVirtualization ? "none" : `padding 150ms ease-in-out`, zIndex: column2.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column2.id ? 2 : columnDefType !== "group" && isColumnPinned ? 1 : 0, "&:focus-visible": {
    outline: `2px solid ${table.options.mrtTheme.cellNavigationOutlineColor}`,
    outlineOffset: "-2px"
  } }, pinnedStyles), widthStyles), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme));
};
const getCommonToolbarStyles = ({ table }) => ({
  alignItems: "flex-start",
  backgroundColor: table.options.mrtTheme.baseBackgroundColor,
  display: "grid",
  flexWrap: "wrap-reverse",
  minHeight: "3.5rem",
  overflow: "hidden",
  position: "relative",
  transition: "all 150ms ease-in-out",
  zIndex: 1
});
const flipIconStyles = (theme) => theme.direction === "rtl" ? { style: { transform: "scaleX(-1)" } } : void 0;
const getCommonTooltipProps = (placement) => ({
  disableInteractive: true,
  enterDelay: 1e3,
  enterNextDelay: 1e3,
  placement
});
const MRT_ActionMenuItem = (_a2) => {
  var { icon, label, onOpenSubMenu, table } = _a2, rest = __rest(_a2, ["icon", "label", "onOpenSubMenu", "table"]);
  const { options: { icons: { ArrowRightIcon: ArrowRightIcon2 } } } = table;
  return jsxRuntimeExports.jsxs(MenuItem, Object.assign({ sx: {
    alignItems: "center",
    justifyContent: "space-between",
    minWidth: "120px",
    my: 0,
    py: "6px"
  }, tabIndex: 0 }, rest, { children: [jsxRuntimeExports.jsxs(Box, { sx: {
    alignItems: "center",
    display: "flex"
  }, children: [jsxRuntimeExports.jsx(ListItemIcon, { children: icon }), label] }), onOpenSubMenu && jsxRuntimeExports.jsx(IconButton, { onClick: onOpenSubMenu, onMouseEnter: onOpenSubMenu, size: "small", sx: { p: 0 }, children: jsxRuntimeExports.jsx(ArrowRightIcon2, {}) })] }));
};
const MRT_RowActionMenu = (_a2) => {
  var { anchorEl, handleEdit, row, setAnchorEl, staticRowIndex, table } = _a2, rest = __rest(_a2, ["anchorEl", "handleEdit", "row", "setAnchorEl", "staticRowIndex", "table"]);
  const { getState, options: { editDisplayMode, enableEditing, icons: { EditIcon }, localization, mrtTheme: { menuBackgroundColor }, renderRowActionMenuItems } } = table;
  const { density } = getState();
  const menuItems = reactExports.useMemo(() => {
    const items = [];
    const editItem = parseFromValuesOrFunc(enableEditing, row) && ["modal", "row"].includes(editDisplayMode) && jsxRuntimeExports.jsx(MRT_ActionMenuItem, { icon: jsxRuntimeExports.jsx(EditIcon, {}), label: localization.edit, onClick: handleEdit, table });
    if (editItem)
      items.push(editItem);
    const rowActionMenuItems = renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
      closeMenu: () => setAnchorEl(null),
      row,
      staticRowIndex,
      table
    });
    if (rowActionMenuItems === null || rowActionMenuItems === void 0 ? void 0 : rowActionMenuItems.length)
      items.push(...rowActionMenuItems);
    return items;
  }, [renderRowActionMenuItems, row, staticRowIndex, table]);
  if (!menuItems.length)
    return null;
  return jsxRuntimeExports.jsx(Menu, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: menuItems }));
};
const commonIconButtonStyles = {
  "&:hover": {
    opacity: 1
  },
  height: "2rem",
  ml: "10px",
  opacity: 0.5,
  transition: "opacity 150ms",
  width: "2rem"
};
const MRT_ToggleRowActionMenuButton = (_a2) => {
  var _b2;
  var { cell, row, staticRowIndex, table } = _a2, rest = __rest(_a2, ["cell", "row", "staticRowIndex", "table"]);
  const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { EditIcon, MoreHorizIcon }, localization, renderRowActionMenuItems, renderRowActions }, setEditingRow } = table;
  const { creatingRow, editingRow } = getState();
  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
  const showEditActionButtons = isCreating && createDisplayMode === "row" || isEditing && editDisplayMode === "row";
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const handleOpenRowActionMenu = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const handleStartEditMode = (event) => {
    event.stopPropagation();
    setEditingRow(Object.assign({}, row));
    setAnchorEl(null);
  };
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderRowActions && !showEditActionButtons ? renderRowActions({ cell, row, staticRowIndex, table }) : showEditActionButtons ? jsxRuntimeExports.jsx(MRT_EditActionButtons, { row, table }) : !renderRowActionMenuItems && parseFromValuesOrFunc(enableEditing, row) && ["modal", "row"].includes(editDisplayMode) ? jsxRuntimeExports.jsx(Tooltip, { placement: "right", title: localization.edit, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.edit, onClick: handleStartEditMode, sx: commonIconButtonStyles }, rest, { children: jsxRuntimeExports.jsx(EditIcon, {}) })) }) : ((_b2 = renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
    row,
    staticRowIndex,
    table
  })) === null || _b2 === void 0 ? void 0 : _b2.length) ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), { title: localization.rowActions, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.rowActions, onClick: handleOpenRowActionMenu, size: "small", sx: commonIconButtonStyles }, rest, { children: jsxRuntimeExports.jsx(MoreHorizIcon, {}) })) })), jsxRuntimeExports.jsx(MRT_RowActionMenu, { anchorEl, handleEdit: handleStartEditMode, row, setAnchorEl, staticRowIndex, table })] }) : null });
};
const getMRT_RowActionsColumnDef = (tableOptions) => {
  return Object.assign({ Cell: ({ cell, row, staticRowIndex, table }) => jsxRuntimeExports.jsx(MRT_ToggleRowActionMenuButton, { cell, row, staticRowIndex, table }) }, defaultDisplayColumnProps({
    header: "actions",
    id: "mrt-row-actions",
    size: 70,
    tableOptions
  }));
};
const MRT_GrabHandleButton = (_a2) => {
  var _b2, _c2;
  var { location, table } = _a2, rest = __rest(_a2, ["location", "table"]);
  const { options: { icons: { DragHandleIcon }, localization } } = table;
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps("top"), { title: (_b2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b2 !== void 0 ? _b2 : localization.move, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": (_c2 = rest.title) !== null && _c2 !== void 0 ? _c2 : localization.move, disableRipple: true, draggable: "true", size: "small" }, rest, { onClick: (e3) => {
    var _a3;
    e3.stopPropagation();
    (_a3 = rest === null || rest === void 0 ? void 0 : rest.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(rest, e3);
  }, sx: (theme) => Object.assign({ "&:active": {
    cursor: "grabbing"
  }, "&:hover": {
    backgroundColor: "transparent",
    opacity: 1
  }, cursor: "grab", m: "0 -0.1rem", opacity: location === "row" ? 1 : 0.5, p: "2px", transition: "all 150ms ease-in-out" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), title: void 0, children: jsxRuntimeExports.jsx(DragHandleIcon, {}) })) }));
};
const MRT_TableBodyRowGrabHandle = (_a2) => {
  var { row, rowRef, table } = _a2, rest = __rest(_a2, ["row", "rowRef", "table"]);
  const { options: { muiRowDragHandleProps } } = table;
  const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiRowDragHandleProps, {
    row,
    table
  })), rest);
  const handleDragStart = (event) => {
    var _a3;
    (_a3 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a3 === void 0 ? void 0 : _a3.call(iconButtonProps, event);
    try {
      event.dataTransfer.setDragImage(rowRef.current, 0, 0);
    } catch (e3) {
      console.error(e3);
    }
    table.setDraggingRow(row);
  };
  const handleDragEnd = (event) => {
    var _a3;
    (_a3 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a3 === void 0 ? void 0 : _a3.call(iconButtonProps, event);
    table.setDraggingRow(null);
    table.setHoveredRow(null);
  };
  return jsxRuntimeExports.jsx(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, { location: "row", onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }));
};
const getMRT_RowDragColumnDef = (tableOptions) => {
  return Object.assign({ Cell: ({ row, rowRef, table }) => jsxRuntimeExports.jsx(MRT_TableBodyRowGrabHandle, { row, rowRef, table }), grow: false }, defaultDisplayColumnProps({
    header: "move",
    id: "mrt-row-drag",
    size: 60,
    tableOptions
  }));
};
const MRT_ExpandAllButton = (_a2) => {
  var _b2, _c2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getCanSomeRowsExpand, getIsAllRowsExpanded, getIsSomeRowsExpanded, getState, options: { icons: { KeyboardDoubleArrowDownIcon }, localization, muiExpandAllButtonProps, renderDetailPanel }, toggleAllRowsExpanded } = table;
  const { density, isLoading } = getState();
  const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiExpandAllButtonProps, {
    table
  })), rest);
  const isAllRowsExpanded = getIsAllRowsExpanded();
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), { title: (_b2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b2 !== void 0 ? _b2 : isAllRowsExpanded ? localization.collapseAll : localization.expandAll, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.expandAll, disabled: isLoading || !renderDetailPanel && !getCanSomeRowsExpand(), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded) }, iconButtonProps, { sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", mt: density !== "compact" ? "-0.25rem" : void 0, width: density === "compact" ? "1.75rem" : "2.25rem" }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)), title: void 0, children: (_c2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c2 !== void 0 ? _c2 : jsxRuntimeExports.jsx(KeyboardDoubleArrowDownIcon, { style: {
    transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,
    transition: "transform 150ms"
  } }) })) }) }));
};
const MRT_ExpandButton = ({ row, staticRowIndex, table }) => {
  var _a2, _b2;
  const theme = useTheme();
  const { getState, options: { icons: { ExpandMoreIcon }, localization, muiExpandButtonProps, positionExpandColumn, renderDetailPanel } } = table;
  const { density } = getState();
  const iconButtonProps = parseFromValuesOrFunc(muiExpandButtonProps, {
    row,
    staticRowIndex,
    table
  });
  const canExpand = row.getCanExpand();
  const isExpanded = row.getIsExpanded();
  const handleToggleExpand = (event) => {
    var _a3;
    event.stopPropagation();
    row.toggleExpanded();
    (_a3 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(iconButtonProps, event);
  };
  const detailPanel = !!(renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({ disableHoverListener: !canExpand && !detailPanel }, getCommonTooltipProps(), { title: (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a2 !== void 0 ? _a2 : isExpanded ? localization.collapse : localization.expand, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.expand, disabled: !canExpand && !detailPanel }, iconButtonProps, { onClick: handleToggleExpand, sx: (theme2) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", opacity: !canExpand && !detailPanel ? 0.3 : 1, [theme2.direction === "rtl" || positionExpandColumn === "last" ? "mr" : "ml"]: `${row.depth * 16}px`, width: density === "compact" ? "1.75rem" : "2.25rem" }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme2)), title: void 0, children: (_b2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _b2 !== void 0 ? _b2 : jsxRuntimeExports.jsx(ExpandMoreIcon, { style: {
    transform: `rotate(${!canExpand && !renderDetailPanel ? positionExpandColumn === "last" || theme.direction === "rtl" ? 90 : -90 : isExpanded ? -180 : 0}deg)`,
    transition: "transform 150ms"
  } }) })) }) }));
};
const getMRT_RowExpandColumnDef = (tableOptions) => {
  var _a2;
  const { defaultColumn, enableExpandAll, groupedColumnMode, positionExpandColumn, renderDetailPanel, state: { grouping } } = tableOptions;
  const alignProps = positionExpandColumn === "last" ? {
    align: "right"
  } : void 0;
  return Object.assign({ Cell: ({ cell, column: column2, row, staticRowIndex, table }) => {
    var _a3, _b2, _c2;
    const expandButtonProps = { row, staticRowIndex, table };
    const subRowsLength = (_a3 = row.subRows) === null || _a3 === void 0 ? void 0 : _a3.length;
    if (groupedColumnMode === "remove" && row.groupingColumnId) {
      return jsxRuntimeExports.jsxs(Stack, { alignItems: "center", flexDirection: "row", gap: "0.25rem", children: [jsxRuntimeExports.jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps("right"), { title: table.getColumn(row.groupingColumnId).columnDef.header, children: jsxRuntimeExports.jsx("span", { children: row.groupingValue }) })), !!subRowsLength && jsxRuntimeExports.jsxs("span", { children: ["(", subRowsLength, ")"] })] });
    } else {
      return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (_c2 = (_b2 = column2.columnDef).GroupedCell) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, { cell, column: column2, row, table })] });
    }
  }, Header: enableExpandAll ? ({ table }) => {
    var _a3;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(MRT_ExpandAllButton, { table }), groupedColumnMode === "remove" && ((_a3 = grouping === null || grouping === void 0 ? void 0 : grouping.map((groupedColumnId) => table.getColumn(groupedColumnId).columnDef.header)) === null || _a3 === void 0 ? void 0 : _a3.join(", "))] });
  } : void 0, muiTableBodyCellProps: alignProps, muiTableHeadCellProps: alignProps }, defaultDisplayColumnProps({
    header: "expand",
    id: "mrt-row-expand",
    size: groupedColumnMode === "remove" ? (_a2 = defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.size) !== null && _a2 !== void 0 ? _a2 : 180 : renderDetailPanel ? enableExpandAll ? 60 : 70 : 100,
    tableOptions
  }));
};
const getMRT_RowNumbersColumnDef = (tableOptions) => {
  const { localization, rowNumberDisplayMode } = tableOptions;
  const { pagination: { pageIndex, pageSize: pageSize2 } } = tableOptions.state;
  return Object.assign({ Cell: ({ row, staticRowIndex }) => {
    var _a2;
    return ((_a2 = rowNumberDisplayMode === "static" ? (staticRowIndex || 0) + (pageSize2 || 0) * (pageIndex || 0) : row.index) !== null && _a2 !== void 0 ? _a2 : 0) + 1;
  }, Header: () => localization.rowNumber, grow: false }, defaultDisplayColumnProps({
    header: "rowNumbers",
    id: "mrt-row-numbers",
    size: 50,
    tableOptions
  }));
};
const MRT_RowPinButton = (_a2) => {
  var { pinningPosition, row, table } = _a2, rest = __rest(_a2, ["pinningPosition", "row", "table"]);
  const { options: { icons: { CloseIcon: CloseIcon2, PushPinIcon }, localization, rowPinningDisplayMode } } = table;
  const isPinned = row.getIsPinned();
  const [tooltipOpened, setTooltipOpened] = reactExports.useState(false);
  const handleTogglePin = (event) => {
    setTooltipOpened(false);
    event.stopPropagation();
    row.pin(isPinned ? false : pinningPosition);
  };
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), { open: tooltipOpened, title: isPinned ? localization.unpin : localization.pin, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.pin, onBlur: () => setTooltipOpened(false), onClick: handleTogglePin, onFocus: () => setTooltipOpened(true), onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: "small" }, rest, { sx: (theme) => Object.assign({ height: "24px", width: "24px" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: isPinned ? jsxRuntimeExports.jsx(CloseIcon2, {}) : jsxRuntimeExports.jsx(PushPinIcon, { fontSize: "small", style: {
    transform: `rotate(${rowPinningDisplayMode === "sticky" ? 135 : pinningPosition === "top" ? 180 : 0}deg)`
  } }) })) }));
};
const MRT_TableBodyRowPinButton = (_a2) => {
  var { row, table } = _a2, rest = __rest(_a2, ["row", "table"]);
  const { getState, options: { enableRowPinning, rowPinningDisplayMode } } = table;
  const { density } = getState();
  const canPin = parseFromValuesOrFunc(enableRowPinning, row);
  if (!canPin)
    return null;
  const rowPinButtonProps = Object.assign({
    row,
    table
  }, rest);
  if (rowPinningDisplayMode === "top-and-bottom" && !row.getIsPinned()) {
    return jsxRuntimeExports.jsxs(Box, { sx: {
      display: "flex",
      flexDirection: density === "compact" ? "row" : "column"
    }, children: [jsxRuntimeExports.jsx(MRT_RowPinButton, Object.assign({ pinningPosition: "top" }, rowPinButtonProps)), jsxRuntimeExports.jsx(MRT_RowPinButton, Object.assign({ pinningPosition: "bottom" }, rowPinButtonProps))] });
  }
  return jsxRuntimeExports.jsx(MRT_RowPinButton, Object.assign({ pinningPosition: rowPinningDisplayMode === "bottom" ? "bottom" : "top" }, rowPinButtonProps));
};
const getMRT_RowPinningColumnDef = (tableOptions) => {
  return Object.assign({ Cell: ({ row, table }) => jsxRuntimeExports.jsx(MRT_TableBodyRowPinButton, { row, table }), grow: false }, defaultDisplayColumnProps({
    header: "pin",
    id: "mrt-row-pin",
    size: 60,
    tableOptions
  }));
};
const MRT_SelectCheckbox = (_a2) => {
  var _b2;
  var { row, staticRowIndex, table } = _a2, rest = __rest(_a2, ["row", "staticRowIndex", "table"]);
  const { getState, options: { enableMultiRowSelection, localization, muiSelectAllCheckboxProps, muiSelectCheckboxProps, selectAllMode } } = table;
  const { density, isLoading } = getState();
  const selectAll = !row;
  const allRowsSelected = selectAll ? selectAllMode === "page" ? table.getIsAllPageRowsSelected() : table.getIsAllRowsSelected() : void 0;
  const isChecked = selectAll ? allRowsSelected : getIsRowSelected({ row, table });
  const checkboxProps = Object.assign(Object.assign({}, selectAll ? parseFromValuesOrFunc(muiSelectAllCheckboxProps, { table }) : parseFromValuesOrFunc(muiSelectCheckboxProps, {
    row,
    staticRowIndex,
    table
  })), rest);
  const onSelectionChange = row ? getMRT_RowSelectionHandler({
    row,
    staticRowIndex,
    table
  }) : void 0;
  const onSelectAllChange = getMRT_SelectAllHandler({ table });
  const commonProps = Object.assign(Object.assign({ "aria-label": selectAll ? localization.toggleSelectAll : localization.toggleSelectRow, checked: isChecked, disabled: isLoading || row && !row.getCanSelect() || (row === null || row === void 0 ? void 0 : row.id) === "mrt-row-create", inputProps: {
    "aria-label": selectAll ? localization.toggleSelectAll : localization.toggleSelectRow
  }, onChange: (event) => {
    event.stopPropagation();
    selectAll ? onSelectAllChange(event) : onSelectionChange(event);
  }, size: density === "compact" ? "small" : "medium" }, checkboxProps), { onClick: (e3) => {
    var _a3;
    e3.stopPropagation();
    (_a3 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(checkboxProps, e3);
  }, sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.5rem", m: density !== "compact" ? "-0.4rem" : void 0, width: density === "compact" ? "1.75rem" : "2.5rem", zIndex: 0 }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme)), title: void 0 });
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), { title: (_b2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b2 !== void 0 ? _b2 : selectAll ? localization.toggleSelectAll : localization.toggleSelectRow, children: enableMultiRowSelection === false ? jsxRuntimeExports.jsx(Radio, Object.assign({}, commonProps)) : jsxRuntimeExports.jsx(Checkbox, Object.assign({ indeterminate: !isChecked && selectAll ? table.getIsSomeRowsSelected() : (row === null || row === void 0 ? void 0 : row.getIsSomeSelected()) && row.getCanSelectSubRows() }, commonProps)) }));
};
const getMRT_RowSelectColumnDef = (tableOptions) => {
  const { enableMultiRowSelection, enableSelectAll } = tableOptions;
  return Object.assign({ Cell: ({ row, staticRowIndex, table }) => jsxRuntimeExports.jsx(MRT_SelectCheckbox, { row, staticRowIndex, table }), Header: enableSelectAll && enableMultiRowSelection ? ({ table }) => jsxRuntimeExports.jsx(MRT_SelectCheckbox, { table }) : void 0, grow: false }, defaultDisplayColumnProps({
    header: "select",
    id: "mrt-row-select",
    size: enableSelectAll ? 60 : 70,
    tableOptions
  }));
};
const MRT_Default_Icons = {
  ArrowDownwardIcon: default_1$x,
  ArrowRightIcon: default_1$w,
  CancelIcon: default_1$v,
  ChevronLeftIcon: default_1$u,
  ChevronRightIcon: default_1$t,
  ClearAllIcon: default_1$s,
  CloseIcon: default_1$r,
  ContentCopy: default_1$q,
  DensityLargeIcon: default_1$p,
  DensityMediumIcon: default_1$o,
  DensitySmallIcon: default_1$n,
  DragHandleIcon: default_1$m,
  DynamicFeedIcon: default_1$l,
  EditIcon: default_1$y,
  ExpandMoreIcon: default_1$k,
  FilterAltIcon: default_1$j,
  FilterListIcon: default_1$i,
  FilterListOffIcon: default_1$h,
  FirstPageIcon: default_1$g,
  FullscreenExitIcon: default_1$e,
  FullscreenIcon: default_1$f,
  KeyboardDoubleArrowDownIcon: default_1$d,
  LastPageIcon: default_1$c,
  MoreHorizIcon: default_1$b,
  MoreVertIcon: default_1$a,
  PushPinIcon: default_1$9,
  RestartAltIcon: default_1$8,
  SaveIcon: default_1$7,
  SearchIcon: default_1$6,
  SearchOffIcon: default_1$5,
  SortIcon: default_1$4,
  SyncAltIcon: default_1$3,
  ViewColumnIcon: default_1$2,
  VisibilityOffIcon: default_1$1
};
const MRT_Localization_EN = {
  actions: "Actions",
  and: "and",
  cancel: "Cancel",
  changeFilterMode: "Change filter mode",
  changeSearchMode: "Change search mode",
  clearFilter: "Clear filter",
  clearSearch: "Clear search",
  clearSelection: "Clear selection",
  clearSort: "Clear sort",
  clickToCopy: "Click to copy",
  copy: "Copy",
  collapse: "Collapse",
  collapseAll: "Collapse all",
  columnActions: "Column Actions",
  copiedToClipboard: "Copied to clipboard",
  dropToGroupBy: "Drop to group by {column}",
  edit: "Edit",
  expand: "Expand",
  expandAll: "Expand all",
  filterArrIncludes: "Includes",
  filterArrIncludesAll: "Includes all",
  filterArrIncludesSome: "Includes",
  filterBetween: "Between",
  filterBetweenInclusive: "Between Inclusive",
  filterByColumn: "Filter by {column}",
  filterContains: "Contains",
  filterEmpty: "Empty",
  filterEndsWith: "Ends With",
  filterEquals: "Equals",
  filterEqualsString: "Equals",
  filterFuzzy: "Fuzzy",
  filterGreaterThan: "Greater Than",
  filterGreaterThanOrEqualTo: "Greater Than Or Equal To",
  filterInNumberRange: "Between",
  filterIncludesString: "Contains",
  filterIncludesStringSensitive: "Contains",
  filterLessThan: "Less Than",
  filterLessThanOrEqualTo: "Less Than Or Equal To",
  filterMode: "Filter Mode: {filterType}",
  filterNotEmpty: "Not Empty",
  filterNotEquals: "Not Equals",
  filterStartsWith: "Starts With",
  filterWeakEquals: "Equals",
  filteringByColumn: "Filtering by {column} - {filterType} {filterValue}",
  goToFirstPage: "Go to first page",
  goToLastPage: "Go to last page",
  goToNextPage: "Go to next page",
  goToPreviousPage: "Go to previous page",
  grab: "Grab",
  groupByColumn: "Group by {column}",
  groupedBy: "Grouped by ",
  hideAll: "Hide all",
  hideColumn: "Hide {column} column",
  max: "Max",
  min: "Min",
  move: "Move",
  noRecordsToDisplay: "No records to display",
  noResultsFound: "No results found",
  of: "of",
  or: "or",
  pin: "Pin",
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  resetColumnSize: "Reset column size",
  resetOrder: "Reset order",
  rowActions: "Row Actions",
  rowNumber: "#",
  rowNumbers: "Row Numbers",
  rowsPerPage: "Rows per page",
  save: "Save",
  search: "Search",
  selectedCountOfRowCountRowsSelected: "{selectedCount} of {rowCount} row(s) selected",
  select: "Select",
  showAll: "Show all",
  showAllColumns: "Show all columns",
  showHideColumns: "Show/Hide columns",
  showHideFilters: "Show/Hide filters",
  showHideSearch: "Show/Hide search",
  sortByColumnAsc: "Sort by {column} ascending",
  sortByColumnDesc: "Sort by {column} descending",
  sortedByColumnAsc: "Sorted by {column} ascending",
  sortedByColumnDesc: "Sorted by {column} descending",
  thenBy: ", then by ",
  toggleDensity: "Toggle density",
  toggleFullScreen: "Toggle full screen",
  toggleSelectAll: "Toggle select all",
  toggleSelectRow: "Toggle select row",
  toggleVisibility: "Toggle visibility",
  ungroupByColumn: "Ungroup by {column}",
  unpin: "Unpin",
  unpinAll: "Unpin all"
};
const MRT_DefaultColumn = {
  filterVariant: "text",
  maxSize: 1e3,
  minSize: 40,
  size: 180
};
const MRT_DefaultDisplayColumn = {
  columnDefType: "display",
  enableClickToCopy: false,
  enableColumnActions: false,
  enableColumnDragging: false,
  enableColumnFilter: false,
  enableColumnOrdering: false,
  enableEditing: false,
  enableGlobalFilter: false,
  enableGrouping: false,
  enableHiding: false,
  enableResizing: false,
  enableSorting: false
};
const useMRT_TableOptions = (_a2) => {
  var _b2;
  var { aggregationFns: aggregationFns2, autoResetExpanded = false, columnFilterDisplayMode = "subheader", columnResizeDirection, columnResizeMode = "onChange", createDisplayMode = "modal", defaultColumn, defaultDisplayColumn, editDisplayMode = "modal", enableBatchRowSelection = true, enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnPinning = false, enableColumnResizing = false, enableColumnVirtualization, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFacetedValues = false, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableKeyboardShortcuts = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enableRowPinning = false, enableRowSelection = false, enableRowVirtualization, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns: filterFns2, icons, id: id2 = reactExports.useId(), layoutMode, localization, manualFiltering, manualGrouping, manualPagination, manualSorting, mrtTheme, paginationDisplayMode = "default", positionActionsColumn = "first", positionCreatingRow = "top", positionExpandColumn = "first", positionGlobalFilter = "right", positionPagination = "bottom", positionToolbarAlertBanner = "top", positionToolbarDropZone = "top", rowNumberDisplayMode = "static", rowPinningDisplayMode = "sticky", selectAllMode = "page", sortingFns: sortingFns2 } = _a2, rest = __rest(_a2, ["aggregationFns", "autoResetExpanded", "columnFilterDisplayMode", "columnResizeDirection", "columnResizeMode", "createDisplayMode", "defaultColumn", "defaultDisplayColumn", "editDisplayMode", "enableBatchRowSelection", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnPinning", "enableColumnResizing", "enableColumnVirtualization", "enableDensityToggle", "enableExpandAll", "enableExpanding", "enableFacetedValues", "enableFilterMatchHighlighting", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableKeyboardShortcuts", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enableRowPinning", "enableRowSelection", "enableRowVirtualization", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "id", "layoutMode", "localization", "manualFiltering", "manualGrouping", "manualPagination", "manualSorting", "mrtTheme", "paginationDisplayMode", "positionActionsColumn", "positionCreatingRow", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberDisplayMode", "rowPinningDisplayMode", "selectAllMode", "sortingFns"]);
  const theme = useTheme();
  icons = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_Default_Icons), icons), [icons]);
  localization = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_Localization_EN), localization), [localization]);
  mrtTheme = reactExports.useMemo(() => getMRTTheme(mrtTheme, theme), [mrtTheme, theme]);
  aggregationFns2 = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns2), []);
  filterFns2 = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_FilterFns), filterFns2), []);
  sortingFns2 = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_SortingFns), sortingFns2), []);
  defaultColumn = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn), [defaultColumn]);
  defaultDisplayColumn = reactExports.useMemo(() => Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn), [defaultDisplayColumn]);
  [enableColumnVirtualization, enableRowVirtualization] = reactExports.useMemo(() => [enableColumnVirtualization, enableRowVirtualization], []);
  if (!columnResizeDirection) {
    columnResizeDirection = theme.direction || "ltr";
  }
  layoutMode = layoutMode || (enableColumnResizing ? "grid-no-grow" : "semantic");
  if (layoutMode === "semantic" && (enableRowVirtualization || enableColumnVirtualization)) {
    layoutMode = "grid";
  }
  if (enableRowVirtualization) {
    enableStickyHeader = true;
  }
  if (enablePagination === false && manualPagination === void 0) {
    manualPagination = true;
  }
  if (!((_b2 = rest.data) === null || _b2 === void 0 ? void 0 : _b2.length)) {
    manualFiltering = true;
    manualGrouping = true;
    manualPagination = true;
    manualSorting = true;
  }
  return Object.assign({
    aggregationFns: aggregationFns2,
    autoResetExpanded,
    columnFilterDisplayMode,
    columnResizeDirection,
    columnResizeMode,
    createDisplayMode,
    defaultColumn,
    defaultDisplayColumn,
    editDisplayMode,
    enableBatchRowSelection,
    enableBottomToolbar,
    enableColumnActions,
    enableColumnFilters,
    enableColumnOrdering,
    enableColumnPinning,
    enableColumnResizing,
    enableColumnVirtualization,
    enableDensityToggle,
    enableExpandAll,
    enableExpanding,
    enableFacetedValues,
    enableFilterMatchHighlighting,
    enableFilters,
    enableFullScreenToggle,
    enableGlobalFilter,
    enableGlobalFilterRankedResults,
    enableGrouping,
    enableHiding,
    enableKeyboardShortcuts,
    enableMultiRowSelection,
    enableMultiSort,
    enablePagination,
    enableRowPinning,
    enableRowSelection,
    enableRowVirtualization,
    enableSelectAll,
    enableSorting,
    enableStickyHeader,
    enableTableFooter,
    enableTableHead,
    enableToolbarInternalActions,
    enableTopToolbar,
    filterFns: filterFns2,
    getCoreRowModel: getCoreRowModel(),
    getExpandedRowModel: enableExpanding || enableGrouping ? getExpandedRowModel() : void 0,
    getFacetedMinMaxValues: enableFacetedValues ? getFacetedMinMaxValues() : void 0,
    getFacetedRowModel: enableFacetedValues ? getFacetedRowModel() : void 0,
    getFacetedUniqueValues: enableFacetedValues ? getFacetedUniqueValues() : void 0,
    getFilteredRowModel: (enableColumnFilters || enableGlobalFilter || enableFilters) && !manualFiltering ? getFilteredRowModel() : void 0,
    getGroupedRowModel: enableGrouping && !manualGrouping ? getGroupedRowModel() : void 0,
    getPaginationRowModel: enablePagination && !manualPagination ? getPaginationRowModel() : void 0,
    getSortedRowModel: enableSorting && !manualSorting ? getSortedRowModel() : void 0,
    getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows,
    icons,
    id: id2,
    layoutMode,
    localization,
    manualFiltering,
    manualGrouping,
    manualPagination,
    manualSorting,
    mrtTheme,
    paginationDisplayMode,
    positionActionsColumn,
    positionCreatingRow,
    positionExpandColumn,
    positionGlobalFilter,
    positionPagination,
    positionToolbarAlertBanner,
    positionToolbarDropZone,
    rowNumberDisplayMode,
    rowPinningDisplayMode,
    selectAllMode,
    sortingFns: sortingFns2
  }, rest);
};
const blankColProps = {
  children: null,
  sx: {
    minWidth: 0,
    p: 0,
    width: 0
  }
};
const getMRT_RowSpacerColumnDef = (tableOptions) => {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumnProps({
    id: "mrt-row-spacer",
    size: 0,
    tableOptions
  })), { grow: true }), MRT_DefaultDisplayColumn), { muiTableBodyCellProps: blankColProps, muiTableFooterCellProps: blankColProps, muiTableHeadCellProps: blankColProps });
};
const useMRT_Effects = (table) => {
  const { getIsSomeRowsPinned, getPrePaginationRowModel, getState, options: { enablePagination, enableRowPinning, rowCount } } = table;
  const { columnOrder, density, globalFilter, isFullScreen, isLoading, pagination, showSkeletons, sorting } = getState();
  const totalColumnCount = table.options.columns.length;
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
  const rerender = reactExports.useReducer(() => ({}), {})[1];
  const initialBodyHeight = reactExports.useRef();
  const previousTop = reactExports.useRef();
  reactExports.useEffect(() => {
    if (typeof window !== "undefined") {
      initialBodyHeight.current = document.body.style.height;
    }
  }, []);
  reactExports.useEffect(() => {
    if (typeof window !== "undefined") {
      if (isFullScreen) {
        previousTop.current = document.body.getBoundingClientRect().top;
        document.body.style.height = "100dvh";
      } else {
        document.body.style.height = initialBodyHeight.current;
        if (!previousTop.current)
          return;
        window.scrollTo({
          behavior: "instant",
          top: -1 * previousTop.current
        });
      }
    }
  }, [isFullScreen]);
  reactExports.useEffect(() => {
    if (totalColumnCount !== columnOrder.length) {
      table.setColumnOrder(getDefaultColumnOrderIds(table.options));
    }
  }, [totalColumnCount]);
  reactExports.useEffect(() => {
    if (!enablePagination || isLoading || showSkeletons)
      return;
    const { pageIndex, pageSize: pageSize2 } = pagination;
    const firstVisibleRowIndex = pageIndex * pageSize2;
    if (firstVisibleRowIndex >= totalRowCount) {
      table.setPageIndex(Math.ceil(totalRowCount / pageSize2) - 1);
    }
  }, [totalRowCount]);
  const appliedSort = reactExports.useRef(sorting);
  reactExports.useEffect(() => {
    if (sorting.length) {
      appliedSort.current = sorting;
    }
  }, [sorting]);
  reactExports.useEffect(() => {
    if (!getCanRankRows(table))
      return;
    if (globalFilter) {
      table.setSorting([]);
    } else {
      table.setSorting(() => appliedSort.current || []);
    }
  }, [globalFilter]);
  reactExports.useEffect(() => {
    if (enableRowPinning && getIsSomeRowsPinned()) {
      setTimeout(() => {
        rerender();
      }, 150);
    }
  }, [density]);
};
const useMRT_TableInstance = (definedTableOptions) => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k, _l, _m, _o, _p, _q, _r, _s, _t2, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
  const lastSelectedRowId = reactExports.useRef(null);
  const actionCellRef = reactExports.useRef(null);
  const bottomToolbarRef = reactExports.useRef(null);
  const editInputRefs = reactExports.useRef({});
  const filterInputRefs = reactExports.useRef({});
  const searchInputRef = reactExports.useRef(null);
  const tableContainerRef = reactExports.useRef(null);
  const tableHeadCellRefs = reactExports.useRef({});
  const tablePaperRef = reactExports.useRef(null);
  const topToolbarRef = reactExports.useRef(null);
  const tableHeadRef = reactExports.useRef(null);
  const tableFooterRef = reactExports.useRef(null);
  const initialState2 = reactExports.useMemo(() => {
    var _a3, _b3, _c3;
    const initState = (_a3 = definedTableOptions.initialState) !== null && _a3 !== void 0 ? _a3 : {};
    initState.columnOrder = (_b3 = initState.columnOrder) !== null && _b3 !== void 0 ? _b3 : getDefaultColumnOrderIds(Object.assign(Object.assign({}, definedTableOptions), { state: Object.assign(Object.assign({}, definedTableOptions.initialState), definedTableOptions.state) }));
    initState.globalFilterFn = (_c3 = definedTableOptions.globalFilterFn) !== null && _c3 !== void 0 ? _c3 : "fuzzy";
    return initState;
  }, []);
  definedTableOptions.initialState = initialState2;
  const [actionCell, setActionCell] = reactExports.useState((_a2 = initialState2.actionCell) !== null && _a2 !== void 0 ? _a2 : null);
  const [creatingRow, _setCreatingRow] = reactExports.useState((_b2 = initialState2.creatingRow) !== null && _b2 !== void 0 ? _b2 : null);
  const [columnFilterFns, setColumnFilterFns] = reactExports.useState(() => Object.assign({}, ...getAllLeafColumnDefs(definedTableOptions.columns).map((col) => {
    var _a3, _b3, _c3, _d3;
    return {
      [getColumnId(col)]: col.filterFn instanceof Function ? (_a3 = col.filterFn.name) !== null && _a3 !== void 0 ? _a3 : "custom" : (_d3 = (_b3 = col.filterFn) !== null && _b3 !== void 0 ? _b3 : (_c3 = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.columnFilterFns) === null || _c3 === void 0 ? void 0 : _c3[getColumnId(col)]) !== null && _d3 !== void 0 ? _d3 : getDefaultColumnFilterFn(col)
    };
  })));
  const [columnOrder, onColumnOrderChange] = reactExports.useState((_c2 = initialState2.columnOrder) !== null && _c2 !== void 0 ? _c2 : []);
  const [columnSizingInfo, onColumnSizingInfoChange] = reactExports.useState((_d2 = initialState2.columnSizingInfo) !== null && _d2 !== void 0 ? _d2 : {});
  const [density, setDensity] = reactExports.useState((_e2 = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.density) !== null && _e2 !== void 0 ? _e2 : "comfortable");
  const [draggingColumn, setDraggingColumn] = reactExports.useState((_f2 = initialState2.draggingColumn) !== null && _f2 !== void 0 ? _f2 : null);
  const [draggingRow, setDraggingRow] = reactExports.useState((_g2 = initialState2.draggingRow) !== null && _g2 !== void 0 ? _g2 : null);
  const [editingCell, setEditingCell] = reactExports.useState((_h2 = initialState2.editingCell) !== null && _h2 !== void 0 ? _h2 : null);
  const [editingRow, setEditingRow] = reactExports.useState((_j2 = initialState2.editingRow) !== null && _j2 !== void 0 ? _j2 : null);
  const [globalFilterFn, setGlobalFilterFn] = reactExports.useState((_k = initialState2.globalFilterFn) !== null && _k !== void 0 ? _k : "fuzzy");
  const [grouping, onGroupingChange] = reactExports.useState((_l = initialState2.grouping) !== null && _l !== void 0 ? _l : []);
  const [hoveredColumn, setHoveredColumn] = reactExports.useState((_m = initialState2.hoveredColumn) !== null && _m !== void 0 ? _m : null);
  const [hoveredRow, setHoveredRow] = reactExports.useState((_o = initialState2.hoveredRow) !== null && _o !== void 0 ? _o : null);
  const [isFullScreen, setIsFullScreen] = reactExports.useState((_p = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.isFullScreen) !== null && _p !== void 0 ? _p : false);
  const [pagination, onPaginationChange] = reactExports.useState((_q = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.pagination) !== null && _q !== void 0 ? _q : { pageIndex: 0, pageSize: 10 });
  const [showAlertBanner, setShowAlertBanner] = reactExports.useState((_r = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.showAlertBanner) !== null && _r !== void 0 ? _r : false);
  const [showColumnFilters, setShowColumnFilters] = reactExports.useState((_s = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.showColumnFilters) !== null && _s !== void 0 ? _s : false);
  const [showGlobalFilter, setShowGlobalFilter] = reactExports.useState((_t2 = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.showGlobalFilter) !== null && _t2 !== void 0 ? _t2 : false);
  const [showToolbarDropZone, setShowToolbarDropZone] = reactExports.useState((_u = initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.showToolbarDropZone) !== null && _u !== void 0 ? _u : false);
  definedTableOptions.state = Object.assign({
    actionCell,
    columnFilterFns,
    columnOrder,
    columnSizingInfo,
    creatingRow,
    density,
    draggingColumn,
    draggingRow,
    editingCell,
    editingRow,
    globalFilterFn,
    grouping,
    hoveredColumn,
    hoveredRow,
    isFullScreen,
    pagination,
    showAlertBanner,
    showColumnFilters,
    showGlobalFilter,
    showToolbarDropZone
  }, definedTableOptions.state);
  const statefulTableOptions = definedTableOptions;
  const columnDefsRef = reactExports.useRef([]);
  statefulTableOptions.columns = statefulTableOptions.state.columnSizingInfo.isResizingColumn || statefulTableOptions.state.draggingColumn || statefulTableOptions.state.draggingRow ? columnDefsRef.current : prepareColumns({
    columnDefs: [
      ...[
        showRowPinningColumn(statefulTableOptions) && getMRT_RowPinningColumnDef(statefulTableOptions),
        showRowDragColumn(statefulTableOptions) && getMRT_RowDragColumnDef(statefulTableOptions),
        showRowActionsColumn(statefulTableOptions) && getMRT_RowActionsColumnDef(statefulTableOptions),
        showRowExpandColumn(statefulTableOptions) && getMRT_RowExpandColumnDef(statefulTableOptions),
        showRowSelectionColumn(statefulTableOptions) && getMRT_RowSelectColumnDef(statefulTableOptions),
        showRowNumbersColumn(statefulTableOptions) && getMRT_RowNumbersColumnDef(statefulTableOptions)
      ].filter(Boolean),
      ...statefulTableOptions.columns,
      ...[
        showRowSpacerColumn(statefulTableOptions) && getMRT_RowSpacerColumnDef(statefulTableOptions)
      ].filter(Boolean)
    ],
    tableOptions: statefulTableOptions
  });
  columnDefsRef.current = statefulTableOptions.columns;
  statefulTableOptions.data = reactExports.useMemo(() => (statefulTableOptions.state.isLoading || statefulTableOptions.state.showSkeletons) && !statefulTableOptions.data.length ? [
    ...Array(Math.min(statefulTableOptions.state.pagination.pageSize, 20)).fill(null)
  ].map(() => Object.assign({}, ...getAllLeafColumnDefs(statefulTableOptions.columns).map((col) => ({
    [getColumnId(col)]: null
  })))) : statefulTableOptions.data, [
    statefulTableOptions.data,
    statefulTableOptions.state.isLoading,
    statefulTableOptions.state.showSkeletons
  ]);
  const table = useReactTable(Object.assign(Object.assign({
    onColumnOrderChange,
    onColumnSizingInfoChange,
    onGroupingChange,
    onPaginationChange
  }, statefulTableOptions), { globalFilterFn: (_v = statefulTableOptions.filterFns) === null || _v === void 0 ? void 0 : _v[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : "fuzzy"] }));
  table.refs = {
    actionCellRef,
    bottomToolbarRef,
    editInputRefs,
    filterInputRefs,
    lastSelectedRowId,
    searchInputRef,
    tableContainerRef,
    tableFooterRef,
    tableHeadCellRefs,
    tableHeadRef,
    tablePaperRef,
    topToolbarRef
  };
  table.setActionCell = (_w = statefulTableOptions.onActionCellChange) !== null && _w !== void 0 ? _w : setActionCell;
  table.setCreatingRow = (row) => {
    var _a3, _b3;
    let _row = row;
    if (row === true) {
      _row = createRow(table);
    }
    (_b3 = (_a3 = statefulTableOptions === null || statefulTableOptions === void 0 ? void 0 : statefulTableOptions.onCreatingRowChange) === null || _a3 === void 0 ? void 0 : _a3.call(statefulTableOptions, _row)) !== null && _b3 !== void 0 ? _b3 : _setCreatingRow(_row);
  };
  table.setColumnFilterFns = (_x = statefulTableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;
  table.setDensity = (_y = statefulTableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;
  table.setDraggingColumn = (_z = statefulTableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;
  table.setDraggingRow = (_0 = statefulTableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;
  table.setEditingCell = (_1 = statefulTableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;
  table.setEditingRow = (_2 = statefulTableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;
  table.setGlobalFilterFn = (_3 = statefulTableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;
  table.setHoveredColumn = (_4 = statefulTableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;
  table.setHoveredRow = (_5 = statefulTableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;
  table.setIsFullScreen = (_6 = statefulTableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;
  table.setShowAlertBanner = (_7 = statefulTableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;
  table.setShowColumnFilters = (_8 = statefulTableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;
  table.setShowGlobalFilter = (_9 = statefulTableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;
  table.setShowToolbarDropZone = (_10 = statefulTableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;
  useMRT_Effects(table);
  return table;
};
const useMaterialReactTable = (tableOptions) => useMRT_TableInstance(useMRT_TableOptions(tableOptions));
const extraIndexRangeExtractor = (range, draggingIndex) => {
  const newIndexes = defaultRangeExtractor(range);
  if (draggingIndex === void 0)
    return newIndexes;
  if (draggingIndex >= 0 && draggingIndex < Math.max(range.startIndex - range.overscan, 0)) {
    newIndexes.unshift(draggingIndex);
  }
  if (draggingIndex >= 0 && draggingIndex > range.endIndex + range.overscan) {
    newIndexes.push(draggingIndex);
  }
  return newIndexes;
};
const useMRT_ColumnVirtualizer = (table) => {
  var _a2, _b2, _c2, _d2;
  const { getState, options: { columnVirtualizerInstanceRef, columnVirtualizerOptions, enableColumnPinning, enableColumnVirtualization }, refs: { tableContainerRef } } = table;
  const { columnPinning, columnVisibility, draggingColumn } = getState();
  if (!enableColumnVirtualization)
    return void 0;
  const columnVirtualizerProps = parseFromValuesOrFunc(columnVirtualizerOptions, {
    table
  });
  const visibleColumns = table.getVisibleLeafColumns();
  const [leftPinnedIndexes, rightPinnedIndexes] = reactExports.useMemo(() => enableColumnPinning ? [
    table.getLeftVisibleLeafColumns().map((c3) => c3.getPinnedIndex()),
    table.getRightVisibleLeafColumns().map((column2) => visibleColumns.length - column2.getPinnedIndex() - 1).sort((a3, b3) => a3 - b3)
  ] : [[], []], [columnPinning, columnVisibility, enableColumnPinning]);
  const numPinnedLeft = leftPinnedIndexes.length;
  const numPinnedRight = rightPinnedIndexes.length;
  const draggingColumnIndex = reactExports.useMemo(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) ? visibleColumns.findIndex((c3) => c3.id === (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) : void 0, [draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id]);
  const columnVirtualizer = useVirtualizer(Object.assign({ count: visibleColumns.length, estimateSize: (index) => visibleColumns[index].getSize(), getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: reactExports.useCallback((range) => {
    const newIndexes = extraIndexRangeExtractor(range, draggingColumnIndex);
    if (!numPinnedLeft && !numPinnedRight) {
      return newIndexes;
    }
    return [
      .../* @__PURE__ */ new Set([
        ...leftPinnedIndexes,
        ...newIndexes,
        ...rightPinnedIndexes
      ])
    ];
  }, [leftPinnedIndexes, rightPinnedIndexes, draggingColumnIndex]) }, columnVirtualizerProps));
  const virtualColumns = columnVirtualizer.getVirtualItems();
  columnVirtualizer.virtualColumns = virtualColumns;
  const numColumns = virtualColumns.length;
  if (numColumns) {
    const totalSize = columnVirtualizer.getTotalSize();
    const leftNonPinnedStart = ((_a2 = virtualColumns[numPinnedLeft]) === null || _a2 === void 0 ? void 0 : _a2.start) || 0;
    const leftNonPinnedEnd = ((_b2 = virtualColumns[leftPinnedIndexes.length - 1]) === null || _b2 === void 0 ? void 0 : _b2.end) || 0;
    const rightNonPinnedStart = ((_c2 = virtualColumns[numColumns - numPinnedRight]) === null || _c2 === void 0 ? void 0 : _c2.start) || 0;
    const rightNonPinnedEnd = ((_d2 = virtualColumns[numColumns - numPinnedRight - 1]) === null || _d2 === void 0 ? void 0 : _d2.end) || 0;
    columnVirtualizer.virtualPaddingLeft = leftNonPinnedStart - leftNonPinnedEnd;
    columnVirtualizer.virtualPaddingRight = totalSize - rightNonPinnedEnd - (numPinnedRight ? totalSize - rightNonPinnedStart : 0);
  }
  if (columnVirtualizerInstanceRef) {
    columnVirtualizerInstanceRef.current = columnVirtualizer;
  }
  return columnVirtualizer;
};
const useMRT_RowVirtualizer = (table, rows) => {
  var _a2;
  const { getRowModel, getState, options: { enableRowVirtualization, renderDetailPanel, rowVirtualizerInstanceRef, rowVirtualizerOptions }, refs: { tableContainerRef } } = table;
  const { density, draggingRow, expanded } = getState();
  if (!enableRowVirtualization)
    return void 0;
  const rowVirtualizerProps = parseFromValuesOrFunc(rowVirtualizerOptions, {
    table
  });
  const rowCount = (_a2 = rows === null || rows === void 0 ? void 0 : rows.length) !== null && _a2 !== void 0 ? _a2 : getRowModel().rows.length;
  const normalRowHeight = density === "compact" ? 37 : density === "comfortable" ? 58 : 73;
  const rowVirtualizer = useVirtualizer(Object.assign({ count: renderDetailPanel ? rowCount * 2 : rowCount, estimateSize: (index) => renderDetailPanel && index % 2 === 1 ? expanded === true ? 100 : 0 : normalRowHeight, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== "undefined" && navigator.userAgent.indexOf("Firefox") === -1 ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height : void 0, overscan: 4, rangeExtractor: reactExports.useCallback((range) => {
    var _a3;
    return extraIndexRangeExtractor(range, (_a3 = draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.index) !== null && _a3 !== void 0 ? _a3 : 0);
  }, [draggingRow]) }, rowVirtualizerProps));
  rowVirtualizer.virtualRows = rowVirtualizer.getVirtualItems();
  if (rowVirtualizerInstanceRef) {
    rowVirtualizerInstanceRef.current = rowVirtualizer;
  }
  return rowVirtualizer;
};
const useMRT_Rows = (table) => {
  const { getRowModel, getState, options: { data, enableGlobalFilterRankedResults, positionCreatingRow } } = table;
  const { creatingRow, expanded, globalFilter, pagination, rowPinning, sorting } = getState();
  const rows = reactExports.useMemo(() => getMRT_Rows(table), [
    creatingRow,
    data,
    enableGlobalFilterRankedResults,
    expanded,
    getRowModel().rows,
    globalFilter,
    pagination.pageIndex,
    pagination.pageSize,
    positionCreatingRow,
    rowPinning,
    sorting
  ]);
  return rows;
};
const allowedTypes = ["string", "number"];
const MRT_TableBodyCellValue = ({ cell, rowRef, staticColumnIndex, staticRowIndex, table }) => {
  var _a2, _b2, _c2;
  const { getState, options: { enableFilterMatchHighlighting, mrtTheme: { matchHighlightColor } } } = table;
  const { column: column2, row } = cell;
  const { columnDef } = column2;
  const { globalFilter, globalFilterFn } = getState();
  const filterValue = column2.getFilterValue();
  let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell ? columnDef.AggregatedCell({
    cell,
    column: column2,
    row,
    table,
    staticColumnIndex,
    staticRowIndex
  }) : row.getIsGrouped() && !cell.getIsGrouped() ? null : cell.getIsGrouped() && columnDef.GroupedCell ? columnDef.GroupedCell({
    cell,
    column: column2,
    row,
    table,
    staticColumnIndex,
    staticRowIndex
  }) : void 0;
  const isGroupedValue = renderedCellValue !== void 0;
  if (!isGroupedValue) {
    renderedCellValue = cell.renderValue();
  }
  if (enableFilterMatchHighlighting && columnDef.enableFilterMatchHighlighting !== false && String(renderedCellValue) && allowedTypes.includes(typeof renderedCellValue) && (filterValue && allowedTypes.includes(typeof filterValue) && ["autocomplete", "text"].includes(columnDef.filterVariant) || globalFilter && allowedTypes.includes(typeof globalFilter) && column2.getCanGlobalFilter())) {
    const chunks = highlightWords === null || highlightWords === void 0 ? void 0 : highlightWords({
      matchExactly: (filterValue ? columnDef._filterFn : globalFilterFn) !== "fuzzy",
      query: ((_a2 = filterValue !== null && filterValue !== void 0 ? filterValue : globalFilter) !== null && _a2 !== void 0 ? _a2 : "").toString(),
      text: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString()
    });
    if ((chunks === null || chunks === void 0 ? void 0 : chunks.length) > 1 || ((_b2 = chunks === null || chunks === void 0 ? void 0 : chunks[0]) === null || _b2 === void 0 ? void 0 : _b2.match)) {
      renderedCellValue = jsxRuntimeExports.jsx("span", { "aria-label": renderedCellValue, role: "note", children: (_c2 = chunks === null || chunks === void 0 ? void 0 : chunks.map(({ key, match: match2, text: text2 }) => jsxRuntimeExports.jsx(Box, { "aria-hidden": "true", component: "span", sx: match2 ? {
        backgroundColor: matchHighlightColor,
        borderRadius: "2px",
        color: (theme) => theme.palette.mode === "dark" ? theme.palette.common.white : theme.palette.common.black,
        padding: "2px 1px"
      } : void 0, children: text2 }, key))) !== null && _c2 !== void 0 ? _c2 : renderedCellValue });
    }
  }
  if (columnDef.Cell && !isGroupedValue) {
    renderedCellValue = columnDef.Cell({
      cell,
      column: column2,
      renderedCellValue,
      row,
      rowRef,
      staticColumnIndex,
      staticRowIndex,
      table
    });
  }
  return renderedCellValue;
};
const MRT_CopyButton = (_a2) => {
  var _b2;
  var { cell, table } = _a2, rest = __rest(_a2, ["cell", "table"]);
  const { options: { localization, muiCopyButtonProps } } = table;
  const { column: column2, row } = cell;
  const { columnDef } = column2;
  const [copied, setCopied] = reactExports.useState(false);
  const handleCopy = (event, text2) => {
    event.stopPropagation();
    navigator.clipboard.writeText(text2);
    setCopied(true);
    setTimeout(() => setCopied(false), 4e3);
  };
  const buttonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCopyButtonProps, {
    cell,
    column: column2,
    row,
    table
  })), parseFromValuesOrFunc(columnDef.muiCopyButtonProps, {
    cell,
    column: column2,
    row,
    table
  })), rest);
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps("top"), { title: (_b2 = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _b2 !== void 0 ? _b2 : copied ? localization.copiedToClipboard : localization.clickToCopy, children: jsxRuntimeExports.jsx(Button, Object.assign({ onClick: (e3) => handleCopy(e3, cell.getValue()), size: "small", type: "button", variant: "text" }, buttonProps, { sx: (theme) => Object.assign({ backgroundColor: "transparent", border: "none", color: "inherit", cursor: "copy", fontFamily: "inherit", fontSize: "inherit", letterSpacing: "inherit", m: "-0.25rem", minWidth: "unset", py: 0, textAlign: "inherit", textTransform: "inherit" }, parseFromValuesOrFunc(buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx, theme)), title: void 0 })) }));
};
const MRT_EditCellTextField = (_a2) => {
  var _b2, _c2;
  var { cell, table } = _a2, rest = __rest(_a2, ["cell", "table"]);
  const { getState, options: { createDisplayMode, editDisplayMode, muiEditTextFieldProps }, refs: { editInputRefs }, setCreatingRow, setEditingCell, setEditingRow } = table;
  const { column: column2, row } = cell;
  const { columnDef } = column2;
  const { creatingRow, editingRow } = getState();
  const { editSelectOptions, editVariant } = columnDef;
  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
  const [value, setValue2] = reactExports.useState(() => cell.getValue());
  const [completesComposition, setCompletesComposition] = reactExports.useState(true);
  const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditTextFieldProps, {
    cell,
    column: column2,
    row,
    table
  })), parseFromValuesOrFunc(columnDef.muiEditTextFieldProps, {
    cell,
    column: column2,
    row,
    table
  })), rest);
  const selectOptions = parseFromValuesOrFunc(editSelectOptions, {
    cell,
    column: column2,
    row,
    table
  });
  const isSelectEdit = editVariant === "select" || (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.select);
  const saveInputValueToRowCache = (newValue) => {
    row._valuesCache[column2.id] = newValue;
    if (isCreating) {
      setCreatingRow(row);
    } else if (isEditing) {
      setEditingRow(row);
    }
  };
  const handleChange = (event) => {
    var _a3;
    (_a3 = textFieldProps.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(textFieldProps, event);
    setValue2(event.target.value);
    if (isSelectEdit) {
      saveInputValueToRowCache(event.target.value);
    }
  };
  const handleBlur = (event) => {
    var _a3;
    (_a3 = textFieldProps.onBlur) === null || _a3 === void 0 ? void 0 : _a3.call(textFieldProps, event);
    saveInputValueToRowCache(value);
    setEditingCell(null);
  };
  const handleEnterKeyDown = (event) => {
    var _a3, _b3;
    (_a3 = textFieldProps.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(textFieldProps, event);
    if (event.key === "Enter" && !event.shiftKey && completesComposition) {
      (_b3 = editInputRefs.current[column2.id]) === null || _b3 === void 0 ? void 0 : _b3.blur();
    }
  };
  if (columnDef.Edit) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: (_b2 = columnDef.Edit) === null || _b2 === void 0 ? void 0 : _b2.call(columnDef, { cell, column: column2, row, table }) });
  }
  return jsxRuntimeExports.jsx(TextField, Object.assign({ disabled: parseFromValuesOrFunc(columnDef.enableEditing, row) === false, fullWidth: true, inputRef: (inputRef) => {
    if (inputRef) {
      editInputRefs.current[column2.id] = inputRef;
      if (textFieldProps.inputRef) {
        textFieldProps.inputRef = inputRef;
      }
    }
  }, label: ["custom", "modal"].includes(isCreating ? createDisplayMode : editDisplayMode) ? columnDef.header : void 0, margin: "none", name: column2.id, placeholder: !["custom", "modal"].includes(isCreating ? createDisplayMode : editDisplayMode) ? columnDef.header : void 0, select: isSelectEdit, size: "small", value: value !== null && value !== void 0 ? value : "", variant: "standard" }, textFieldProps, { InputProps: Object.assign(Object.assign(Object.assign({}, textFieldProps.variant !== "outlined" ? { disableUnderline: editDisplayMode === "table" } : {}), textFieldProps.InputProps), { sx: (theme) => {
    var _a3;
    return Object.assign({ mb: 0 }, parseFromValuesOrFunc((_a3 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a3 === void 0 ? void 0 : _a3.sx, theme));
  } }), SelectProps: Object.assign({ MenuProps: { disableScrollLock: true } }, textFieldProps.SelectProps), inputProps: Object.assign({ autoComplete: "new-password" }, textFieldProps.inputProps), onBlur: handleBlur, onChange: handleChange, onClick: (e3) => {
    var _a3;
    e3.stopPropagation();
    (_a3 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(textFieldProps, e3);
  }, onKeyDown: handleEnterKeyDown, onCompositionStart: () => setCompletesComposition(false), onCompositionEnd: () => setCompletesComposition(true), children: (_c2 = textFieldProps.children) !== null && _c2 !== void 0 ? _c2 : selectOptions === null || selectOptions === void 0 ? void 0 : selectOptions.map((option) => {
    const { label, value: value2 } = getValueAndLabel(option);
    return jsxRuntimeExports.jsx(MenuItem, { sx: {
      alignItems: "center",
      display: "flex",
      gap: "0.5rem",
      m: 0
    }, value: value2, children: label }, value2);
  }) }));
};
const MRT_TableBodyCell = (_a2) => {
  var _b2, _c2, _d2, _e2, _f2;
  var { cell, numRows, rowRef, staticColumnIndex, staticRowIndex, table } = _a2, rest = __rest(_a2, ["cell", "numRows", "rowRef", "staticColumnIndex", "staticRowIndex", "table"]);
  const theme = useTheme();
  const { getState, options: { columnResizeDirection, columnResizeMode, createDisplayMode, editDisplayMode, enableCellActions, enableClickToCopy, enableColumnOrdering, enableColumnPinning, enableGrouping, enableKeyboardShortcuts, layoutMode, mrtTheme: { draggingBorderColor }, muiSkeletonProps, muiTableBodyCellProps }, setHoveredColumn } = table;
  const { actionCell, columnSizingInfo, creatingRow, density, draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, isLoading, showSkeletons } = getState();
  const { column: column2, row } = cell;
  const { columnDef } = column2;
  const { columnDefType } = columnDef;
  const args = { cell, column: column2, row, table };
  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableBodyCellProps, args)), rest);
  const skeletonProps = parseFromValuesOrFunc(muiSkeletonProps, {
    cell,
    column: column2,
    row,
    table
  });
  const [skeletonWidth, setSkeletonWidth] = reactExports.useState(100);
  reactExports.useEffect(() => {
    if (!isLoading && !showSkeletons || skeletonWidth !== 100)
      return;
    const size2 = column2.getSize();
    setSkeletonWidth(columnDefType === "display" ? size2 / 2 : Math.round(Math.random() * (size2 - size2 / 3) + size2 / 3));
  }, [isLoading, showSkeletons]);
  const draggingBorders = reactExports.useMemo(() => {
    const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column2.id;
    const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column2.id;
    const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
    const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
    const isFirstColumn = column2.getIsFirstColumn();
    const isLastColumn = column2.getIsLastColumn();
    const isLastRow = numRows && staticRowIndex === numRows - 1;
    const isResizingColumn = columnSizingInfo.isResizingColumn === column2.id;
    const showResizeBorder = isResizingColumn && columnResizeMode === "onChange";
    const borderStyle = showResizeBorder ? `2px solid ${draggingBorderColor} !important` : isDraggingColumn || isDraggingRow ? `1px dashed ${theme.palette.grey[500]} !important` : isHoveredColumn || isHoveredRow || isResizingColumn ? `2px dashed ${draggingBorderColor} !important` : void 0;
    if (showResizeBorder) {
      return columnResizeDirection === "ltr" ? { borderRight: borderStyle } : { borderLeft: borderStyle };
    }
    return borderStyle ? {
      borderBottom: isDraggingRow || isHoveredRow || isLastRow && !isResizingColumn ? borderStyle : void 0,
      borderLeft: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isFirstColumn ? borderStyle : void 0,
      borderRight: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isLastColumn ? borderStyle : void 0,
      borderTop: isDraggingRow || isHoveredRow ? borderStyle : void 0
    } : void 0;
  }, [
    columnSizingInfo.isResizingColumn,
    draggingColumn,
    draggingRow,
    hoveredColumn,
    hoveredRow,
    staticRowIndex
  ]);
  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== "group" && column2.getIsPinned();
  const isEditable = isCellEditable({ cell, table });
  const isEditing = isEditable && !["custom", "modal"].includes(editDisplayMode) && (editDisplayMode === "table" || (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id || (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) && !row.getIsGrouped();
  const isCreating = isEditable && createDisplayMode === "row" && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const showClickToCopyButton = (parseFromValuesOrFunc(enableClickToCopy, cell) === true || parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === true) && !["context-menu", false].includes(
    // @ts-ignore
    parseFromValuesOrFunc(columnDef.enableClickToCopy, cell)
  );
  const isRightClickable = parseFromValuesOrFunc(enableCellActions, cell);
  const cellValueProps = {
    cell,
    table,
    staticColumnIndex,
    staticRowIndex
  };
  const handleDoubleClick = (event) => {
    var _a3;
    (_a3 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a3 === void 0 ? void 0 : _a3.call(tableCellProps, event);
    openEditingCell({ cell, table });
  };
  const handleDragEnter = (e3) => {
    var _a3;
    (_a3 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a3 === void 0 ? void 0 : _a3.call(tableCellProps, e3);
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn) {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column2 : null);
    }
  };
  const handleDragOver = (e3) => {
    if (columnDef.enableColumnOrdering !== false) {
      e3.preventDefault();
    }
  };
  const handleContextMenu = (e3) => {
    var _a3;
    (_a3 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onContextMenu) === null || _a3 === void 0 ? void 0 : _a3.call(tableCellProps, e3);
    if (isRightClickable) {
      e3.preventDefault();
      table.setActionCell(cell);
      table.refs.actionCellRef.current = e3.currentTarget;
    }
  };
  const handleKeyDown = (event) => {
    var _a3;
    cellKeyboardShortcuts({
      cell,
      cellValue: cell.getValue(),
      event,
      table
    });
    (_a3 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(tableCellProps, event);
  };
  return jsxRuntimeExports.jsx(TableCell, Object.assign({ align: theme.direction === "rtl" ? "right" : "left", "data-index": staticColumnIndex, "data-pinned": !!isColumnPinned || void 0, tabIndex: enableKeyboardShortcuts ? 0 : void 0 }, tableCellProps, { onKeyDown: handleKeyDown, onContextMenu: handleContextMenu, onDoubleClick: handleDoubleClick, onDragEnter: handleDragEnter, onDragOver: handleDragOver, sx: (theme2) => Object.assign(Object.assign({ "&:hover": {
    outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id || editDisplayMode === "cell" && isEditable || editDisplayMode === "table" && (isCreating || isEditing) ? `1px solid ${theme2.palette.grey[500]}` : void 0,
    textOverflow: "clip"
  }, alignItems: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "center" : void 0, cursor: isRightClickable ? "context-menu" : isEditable && editDisplayMode === "cell" ? "pointer" : "inherit", outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id ? `1px solid ${theme2.palette.grey[500]}` : void 0, outlineOffset: "-1px", overflow: "hidden", p: density === "compact" ? columnDefType === "display" ? "0 0.5rem" : "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.5rem 0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", textOverflow: columnDefType !== "display" ? "ellipsis" : void 0, whiteSpace: row.getIsPinned() || density === "compact" ? "nowrap" : "normal" }, getCommonMRTCellStyles({
    column: column2,
    table,
    tableCellProps,
    theme: theme2
  })), draggingBorders), children: (_b2 = tableCellProps.children) !== null && _b2 !== void 0 ? _b2 : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [cell.getIsPlaceholder() ? (_d2 = (_c2 = columnDef.PlaceholderCell) === null || _c2 === void 0 ? void 0 : _c2.call(columnDef, { cell, column: column2, row, table })) !== null && _d2 !== void 0 ? _d2 : null : showSkeletons !== false && (isLoading || showSkeletons) ? jsxRuntimeExports.jsx(Skeleton, Object.assign({ animation: "wave", height: 20, width: skeletonWidth }, skeletonProps)) : columnDefType === "display" && (["mrt-row-expand", "mrt-row-numbers", "mrt-row-select"].includes(column2.id) || !row.getIsGrouped()) ? (_e2 = columnDef.Cell) === null || _e2 === void 0 ? void 0 : _e2.call(columnDef, {
    cell,
    column: column2,
    renderedCellValue: cell.renderValue(),
    row,
    rowRef,
    staticColumnIndex,
    staticRowIndex,
    table
  }) : isCreating || isEditing ? jsxRuntimeExports.jsx(MRT_EditCellTextField, { cell, table }) : showClickToCopyButton && columnDef.enableClickToCopy !== false ? jsxRuntimeExports.jsx(MRT_CopyButton, { cell, table, children: jsxRuntimeExports.jsx(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)) }) : jsxRuntimeExports.jsx(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)), cell.getIsGrouped() && !columnDef.GroupedCell && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [" (", (_f2 = row.subRows) === null || _f2 === void 0 ? void 0 : _f2.length, ")"] })] }) }));
};
const Memo_MRT_TableBodyCell = reactExports.memo(MRT_TableBodyCell, (prev2, next2) => next2.cell === prev2.cell);
const MRT_TableDetailPanel = (_a2) => {
  var { parentRowRef, row, rowVirtualizer, staticRowIndex, table, virtualRow } = _a2, rest = __rest(_a2, ["parentRowRef", "row", "rowVirtualizer", "staticRowIndex", "table", "virtualRow"]);
  const { getState, getVisibleLeafColumns, options: { layoutMode, mrtTheme: { baseBackgroundColor }, muiDetailPanelProps, muiTableBodyRowProps, renderDetailPanel } } = table;
  const { isLoading } = getState();
  const tableRowProps = parseFromValuesOrFunc(muiTableBodyRowProps, {
    isDetailPanel: true,
    row,
    staticRowIndex,
    table
  });
  const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiDetailPanelProps, {
    row,
    table
  })), rest);
  const DetailPanel = !isLoading && (renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));
  return jsxRuntimeExports.jsx(TableRow, Object.assign({ className: "Mui-TableBodyCell-DetailPanel", "data-index": renderDetailPanel ? staticRowIndex * 2 + 1 : staticRowIndex, ref: (node2) => {
    var _a3;
    if (node2) {
      (_a3 = rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement) === null || _a3 === void 0 ? void 0 : _a3.call(rowVirtualizer, node2);
    }
  } }, tableRowProps, { sx: (theme) => {
    var _a3, _b2;
    return Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, position: virtualRow ? "absolute" : void 0, top: virtualRow ? `${(_b2 = (_a3 = parentRowRef.current) === null || _a3 === void 0 ? void 0 : _a3.getBoundingClientRect()) === null || _b2 === void 0 ? void 0 : _b2.height}px` : void 0, transform: virtualRow ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)` : void 0, width: "100%" }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme));
  }, children: jsxRuntimeExports.jsx(TableCell, Object.assign({ className: "Mui-TableBodyCell-DetailPanel", colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => Object.assign({ backgroundColor: virtualRow ? baseBackgroundColor : void 0, borderBottom: !row.getIsExpanded() ? "none" : void 0, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, py: !!DetailPanel && row.getIsExpanded() ? "1rem" : 0, transition: !virtualRow ? "all 150ms ease-in-out" : void 0, width: `100%` }, parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme)), children: virtualRow ? row.getIsExpanded() && DetailPanel : jsxRuntimeExports.jsx(Collapse, { in: row.getIsExpanded(), mountOnEnter: true, unmountOnExit: true, children: DetailPanel }) })) }));
};
const MRT_TableBodyRow = (_a2) => {
  var _b2, _c2, _d2, _f2;
  var { columnVirtualizer, numRows, pinnedRowIds, row, rowVirtualizer, staticRowIndex, table, virtualRow } = _a2, rest = __rest(_a2, ["columnVirtualizer", "numRows", "pinnedRowIds", "row", "rowVirtualizer", "staticRowIndex", "table", "virtualRow"]);
  const theme = useTheme();
  const { getState, options: { enableRowOrdering, enableRowPinning, enableStickyFooter, enableStickyHeader, layoutMode, memoMode, mrtTheme: { baseBackgroundColor, pinnedRowBackgroundColor, selectedRowBackgroundColor }, muiTableBodyRowProps, renderDetailPanel, rowPinningDisplayMode }, refs: { tableFooterRef, tableHeadRef }, setHoveredRow } = table;
  const { density, draggingColumn, draggingRow, editingCell, editingRow, hoveredRow, isFullScreen, rowPinning } = getState();
  const visibleCells = row.getVisibleCells();
  const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
  const isRowSelected2 = getIsRowSelected({ row, table });
  const isRowPinned = enableRowPinning && row.getIsPinned();
  const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
  const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyRowProps, {
    row,
    staticRowIndex,
    table
  })), rest);
  const [bottomPinnedIndex, topPinnedIndex] = reactExports.useMemo(() => {
    if (!enableRowPinning || !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) || !pinnedRowIds || !row.getIsPinned())
      return [];
    return [
      [...pinnedRowIds].reverse().indexOf(row.id),
      pinnedRowIds.indexOf(row.id)
    ];
  }, [pinnedRowIds, rowPinning]);
  const tableHeadHeight = (enableStickyHeader || isFullScreen) && ((_b2 = tableHeadRef.current) === null || _b2 === void 0 ? void 0 : _b2.clientHeight) || 0;
  const tableFooterHeight = enableStickyFooter && ((_c2 = tableFooterRef.current) === null || _c2 === void 0 ? void 0 : _c2.clientHeight) || 0;
  const sx = parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme);
  const defaultRowHeight = density === "compact" ? 37 : density === "comfortable" ? 53 : 69;
  const customRowHeight = (
    // @ts-ignore
    parseInt((_f2 = (_d2 = tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style) === null || _d2 === void 0 ? void 0 : _d2.height) !== null && _f2 !== void 0 ? _f2 : sx === null || sx === void 0 ? void 0 : sx.height, 10) || void 0
  );
  const rowHeight = customRowHeight || defaultRowHeight;
  const handleDragEnter = (_e2) => {
    if (enableRowOrdering && draggingRow) {
      setHoveredRow(row);
    }
  };
  const handleDragOver = (e3) => {
    e3.preventDefault();
  };
  const rowRef = reactExports.useRef(null);
  const cellHighlightColor = isRowSelected2 ? selectedRowBackgroundColor : isRowPinned ? pinnedRowBackgroundColor : void 0;
  const cellHighlightColorHover = (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false ? isRowSelected2 ? cellHighlightColor : theme.palette.mode === "dark" ? `${lighten(baseBackgroundColor, 0.3)}` : `${darken(baseBackgroundColor, 0.3)}` : void 0;
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs(TableRow, Object.assign({ "data-index": renderDetailPanel ? staticRowIndex * 2 : staticRowIndex, "data-pinned": !!isRowPinned || void 0, "data-selected": isRowSelected2 || void 0, onDragEnter: handleDragEnter, onDragOver: handleDragOver, ref: (node2) => {
    if (node2) {
      rowRef.current = node2;
      rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement(node2);
    }
  }, selected: isRowSelected2 }, tableRowProps, { style: Object.assign({ transform: virtualRow ? `translateY(${virtualRow.start}px)` : void 0 }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style), sx: (theme2) => Object.assign({ "&:hover td:after": cellHighlightColorHover ? Object.assign({ backgroundColor: alpha(cellHighlightColorHover, 0.3) }, commonCellBeforeAfterStyles) : void 0, backgroundColor: `${baseBackgroundColor} !important`, bottom: !virtualRow && bottomPinnedIndex !== void 0 && isRowPinned ? `${bottomPinnedIndex * rowHeight + (enableStickyFooter ? tableFooterHeight - 1 : 0)}px` : void 0, boxSizing: "border-box", display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, opacity: isRowPinned ? 0.97 : isDraggingRow || isHoveredRow ? 0.5 : 1, position: virtualRow ? "absolute" : (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && isRowPinned ? "sticky" : "relative", td: Object.assign({}, getCommonPinnedCellStyles({ table, theme: theme2 })), "td:after": cellHighlightColor ? Object.assign({ backgroundColor: cellHighlightColor }, commonCellBeforeAfterStyles) : void 0, top: virtualRow ? 0 : topPinnedIndex !== void 0 && isRowPinned ? `${topPinnedIndex * rowHeight + (enableStickyHeader || isFullScreen ? tableHeadHeight - 1 : 0)}px` : void 0, transition: virtualRow ? "none" : "all 150ms ease-in-out", width: "100%", zIndex: (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && isRowPinned ? 2 : 0 }, sx), children: [virtualPaddingLeft ? jsxRuntimeExports.jsx("td", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : visibleCells).map((cellOrVirtualCell, staticColumnIndex) => {
    let cell = cellOrVirtualCell;
    if (columnVirtualizer) {
      staticColumnIndex = cellOrVirtualCell.index;
      cell = visibleCells[staticColumnIndex];
    }
    const props = {
      cell,
      numRows,
      rowRef,
      staticColumnIndex,
      staticRowIndex,
      table
    };
    const key = `${cell.id}-${staticRowIndex}`;
    return cell ? memoMode === "cells" && cell.column.columnDef.columnDefType === "data" && !draggingColumn && !draggingRow && (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id && (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? jsxRuntimeExports.jsx(Memo_MRT_TableBodyCell, Object.assign({}, props), key) : jsxRuntimeExports.jsx(MRT_TableBodyCell, Object.assign({}, props), key) : null;
  }), virtualPaddingRight ? jsxRuntimeExports.jsx("td", { style: { display: "flex", width: virtualPaddingRight } }) : null] })), renderDetailPanel && !row.getIsGrouped() && jsxRuntimeExports.jsx(MRT_TableDetailPanel, { parentRowRef: rowRef, row, rowVirtualizer, staticRowIndex, table, virtualRow })] });
};
const Memo_MRT_TableBodyRow = reactExports.memo(MRT_TableBodyRow, (prev2, next2) => prev2.row === next2.row && prev2.staticRowIndex === next2.staticRowIndex);
const MRT_TableBody = (_a2) => {
  var _b2, _c2, _d2, _e2, _f2, _g2;
  var { columnVirtualizer, table } = _a2, rest = __rest(_a2, ["columnVirtualizer", "table"]);
  const { getBottomRows, getIsSomeRowsPinned, getRowModel, getState, getTopRows, options: { enableStickyFooter, enableStickyHeader, layoutMode, localization, memoMode, muiTableBodyProps, renderDetailPanel, renderEmptyRowsFallback, rowPinningDisplayMode }, refs: { tableFooterRef, tableHeadRef, tablePaperRef } } = table;
  const { columnFilters, globalFilter, isFullScreen, rowPinning } = getState();
  const tableBodyProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyProps, { table })), rest);
  const tableHeadHeight = (enableStickyHeader || isFullScreen) && ((_b2 = tableHeadRef.current) === null || _b2 === void 0 ? void 0 : _b2.clientHeight) || 0;
  const tableFooterHeight = enableStickyFooter && ((_c2 = tableFooterRef.current) === null || _c2 === void 0 ? void 0 : _c2.clientHeight) || 0;
  const pinnedRowIds = reactExports.useMemo(() => {
    var _a3, _b3;
    if (!((_a3 = rowPinning.bottom) === null || _a3 === void 0 ? void 0 : _a3.length) && !((_b3 = rowPinning.top) === null || _b3 === void 0 ? void 0 : _b3.length))
      return [];
    return getRowModel().rows.filter((row) => row.getIsPinned()).map((r2) => r2.id);
  }, [rowPinning, getRowModel().rows]);
  const rows = useMRT_Rows(table);
  const rowVirtualizer = useMRT_RowVirtualizer(table, rows);
  const { virtualRows } = rowVirtualizer !== null && rowVirtualizer !== void 0 ? rowVirtualizer : {};
  const commonRowProps = {
    columnVirtualizer,
    numRows: rows.length,
    table
  };
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [!(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && getIsSomeRowsPinned("top") && jsxRuntimeExports.jsx(TableBody, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, position: "sticky", top: tableHeadHeight - 1, zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)), children: getTopRows().map((row, staticRowIndex) => {
    const props = Object.assign(Object.assign({}, commonRowProps), {
      row,
      staticRowIndex
    });
    return memoMode === "rows" ? jsxRuntimeExports.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : jsxRuntimeExports.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id);
  }) })), jsxRuntimeExports.jsx(TableBody, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, height: rowVirtualizer ? `${rowVirtualizer.getTotalSize()}px` : void 0, minHeight: !rows.length ? "100px" : void 0, position: "relative" }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)), children: (_d2 = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _d2 !== void 0 ? _d2 : !rows.length ? jsxRuntimeExports.jsx("tr", { style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0
  }, children: jsxRuntimeExports.jsx("td", { colSpan: table.getVisibleLeafColumns().length, style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0
  }, children: (_e2 = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _e2 !== void 0 ? _e2 : jsxRuntimeExports.jsx(Typography, { sx: {
    color: "text.secondary",
    fontStyle: "italic",
    maxWidth: `min(100vw, ${(_g2 = (_f2 = tablePaperRef.current) === null || _f2 === void 0 ? void 0 : _f2.clientWidth) !== null && _g2 !== void 0 ? _g2 : 360}px)`,
    py: "2rem",
    textAlign: "center",
    width: "100%"
  }, children: globalFilter || columnFilters.length ? localization.noResultsFound : localization.noRecordsToDisplay }) }) }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, staticRowIndex) => {
    let row = rowOrVirtualRow;
    if (rowVirtualizer) {
      if (renderDetailPanel) {
        if (rowOrVirtualRow.index % 2 === 1) {
          return null;
        } else {
          staticRowIndex = rowOrVirtualRow.index / 2;
        }
      } else {
        staticRowIndex = rowOrVirtualRow.index;
      }
      row = rows[staticRowIndex];
    }
    const props = Object.assign(Object.assign({}, commonRowProps), {
      pinnedRowIds,
      row,
      rowVirtualizer,
      staticRowIndex,
      virtualRow: rowVirtualizer ? rowOrVirtualRow : void 0
    });
    const key = `${row.id}-${row.index}`;
    return memoMode === "rows" ? jsxRuntimeExports.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), key) : jsxRuntimeExports.jsx(MRT_TableBodyRow, Object.assign({}, props), key);
  }) }) })), !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && getIsSomeRowsPinned("bottom") && jsxRuntimeExports.jsx(TableBody, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ bottom: tableFooterHeight - 1, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, position: "sticky", zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)), children: getBottomRows().map((row, staticRowIndex) => {
    const props = Object.assign(Object.assign({}, commonRowProps), {
      row,
      staticRowIndex
    });
    return memoMode === "rows" ? jsxRuntimeExports.jsx(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : jsxRuntimeExports.jsx(MRT_TableBodyRow, Object.assign({}, props), row.id);
  }) }))] });
};
const Memo_MRT_TableBody = reactExports.memo(MRT_TableBody, (prev2, next2) => prev2.table.options.data === next2.table.options.data);
const MRT_TableFooterCell = (_a2) => {
  var _b2, _c2, _d2;
  var { footer, staticColumnIndex, table } = _a2, rest = __rest(_a2, ["footer", "staticColumnIndex", "table"]);
  const theme = useTheme();
  const { getState, options: { enableColumnPinning, muiTableFooterCellProps, enableKeyboardShortcuts } } = table;
  const { density } = getState();
  const { column: column2 } = footer;
  const { columnDef } = column2;
  const { columnDefType } = columnDef;
  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== "group" && column2.getIsPinned();
  const args = { column: column2, table };
  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableFooterCellProps, args)), rest);
  const handleKeyDown = (event) => {
    var _a3;
    cellKeyboardShortcuts({
      event,
      cellValue: footer.column.columnDef.footer,
      table
    });
    (_a3 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(tableCellProps, event);
  };
  return jsxRuntimeExports.jsx(TableCell, Object.assign({ align: columnDefType === "group" ? "center" : theme.direction === "rtl" ? "right" : "left", colSpan: footer.colSpan, "data-index": staticColumnIndex, "data-pinned": !!isColumnPinned || void 0, tabIndex: enableKeyboardShortcuts ? 0 : void 0, variant: "footer" }, tableCellProps, { onKeyDown: handleKeyDown, sx: (theme2) => Object.assign(Object.assign({ fontWeight: "bold", p: density === "compact" ? "0.5rem" : density === "comfortable" ? "1rem" : "1.5rem", verticalAlign: "top" }, getCommonMRTCellStyles({
    column: column2,
    header: footer,
    table,
    tableCellProps,
    theme: theme2
  })), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme2)), children: (_b2 = tableCellProps.children) !== null && _b2 !== void 0 ? _b2 : footer.isPlaceholder ? null : (_d2 = (_c2 = parseFromValuesOrFunc(columnDef.Footer, {
    column: column2,
    footer,
    table
  })) !== null && _c2 !== void 0 ? _c2 : columnDef.footer) !== null && _d2 !== void 0 ? _d2 : null }));
};
const MRT_TableFooterRow = (_a2) => {
  var _b2;
  var { columnVirtualizer, footerGroup, table } = _a2, rest = __rest(_a2, ["columnVirtualizer", "footerGroup", "table"]);
  const { options: { layoutMode, mrtTheme: { baseBackgroundColor }, muiTableFooterRowProps } } = table;
  const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
  if (!((_b2 = footerGroup.headers) === null || _b2 === void 0 ? void 0 : _b2.some((header) => typeof header.column.columnDef.footer === "string" && !!header.column.columnDef.footer || header.column.columnDef.Footer))) {
    return null;
  }
  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterRowProps, {
    footerGroup,
    table
  })), rest);
  return jsxRuntimeExports.jsxs(TableRow, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: baseBackgroundColor, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, position: "relative", width: "100%" }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)), children: [virtualPaddingLeft ? jsxRuntimeExports.jsx("th", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter, staticColumnIndex) => {
    let footer = footerOrVirtualFooter;
    if (columnVirtualizer) {
      staticColumnIndex = footerOrVirtualFooter.index;
      footer = footerGroup.headers[staticColumnIndex];
    }
    return footer ? jsxRuntimeExports.jsx(MRT_TableFooterCell, { footer, staticColumnIndex, table }, footer.id) : null;
  }), virtualPaddingRight ? jsxRuntimeExports.jsx("th", { style: { display: "flex", width: virtualPaddingRight } }) : null] }));
};
const MRT_TableFooter = (_a2) => {
  var { columnVirtualizer, table } = _a2, rest = __rest(_a2, ["columnVirtualizer", "table"]);
  const { getState, options: { enableStickyFooter, layoutMode, muiTableFooterProps }, refs: { tableFooterRef } } = table;
  const { isFullScreen } = getState();
  const tableFooterProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterProps, {
    table
  })), rest);
  const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
  const footerGroups = table.getFooterGroups();
  if (!footerGroups.some((footerGroup) => {
    var _a3;
    return (_a3 = footerGroup.headers) === null || _a3 === void 0 ? void 0 : _a3.some((header) => typeof header.column.columnDef.footer === "string" && !!header.column.columnDef.footer || header.column.columnDef.Footer);
  })) {
    return null;
  }
  return jsxRuntimeExports.jsx(TableFooter, Object.assign({}, tableFooterProps, { ref: (ref) => {
    tableFooterRef.current = ref;
    if (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.ref) {
      tableFooterProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign({ bottom: stickFooter ? 0 : void 0, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, opacity: stickFooter ? 0.97 : void 0, outline: stickFooter ? theme.palette.mode === "light" ? `1px solid ${theme.palette.grey[300]}` : `1px solid ${theme.palette.grey[700]}` : void 0, position: stickFooter ? "sticky" : "relative", zIndex: stickFooter ? 1 : void 0 }, parseFromValuesOrFunc(tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx, theme)), children: footerGroups.map((footerGroup) => jsxRuntimeExports.jsx(MRT_TableFooterRow, { columnVirtualizer, footerGroup, table }, footerGroup.id)) }));
};
const mrtFilterOptions = (localization) => [
  {
    divider: false,
    label: localization.filterFuzzy,
    option: "fuzzy",
    symbol: "≈"
  },
  {
    divider: false,
    label: localization.filterContains,
    option: "contains",
    symbol: "*"
  },
  {
    divider: false,
    label: localization.filterStartsWith,
    option: "startsWith",
    symbol: "a"
  },
  {
    divider: true,
    label: localization.filterEndsWith,
    option: "endsWith",
    symbol: "z"
  },
  {
    divider: false,
    label: localization.filterEquals,
    option: "equals",
    symbol: "="
  },
  {
    divider: true,
    label: localization.filterNotEquals,
    option: "notEquals",
    symbol: "≠"
  },
  {
    divider: false,
    label: localization.filterBetween,
    option: "between",
    symbol: "⇿"
  },
  {
    divider: true,
    label: localization.filterBetweenInclusive,
    option: "betweenInclusive",
    symbol: "⬌"
  },
  {
    divider: false,
    label: localization.filterGreaterThan,
    option: "greaterThan",
    symbol: ">"
  },
  {
    divider: false,
    label: localization.filterGreaterThanOrEqualTo,
    option: "greaterThanOrEqualTo",
    symbol: "≥"
  },
  {
    divider: false,
    label: localization.filterLessThan,
    option: "lessThan",
    symbol: "<"
  },
  {
    divider: true,
    label: localization.filterLessThanOrEqualTo,
    option: "lessThanOrEqualTo",
    symbol: "≤"
  },
  {
    divider: false,
    label: localization.filterEmpty,
    option: "empty",
    symbol: "∅"
  },
  {
    divider: false,
    label: localization.filterNotEmpty,
    option: "notEmpty",
    symbol: "!∅"
  }
];
const rangeModes = ["between", "betweenInclusive", "inNumberRange"];
const emptyModes = ["empty", "notEmpty"];
const arrModes = ["arrIncludesSome", "arrIncludesAll", "arrIncludes"];
const rangeVariants = ["range-slider", "date-range", "datetime-range", "range"];
const MRT_FilterOptionMenu = (_a2) => {
  var _b2, _c2, _d2, _e2;
  var { anchorEl, header, onSelect, setAnchorEl, setFilterValue, table } = _a2, rest = __rest(_a2, ["anchorEl", "header", "onSelect", "setAnchorEl", "setFilterValue", "table"]);
  const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, mrtTheme: { menuBackgroundColor }, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems }, setColumnFilterFns, setGlobalFilterFn } = table;
  const { density, globalFilterFn } = getState();
  const { column: column2 } = header !== null && header !== void 0 ? header : {};
  const { columnDef } = column2 !== null && column2 !== void 0 ? column2 : {};
  const currentFilterValue = column2 === null || column2 === void 0 ? void 0 : column2.getFilterValue();
  let allowedColumnFilterOptions = (_b2 = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b2 !== void 0 ? _b2 : columnFilterModeOptions;
  if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {
    allowedColumnFilterOptions = [
      ...rangeModes,
      ...allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []
    ].filter((option) => rangeModes.includes(option));
  }
  const internalFilterOptions = reactExports.useMemo(() => mrtFilterOptions(localization).filter((filterOption2) => columnDef ? allowedColumnFilterOptions === void 0 || (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption2.option)) : (!globalFilterModeOptions || globalFilterModeOptions.includes(filterOption2.option)) && ["contains", "fuzzy", "startsWith"].includes(filterOption2.option)), []);
  const handleSelectFilterMode = (option) => {
    var _a3, _b3;
    const prevFilterMode = (_a3 = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a3 !== void 0 ? _a3 : "";
    if (!header || !column2) {
      setGlobalFilterFn(option);
    } else if (option !== prevFilterMode) {
      setColumnFilterFns((prev2) => Object.assign(Object.assign({}, prev2), { [header.id]: option }));
      if (emptyModes.includes(option)) {
        if (currentFilterValue !== " " && !emptyModes.includes(prevFilterMode)) {
          column2.setFilterValue(" ");
        } else if (currentFilterValue) {
          column2.setFilterValue(currentFilterValue);
        }
      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "multi-select" || arrModes.includes(option)) {
        if (currentFilterValue instanceof String || (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {
          column2.setFilterValue([]);
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue([]);
        } else if (currentFilterValue) {
          column2.setFilterValue(currentFilterValue);
        }
      } else if (((_b3 = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === null || _b3 === void 0 ? void 0 : _b3.includes("range")) || rangeModes.includes(option)) {
        if (!Array.isArray(currentFilterValue) || !(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v2) => v2 === "")) && !rangeModes.includes(prevFilterMode)) {
          column2.setFilterValue(["", ""]);
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
        } else {
          column2.setFilterValue(currentFilterValue);
        }
      } else {
        if (Array.isArray(currentFilterValue)) {
          column2.setFilterValue("");
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
        } else if (currentFilterValue === " " && emptyModes.includes(prevFilterMode)) {
          column2.setFilterValue(void 0);
        } else {
          column2.setFilterValue(currentFilterValue);
        }
      }
    }
    setAnchorEl(null);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect();
  };
  const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
  return jsxRuntimeExports.jsx(Menu, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, anchorOrigin: { horizontal: "right", vertical: "center" }, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: (_e2 = header && column2 && columnDef ? (_d2 = (_c2 = columnDef.renderColumnFilterModeMenuItems) === null || _c2 === void 0 ? void 0 : _c2.call(columnDef, {
    column: column2,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _d2 !== void 0 ? _d2 : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
    column: column2,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  }) : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _e2 !== void 0 ? _e2 : internalFilterOptions.map(({ divider, label, option, symbol }, index) => jsxRuntimeExports.jsx(MRT_ActionMenuItem, { divider, icon: symbol, label, onClick: () => handleSelectFilterMode(option), selected: option === filterOption, table, value: option }, index)) }));
};
const MRT_ColumnActionMenu = (_a2) => {
  var _b2, _c2, _d2, _e2, _f2, _g2, _h2, _j2, _k, _l;
  var { anchorEl, header, setAnchorEl, table } = _a2, rest = __rest(_a2, ["anchorEl", "header", "setAnchorEl", "table"]);
  const { getAllLeafColumns, getState, options: { columnFilterDisplayMode, columnFilterModeOptions, enableColumnFilterModes, enableColumnFilters, enableColumnPinning, enableColumnResizing, enableGrouping, enableHiding, enableSorting, enableSortingRemoval, icons: { ClearAllIcon, DynamicFeedIcon, FilterListIcon, FilterListOffIcon, PushPinIcon, RestartAltIcon, SortIcon, ViewColumnIcon, VisibilityOffIcon }, localization, mrtTheme: { menuBackgroundColor }, renderColumnActionsMenuItems }, refs: { filterInputRefs }, setColumnFilterFns, setColumnOrder, setColumnSizingInfo, setShowColumnFilters } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { columnSizing, columnVisibility, density, showColumnFilters } = getState();
  const columnFilterValue = column2.getFilterValue();
  const [filterMenuAnchorEl, setFilterMenuAnchorEl] = reactExports.useState(null);
  const handleClearSort = () => {
    column2.clearSorting();
    setAnchorEl(null);
  };
  const handleSortAsc = () => {
    column2.toggleSorting(false);
    setAnchorEl(null);
  };
  const handleSortDesc = () => {
    column2.toggleSorting(true);
    setAnchorEl(null);
  };
  const handleResetColumnSize = () => {
    setColumnSizingInfo((old) => Object.assign(Object.assign({}, old), { isResizingColumn: false }));
    column2.resetSize();
    setAnchorEl(null);
  };
  const handleHideColumn = () => {
    column2.toggleVisibility(false);
    setAnchorEl(null);
  };
  const handlePinColumn = (pinDirection) => {
    column2.pin(pinDirection);
    setAnchorEl(null);
  };
  const handleGroupByColumn = () => {
    column2.toggleGrouping();
    setColumnOrder((old) => ["mrt-row-expand", ...old]);
    setAnchorEl(null);
  };
  const handleClearFilter = () => {
    column2.setFilterValue(void 0);
    setAnchorEl(null);
    if (["empty", "notEmpty"].includes(columnDef._filterFn)) {
      setColumnFilterFns((prev2) => {
        var _a3;
        return Object.assign(Object.assign({}, prev2), { [header.id]: (_a3 = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a3 !== void 0 ? _a3 : "fuzzy" });
      });
    }
  };
  const handleFilterByColumn = () => {
    setShowColumnFilters(true);
    queueMicrotask(() => {
      var _a3;
      return (_a3 = filterInputRefs.current[`${column2.id}-0`]) === null || _a3 === void 0 ? void 0 : _a3.focus();
    });
    setAnchorEl(null);
  };
  const handleShowAllColumns = () => {
    getAllLeafColumns().filter((col) => col.columnDef.enableHiding !== false).forEach((col) => col.toggleVisibility(true));
    setAnchorEl(null);
  };
  const handleOpenFilterModeMenu = (event) => {
    event.stopPropagation();
    setFilterMenuAnchorEl(event.currentTarget);
  };
  const isSelectFilter = !!columnDef.filterSelectOptions;
  const allowedColumnFilterOptions = (_b2 = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b2 !== void 0 ? _b2 : columnFilterModeOptions;
  const showFilterModeSubMenu = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !isSelectFilter && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  const internalColumnMenuItems = [
    ...enableSorting && column2.getCanSort() ? [
      enableSortingRemoval !== false && jsxRuntimeExports.jsx(MRT_ActionMenuItem, { icon: jsxRuntimeExports.jsx(ClearAllIcon, {}), label: localization.clearSort, onClick: handleClearSort, table }, 0),
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: column2.getIsSorted() === "asc", icon: jsxRuntimeExports.jsx(SortIcon, { style: { transform: "rotate(180deg) scaleX(-1)" } }), label: (_c2 = localization.sortByColumnAsc) === null || _c2 === void 0 ? void 0 : _c2.replace("{column}", String(columnDef.header)), onClick: handleSortAsc, table }, 1),
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: column2.getIsSorted() === "desc", divider: enableColumnFilters || enableGrouping || enableHiding, icon: jsxRuntimeExports.jsx(SortIcon, {}), label: (_d2 = localization.sortByColumnDesc) === null || _d2 === void 0 ? void 0 : _d2.replace("{column}", String(columnDef.header)), onClick: handleSortDesc, table }, 2)
    ] : [],
    ...enableColumnFilters && column2.getCanFilter() ? [
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: !columnFilterValue || Array.isArray(columnFilterValue) && !columnFilterValue.filter((value) => value).length, icon: jsxRuntimeExports.jsx(FilterListOffIcon, {}), label: localization.clearFilter, onClick: handleClearFilter, table }, 3),
      columnFilterDisplayMode === "subheader" && jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: showColumnFilters && !enableColumnFilterModes, divider: enableGrouping || enableHiding, icon: jsxRuntimeExports.jsx(FilterListIcon, {}), label: (_e2 = localization.filterByColumn) === null || _e2 === void 0 ? void 0 : _e2.replace("{column}", String(columnDef.header)), onClick: showColumnFilters ? handleOpenFilterModeMenu : handleFilterByColumn, onOpenSubMenu: showFilterModeSubMenu ? handleOpenFilterModeMenu : void 0, table }, 4),
      showFilterModeSubMenu && jsxRuntimeExports.jsx(MRT_FilterOptionMenu, { anchorEl: filterMenuAnchorEl, header, onSelect: handleFilterByColumn, setAnchorEl: setFilterMenuAnchorEl, table }, 5)
    ].filter(Boolean) : [],
    ...enableGrouping && column2.getCanGroup() ? [
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { divider: enableColumnPinning, icon: jsxRuntimeExports.jsx(DynamicFeedIcon, {}), label: (_f2 = localization[column2.getIsGrouped() ? "ungroupByColumn" : "groupByColumn"]) === null || _f2 === void 0 ? void 0 : _f2.replace("{column}", String(columnDef.header)), onClick: handleGroupByColumn, table }, 6)
    ] : [],
    ...enableColumnPinning && column2.getCanPin() ? [
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: column2.getIsPinned() === "left" || !column2.getCanPin(), icon: jsxRuntimeExports.jsx(PushPinIcon, { style: { transform: "rotate(90deg)" } }), label: localization.pinToLeft, onClick: () => handlePinColumn("left"), table }, 7),
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: column2.getIsPinned() === "right" || !column2.getCanPin(), icon: jsxRuntimeExports.jsx(PushPinIcon, { style: { transform: "rotate(-90deg)" } }), label: localization.pinToRight, onClick: () => handlePinColumn("right"), table }, 8),
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: !column2.getIsPinned(), divider: enableHiding, icon: jsxRuntimeExports.jsx(PushPinIcon, {}), label: localization.unpin, onClick: () => handlePinColumn(false), table }, 9)
    ] : [],
    ...enableColumnResizing && column2.getCanResize() ? [
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: !columnSizing[column2.id], icon: jsxRuntimeExports.jsx(RestartAltIcon, {}), label: localization.resetColumnSize, onClick: handleResetColumnSize, table }, 10)
    ] : [],
    ...enableHiding ? [
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: !column2.getCanHide(), icon: jsxRuntimeExports.jsx(VisibilityOffIcon, {}), label: (_g2 = localization.hideColumn) === null || _g2 === void 0 ? void 0 : _g2.replace("{column}", String(columnDef.header)), onClick: handleHideColumn, table }, 11),
      jsxRuntimeExports.jsx(MRT_ActionMenuItem, { disabled: !Object.values(columnVisibility).filter((visible) => !visible).length, icon: jsxRuntimeExports.jsx(ViewColumnIcon, {}), label: (_h2 = localization.showAllColumns) === null || _h2 === void 0 ? void 0 : _h2.replace("{column}", String(columnDef.header)), onClick: handleShowAllColumns, table }, 12)
    ] : []
  ].filter(Boolean);
  return jsxRuntimeExports.jsx(Menu, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: (_l = (_k = (_j2 = columnDef.renderColumnActionsMenuItems) === null || _j2 === void 0 ? void 0 : _j2.call(columnDef, {
    closeMenu: () => setAnchorEl(null),
    column: column2,
    internalColumnMenuItems,
    table
  })) !== null && _k !== void 0 ? _k : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
    closeMenu: () => setAnchorEl(null),
    column: column2,
    internalColumnMenuItems,
    table
  })) !== null && _l !== void 0 ? _l : internalColumnMenuItems }));
};
const MRT_TableHeadCellColumnActionsButton = (_a2) => {
  var _b2, _c2;
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  const { options: { icons: { MoreVertIcon }, localization, muiColumnActionsButtonProps } } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const handleClick = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnActionsButtonProps, {
    column: column2,
    table
  })), parseFromValuesOrFunc(columnDef.muiColumnActionsButtonProps, {
    column: column2,
    table
  })), rest);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps("top"), { title: (_b2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b2 !== void 0 ? _b2 : localization.columnActions, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.columnActions, onClick: handleClick, size: "small" }, iconButtonProps, { sx: (theme) => Object.assign({ "&:hover": {
    opacity: 1
  }, height: "2rem", m: "-8px -4px", opacity: 0.3, transition: "all 150ms", width: "2rem" }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)), title: void 0, children: (_c2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c2 !== void 0 ? _c2 : jsxRuntimeExports.jsx(MoreVertIcon, { style: { transform: "scale(0.9)" } }) })) })), anchorEl && jsxRuntimeExports.jsx(MRT_ColumnActionMenu, { anchorEl, header, setAnchorEl, table })] });
};
const MRT_FilterCheckbox = (_a2) => {
  var _b2, _c2, _d2;
  var { column: column2, table } = _a2, rest = __rest(_a2, ["column", "table"]);
  const { getState, options: { localization, muiFilterCheckboxProps } } = table;
  const { density } = getState();
  const { columnDef } = column2;
  const checkboxProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterCheckboxProps, {
    column: column2,
    table
  })), parseFromValuesOrFunc(columnDef.muiFilterCheckboxProps, {
    column: column2,
    table
  })), rest);
  const filterLabel = (_b2 = localization.filterByColumn) === null || _b2 === void 0 ? void 0 : _b2.replace("{column}", columnDef.header);
  return jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), { title: (_c2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _c2 !== void 0 ? _c2 : filterLabel, children: jsxRuntimeExports.jsx(FormControlLabel, { control: jsxRuntimeExports.jsx(Checkbox, Object.assign({ checked: column2.getFilterValue() === "true", color: column2.getFilterValue() === void 0 ? "default" : "primary", indeterminate: column2.getFilterValue() === void 0, size: density === "compact" ? "small" : "medium" }, checkboxProps, { onChange: (e3, checked) => {
    var _a3;
    column2.setFilterValue(column2.getFilterValue() === void 0 ? "true" : column2.getFilterValue() === "true" ? "false" : void 0);
    (_a3 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(checkboxProps, e3, checked);
  }, onClick: (e3) => {
    var _a3;
    e3.stopPropagation();
    (_a3 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(checkboxProps, e3);
  }, sx: (theme) => Object.assign({ height: "2.5rem", width: "2.5rem" }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme)) })), disableTypography: true, label: (_d2 = checkboxProps.title) !== null && _d2 !== void 0 ? _d2 : filterLabel, sx: { color: "text.secondary", fontWeight: "normal", mt: "-4px" }, title: void 0 }) }));
};
const MRT_FilterTextField = (_a2) => {
  var _b2, _c2, _d2, _f2, _g2, _h2, _j2, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
  var { header, rangeFilterIndex, table } = _a2, rest = __rest(_a2, ["header", "rangeFilterIndex", "table"]);
  const { options: { enableColumnFilterModes, icons: { CloseIcon: CloseIcon2, FilterListIcon }, localization, manualFiltering, muiFilterAutocompleteProps, muiFilterDatePickerProps, muiFilterDateTimePickerProps, muiFilterTextFieldProps, muiFilterTimePickerProps }, refs: { filterInputRefs }, setColumnFilterFns } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { filterVariant } = columnDef;
  const args = { column: column2, rangeFilterIndex, table };
  const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTextFieldProps, args)), parseFromValuesOrFunc(columnDef.muiFilterTextFieldProps, args)), rest);
  const autocompleteProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterAutocompleteProps, args)), parseFromValuesOrFunc(columnDef.muiFilterAutocompleteProps, args));
  const datePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDatePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterDatePickerProps, args));
  const dateTimePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDateTimePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterDateTimePickerProps, args));
  const timePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTimePickerProps, args)), parseFromValuesOrFunc(columnDef.muiFilterTimePickerProps, args));
  const { allowedColumnFilterOptions, currentFilterOption, facetedUniqueValues, isAutocompleteFilter, isDateFilter, isMultiSelectFilter, isRangeFilter, isSelectFilter, isTextboxFilter } = getColumnFilterInfo({ header, table });
  const dropdownOptions = useDropdownOptions({ header, table });
  const filterChipLabel = ["empty", "notEmpty"].includes(currentFilterOption) ? (
    //@ts-ignore
    localization[`filter${((_c2 = (_b2 = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _b2 === void 0 ? void 0 : _b2.call(currentFilterOption, 0)) === null || _c2 === void 0 ? void 0 : _c2.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) : "";
  const filterPlaceholder = !isRangeFilter ? (_d2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.placeholder) !== null && _d2 !== void 0 ? _d2 : (_f2 = localization.filterByColumn) === null || _f2 === void 0 ? void 0 : _f2.replace("{column}", String(columnDef.header)) : rangeFilterIndex === 0 ? localization.min : rangeFilterIndex === 1 ? localization.max : "";
  const showChangeModeButton = !!(enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !rangeFilterIndex && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length)));
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [filterValue, setFilterValue] = reactExports.useState(() => {
    var _a3, _b3;
    return isMultiSelectFilter ? column2.getFilterValue() || [] : isRangeFilter ? ((_a3 = column2.getFilterValue()) === null || _a3 === void 0 ? void 0 : _a3[rangeFilterIndex]) || "" : (_b3 = column2.getFilterValue()) !== null && _b3 !== void 0 ? _b3 : "";
  });
  const [autocompleteValue, setAutocompleteValue] = reactExports.useState(isAutocompleteFilter ? filterValue : null);
  const handleChangeDebounced = reactExports.useCallback(debounce$2((newValue) => {
    if (isRangeFilter) {
      column2.setFilterValue((old) => {
        const newFilterValues = old !== null && old !== void 0 ? old : ["", ""];
        newFilterValues[rangeFilterIndex] = newValue !== null && newValue !== void 0 ? newValue : void 0;
        return newFilterValues;
      });
    } else {
      column2.setFilterValue(newValue !== null && newValue !== void 0 ? newValue : void 0);
    }
  }, isTextboxFilter ? manualFiltering ? 400 : 200 : 1), []);
  const handleChange = (newValue) => {
    setFilterValue(newValue !== null && newValue !== void 0 ? newValue : "");
    handleChangeDebounced(newValue);
  };
  const handleTextFieldChange = (event) => {
    var _a3;
    const newValue = textFieldProps.type === "date" ? event.target.valueAsDate : textFieldProps.type === "number" ? event.target.valueAsNumber : event.target.value;
    handleChange(newValue);
    (_a3 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(textFieldProps, event);
  };
  const handleAutocompleteChange = (newValue) => {
    setAutocompleteValue(newValue);
    handleChange(getValueAndLabel(newValue).value);
  };
  const handleClear = () => {
    if (isMultiSelectFilter) {
      setFilterValue([]);
      column2.setFilterValue([]);
    } else if (isRangeFilter) {
      setFilterValue("");
      column2.setFilterValue((old) => {
        const newFilterValues = Array.isArray(old) && old || ["", ""];
        newFilterValues[rangeFilterIndex] = void 0;
        return newFilterValues;
      });
    } else {
      setFilterValue("");
      column2.setFilterValue(void 0);
    }
  };
  const handleClearEmptyFilterChip = () => {
    setFilterValue("");
    column2.setFilterValue(void 0);
    setColumnFilterFns((prev2) => {
      var _a3;
      return Object.assign(Object.assign({}, prev2), { [header.id]: (_a3 = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a3 !== void 0 ? _a3 : "fuzzy" });
    });
  };
  const handleFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const isMounted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (isMounted.current) {
      const filterValue2 = column2.getFilterValue();
      if (filterValue2 === void 0) {
        handleClear();
      } else if (isRangeFilter && rangeFilterIndex !== void 0) {
        setFilterValue(filterValue2[rangeFilterIndex]);
      } else {
        setFilterValue(filterValue2);
      }
    }
    isMounted.current = true;
  }, [column2.getFilterValue()]);
  if (columnDef.Filter) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: (_g2 = columnDef.Filter) === null || _g2 === void 0 ? void 0 : _g2.call(columnDef, { column: column2, header, rangeFilterIndex, table }) });
  }
  const endAdornment = !isAutocompleteFilter && !isDateFilter && !filterChipLabel ? jsxRuntimeExports.jsx(InputAdornment, { position: "end", sx: { mr: isSelectFilter || isMultiSelectFilter ? "20px" : void 0 }, children: jsxRuntimeExports.jsx(Tooltip, { placement: "right", title: (_h2 = localization.clearFilter) !== null && _h2 !== void 0 ? _h2 : "", children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.clearFilter, disabled: !((_j2 = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _j2 === void 0 ? void 0 : _j2.length), onClick: handleClear, size: "small", sx: {
    height: "2rem",
    transform: "scale(0.9)",
    width: "2rem"
  }, children: jsxRuntimeExports.jsx(CloseIcon2, {}) }) }) }) }) : null;
  const startAdornment = showChangeModeButton ? jsxRuntimeExports.jsxs(InputAdornment, { position: "start", children: [jsxRuntimeExports.jsx(Tooltip, { title: localization.changeFilterMode, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.changeFilterMode, onClick: handleFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" }, children: jsxRuntimeExports.jsx(FilterListIcon, {}) }) }) }), filterChipLabel && jsxRuntimeExports.jsx(Chip, { label: filterChipLabel, onDelete: handleClearEmptyFilterChip })] }) : null;
  const commonTextFieldProps = Object.assign(Object.assign({ FormHelperTextProps: {
    sx: {
      fontSize: "0.75rem",
      lineHeight: "0.8rem",
      whiteSpace: "nowrap"
    }
  }, InputProps: endAdornment ? { endAdornment, startAdornment } : { startAdornment }, fullWidth: true, helperText: showChangeModeButton ? jsxRuntimeExports.jsx("label", { children: localization.filterMode.replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_k = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _k === void 0 ? void 0 : _k.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) }) : null, inputProps: {
    "aria-label": filterPlaceholder,
    autoComplete: "new-password",
    // disable autocomplete and autofill
    disabled: !!filterChipLabel,
    sx: {
      textOverflow: "ellipsis",
      width: filterChipLabel ? 0 : void 0
    },
    title: filterPlaceholder
  }, inputRef: (inputRef) => {
    filterInputRefs.current[`${column2.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] = inputRef;
    if (textFieldProps.inputRef) {
      textFieldProps.inputRef = inputRef;
    }
  }, margin: "none", placeholder: filterChipLabel || isSelectFilter || isMultiSelectFilter ? void 0 : filterPlaceholder, variant: "standard" }, textFieldProps), { onKeyDown: (e3) => {
    var _a3;
    e3.stopPropagation();
    (_a3 = textFieldProps.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(textFieldProps, e3);
  }, sx: (theme) => Object.assign({ minWidth: isDateFilter ? "160px" : enableColumnFilterModes && rangeFilterIndex === 0 ? "110px" : isRangeFilter ? "100px" : !filterChipLabel ? "120px" : "auto", mx: "-2px", p: 0, width: "calc(100% + 4px)" }, parseFromValuesOrFunc(textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx, theme)) });
  const commonDatePickerProps = {
    onChange: (newDate) => {
      handleChange(newDate);
    },
    value: filterValue || null
  };
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [(filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("time")) ? jsxRuntimeExports.jsx(TimePicker, Object.assign({}, commonDatePickerProps, timePickerProps, { slotProps: {
    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_l = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _l === void 0 ? void 0 : _l.field),
    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_m = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _m === void 0 ? void 0 : _m.textField)
  } })) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("datetime")) ? jsxRuntimeExports.jsx(DateTimePicker, Object.assign({}, commonDatePickerProps, dateTimePickerProps, { slotProps: {
    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_o = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _o === void 0 ? void 0 : _o.field),
    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_p = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _p === void 0 ? void 0 : _p.textField)
  } })) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("date")) ? jsxRuntimeExports.jsx(DatePicker, Object.assign({}, commonDatePickerProps, datePickerProps, { slotProps: {
    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_q = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _q === void 0 ? void 0 : _q.field),
    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_r = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _r === void 0 ? void 0 : _r.textField)
  } })) : isAutocompleteFilter ? jsxRuntimeExports.jsx(Autocomplete, Object.assign({ freeSolo: true, getOptionLabel: (option) => getValueAndLabel(option).label, onChange: (_e2, newValue) => handleAutocompleteChange(newValue), options: (_s = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option) => getValueAndLabel(option))) !== null && _s !== void 0 ? _s : [] }, autocompleteProps, { renderInput: (builtinTextFieldProps) => {
    var _a3;
    return jsxRuntimeExports.jsx(TextField, Object.assign({}, builtinTextFieldProps, commonTextFieldProps, { InputProps: Object.assign(Object.assign({}, builtinTextFieldProps.InputProps), { startAdornment: (_a3 = commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.InputProps) === null || _a3 === void 0 ? void 0 : _a3.startAdornment }), inputProps: Object.assign(Object.assign({}, builtinTextFieldProps.inputProps), commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.inputProps), onChange: handleTextFieldChange, onClick: (e3) => e3.stopPropagation() }));
  }, value: autocompleteValue })) : jsxRuntimeExports.jsx(TextField, Object.assign({ select: isSelectFilter || isMultiSelectFilter }, commonTextFieldProps, { SelectProps: Object.assign({ MenuProps: { disableScrollLock: true }, displayEmpty: true, multiple: isMultiSelectFilter, renderValue: isMultiSelectFilter ? (selected) => !(selected === null || selected === void 0 ? void 0 : selected.length) ? jsxRuntimeExports.jsx(Box, { sx: { opacity: 0.5 }, children: filterPlaceholder }) : jsxRuntimeExports.jsx(Box, { sx: { display: "flex", flexWrap: "wrap", gap: "2px" }, children: selected === null || selected === void 0 ? void 0 : selected.map((value) => {
    const selectedValue = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find((option) => getValueAndLabel(option).value === value);
    return jsxRuntimeExports.jsx(Chip, { label: getValueAndLabel(selectedValue).label }, value);
  }) }) : void 0 }, commonTextFieldProps.SelectProps), onChange: handleTextFieldChange, onClick: (e3) => e3.stopPropagation(), value: filterValue !== null && filterValue !== void 0 ? filterValue : "", children: (isSelectFilter || isMultiSelectFilter) && [
    jsxRuntimeExports.jsx(MenuItem, { disabled: true, divider: true, hidden: true, value: "", children: jsxRuntimeExports.jsx(Box, { sx: { opacity: 0.5 }, children: filterPlaceholder }) }, "p"),
    ...[
      (_t2 = textFieldProps.children) !== null && _t2 !== void 0 ? _t2 : dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option, index) => {
        var _a3;
        const { label, value } = getValueAndLabel(option);
        return jsxRuntimeExports.jsxs(MenuItem, { sx: {
          alignItems: "center",
          display: "flex",
          gap: "0.5rem",
          m: 0
        }, value, children: [isMultiSelectFilter && jsxRuntimeExports.jsx(Checkbox, { checked: ((_a3 = column2.getFilterValue()) !== null && _a3 !== void 0 ? _a3 : []).includes(value), sx: { mr: "0.5rem" } }), label, " ", !columnDef.filterSelectOptions && `(${facetedUniqueValues.get(value)})`] }, `${index}-${value}`);
      })
    ]
  ] })), jsxRuntimeExports.jsx(MRT_FilterOptionMenu, { anchorEl, header, setAnchorEl, setFilterValue, table })] });
};
const MRT_FilterRangeFields = (_a2) => {
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  return jsxRuntimeExports.jsx(Box, Object.assign({}, rest, { sx: (theme) => Object.assign({ display: "grid", gap: "1rem", gridTemplateColumns: "1fr 1fr" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: [0, 1].map((rangeFilterIndex) => jsxRuntimeExports.jsx(MRT_FilterTextField, { header, rangeFilterIndex, table }, rangeFilterIndex)) }));
};
const MRT_FilterRangeSlider = (_a2) => {
  var _b2, _c2;
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  const { options: { enableColumnFilterModes, localization, muiFilterSliderProps }, refs: { filterInputRefs } } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const currentFilterOption = columnDef._filterFn;
  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false;
  const sliderProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterSliderProps, { column: column2, table })), parseFromValuesOrFunc(columnDef.muiFilterSliderProps, { column: column2, table })), rest);
  let [min2, max2] = sliderProps.min !== void 0 && sliderProps.max !== void 0 ? [sliderProps.min, sliderProps.max] : (_b2 = column2.getFacetedMinMaxValues()) !== null && _b2 !== void 0 ? _b2 : [0, 1];
  if (Array.isArray(min2))
    min2 = min2[0];
  if (Array.isArray(max2))
    max2 = max2[0];
  if (min2 === null)
    min2 = 0;
  if (max2 === null)
    max2 = 1;
  const [filterValues, setFilterValues] = reactExports.useState([min2, max2]);
  const columnFilterValue = column2.getFilterValue();
  const isMounted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (isMounted.current) {
      if (columnFilterValue === void 0) {
        setFilterValues([min2, max2]);
      } else if (Array.isArray(columnFilterValue)) {
        setFilterValues(columnFilterValue);
      }
    }
    isMounted.current = true;
  }, [columnFilterValue, min2, max2]);
  return jsxRuntimeExports.jsxs(Stack, { children: [jsxRuntimeExports.jsx(Slider, Object.assign({ disableSwap: true, max: max2, min: min2, onChange: (_event, values2) => {
    setFilterValues(values2);
  }, onChangeCommitted: (_event, value) => {
    if (Array.isArray(value)) {
      if (value[0] <= min2 && value[1] >= max2) {
        column2.setFilterValue(void 0);
      } else {
        column2.setFilterValue(value);
      }
    }
  }, value: filterValues, valueLabelDisplay: "auto" }, sliderProps, { slotProps: {
    input: {
      ref: (node2) => {
        var _a3, _b3;
        if (node2) {
          filterInputRefs.current[`${column2.id}-0`] = node2;
          if ((_b3 = (_a3 = sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.slotProps) === null || _a3 === void 0 ? void 0 : _a3.input) === null || _b3 === void 0 ? void 0 : _b3.ref) {
            sliderProps.slotProps.input.ref = node2;
          }
        }
      }
    }
  }, sx: (theme) => Object.assign({ m: "auto", minWidth: `${column2.getSize() - 50}px`, mt: !showChangeModeButton ? "10px" : "6px", px: "4px", width: "calc(100% - 8px)" }, parseFromValuesOrFunc(sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.sx, theme)) })), showChangeModeButton ? jsxRuntimeExports.jsx(FormHelperText, { sx: {
    fontSize: "0.75rem",
    lineHeight: "0.8rem",
    m: "-3px -6px",
    whiteSpace: "nowrap"
  }, children: localization.filterMode.replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_c2 = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c2 === void 0 ? void 0 : _c2.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) }) : null] });
};
const MRT_TableHeadCellFilterContainer = (_a2) => {
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  const { getState, options: { columnFilterDisplayMode } } = table;
  const { showColumnFilters } = getState();
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { isRangeFilter } = getColumnFilterInfo({ header, table });
  return jsxRuntimeExports.jsx(Collapse, Object.assign({ in: showColumnFilters || columnFilterDisplayMode === "popover", mountOnEnter: true, unmountOnExit: true }, rest, { children: columnDef.filterVariant === "checkbox" ? jsxRuntimeExports.jsx(MRT_FilterCheckbox, { column: column2, table }) : columnDef.filterVariant === "range-slider" ? jsxRuntimeExports.jsx(MRT_FilterRangeSlider, { header, table }) : isRangeFilter ? jsxRuntimeExports.jsx(MRT_FilterRangeFields, { header, table }) : jsxRuntimeExports.jsx(MRT_FilterTextField, { header, table }) }));
};
const MRT_TableHeadCellFilterLabel = (_a2) => {
  var _b2, _c2;
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  const { options: { columnFilterDisplayMode, icons: { FilterAltIcon }, localization }, refs: { filterInputRefs }, setShowColumnFilters } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const filterValue = column2.getFilterValue();
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const { currentFilterOption, isMultiSelectFilter, isRangeFilter, isSelectFilter } = getColumnFilterInfo({ header, table });
  const dropdownOptions = useDropdownOptions({ header, table });
  const getSelectLabel = (index) => getValueAndLabel(dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find((option) => getValueAndLabel(option).value === (index !== void 0 ? filterValue[index] : filterValue))).label;
  const isFilterActive = Array.isArray(filterValue) && filterValue.some(Boolean) || !!filterValue && !Array.isArray(filterValue);
  const filterTooltip = columnFilterDisplayMode === "popover" && !isFilterActive ? (_b2 = localization.filterByColumn) === null || _b2 === void 0 ? void 0 : _b2.replace("{column}", String(columnDef.header)) : localization.filteringByColumn.replace("{column}", String(columnDef.header)).replace("{filterType}", currentFilterOption ? (
    // @ts-ignore
    localization[`filter${((_c2 = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c2 === void 0 ? void 0 : _c2.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) : "").replace("{filterValue}", `"${Array.isArray(filterValue) ? filterValue.map((value, index) => isMultiSelectFilter ? getSelectLabel(index) : value).join(`" ${isRangeFilter ? localization.and : localization.or} "`) : isSelectFilter ? getSelectLabel() : filterValue}"`).replace('" "', "");
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Grow, { in: columnFilterDisplayMode === "popover" || !!filterValue && !isRangeFilter || isRangeFilter && // @ts-ignore
  (!!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[0]) || !!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[1])), unmountOnExit: true, children: jsxRuntimeExports.jsx(Box, { component: "span", sx: { flex: "0 0" }, children: jsxRuntimeExports.jsx(Tooltip, { placement: "top", title: filterTooltip, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ disableRipple: true, onClick: (event) => {
    if (columnFilterDisplayMode === "popover") {
      setAnchorEl(event.currentTarget);
    } else {
      setShowColumnFilters(true);
    }
    queueMicrotask(() => {
      var _a3, _b3, _c3, _d2;
      (_b3 = (_a3 = filterInputRefs.current[`${column2.id}-0`]) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b3 === void 0 ? void 0 : _b3.call(_a3);
      (_d2 = (_c3 = filterInputRefs.current[`${column2.id}-0`]) === null || _c3 === void 0 ? void 0 : _c3.select) === null || _d2 === void 0 ? void 0 : _d2.call(_c3);
    });
    event.stopPropagation();
  }, size: "small" }, rest, { sx: (theme) => Object.assign({ height: "16px", ml: "4px", opacity: isFilterActive ? 1 : 0.3, p: "8px", transform: "scale(0.75)", transition: "all 150ms ease-in-out", width: "16px" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: jsxRuntimeExports.jsx(FilterAltIcon, {}) })) }) }) }), columnFilterDisplayMode === "popover" && jsxRuntimeExports.jsx(Popover, { anchorEl, anchorOrigin: {
    horizontal: "center",
    vertical: "top"
  }, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: (event) => {
    event.stopPropagation();
    setAnchorEl(null);
  }, onKeyDown: (event) => event.key === "Enter" && setAnchorEl(null), open: !!anchorEl, slotProps: { paper: { sx: { overflow: "visible" } } }, transformOrigin: {
    horizontal: "center",
    vertical: "bottom"
  }, children: jsxRuntimeExports.jsx(Box, { sx: { p: "1rem" }, children: jsxRuntimeExports.jsx(MRT_TableHeadCellFilterContainer, { header, table }) }) })] });
};
const MRT_TableHeadCellGrabHandle = (_a2) => {
  var { column: column2, table, tableHeadCellRef } = _a2, rest = __rest(_a2, ["column", "table", "tableHeadCellRef"]);
  const { getState, options: { enableColumnOrdering, muiColumnDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn } = table;
  const { columnDef } = column2;
  const { columnOrder, draggingColumn, hoveredColumn } = getState();
  const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnDragHandleProps, { column: column2, table })), parseFromValuesOrFunc(columnDef.muiColumnDragHandleProps, {
    column: column2,
    table
  })), rest);
  const handleDragStart = (event) => {
    var _a3;
    (_a3 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a3 === void 0 ? void 0 : _a3.call(iconButtonProps, event);
    setDraggingColumn(column2);
    try {
      event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
    } catch (e3) {
      console.error(e3);
    }
  };
  const handleDragEnd = (event) => {
    var _a3;
    (_a3 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a3 === void 0 ? void 0 : _a3.call(iconButtonProps, event);
    if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      column2.toggleGrouping();
    } else if (enableColumnOrdering && hoveredColumn && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
      setColumnOrder(reorderColumn(column2, hoveredColumn, columnOrder));
    }
    setDraggingColumn(null);
    setHoveredColumn(null);
  };
  return jsxRuntimeExports.jsx(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }));
};
const MRT_TableHeadCellResizeHandle = (_a2) => {
  var _b2;
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  const { getState, options: { columnResizeDirection, columnResizeMode }, setColumnSizingInfo } = table;
  const { density } = getState();
  const { column: column2 } = header;
  const handler = header.getResizeHandler();
  const mx = density === "compact" ? "-8px" : density === "comfortable" ? "-16px" : "-24px";
  const lr = column2.columnDef.columnDefType === "display" ? "4px" : "0";
  return jsxRuntimeExports.jsx(Box, { className: "Mui-TableHeadCell-ResizeHandle-Wrapper", onDoubleClick: () => {
    setColumnSizingInfo((old) => Object.assign(Object.assign({}, old), { isResizingColumn: false }));
    column2.resetSize();
  }, onMouseDown: handler, onTouchStart: handler, style: {
    transform: column2.getIsResizing() && columnResizeMode === "onEnd" ? `translateX(${(columnResizeDirection === "rtl" ? -1 : 1) * ((_b2 = getState().columnSizingInfo.deltaOffset) !== null && _b2 !== void 0 ? _b2 : 0)}px)` : void 0
  }, sx: (theme) => ({
    "&:active > hr": {
      backgroundColor: theme.palette.info.main,
      opacity: header.subHeaders.length || columnResizeMode === "onEnd" ? 1 : 0
    },
    cursor: "col-resize",
    left: columnResizeDirection === "rtl" ? lr : void 0,
    ml: columnResizeDirection === "rtl" ? mx : void 0,
    mr: columnResizeDirection === "ltr" ? mx : void 0,
    position: "absolute",
    px: "4px",
    right: columnResizeDirection === "ltr" ? lr : void 0
  }), children: jsxRuntimeExports.jsx(Divider, { className: "Mui-TableHeadCell-ResizeHandle-Divider", flexItem: true, orientation: "vertical", sx: (theme) => Object.assign({ borderRadius: "2px", borderWidth: "2px", height: "24px", touchAction: "none", transform: "translateX(4px)", transition: column2.getIsResizing() ? void 0 : "all 150ms ease-in-out", userSelect: "none", zIndex: 4 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)) }) });
};
const MRT_TableHeadCellSortLabel = (_a2) => {
  var { header, table } = _a2, rest = __rest(_a2, ["header", "table"]);
  const { getState, options: { icons: { ArrowDownwardIcon: ArrowDownwardIcon2, SyncAltIcon }, localization } } = table;
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { isLoading, showSkeletons, sorting } = getState();
  const isSorted = !!column2.getIsSorted();
  const sortTooltip = isLoading || showSkeletons ? "" : column2.getIsSorted() ? column2.getIsSorted() === "desc" ? localization.sortedByColumnDesc.replace("{column}", columnDef.header) : localization.sortedByColumnAsc.replace("{column}", columnDef.header) : column2.getNextSortingOrder() === "desc" ? localization.sortByColumnDesc.replace("{column}", columnDef.header) : localization.sortByColumnAsc.replace("{column}", columnDef.header);
  const direction = isSorted ? column2.getIsSorted() : void 0;
  return jsxRuntimeExports.jsx(Tooltip, { placement: "top", title: sortTooltip, children: jsxRuntimeExports.jsx(Badge, { badgeContent: sorting.length > 1 ? column2.getSortIndex() + 1 : 0, overlap: "circular", children: jsxRuntimeExports.jsx(TableSortLabel, Object.assign({ IconComponent: !isSorted ? (props) => jsxRuntimeExports.jsx(SyncAltIcon, Object.assign({}, props, { direction, style: {
    transform: "rotate(-90deg) scaleX(0.9) translateX(-1px)"
  } })) : ArrowDownwardIcon2, active: true, "aria-label": sortTooltip, direction, onClick: (e3) => {
    var _a3;
    e3.stopPropagation();
    (_a3 = header.column.getToggleSortingHandler()) === null || _a3 === void 0 ? void 0 : _a3(e3);
  } }, rest, { sx: (theme) => Object.assign({ ".MuiTableSortLabel-icon": {
    color: `${theme.palette.mode === "dark" ? theme.palette.text.primary : theme.palette.text.secondary} !important`
  }, flex: "0 0", opacity: isSorted ? 1 : 0.3, transition: "all 150ms ease-in-out", width: "3ch" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)) })) }) });
};
const MRT_TableHeadCell = (_a2) => {
  var _b2, _c2, _d2, _f2, _g2, _h2;
  var { columnVirtualizer, header, staticColumnIndex, table } = _a2, rest = __rest(_a2, ["columnVirtualizer", "header", "staticColumnIndex", "table"]);
  const theme = useTheme();
  const { getState, options: { columnFilterDisplayMode, columnResizeDirection, columnResizeMode, enableKeyboardShortcuts, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableColumnPinning, enableGrouping, enableMultiSort, layoutMode, mrtTheme: { draggingBorderColor }, muiTableHeadCellProps }, refs: { tableHeadCellRefs }, setHoveredColumn } = table;
  const { columnSizingInfo, density, draggingColumn, grouping, hoveredColumn, showColumnFilters } = getState();
  const { column: column2 } = header;
  const { columnDef } = column2;
  const { columnDefType } = columnDef;
  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadCellProps, { column: column2, table })), parseFromValuesOrFunc(columnDef.muiTableHeadCellProps, {
    column: column2,
    table
  })), rest);
  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== "group" && column2.getIsPinned();
  const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) && columnDef.enableColumnActions !== false;
  const showDragHandle = enableColumnDragging !== false && columnDef.enableColumnDragging !== false && (enableColumnDragging || enableColumnOrdering && columnDef.enableColumnOrdering !== false || enableGrouping && columnDef.enableGrouping !== false && !grouping.includes(column2.id));
  const headerPL = reactExports.useMemo(() => {
    let pl2 = 0;
    if (column2.getCanSort())
      pl2 += 1;
    if (showColumnActions)
      pl2 += 1.75;
    if (showDragHandle)
      pl2 += 1.5;
    return pl2;
  }, [showColumnActions, showDragHandle]);
  const draggingBorders = reactExports.useMemo(() => {
    const showResizeBorder = columnSizingInfo.isResizingColumn === column2.id && columnResizeMode === "onChange" && !header.subHeaders.length;
    const borderStyle = showResizeBorder ? `2px solid ${draggingBorderColor} !important` : (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column2.id ? `1px dashed ${theme.palette.grey[500]}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column2.id ? `2px dashed ${draggingBorderColor}` : void 0;
    if (showResizeBorder) {
      return columnResizeDirection === "ltr" ? { borderRight: borderStyle } : { borderLeft: borderStyle };
    }
    const draggingBorders2 = borderStyle ? {
      borderLeft: borderStyle,
      borderRight: borderStyle,
      borderTop: borderStyle
    } : void 0;
    return draggingBorders2;
  }, [draggingColumn, hoveredColumn, columnSizingInfo.isResizingColumn]);
  const handleDragEnter = (_e2) => {
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn && columnDefType !== "group") {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column2 : null);
    }
  };
  const handleDragOver = (e3) => {
    if (columnDef.enableColumnOrdering !== false) {
      e3.preventDefault();
    }
  };
  const handleKeyDown = (event) => {
    var _a3;
    cellKeyboardShortcuts({
      event,
      cellValue: header.column.columnDef.header,
      table,
      header
    });
    (_a3 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(tableCellProps, event);
  };
  const HeaderElement = (_b2 = parseFromValuesOrFunc(columnDef.Header, {
    column: column2,
    header,
    table
  })) !== null && _b2 !== void 0 ? _b2 : columnDef.header;
  return jsxRuntimeExports.jsxs(TableCell, Object.assign({ align: columnDefType === "group" ? "center" : theme.direction === "rtl" ? "right" : "left", "aria-sort": column2.getIsSorted() ? column2.getIsSorted() === "asc" ? "ascending" : "descending" : "none", colSpan: header.colSpan, "data-can-sort": column2.getCanSort() || void 0, "data-index": staticColumnIndex, "data-pinned": !!isColumnPinned || void 0, "data-sort": column2.getIsSorted() || void 0, onDragEnter: handleDragEnter, onDragOver: handleDragOver, ref: (node2) => {
    var _a3;
    if (node2) {
      tableHeadCellRefs.current[column2.id] = node2;
      if (columnDefType !== "group") {
        (_a3 = columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement) === null || _a3 === void 0 ? void 0 : _a3.call(columnVirtualizer, node2);
      }
    }
  }, tabIndex: enableKeyboardShortcuts ? 0 : void 0 }, tableCellProps, { onKeyDown: handleKeyDown, sx: (theme2) => Object.assign(Object.assign({ "& :hover": {
    ".MuiButtonBase-root": {
      opacity: 1
    }
  }, flexDirection: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "column" : void 0, fontWeight: "bold", overflow: "visible", p: density === "compact" ? "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", pb: columnDefType === "display" ? 0 : showColumnFilters || density === "compact" ? "0.4rem" : "0.6rem", pt: columnDefType === "group" || density === "compact" ? "0.25rem" : density === "comfortable" ? ".75rem" : "1.25rem", userSelect: enableMultiSort && column2.getCanSort() ? "none" : void 0, verticalAlign: "top" }, getCommonMRTCellStyles({
    column: column2,
    header,
    table,
    tableCellProps,
    theme: theme2
  })), draggingBorders), children: [header.isPlaceholder ? null : (_c2 = tableCellProps.children) !== null && _c2 !== void 0 ? _c2 : jsxRuntimeExports.jsxs(Box, { className: "Mui-TableHeadCell-Content", sx: {
    alignItems: "center",
    display: "flex",
    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
    justifyContent: columnDefType === "group" || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? "center" : column2.getCanResize() ? "space-between" : "flex-start",
    position: "relative",
    width: "100%"
  }, children: [jsxRuntimeExports.jsxs(Box, { className: "Mui-TableHeadCell-Content-Labels", onClick: column2.getToggleSortingHandler(), sx: {
    alignItems: "center",
    cursor: column2.getCanSort() && columnDefType !== "group" ? "pointer" : void 0,
    display: "flex",
    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
    overflow: columnDefType === "data" ? "hidden" : void 0,
    pl: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? `${headerPL}rem` : void 0
  }, children: [jsxRuntimeExports.jsx(Box, { className: "Mui-TableHeadCell-Content-Wrapper", sx: {
    "&:hover": {
      textOverflow: "clip"
    },
    minWidth: `${Math.min((_f2 = (_d2 = columnDef.header) === null || _d2 === void 0 ? void 0 : _d2.length) !== null && _f2 !== void 0 ? _f2 : 0, 4)}ch`,
    overflow: columnDefType === "data" ? "hidden" : void 0,
    textOverflow: "ellipsis",
    whiteSpace: ((_h2 = (_g2 = columnDef.header) === null || _g2 === void 0 ? void 0 : _g2.length) !== null && _h2 !== void 0 ? _h2 : 0) < 20 ? "nowrap" : "normal"
  }, children: HeaderElement }), column2.getCanFilter() && jsxRuntimeExports.jsx(MRT_TableHeadCellFilterLabel, { header, table }), column2.getCanSort() && jsxRuntimeExports.jsx(MRT_TableHeadCellSortLabel, { header, table })] }), columnDefType !== "group" && jsxRuntimeExports.jsxs(Box, { className: "Mui-TableHeadCell-Content-Actions", sx: {
    whiteSpace: "nowrap"
  }, children: [showDragHandle && jsxRuntimeExports.jsx(MRT_TableHeadCellGrabHandle, { column: column2, table, tableHeadCellRef: {
    current: tableHeadCellRefs.current[column2.id]
  } }), showColumnActions && jsxRuntimeExports.jsx(MRT_TableHeadCellColumnActionsButton, { header, table })] }), column2.getCanResize() && jsxRuntimeExports.jsx(MRT_TableHeadCellResizeHandle, { header, table })] }), columnFilterDisplayMode === "subheader" && column2.getCanFilter() && jsxRuntimeExports.jsx(MRT_TableHeadCellFilterContainer, { header, table })] }));
};
const MRT_TableHeadRow = (_a2) => {
  var { columnVirtualizer, headerGroup, table } = _a2, rest = __rest(_a2, ["columnVirtualizer", "headerGroup", "table"]);
  const { options: { enableStickyHeader, layoutMode, mrtTheme: { baseBackgroundColor }, muiTableHeadRowProps } } = table;
  const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadRowProps, {
    headerGroup,
    table
  })), rest);
  return jsxRuntimeExports.jsxs(TableRow, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: baseBackgroundColor, boxShadow: `4px 0 8px ${alpha(theme.palette.common.black, 0.1)}`, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, position: enableStickyHeader && layoutMode === "semantic" ? "sticky" : "relative", top: 0 }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)), children: [virtualPaddingLeft ? jsxRuntimeExports.jsx("th", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader, staticColumnIndex) => {
    let header = headerOrVirtualHeader;
    if (columnVirtualizer) {
      staticColumnIndex = headerOrVirtualHeader.index;
      header = headerGroup.headers[staticColumnIndex];
    }
    return header ? jsxRuntimeExports.jsx(MRT_TableHeadCell, { columnVirtualizer, header, staticColumnIndex, table }, header.id) : null;
  }), virtualPaddingRight ? jsxRuntimeExports.jsx("th", { style: { display: "flex", width: virtualPaddingRight } }) : null] }));
};
const MRT_ToolbarAlertBanner = (_a2) => {
  var _b2, _c2, _d2;
  var { stackAlertBanner, table } = _a2, rest = __rest(_a2, ["stackAlertBanner", "table"]);
  const { getFilteredSelectedRowModel, getPrePaginationRowModel, getState, options: { enableRowSelection, enableSelectAll, localization, manualPagination, muiToolbarAlertBannerChipProps, muiToolbarAlertBannerProps, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount }, refs: { tablePaperRef } } = table;
  const { density, grouping, rowSelection, showAlertBanner } = getState();
  const alertProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiToolbarAlertBannerProps, {
    table
  })), rest);
  const chipProps = parseFromValuesOrFunc(muiToolbarAlertBannerChipProps, {
    table
  });
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().flatRows.length;
  const selectedRowCount = reactExports.useMemo(() => manualPagination ? Object.values(rowSelection).filter(Boolean).length : getFilteredSelectedRowModel().rows.length, [rowSelection, totalRowCount, manualPagination]);
  const selectedAlert = selectedRowCount > 0 ? jsxRuntimeExports.jsxs(Stack, { alignItems: "center", direction: "row", gap: "16px", children: [(_c2 = (_b2 = localization.selectedCountOfRowCountRowsSelected) === null || _b2 === void 0 ? void 0 : _b2.replace("{selectedCount}", selectedRowCount.toLocaleString())) === null || _c2 === void 0 ? void 0 : _c2.replace("{rowCount}", totalRowCount.toString()), jsxRuntimeExports.jsx(Button, { onClick: (event) => getMRT_SelectAllHandler({ table })(event, false, true), size: "small", sx: { p: "2px" }, children: localization.clearSelection })] }) : null;
  const groupedAlert = grouping.length > 0 ? jsxRuntimeExports.jsxs("span", { children: [localization.groupedBy, " ", grouping.map((columnId, index) => jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [index > 0 ? localization.thenBy : "", jsxRuntimeExports.jsx(Chip, Object.assign({ label: table.getColumn(columnId).columnDef.header, onDelete: () => table.getColumn(columnId).toggleGrouping() }, chipProps))] }, `${index}-${columnId}`))] }) : null;
  return jsxRuntimeExports.jsx(Collapse, { in: showAlertBanner || !!selectedAlert || !!groupedAlert, timeout: stackAlertBanner ? 200 : 0, children: jsxRuntimeExports.jsx(Alert, Object.assign({ color: "info", icon: false }, alertProps, { sx: (theme) => {
    var _a3, _b3;
    return Object.assign({ "& .MuiAlert-message": {
      maxWidth: `calc(${(_b3 = (_a3 = tablePaperRef.current) === null || _a3 === void 0 ? void 0 : _a3.clientWidth) !== null && _b3 !== void 0 ? _b3 : 360}px - 1rem)`,
      width: "100%"
    }, borderRadius: 0, fontSize: "1rem", left: 0, mb: stackAlertBanner ? 0 : positionToolbarAlertBanner === "bottom" ? "-1rem" : void 0, p: 0, position: "relative", right: 0, top: 0, width: "100%", zIndex: 2 }, parseFromValuesOrFunc(alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx, theme));
  }, children: (_d2 = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({
    groupedAlert,
    selectedAlert,
    table
  })) !== null && _d2 !== void 0 ? _d2 : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [(alertProps === null || alertProps === void 0 ? void 0 : alertProps.title) && jsxRuntimeExports.jsx(AlertTitle, { children: alertProps.title }), jsxRuntimeExports.jsxs(Stack, { sx: {
    p: positionToolbarAlertBanner !== "head-overlay" ? "0.5rem 1rem" : density === "spacious" ? "0.75rem 1.25rem" : density === "comfortable" ? "0.5rem 0.75rem" : "0.25rem 0.5rem"
  }, children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && jsxRuntimeExports.jsx("br", {}), jsxRuntimeExports.jsxs(Box, { sx: { display: "flex" }, children: [enableRowSelection && enableSelectAll && positionToolbarAlertBanner === "head-overlay" && jsxRuntimeExports.jsx(MRT_SelectCheckbox, { table }), " ", selectedAlert] }), selectedAlert && groupedAlert && jsxRuntimeExports.jsx("br", {}), groupedAlert] })] }) })) });
};
const MRT_TableHead = (_a2) => {
  var { columnVirtualizer, table } = _a2, rest = __rest(_a2, ["columnVirtualizer", "table"]);
  const { getState, options: { enableStickyHeader, layoutMode, muiTableHeadProps, positionToolbarAlertBanner }, refs: { tableHeadRef } } = table;
  const { isFullScreen, showAlertBanner } = getState();
  const tableHeadProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadProps, { table })), rest);
  const stickyHeader = enableStickyHeader || isFullScreen;
  return jsxRuntimeExports.jsx(TableHead, Object.assign({}, tableHeadProps, { ref: (ref) => {
    tableHeadRef.current = ref;
    if (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.ref) {
      tableHeadProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, opacity: 0.97, position: stickyHeader ? "sticky" : "relative", top: stickyHeader && (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? 0 : void 0, zIndex: stickyHeader ? 2 : void 0 }, parseFromValuesOrFunc(tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx, theme)), children: positionToolbarAlertBanner === "head-overlay" && (showAlertBanner || table.getSelectedRowModel().rows.length > 0) ? jsxRuntimeExports.jsx("tr", { style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0
  }, children: jsxRuntimeExports.jsx("th", { colSpan: table.getVisibleLeafColumns().length, style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0,
    padding: 0
  }, children: jsxRuntimeExports.jsx(MRT_ToolbarAlertBanner, { table }) }) }) : table.getHeaderGroups().map((headerGroup) => jsxRuntimeExports.jsx(MRT_TableHeadRow, { columnVirtualizer, headerGroup, table }, headerGroup.id)) }));
};
const MRT_Table = (_a2) => {
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getFlatHeaders, getState, options: { columns, enableStickyHeader, enableTableFooter, enableTableHead, layoutMode, memoMode, muiTableProps, renderCaption } } = table;
  const { columnSizing, columnSizingInfo, columnVisibility, isFullScreen } = getState();
  const tableProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableProps, { table })), rest);
  const Caption = parseFromValuesOrFunc(renderCaption, { table });
  const columnSizeVars = reactExports.useMemo(() => {
    const headers = getFlatHeaders();
    const colSizes = {};
    for (let i2 = 0; i2 < headers.length; i2++) {
      const header = headers[i2];
      const colSize = header.getSize();
      colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;
      colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;
    }
    return colSizes;
  }, [columns, columnSizing, columnSizingInfo, columnVisibility]);
  const columnVirtualizer = useMRT_ColumnVirtualizer(table);
  const commonTableGroupProps = {
    columnVirtualizer,
    table
  };
  return jsxRuntimeExports.jsxs(Table, Object.assign({ stickyHeader: enableStickyHeader || isFullScreen }, tableProps, { style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style), sx: (theme) => Object.assign({ borderCollapse: "separate", display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, position: "relative" }, parseFromValuesOrFunc(tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx, theme)), children: [!!Caption && jsxRuntimeExports.jsx("caption", { children: Caption }), enableTableHead && jsxRuntimeExports.jsx(MRT_TableHead, Object.assign({}, commonTableGroupProps)), memoMode === "table-body" || columnSizingInfo.isResizingColumn ? jsxRuntimeExports.jsx(Memo_MRT_TableBody, Object.assign({}, commonTableGroupProps)) : jsxRuntimeExports.jsx(MRT_TableBody, Object.assign({}, commonTableGroupProps)), enableTableFooter && jsxRuntimeExports.jsx(MRT_TableFooter, Object.assign({}, commonTableGroupProps))] }));
};
const MRT_TableLoadingOverlay = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { options: { id: id2, localization, mrtTheme: { baseBackgroundColor }, muiCircularProgressProps } } = table;
  const circularProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCircularProgressProps, { table })), rest);
  return jsxRuntimeExports.jsx(Box, { sx: {
    alignItems: "center",
    backgroundColor: alpha(baseBackgroundColor, 0.5),
    bottom: 0,
    display: "flex",
    justifyContent: "center",
    left: 0,
    maxHeight: "100vh",
    position: "absolute",
    right: 0,
    top: 0,
    width: "100%",
    zIndex: 3
  }, children: (_b2 = circularProgressProps === null || circularProgressProps === void 0 ? void 0 : circularProgressProps.Component) !== null && _b2 !== void 0 ? _b2 : jsxRuntimeExports.jsx(CircularProgress, Object.assign({ "aria-label": localization.noRecordsToDisplay, id: `mrt-progress-${id2}` }, circularProgressProps)) });
};
const MRT_CellActionMenu = (_a2) => {
  var _b2, _c2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { editDisplayMode, enableClickToCopy, enableEditing, icons: { ContentCopy: ContentCopy2, EditIcon }, localization, mrtTheme: { menuBackgroundColor }, renderCellActionMenuItems }, refs: { actionCellRef } } = table;
  const { actionCell, density } = getState();
  const cell = actionCell;
  const { row } = cell;
  const { column: column2 } = cell;
  const { columnDef } = column2;
  const handleClose = (event) => {
    event === null || event === void 0 ? void 0 : event.stopPropagation();
    table.setActionCell(null);
    actionCellRef.current = null;
  };
  const internalMenuItems = [
    (parseFromValuesOrFunc(enableClickToCopy, cell) === "context-menu" || parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === "context-menu") && jsxRuntimeExports.jsx(MRT_ActionMenuItem, { icon: jsxRuntimeExports.jsx(ContentCopy2, {}), label: localization.copy, onClick: (event) => {
      event.stopPropagation();
      navigator.clipboard.writeText(cell.getValue());
      handleClose();
    }, table }, "mrt-copy"),
    parseFromValuesOrFunc(enableEditing, row) && editDisplayMode === "cell" && jsxRuntimeExports.jsx(MRT_ActionMenuItem, { icon: jsxRuntimeExports.jsx(EditIcon, {}), label: localization.edit, onClick: () => {
      openEditingCell({ cell, table });
      handleClose();
    }, table }, "mrt-edit")
  ].filter(Boolean);
  const renderActionProps = {
    cell,
    closeMenu: handleClose,
    column: column2,
    internalMenuItems,
    row,
    table
  };
  const menuItems = (_c2 = (_b2 = columnDef.renderCellActionMenuItems) === null || _b2 === void 0 ? void 0 : _b2.call(columnDef, renderActionProps)) !== null && _c2 !== void 0 ? _c2 : renderCellActionMenuItems === null || renderCellActionMenuItems === void 0 ? void 0 : renderCellActionMenuItems(renderActionProps);
  return (!!(menuItems === null || menuItems === void 0 ? void 0 : menuItems.length) || !!(internalMenuItems === null || internalMenuItems === void 0 ? void 0 : internalMenuItems.length)) && jsxRuntimeExports.jsx(Menu, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl: actionCellRef.current, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: handleClose, open: !!cell, transformOrigin: { horizontal: -100, vertical: 8 } }, rest, { children: menuItems !== null && menuItems !== void 0 ? menuItems : internalMenuItems }));
};
const MRT_EditRowModal = (_a2) => {
  var _b2;
  var { open, table } = _a2, rest = __rest(_a2, ["open", "table"]);
  const { getState, options: { localization, muiCreateRowModalProps, muiEditRowDialogProps, onCreatingRowCancel, onEditingRowCancel, renderCreateRowDialogContent, renderEditRowDialogContent }, setCreatingRow, setEditingRow } = table;
  const { creatingRow, editingRow } = getState();
  const row = creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow;
  const dialogProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditRowDialogProps, { row, table })), creatingRow && parseFromValuesOrFunc(muiCreateRowModalProps, { row, table })), rest);
  const internalEditComponents = row.getAllCells().filter((cell) => cell.column.columnDef.columnDefType === "data").map((cell) => jsxRuntimeExports.jsx(MRT_EditCellTextField, { cell, table }, cell.id));
  return jsxRuntimeExports.jsx(Dialog, Object.assign({ fullWidth: true, maxWidth: "xs", onClose: (event, reason) => {
    var _a3;
    if (creatingRow) {
      onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
      setCreatingRow(null);
    } else {
      onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
      setEditingRow(null);
    }
    row._valuesCache = {};
    (_a3 = dialogProps.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(dialogProps, event, reason);
  }, open }, dialogProps, { children: (_b2 = creatingRow && (renderCreateRowDialogContent === null || renderCreateRowDialogContent === void 0 ? void 0 : renderCreateRowDialogContent({
    internalEditComponents,
    row,
    table
  })) || (renderEditRowDialogContent === null || renderEditRowDialogContent === void 0 ? void 0 : renderEditRowDialogContent({
    internalEditComponents,
    row,
    table
  }))) !== null && _b2 !== void 0 ? _b2 : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(DialogTitle, { sx: { textAlign: "center" }, children: localization.edit }), jsxRuntimeExports.jsx(DialogContent, { children: jsxRuntimeExports.jsx("form", { onSubmit: (e3) => e3.preventDefault(), children: jsxRuntimeExports.jsx(Stack, { sx: {
    gap: "32px",
    paddingTop: "16px",
    width: "100%"
  }, children: internalEditComponents }) }) }), jsxRuntimeExports.jsx(DialogActions, { sx: { p: "1.25rem" }, children: jsxRuntimeExports.jsx(MRT_EditActionButtons, { row, table, variant: "text" }) })] }) }));
};
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const MRT_TableContainer = (_a2) => {
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { createDisplayMode, editDisplayMode, enableCellActions, enableStickyHeader, muiTableContainerProps }, refs: { bottomToolbarRef, tableContainerRef, topToolbarRef } } = table;
  const { actionCell, creatingRow, editingRow, isFullScreen, isLoading, showLoadingOverlay } = getState();
  const loading = showLoadingOverlay !== false && (isLoading || showLoadingOverlay);
  const [totalToolbarHeight, setTotalToolbarHeight] = reactExports.useState(0);
  const tableContainerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableContainerProps, {
    table
  })), rest);
  useIsomorphicLayoutEffect(() => {
    var _a3, _b2, _c2, _d2;
    const topToolbarHeight = typeof document !== "undefined" ? (_b2 = (_a3 = topToolbarRef.current) === null || _a3 === void 0 ? void 0 : _a3.offsetHeight) !== null && _b2 !== void 0 ? _b2 : 0 : 0;
    const bottomToolbarHeight = typeof document !== "undefined" ? (_d2 = (_c2 = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c2 === void 0 ? void 0 : _c2.offsetHeight) !== null && _d2 !== void 0 ? _d2 : 0 : 0;
    setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
  });
  const createModalOpen = createDisplayMode === "modal" && creatingRow;
  const editModalOpen = editDisplayMode === "modal" && editingRow;
  return jsxRuntimeExports.jsxs(TableContainer, Object.assign({ "aria-busy": loading, "aria-describedby": loading ? "mrt-progress" : void 0 }, tableContainerProps, { ref: (node2) => {
    if (node2) {
      tableContainerRef.current = node2;
      if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
        tableContainerProps.ref.current = node2;
      }
    }
  }, style: Object.assign({ maxHeight: isFullScreen ? `calc(100vh - ${totalToolbarHeight}px)` : void 0 }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style), sx: (theme) => Object.assign({ maxHeight: enableStickyHeader ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)` : void 0, maxWidth: "100%", overflow: "auto", position: "relative" }, parseFromValuesOrFunc(tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx, theme)), children: [loading ? jsxRuntimeExports.jsx(MRT_TableLoadingOverlay, { table }) : null, jsxRuntimeExports.jsx(MRT_Table, { table }), (createModalOpen || editModalOpen) && jsxRuntimeExports.jsx(MRT_EditRowModal, { open: true, table }), enableCellActions && actionCell && jsxRuntimeExports.jsx(MRT_CellActionMenu, { table })] }));
};
const MRT_LinearProgressBar = (_a2) => {
  var { isTopToolbar, table } = _a2, rest = __rest(_a2, ["isTopToolbar", "table"]);
  const { getState, options: { muiLinearProgressProps } } = table;
  const { isSaving, showProgressBars } = getState();
  const linearProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiLinearProgressProps, {
    isTopToolbar,
    table
  })), rest);
  return jsxRuntimeExports.jsx(Collapse, { in: showProgressBars !== false && (showProgressBars || isSaving), mountOnEnter: true, sx: {
    bottom: isTopToolbar ? 0 : void 0,
    position: "absolute",
    top: !isTopToolbar ? 0 : void 0,
    width: "100%"
  }, unmountOnExit: true, children: jsxRuntimeExports.jsx(LinearProgress, Object.assign({ "aria-busy": "true", "aria-label": "Loading", sx: { position: "relative" } }, linearProgressProps)) });
};
const defaultRowsPerPage = [5, 10, 15, 20, 25, 30, 50, 100];
const MRT_TablePagination = (_a2) => {
  var { position: position2 = "bottom", table } = _a2, rest = __rest(_a2, ["position", "table"]);
  const theme = useTheme();
  const isMobile = useMediaQuery("(max-width: 720px)");
  const { getState, options: { enableToolbarInternalActions, icons: { ChevronLeftIcon, ChevronRightIcon, FirstPageIcon: FirstPageIcon2, LastPageIcon: LastPageIcon2 }, id: id2, localization, muiPaginationProps, paginationDisplayMode } } = table;
  const { pagination: { pageIndex = 0, pageSize: pageSize2 = 10 } } = getState();
  const paginationProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiPaginationProps, {
    table
  })), rest);
  const totalRowCount = table.getRowCount();
  const numberOfPages = table.getPageCount();
  const showFirstLastPageButtons = numberOfPages > 2;
  const firstRowIndex = pageIndex * pageSize2;
  const lastRowIndex = Math.min(pageIndex * pageSize2 + pageSize2, totalRowCount);
  const _b2 = paginationProps !== null && paginationProps !== void 0 ? paginationProps : {}, { SelectProps = {}, disabled = false, rowsPerPageOptions = defaultRowsPerPage, showFirstButton = showFirstLastPageButtons, showLastButton = showFirstLastPageButtons, showRowsPerPage = true } = _b2, restPaginationProps = __rest(_b2, ["SelectProps", "disabled", "rowsPerPageOptions", "showFirstButton", "showLastButton", "showRowsPerPage"]);
  const disableBack = pageIndex <= 0 || disabled;
  const disableNext = lastRowIndex >= totalRowCount || disabled;
  if (isMobile && (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) !== false) {
    SelectProps.native = true;
  }
  const tooltipProps = getCommonTooltipProps();
  return jsxRuntimeExports.jsxs(Box, { className: "MuiTablePagination-root", sx: {
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap",
    gap: "8px",
    justifyContent: { md: "space-between", sm: "center" },
    justifySelf: "flex-end",
    mt: position2 === "top" && enableToolbarInternalActions ? "3rem" : void 0,
    position: "relative",
    px: "8px",
    py: "12px",
    zIndex: 2
  }, children: [showRowsPerPage && jsxRuntimeExports.jsxs(Box, { sx: { alignItems: "center", display: "flex", gap: "8px" }, children: [jsxRuntimeExports.jsx(InputLabel, { htmlFor: `mrt-rows-per-page-${id2}`, sx: { mb: 0 }, children: localization.rowsPerPage }), jsxRuntimeExports.jsx(Select, Object.assign({ MenuProps: { disableScrollLock: true }, disableUnderline: true, disabled, inputProps: {
    "aria-label": localization.rowsPerPage,
    id: `mrt-rows-per-page-${id2}`
  }, label: localization.rowsPerPage, onChange: (event) => table.setPageSize(+event.target.value), sx: { mb: 0 }, value: pageSize2, variant: "standard" }, SelectProps, { children: rowsPerPageOptions.map((option) => {
    var _a3;
    const value = typeof option !== "number" ? option.value : option;
    const label = typeof option !== "number" ? option.label : `${option}`;
    return (_a3 = SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.children) !== null && _a3 !== void 0 ? _a3 : (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) ? jsxRuntimeExports.jsx("option", { value, children: label }, value) : jsxRuntimeExports.jsx(MenuItem, { sx: { m: 0 }, value, children: label }, value);
  }) }))] }), paginationDisplayMode === "pages" ? jsxRuntimeExports.jsx(Pagination, Object.assign({ count: numberOfPages, disabled, onChange: (_e2, newPageIndex) => table.setPageIndex(newPageIndex - 1), page: pageIndex + 1, renderItem: (item) => jsxRuntimeExports.jsx(PaginationItem, Object.assign({ slots: {
    first: FirstPageIcon2,
    last: LastPageIcon2,
    next: ChevronRightIcon,
    previous: ChevronLeftIcon
  } }, item)), showFirstButton, showLastButton }, restPaginationProps)) : paginationDisplayMode === "default" ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Typography, { align: "center", component: "span", sx: { m: "0 4px", minWidth: "8ch" }, variant: "body2", children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}` }), jsxRuntimeExports.jsxs(Box, { gap: "xs", children: [showFirstButton && jsxRuntimeExports.jsx(Tooltip, Object.assign({}, tooltipProps, { title: localization.goToFirstPage, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.goToFirstPage, disabled: disableBack, onClick: () => table.firstPage(), size: "small", children: jsxRuntimeExports.jsx(FirstPageIcon2, Object.assign({}, flipIconStyles(theme))) }) }) })), jsxRuntimeExports.jsx(Tooltip, Object.assign({}, tooltipProps, { title: localization.goToPreviousPage, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.goToPreviousPage, disabled: disableBack, onClick: () => table.previousPage(), size: "small", children: jsxRuntimeExports.jsx(ChevronLeftIcon, Object.assign({}, flipIconStyles(theme))) }) }) })), jsxRuntimeExports.jsx(Tooltip, Object.assign({}, tooltipProps, { title: localization.goToNextPage, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.goToNextPage, disabled: disableNext, onClick: () => table.nextPage(), size: "small", children: jsxRuntimeExports.jsx(ChevronRightIcon, Object.assign({}, flipIconStyles(theme))) }) }) })), showLastButton && jsxRuntimeExports.jsx(Tooltip, Object.assign({}, tooltipProps, { title: localization.goToLastPage, children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.goToLastPage, disabled: disableNext, onClick: () => table.lastPage(), size: "small", children: jsxRuntimeExports.jsx(LastPageIcon2, Object.assign({}, flipIconStyles(theme))) }) }) }))] })] }) : null] });
};
const MRT_ToolbarDropZone = (_a2) => {
  var _b2, _c2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone } = table;
  const { draggingColumn, grouping, hoveredColumn, showToolbarDropZone } = getState();
  const handleDragEnter = (_event) => {
    setHoveredColumn({ id: "drop-zone" });
  };
  const handleDragOver = (e3) => {
    e3.preventDefault();
  };
  reactExports.useEffect(() => {
    var _a3;
    if (((_a3 = table.options.state) === null || _a3 === void 0 ? void 0 : _a3.showToolbarDropZone) !== void 0) {
      setShowToolbarDropZone(!!enableGrouping && !!draggingColumn && draggingColumn.columnDef.enableGrouping !== false && !grouping.includes(draggingColumn.id));
    }
  }, [enableGrouping, draggingColumn, grouping]);
  return jsxRuntimeExports.jsx(Fade, { in: showToolbarDropZone, children: jsxRuntimeExports.jsx(Box, Object.assign({ className: "Mui-ToolbarDropZone", onDragEnter: handleDragEnter, onDragOver: handleDragOver }, rest, { sx: (theme) => Object.assign({ alignItems: "center", backdropFilter: "blur(4px)", backgroundColor: alpha(theme.palette.info.main, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone" ? 0.2 : 0.1), border: `dashed ${theme.palette.info.main} 2px`, boxSizing: "border-box", display: "flex", height: "100%", justifyContent: "center", position: "absolute", width: "100%", zIndex: 4 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: jsxRuntimeExports.jsx(Typography, { fontStyle: "italic", children: localization.dropToGroupBy.replace("{column}", (_c2 = (_b2 = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _b2 === void 0 ? void 0 : _b2.header) !== null && _c2 !== void 0 ? _c2 : "") }) })) });
};
const MRT_BottomToolbar = (_a2) => {
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { enablePagination, muiBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions }, refs: { bottomToolbarRef } } = table;
  const { isFullScreen } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const toolbarProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiBottomToolbarProps, { table })), rest);
  const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
  return jsxRuntimeExports.jsxs(Box, Object.assign({}, toolbarProps, { ref: (node2) => {
    if (node2) {
      bottomToolbarRef.current = node2;
      if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
        toolbarProps.ref.current = node2;
      }
    }
  }, sx: (theme) => Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({ table, theme })), { bottom: isFullScreen ? "0" : void 0, boxShadow: `0 1px 2px -1px ${alpha(theme.palette.grey[700], 0.5)} inset`, left: 0, position: isFullScreen ? "fixed" : "relative", right: 0 }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme)), children: [jsxRuntimeExports.jsx(MRT_LinearProgressBar, { isTopToolbar: false, table }), positionToolbarAlertBanner === "bottom" && jsxRuntimeExports.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner, table }), ["both", "bottom"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && jsxRuntimeExports.jsx(MRT_ToolbarDropZone, { table }), jsxRuntimeExports.jsxs(Box, { sx: {
    alignItems: "center",
    boxSizing: "border-box",
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    width: "100%"
  }, children: [renderBottomToolbarCustomActions ? renderBottomToolbarCustomActions({ table }) : jsxRuntimeExports.jsx("span", {}), jsxRuntimeExports.jsx(Box, { sx: {
    display: "flex",
    justifyContent: "flex-end",
    position: stackAlertBanner ? "relative" : "absolute",
    right: 0,
    top: 0
  }, children: enablePagination && ["both", "bottom"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && jsxRuntimeExports.jsx(MRT_TablePagination, { position: "bottom", table }) })] })] }));
};
const MRT_ColumnPinningButtons = (_a2) => {
  var { column: column2, table } = _a2, rest = __rest(_a2, ["column", "table"]);
  const { options: { icons: { PushPinIcon }, localization } } = table;
  const handlePinColumn = (pinDirection) => {
    column2.pin(pinDirection);
  };
  return jsxRuntimeExports.jsx(Box, Object.assign({}, rest, { sx: (theme) => Object.assign({ minWidth: "70px", textAlign: "center" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: column2.getIsPinned() ? jsxRuntimeExports.jsx(Tooltip, { title: localization.unpin, children: jsxRuntimeExports.jsx(IconButton, { onClick: () => handlePinColumn(false), size: "small", children: jsxRuntimeExports.jsx(PushPinIcon, {}) }) }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, { title: localization.pinToLeft, children: jsxRuntimeExports.jsx(IconButton, { onClick: () => handlePinColumn("left"), size: "small", children: jsxRuntimeExports.jsx(PushPinIcon, { style: {
    transform: "rotate(90deg)"
  } }) }) }), jsxRuntimeExports.jsx(Tooltip, { title: localization.pinToRight, children: jsxRuntimeExports.jsx(IconButton, { onClick: () => handlePinColumn("right"), size: "small", children: jsxRuntimeExports.jsx(PushPinIcon, { style: {
    transform: "rotate(-90deg)"
  } }) }) })] }) }));
};
const MRT_ShowHideColumnsMenuItems = (_a2) => {
  var _b2;
  var { allColumns, column: column2, hoveredColumn, isNestedColumns, setHoveredColumn, table } = _a2, rest = __rest(_a2, ["allColumns", "column", "hoveredColumn", "isNestedColumns", "setHoveredColumn", "table"]);
  const { getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, mrtTheme: { draggingBorderColor } }, setColumnOrder } = table;
  const { columnOrder } = getState();
  const { columnDef } = column2;
  const { columnDefType } = columnDef;
  const switchChecked = column2.getIsVisible();
  const handleToggleColumnHidden = (column3) => {
    var _a3, _b3;
    if (columnDefType === "group") {
      (_b3 = (_a3 = column3 === null || column3 === void 0 ? void 0 : column3.columns) === null || _a3 === void 0 ? void 0 : _a3.forEach) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, (childColumn) => {
        childColumn.toggleVisibility(!switchChecked);
      });
    } else {
      column3.toggleVisibility();
    }
  };
  const menuItemRef = reactExports.useRef(null);
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const handleDragStart = (e3) => {
    setIsDragging(true);
    try {
      e3.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
    } catch (e4) {
      console.error(e4);
    }
  };
  const handleDragEnd = (_e2) => {
    setIsDragging(false);
    setHoveredColumn(null);
    if (hoveredColumn) {
      setColumnOrder(reorderColumn(column2, hoveredColumn, columnOrder));
    }
  };
  const handleDragEnter = (_e2) => {
    if (!isDragging && columnDef.enableColumnOrdering !== false) {
      setHoveredColumn(column2);
    }
  };
  if (!columnDef.header || columnDef.visibleInShowHideMenu === false) {
    return null;
  }
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(MenuItem, Object.assign({ disableRipple: true, onDragEnter: handleDragEnter, ref: menuItemRef }, rest, { sx: (theme) => Object.assign({ alignItems: "center", justifyContent: "flex-start", my: 0, opacity: isDragging ? 0.5 : 1, outline: isDragging ? `2px dashed ${theme.palette.grey[500]}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column2.id ? `2px dashed ${draggingBorderColor}` : "none", outlineOffset: "-2px", pl: `${(column2.depth + 0.5) * 2}rem`, py: "6px" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: jsxRuntimeExports.jsxs(Box, { sx: {
    display: "flex",
    flexWrap: "nowrap",
    gap: "8px"
  }, children: [columnDefType !== "group" && enableColumnOrdering && !isNestedColumns && (columnDef.enableColumnOrdering !== false ? jsxRuntimeExports.jsx(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }) : jsxRuntimeExports.jsx(Box, { sx: { width: "28px" } })), enableColumnPinning && (column2.getCanPin() ? jsxRuntimeExports.jsx(MRT_ColumnPinningButtons, { column: column2, table }) : jsxRuntimeExports.jsx(Box, { sx: { width: "70px" } })), enableHiding ? jsxRuntimeExports.jsx(FormControlLabel, { checked: switchChecked, componentsProps: {
    typography: {
      sx: {
        mb: 0,
        opacity: columnDefType !== "display" ? 1 : 0.5
      }
    }
  }, control: jsxRuntimeExports.jsx(Tooltip, Object.assign({}, getCommonTooltipProps(), { title: localization.toggleVisibility, children: jsxRuntimeExports.jsx(Switch, {}) })), disabled: !column2.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column2) }) : jsxRuntimeExports.jsx(Typography, { sx: { alignSelf: "center" }, children: columnDef.header })] }) })), (_b2 = column2.columns) === null || _b2 === void 0 ? void 0 : _b2.map((c3, i2) => jsxRuntimeExports.jsx(MRT_ShowHideColumnsMenuItems, { allColumns, column: c3, hoveredColumn, isNestedColumns, setHoveredColumn, table }, `${i2}-${c3.id}`))] });
};
const MRT_ShowHideColumnsMenu = (_a2) => {
  var { anchorEl, setAnchorEl, table } = _a2, rest = __rest(_a2, ["anchorEl", "setAnchorEl", "table"]);
  const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, mrtTheme: { menuBackgroundColor } } } = table;
  const { columnOrder, columnPinning, density } = getState();
  const handleToggleAllColumns = (value) => {
    getAllLeafColumns().filter((col) => col.columnDef.enableHiding !== false).forEach((col) => col.toggleVisibility(value));
  };
  const allColumns = reactExports.useMemo(() => {
    const columns = getAllColumns();
    if (columnOrder.length > 0 && !columns.some((col) => col.columnDef.columnDefType === "group")) {
      return [
        ...getLeftLeafColumns(),
        ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
        ...getRightLeafColumns()
      ].filter(Boolean);
    }
    return columns;
  }, [
    columnOrder,
    columnPinning,
    getAllColumns(),
    getCenterLeafColumns(),
    getLeftLeafColumns(),
    getRightLeafColumns()
  ]);
  const isNestedColumns = allColumns.some((col) => col.columnDef.columnDefType === "group");
  const [hoveredColumn, setHoveredColumn] = reactExports.useState(null);
  return jsxRuntimeExports.jsxs(Menu, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: [jsxRuntimeExports.jsxs(Box, { sx: {
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    pt: 0
  }, children: [enableHiding && jsxRuntimeExports.jsx(Button, { disabled: !getIsSomeColumnsVisible(), onClick: () => handleToggleAllColumns(false), children: localization.hideAll }), enableColumnOrdering && jsxRuntimeExports.jsx(Button, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options, true)), children: localization.resetOrder }), enableColumnPinning && jsxRuntimeExports.jsx(Button, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), children: localization.unpinAll }), enableHiding && jsxRuntimeExports.jsx(Button, { disabled: getIsAllColumnsVisible(), onClick: () => handleToggleAllColumns(true), children: localization.showAll })] }), jsxRuntimeExports.jsx(Divider, {}), allColumns.map((column2, index) => jsxRuntimeExports.jsx(MRT_ShowHideColumnsMenuItems, { allColumns, column: column2, hoveredColumn, isNestedColumns, setHoveredColumn, table }, `${index}-${column2.id}`))] }));
};
const MRT_ShowHideColumnsButton = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { options: { icons: { ViewColumnIcon }, localization } } = table;
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Tooltip, { title: (_b2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b2 !== void 0 ? _b2 : localization.showHideColumns, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.showHideColumns, onClick: handleClick }, rest, { title: void 0, children: jsxRuntimeExports.jsx(ViewColumnIcon, {}) })) }), anchorEl && jsxRuntimeExports.jsx(MRT_ShowHideColumnsMenu, { anchorEl, setAnchorEl, table })] });
};
const MRT_ToggleDensePaddingButton = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { icons: { DensityLargeIcon, DensityMediumIcon, DensitySmallIcon }, localization }, setDensity } = table;
  const { density } = getState();
  const handleToggleDensePadding = () => {
    const nextDensity = density === "comfortable" ? "compact" : density === "compact" ? "spacious" : "comfortable";
    setDensity(nextDensity);
  };
  return jsxRuntimeExports.jsx(Tooltip, { title: (_b2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b2 !== void 0 ? _b2 : localization.toggleDensity, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.toggleDensity, onClick: handleToggleDensePadding }, rest, { title: void 0, children: density === "compact" ? jsxRuntimeExports.jsx(DensitySmallIcon, {}) : density === "comfortable" ? jsxRuntimeExports.jsx(DensityMediumIcon, {}) : jsxRuntimeExports.jsx(DensityLargeIcon, {}) })) });
};
const MRT_ToggleFiltersButton = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { icons: { FilterListIcon, FilterListOffIcon }, localization }, setShowColumnFilters } = table;
  const { showColumnFilters } = getState();
  const handleToggleShowFilters = () => {
    setShowColumnFilters(!showColumnFilters);
  };
  return jsxRuntimeExports.jsx(Tooltip, { title: (_b2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b2 !== void 0 ? _b2 : localization.showHideFilters, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleShowFilters }, rest, { title: void 0, children: showColumnFilters ? jsxRuntimeExports.jsx(FilterListOffIcon, {}) : jsxRuntimeExports.jsx(FilterListIcon, {}) })) });
};
const MRT_ToggleFullScreenButton = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { icons: { FullscreenExitIcon, FullscreenIcon }, localization }, setIsFullScreen } = table;
  const { isFullScreen } = getState();
  const [tooltipOpened, setTooltipOpened] = reactExports.useState(false);
  const handleToggleFullScreen = () => {
    setTooltipOpened(false);
    setIsFullScreen(!isFullScreen);
  };
  return jsxRuntimeExports.jsx(Tooltip, { open: tooltipOpened, title: (_b2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b2 !== void 0 ? _b2 : localization.toggleFullScreen, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": localization.toggleFullScreen, onBlur: () => setTooltipOpened(false), onClick: handleToggleFullScreen, onFocus: () => setTooltipOpened(true), onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false) }, rest, { title: void 0, children: isFullScreen ? jsxRuntimeExports.jsx(FullscreenExitIcon, {}) : jsxRuntimeExports.jsx(FullscreenIcon, {}) })) });
};
const MRT_ToggleGlobalFilterButton = (_a2) => {
  var _b2, _c2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { icons: { SearchIcon, SearchOffIcon }, localization }, refs: { searchInputRef }, setShowGlobalFilter } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const handleToggleSearch = () => {
    setShowGlobalFilter(!showGlobalFilter);
    queueMicrotask(() => {
      var _a3;
      return (_a3 = searchInputRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
    });
  };
  return jsxRuntimeExports.jsx(Tooltip, { title: (_b2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b2 !== void 0 ? _b2 : localization.showHideSearch, children: jsxRuntimeExports.jsx(IconButton, Object.assign({ "aria-label": (_c2 = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c2 !== void 0 ? _c2 : localization.showHideSearch, disabled: !!globalFilter, onClick: handleToggleSearch }, rest, { title: void 0, children: showGlobalFilter ? jsxRuntimeExports.jsx(SearchOffIcon, {}) : jsxRuntimeExports.jsx(SearchIcon, {}) })) });
};
const MRT_ToolbarInternalButtons = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableColumnPinning, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, initialState: initialState2, renderToolbarInternalActions } } = table;
  return jsxRuntimeExports.jsx(Box, Object.assign({}, rest, { sx: (theme) => Object.assign({ alignItems: "center", display: "flex", zIndex: 3 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: (_b2 = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({
    table
  })) !== null && _b2 !== void 0 ? _b2 : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [enableFilters && enableGlobalFilter && !(initialState2 === null || initialState2 === void 0 ? void 0 : initialState2.showGlobalFilter) && jsxRuntimeExports.jsx(MRT_ToggleGlobalFilterButton, { table }), enableFilters && enableColumnFilters && columnFilterDisplayMode !== "popover" && jsxRuntimeExports.jsx(MRT_ToggleFiltersButton, { table }), (enableHiding || enableColumnOrdering || enableColumnPinning) && jsxRuntimeExports.jsx(MRT_ShowHideColumnsButton, { table }), enableDensityToggle && jsxRuntimeExports.jsx(MRT_ToggleDensePaddingButton, { table }), enableFullScreenToggle && jsxRuntimeExports.jsx(MRT_ToggleFullScreenButton, { table })] }) }));
};
const MRT_GlobalFilterTextField = (_a2) => {
  var _b2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { enableGlobalFilterModes, icons: { CloseIcon: CloseIcon2, SearchIcon }, localization, manualFiltering, muiSearchTextFieldProps }, refs: { searchInputRef }, setGlobalFilter } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const textFieldProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiSearchTextFieldProps, {
    table
  })), rest);
  const isMounted = reactExports.useRef(false);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [searchValue, setSearchValue] = reactExports.useState(globalFilter !== null && globalFilter !== void 0 ? globalFilter : "");
  const handleChangeDebounced = reactExports.useCallback(debounce$2((event) => {
    var _a3;
    setGlobalFilter((_a3 = event.target.value) !== null && _a3 !== void 0 ? _a3 : void 0);
  }, manualFiltering ? 500 : 250), []);
  const handleChange = (event) => {
    setSearchValue(event.target.value);
    handleChangeDebounced(event);
  };
  const handleGlobalFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClear = () => {
    setSearchValue("");
    setGlobalFilter(void 0);
  };
  reactExports.useEffect(() => {
    if (isMounted.current) {
      if (globalFilter === void 0) {
        handleClear();
      } else {
        setSearchValue(globalFilter);
      }
    }
    isMounted.current = true;
  }, [globalFilter]);
  return jsxRuntimeExports.jsxs(Collapse, { in: showGlobalFilter, mountOnEnter: true, orientation: "horizontal", unmountOnExit: true, children: [jsxRuntimeExports.jsx(TextField, Object.assign({ inputProps: Object.assign({ autoComplete: "new-password" }, textFieldProps.inputProps), onChange: handleChange, placeholder: localization.search, size: "small", value: searchValue !== null && searchValue !== void 0 ? searchValue : "", variant: "outlined" }, textFieldProps, { InputProps: Object.assign(Object.assign({ endAdornment: jsxRuntimeExports.jsx(InputAdornment, { position: "end", children: jsxRuntimeExports.jsx(Tooltip, { title: (_b2 = localization.clearSearch) !== null && _b2 !== void 0 ? _b2 : "", children: jsxRuntimeExports.jsx("span", { children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "small", children: jsxRuntimeExports.jsx(CloseIcon2, {}) }) }) }) }), startAdornment: enableGlobalFilterModes ? jsxRuntimeExports.jsx(InputAdornment, { position: "start", children: jsxRuntimeExports.jsx(Tooltip, { title: localization.changeSearchMode, children: jsxRuntimeExports.jsx(IconButton, { "aria-label": localization.changeSearchMode, onClick: handleGlobalFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" }, children: jsxRuntimeExports.jsx(SearchIcon, {}) }) }) }) : jsxRuntimeExports.jsx(SearchIcon, { style: { marginRight: "4px" } }) }, textFieldProps.InputProps), { sx: (theme) => {
    var _a3;
    return Object.assign({ mb: 0 }, parseFromValuesOrFunc((_a3 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a3 === void 0 ? void 0 : _a3.sx, theme));
  } }), inputRef: (inputRef) => {
    searchInputRef.current = inputRef;
    if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.inputRef) {
      textFieldProps.inputRef = inputRef;
    }
  } })), jsxRuntimeExports.jsx(MRT_FilterOptionMenu, { anchorEl, onSelect: handleClear, setAnchorEl, table })] });
};
const MRT_TopToolbar = ({ table }) => {
  var _a2;
  const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, muiTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions }, refs: { topToolbarRef } } = table;
  const { isFullScreen, showGlobalFilter } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const isTablet = useMediaQuery("(max-width:1024px)");
  const toolbarProps = parseFromValuesOrFunc(muiTopToolbarProps, { table });
  const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter && isTablet;
  const globalFilterProps = {
    sx: !isTablet ? {
      zIndex: 2
    } : void 0,
    table
  };
  return jsxRuntimeExports.jsxs(Box, Object.assign({}, toolbarProps, { ref: (ref) => {
    topToolbarRef.current = ref;
    if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
      toolbarProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({ table, theme })), { position: isFullScreen ? "sticky" : "relative", top: isFullScreen ? "0" : void 0 }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme)), children: [positionToolbarAlertBanner === "top" && jsxRuntimeExports.jsx(MRT_ToolbarAlertBanner, { stackAlertBanner, table }), ["both", "top"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && jsxRuntimeExports.jsx(MRT_ToolbarDropZone, { table }), jsxRuntimeExports.jsxs(Box, { sx: {
    alignItems: "flex-start",
    boxSizing: "border-box",
    display: "flex",
    gap: "0.5rem",
    justifyContent: "space-between",
    p: "0.5rem",
    position: stackAlertBanner ? "relative" : "absolute",
    right: 0,
    top: 0,
    width: "100%"
  }, children: [enableGlobalFilter && positionGlobalFilter === "left" && jsxRuntimeExports.jsx(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps)), (_a2 = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a2 !== void 0 ? _a2 : jsxRuntimeExports.jsx("span", {}), enableToolbarInternalActions ? jsxRuntimeExports.jsxs(Box, { sx: {
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap-reverse",
    gap: "0.5rem",
    justifyContent: "flex-end"
  }, children: [enableGlobalFilter && positionGlobalFilter === "right" && jsxRuntimeExports.jsx(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps)), jsxRuntimeExports.jsx(MRT_ToolbarInternalButtons, { table })] }) : enableGlobalFilter && positionGlobalFilter === "right" && jsxRuntimeExports.jsx(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps))] }), enablePagination && ["both", "top"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && jsxRuntimeExports.jsx(MRT_TablePagination, { position: "top", table }), jsxRuntimeExports.jsx(MRT_LinearProgressBar, { isTopToolbar: true, table })] }));
};
const MRT_TablePaper = (_a2) => {
  var _b2, _c2;
  var { table } = _a2, rest = __rest(_a2, ["table"]);
  const { getState, options: { enableBottomToolbar, enableTopToolbar, mrtTheme: { baseBackgroundColor }, muiTablePaperProps, renderBottomToolbar, renderTopToolbar }, refs: { tablePaperRef } } = table;
  const { isFullScreen } = getState();
  const paperProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTablePaperProps, { table })), rest);
  const theme = useTheme();
  return jsxRuntimeExports.jsxs(Paper, Object.assign({ elevation: 2, onKeyDown: (e3) => e3.key === "Escape" && table.setIsFullScreen(false) }, paperProps, { ref: (ref) => {
    tablePaperRef.current = ref;
    if (paperProps === null || paperProps === void 0 ? void 0 : paperProps.ref) {
      paperProps.ref.current = ref;
    }
  }, style: Object.assign(Object.assign({}, isFullScreen ? {
    bottom: 0,
    height: "100dvh",
    left: 0,
    margin: 0,
    maxHeight: "100dvh",
    maxWidth: "100dvw",
    padding: 0,
    position: "fixed",
    right: 0,
    top: 0,
    width: "100dvw",
    zIndex: theme.zIndex.modal
  } : {}), paperProps === null || paperProps === void 0 ? void 0 : paperProps.style), sx: (theme2) => Object.assign({ backgroundColor: baseBackgroundColor, backgroundImage: "unset", overflow: "hidden", transition: "all 100ms ease-in-out" }, parseFromValuesOrFunc(paperProps === null || paperProps === void 0 ? void 0 : paperProps.sx, theme2)), children: [enableTopToolbar && ((_b2 = parseFromValuesOrFunc(renderTopToolbar, { table })) !== null && _b2 !== void 0 ? _b2 : jsxRuntimeExports.jsx(MRT_TopToolbar, { table })), jsxRuntimeExports.jsx(MRT_TableContainer, { table }), enableBottomToolbar && ((_c2 = parseFromValuesOrFunc(renderBottomToolbar, { table })) !== null && _c2 !== void 0 ? _c2 : jsxRuntimeExports.jsx(MRT_BottomToolbar, { table }))] }));
};
const isTableInstanceProp = (props) => props.table !== void 0;
const MaterialReactTable = (props) => {
  let table;
  if (isTableInstanceProp(props)) {
    table = props.table;
  } else {
    table = useMaterialReactTable(props);
  }
  return jsxRuntimeExports.jsx(MRT_TablePaper, { table });
};
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t3, e3) {
    module.exports = e3();
  }(commonjsGlobal, function() {
    var t3 = 1e3, e3 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s3 = "minute", u3 = "hour", a3 = "day", o = "week", c3 = "month", f2 = "quarter", h4 = "year", d4 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y4 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M4 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t4) {
      var e4 = ["th", "st", "nd", "rd"], n3 = t4 % 100;
      return "[" + t4 + (e4[(n3 - 20) % 10] || e4[n3] || e4[0]) + "]";
    } }, m4 = function(t4, e4, n3) {
      var r3 = String(t4);
      return !r3 || r3.length >= e4 ? t4 : "" + Array(e4 + 1 - r3.length).join(n3) + t4;
    }, v2 = { s: m4, z: function(t4) {
      var e4 = -t4.utcOffset(), n3 = Math.abs(e4), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e4 <= 0 ? "+" : "-") + m4(r3, 2, "0") + ":" + m4(i3, 2, "0");
    }, m: function t4(e4, n3) {
      if (e4.date() < n3.date()) return -t4(n3, e4);
      var r3 = 12 * (n3.year() - e4.year()) + (n3.month() - e4.month()), i3 = e4.clone().add(r3, c3), s4 = n3 - i3 < 0, u4 = e4.clone().add(r3 + (s4 ? -1 : 1), c3);
      return +(-(r3 + (n3 - i3) / (s4 ? i3 - u4 : u4 - i3)) || 0);
    }, a: function(t4) {
      return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
    }, p: function(t4) {
      return { M: c3, y: h4, w: o, d: a3, D: d4, h: u3, m: s3, s: i2, ms: r2, Q: f2 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t4) {
      return void 0 === t4;
    } }, g2 = "en", D3 = {};
    D3[g2] = M4;
    var p2 = "$isDayjsObject", S4 = function(t4) {
      return t4 instanceof _ || !(!t4 || !t4[p2]);
    }, w3 = function t4(e4, n3, r3) {
      var i3;
      if (!e4) return g2;
      if ("string" == typeof e4) {
        var s4 = e4.toLowerCase();
        D3[s4] && (i3 = s4), n3 && (D3[s4] = n3, i3 = s4);
        var u4 = e4.split("-");
        if (!i3 && u4.length > 1) return t4(u4[0]);
      } else {
        var a4 = e4.name;
        D3[a4] = e4, i3 = a4;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, O3 = function(t4, e4) {
      if (S4(t4)) return t4.clone();
      var n3 = "object" == typeof e4 ? e4 : {};
      return n3.date = t4, n3.args = arguments, new _(n3);
    }, b3 = v2;
    b3.l = w3, b3.i = S4, b3.w = function(t4, e4) {
      return O3(t4, { locale: e4.$L, utc: e4.$u, x: e4.$x, $offset: e4.$offset });
    };
    var _ = function() {
      function M5(t4) {
        this.$L = w3(t4.locale, null, true), this.parse(t4), this.$x = this.$x || t4.x || {}, this[p2] = true;
      }
      var m5 = M5.prototype;
      return m5.parse = function(t4) {
        this.$d = function(t5) {
          var e4 = t5.date, n3 = t5.utc;
          if (null === e4) return /* @__PURE__ */ new Date(NaN);
          if (b3.u(e4)) return /* @__PURE__ */ new Date();
          if (e4 instanceof Date) return new Date(e4);
          if ("string" == typeof e4 && !/Z$/i.test(e4)) {
            var r3 = e4.match($);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s4 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s4)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s4);
            }
          }
          return new Date(e4);
        }(t4), this.init();
      }, m5.init = function() {
        var t4 = this.$d;
        this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
      }, m5.$utils = function() {
        return b3;
      }, m5.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m5.isSame = function(t4, e4) {
        var n3 = O3(t4);
        return this.startOf(e4) <= n3 && n3 <= this.endOf(e4);
      }, m5.isAfter = function(t4, e4) {
        return O3(t4) < this.startOf(e4);
      }, m5.isBefore = function(t4, e4) {
        return this.endOf(e4) < O3(t4);
      }, m5.$g = function(t4, e4, n3) {
        return b3.u(t4) ? this[e4] : this.set(n3, t4);
      }, m5.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m5.valueOf = function() {
        return this.$d.getTime();
      }, m5.startOf = function(t4, e4) {
        var n3 = this, r3 = !!b3.u(e4) || e4, f3 = b3.p(t4), l3 = function(t5, e5) {
          var i3 = b3.w(n3.$u ? Date.UTC(n3.$y, e5, t5) : new Date(n3.$y, e5, t5), n3);
          return r3 ? i3 : i3.endOf(a3);
        }, $2 = function(t5, e5) {
          return b3.w(n3.toDate()[t5].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e5)), n3);
        }, y5 = this.$W, M6 = this.$M, m6 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h4:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c3:
            return r3 ? l3(1, M6) : l3(0, M6 + 1);
          case o:
            var g3 = this.$locale().weekStart || 0, D4 = (y5 < g3 ? y5 + 7 : y5) - g3;
            return l3(r3 ? m6 - D4 : m6 + (6 - D4), M6);
          case a3:
          case d4:
            return $2(v3 + "Hours", 0);
          case u3:
            return $2(v3 + "Minutes", 1);
          case s3:
            return $2(v3 + "Seconds", 2);
          case i2:
            return $2(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m5.endOf = function(t4) {
        return this.startOf(t4, false);
      }, m5.$set = function(t4, e4) {
        var n3, o2 = b3.p(t4), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a3] = f3 + "Date", n3[d4] = f3 + "Date", n3[c3] = f3 + "Month", n3[h4] = f3 + "FullYear", n3[u3] = f3 + "Hours", n3[s3] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o2], $2 = o2 === a3 ? this.$D + (e4 - this.$W) : e4;
        if (o2 === c3 || o2 === h4) {
          var y5 = this.clone().set(d4, 1);
          y5.$d[l3]($2), y5.init(), this.$d = y5.set(d4, Math.min(this.$D, y5.daysInMonth())).$d;
        } else l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m5.set = function(t4, e4) {
        return this.clone().$set(t4, e4);
      }, m5.get = function(t4) {
        return this[b3.p(t4)]();
      }, m5.add = function(r3, f3) {
        var d5, l3 = this;
        r3 = Number(r3);
        var $2 = b3.p(f3), y5 = function(t4) {
          var e4 = O3(l3);
          return b3.w(e4.date(e4.date() + Math.round(t4 * r3)), l3);
        };
        if ($2 === c3) return this.set(c3, this.$M + r3);
        if ($2 === h4) return this.set(h4, this.$y + r3);
        if ($2 === a3) return y5(1);
        if ($2 === o) return y5(7);
        var M6 = (d5 = {}, d5[s3] = e3, d5[u3] = n2, d5[i2] = t3, d5)[$2] || 1, m6 = this.$d.getTime() + r3 * M6;
        return b3.w(m6, this);
      }, m5.subtract = function(t4, e4) {
        return this.add(-1 * t4, e4);
      }, m5.format = function(t4) {
        var e4 = this, n3 = this.$locale();
        if (!this.isValid()) return n3.invalidDate || l2;
        var r3 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b3.z(this), s4 = this.$H, u4 = this.$m, a4 = this.$M, o2 = n3.weekdays, c4 = n3.months, f3 = n3.meridiem, h5 = function(t5, n4, i4, s5) {
          return t5 && (t5[n4] || t5(e4, r3)) || i4[n4].slice(0, s5);
        }, d5 = function(t5) {
          return b3.s(s4 % 12 || 12, t5, "0");
        }, $2 = f3 || function(t5, e5, n4) {
          var r4 = t5 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y4, function(t5, r4) {
          return r4 || function(t6) {
            switch (t6) {
              case "YY":
                return String(e4.$y).slice(-2);
              case "YYYY":
                return b3.s(e4.$y, 4, "0");
              case "M":
                return a4 + 1;
              case "MM":
                return b3.s(a4 + 1, 2, "0");
              case "MMM":
                return h5(n3.monthsShort, a4, c4, 3);
              case "MMMM":
                return h5(c4, a4);
              case "D":
                return e4.$D;
              case "DD":
                return b3.s(e4.$D, 2, "0");
              case "d":
                return String(e4.$W);
              case "dd":
                return h5(n3.weekdaysMin, e4.$W, o2, 2);
              case "ddd":
                return h5(n3.weekdaysShort, e4.$W, o2, 3);
              case "dddd":
                return o2[e4.$W];
              case "H":
                return String(s4);
              case "HH":
                return b3.s(s4, 2, "0");
              case "h":
                return d5(1);
              case "hh":
                return d5(2);
              case "a":
                return $2(s4, u4, true);
              case "A":
                return $2(s4, u4, false);
              case "m":
                return String(u4);
              case "mm":
                return b3.s(u4, 2, "0");
              case "s":
                return String(e4.$s);
              case "ss":
                return b3.s(e4.$s, 2, "0");
              case "SSS":
                return b3.s(e4.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t5) || i3.replace(":", "");
        });
      }, m5.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m5.diff = function(r3, d5, l3) {
        var $2, y5 = this, M6 = b3.p(d5), m6 = O3(r3), v3 = (m6.utcOffset() - this.utcOffset()) * e3, g3 = this - m6, D4 = function() {
          return b3.m(y5, m6);
        };
        switch (M6) {
          case h4:
            $2 = D4() / 12;
            break;
          case c3:
            $2 = D4();
            break;
          case f2:
            $2 = D4() / 3;
            break;
          case o:
            $2 = (g3 - v3) / 6048e5;
            break;
          case a3:
            $2 = (g3 - v3) / 864e5;
            break;
          case u3:
            $2 = g3 / n2;
            break;
          case s3:
            $2 = g3 / e3;
            break;
          case i2:
            $2 = g3 / t3;
            break;
          default:
            $2 = g3;
        }
        return l3 ? $2 : b3.a($2);
      }, m5.daysInMonth = function() {
        return this.endOf(c3).$D;
      }, m5.$locale = function() {
        return D3[this.$L];
      }, m5.locale = function(t4, e4) {
        if (!t4) return this.$L;
        var n3 = this.clone(), r3 = w3(t4, e4, true);
        return r3 && (n3.$L = r3), n3;
      }, m5.clone = function() {
        return b3.w(this.$d, this);
      }, m5.toDate = function() {
        return new Date(this.valueOf());
      }, m5.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m5.toISOString = function() {
        return this.$d.toISOString();
      }, m5.toString = function() {
        return this.$d.toUTCString();
      }, M5;
    }(), k3 = _.prototype;
    return O3.prototype = k3, [["$ms", r2], ["$s", i2], ["$m", s3], ["$H", u3], ["$W", a3], ["$M", c3], ["$y", h4], ["$D", d4]].forEach(function(t4) {
      k3[t4[1]] = function(e4) {
        return this.$g(e4, t4[0], t4[1]);
      };
    }), O3.extend = function(t4, e4) {
      return t4.$i || (t4(e4, _, O3), t4.$i = true), O3;
    }, O3.locale = w3, O3.isDayjs = S4, O3.unix = function(t4) {
      return O3(1e3 * t4);
    }, O3.en = D3[g2], O3.Ls = D3, O3.p = {}, O3;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const defaultDayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var weekOfYear = { exports: {} };
(function(module, exports) {
  !function(e3, t3) {
    module.exports = t3();
  }(commonjsGlobal, function() {
    var e3 = "week", t3 = "year";
    return function(i2, n2, r2) {
      var f2 = n2.prototype;
      f2.week = function(i3) {
        if (void 0 === i3 && (i3 = null), null !== i3) return this.add(7 * (i3 - this.week()), "day");
        var n3 = this.$locale().yearStart || 1;
        if (11 === this.month() && this.date() > 25) {
          var f3 = r2(this).startOf(t3).add(1, t3).date(n3), s3 = r2(this).endOf(e3);
          if (f3.isBefore(s3)) return 1;
        }
        var a3 = r2(this).startOf(t3).date(n3).startOf(e3).subtract(1, "millisecond"), o = this.diff(a3, e3, true);
        return o < 0 ? r2(this).startOf("week").week() : Math.ceil(o);
      }, f2.weeks = function(e4) {
        return void 0 === e4 && (e4 = null), this.week(e4);
      };
    };
  });
})(weekOfYear);
var weekOfYearExports = weekOfYear.exports;
const weekOfYearPlugin = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
var customParseFormat = { exports: {} };
(function(module, exports) {
  !function(e3, t3) {
    module.exports = t3();
  }(commonjsGlobal, function() {
    var e3 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t3 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d/, r2 = /\d\d/, i2 = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s3 = {}, a3 = function(e4) {
      return (e4 = +e4) + (e4 > 68 ? 1900 : 2e3);
    };
    var f2 = function(e4) {
      return function(t4) {
        this[e4] = +t4;
      };
    }, h4 = [/[+-]\d\d:?(\d\d)?|Z/, function(e4) {
      (this.zone || (this.zone = {})).offset = function(e5) {
        if (!e5) return 0;
        if ("Z" === e5) return 0;
        var t4 = e5.match(/([+-]|\d\d)/g), n3 = 60 * t4[1] + (+t4[2] || 0);
        return 0 === n3 ? 0 : "+" === t4[0] ? -n3 : n3;
      }(e4);
    }], u3 = function(e4) {
      var t4 = s3[e4];
      return t4 && (t4.indexOf ? t4 : t4.s.concat(t4.f));
    }, d4 = function(e4, t4) {
      var n3, r3 = s3.meridiem;
      if (r3) {
        for (var i3 = 1; i3 <= 24; i3 += 1) if (e4.indexOf(r3(i3, 0, t4)) > -1) {
          n3 = i3 > 12;
          break;
        }
      } else n3 = e4 === (t4 ? "pm" : "PM");
      return n3;
    }, c3 = { A: [o, function(e4) {
      this.afternoon = d4(e4, false);
    }], a: [o, function(e4) {
      this.afternoon = d4(e4, true);
    }], Q: [n2, function(e4) {
      this.month = 3 * (e4 - 1) + 1;
    }], S: [n2, function(e4) {
      this.milliseconds = 100 * +e4;
    }], SS: [r2, function(e4) {
      this.milliseconds = 10 * +e4;
    }], SSS: [/\d{3}/, function(e4) {
      this.milliseconds = +e4;
    }], s: [i2, f2("seconds")], ss: [i2, f2("seconds")], m: [i2, f2("minutes")], mm: [i2, f2("minutes")], H: [i2, f2("hours")], h: [i2, f2("hours")], HH: [i2, f2("hours")], hh: [i2, f2("hours")], D: [i2, f2("day")], DD: [r2, f2("day")], Do: [o, function(e4) {
      var t4 = s3.ordinal, n3 = e4.match(/\d+/);
      if (this.day = n3[0], t4) for (var r3 = 1; r3 <= 31; r3 += 1) t4(r3).replace(/\[|\]/g, "") === e4 && (this.day = r3);
    }], w: [i2, f2("week")], ww: [r2, f2("week")], M: [i2, f2("month")], MM: [r2, f2("month")], MMM: [o, function(e4) {
      var t4 = u3("months"), n3 = (u3("monthsShort") || t4.map(function(e5) {
        return e5.slice(0, 3);
      })).indexOf(e4) + 1;
      if (n3 < 1) throw new Error();
      this.month = n3 % 12 || n3;
    }], MMMM: [o, function(e4) {
      var t4 = u3("months").indexOf(e4) + 1;
      if (t4 < 1) throw new Error();
      this.month = t4 % 12 || t4;
    }], Y: [/[+-]?\d+/, f2("year")], YY: [r2, function(e4) {
      this.year = a3(e4);
    }], YYYY: [/\d{4}/, f2("year")], Z: h4, ZZ: h4 };
    function l2(n3) {
      var r3, i3;
      r3 = n3, i3 = s3 && s3.formats;
      for (var o2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t4, n4, r4) {
        var o3 = r4 && r4.toUpperCase();
        return n4 || i3[r4] || e3[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e4, t5, n5) {
          return t5 || n5.slice(1);
        });
      })).match(t3), a4 = o2.length, f3 = 0; f3 < a4; f3 += 1) {
        var h5 = o2[f3], u4 = c3[h5], d5 = u4 && u4[0], l3 = u4 && u4[1];
        o2[f3] = l3 ? { regex: d5, parser: l3 } : h5.replace(/^\[|\]$/g, "");
      }
      return function(e4) {
        for (var t4 = {}, n4 = 0, r4 = 0; n4 < a4; n4 += 1) {
          var i4 = o2[n4];
          if ("string" == typeof i4) r4 += i4.length;
          else {
            var s4 = i4.regex, f4 = i4.parser, h6 = e4.slice(r4), u5 = s4.exec(h6)[0];
            f4.call(t4, u5), e4 = e4.replace(u5, "");
          }
        }
        return function(e5) {
          var t5 = e5.afternoon;
          if (void 0 !== t5) {
            var n5 = e5.hours;
            t5 ? n5 < 12 && (e5.hours += 12) : 12 === n5 && (e5.hours = 0), delete e5.afternoon;
          }
        }(t4), t4;
      };
    }
    return function(e4, t4, n3) {
      n3.p.customParseFormat = true, e4 && e4.parseTwoDigitYear && (a3 = e4.parseTwoDigitYear);
      var r3 = t4.prototype, i3 = r3.parse;
      r3.parse = function(e5) {
        var t5 = e5.date, r4 = e5.utc, o2 = e5.args;
        this.$u = r4;
        var a4 = o2[1];
        if ("string" == typeof a4) {
          var f3 = true === o2[2], h5 = true === o2[3], u4 = f3 || h5, d5 = o2[2];
          h5 && (d5 = o2[2]), s3 = this.$locale(), !f3 && d5 && (s3 = n3.Ls[d5]), this.$d = function(e6, t6, n4, r5) {
            try {
              if (["x", "X"].indexOf(t6) > -1) return new Date(("X" === t6 ? 1e3 : 1) * e6);
              var i4 = l2(t6)(e6), o3 = i4.year, s4 = i4.month, a5 = i4.day, f4 = i4.hours, h6 = i4.minutes, u5 = i4.seconds, d6 = i4.milliseconds, c5 = i4.zone, m5 = i4.week, M5 = /* @__PURE__ */ new Date(), Y3 = a5 || (o3 || s4 ? 1 : M5.getDate()), p2 = o3 || M5.getFullYear(), v2 = 0;
              o3 && !s4 || (v2 = s4 > 0 ? s4 - 1 : M5.getMonth());
              var D3, w3 = f4 || 0, g2 = h6 || 0, y4 = u5 || 0, L3 = d6 || 0;
              return c5 ? new Date(Date.UTC(p2, v2, Y3, w3, g2, y4, L3 + 60 * c5.offset * 1e3)) : n4 ? new Date(Date.UTC(p2, v2, Y3, w3, g2, y4, L3)) : (D3 = new Date(p2, v2, Y3, w3, g2, y4, L3), m5 && (D3 = r5(D3).week(m5).toDate()), D3);
            } catch (e7) {
              return /* @__PURE__ */ new Date("");
            }
          }(t5, a4, r4, n3), this.init(), d5 && true !== d5 && (this.$L = this.locale(d5).$L), u4 && t5 != this.format(a4) && (this.$d = /* @__PURE__ */ new Date("")), s3 = {};
        } else if (a4 instanceof Array) for (var c4 = a4.length, m4 = 1; m4 <= c4; m4 += 1) {
          o2[1] = a4[m4 - 1];
          var M4 = n3.apply(this, o2);
          if (M4.isValid()) {
            this.$d = M4.$d, this.$L = M4.$L, this.init();
            break;
          }
          m4 === c4 && (this.$d = /* @__PURE__ */ new Date(""));
        }
        else i3.call(this, e5);
      };
    };
  });
})(customParseFormat);
var customParseFormatExports = customParseFormat.exports;
const customParseFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
var localizedFormat = { exports: {} };
(function(module, exports) {
  !function(e3, t3) {
    module.exports = t3();
  }(commonjsGlobal, function() {
    var e3 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(t3, o, n2) {
      var r2 = o.prototype, i2 = r2.format;
      n2.en.formats = e3, r2.format = function(t4) {
        void 0 === t4 && (t4 = "YYYY-MM-DDTHH:mm:ssZ");
        var o2 = this.$locale().formats, n3 = function(t5, o3) {
          return t5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n4, r3) {
            var i3 = r3 && r3.toUpperCase();
            return n4 || o3[r3] || e3[r3] || o3[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e4, t7, o4) {
              return t7 || o4.slice(1);
            });
          });
        }(t4, void 0 === o2 ? {} : o2);
        return i2.call(this, n3);
      };
    };
  });
})(localizedFormat);
var localizedFormatExports = localizedFormat.exports;
const localizedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
var isBetween = { exports: {} };
(function(module, exports) {
  !function(e3, i2) {
    module.exports = i2();
  }(commonjsGlobal, function() {
    return function(e3, i2, t3) {
      i2.prototype.isBetween = function(e4, i3, s3, f2) {
        var n2 = t3(e4), o = t3(i3), r2 = "(" === (f2 = f2 || "()")[0], u3 = ")" === f2[1];
        return (r2 ? this.isAfter(n2, s3) : !this.isBefore(n2, s3)) && (u3 ? this.isBefore(o, s3) : !this.isAfter(o, s3)) || (r2 ? this.isBefore(n2, s3) : !this.isAfter(n2, s3)) && (u3 ? this.isAfter(o, s3) : !this.isBefore(o, s3));
      };
    };
  });
})(isBetween);
var isBetweenExports = isBetween.exports;
const isBetweenPlugin = /* @__PURE__ */ getDefaultExportFromCjs(isBetweenExports);
var advancedFormat = { exports: {} };
(function(module, exports) {
  !function(e3, t3) {
    module.exports = t3();
  }(commonjsGlobal, function() {
    return function(e3, t3) {
      var r2 = t3.prototype, n2 = r2.format;
      r2.format = function(e4) {
        var t4 = this, r3 = this.$locale();
        if (!this.isValid()) return n2.bind(this)(e4);
        var s3 = this.$utils(), a3 = (e4 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e5) {
          switch (e5) {
            case "Q":
              return Math.ceil((t4.$M + 1) / 3);
            case "Do":
              return r3.ordinal(t4.$D);
            case "gggg":
              return t4.weekYear();
            case "GGGG":
              return t4.isoWeekYear();
            case "wo":
              return r3.ordinal(t4.week(), "W");
            case "w":
            case "ww":
              return s3.s(t4.week(), "w" === e5 ? 1 : 2, "0");
            case "W":
            case "WW":
              return s3.s(t4.isoWeek(), "W" === e5 ? 1 : 2, "0");
            case "k":
            case "kk":
              return s3.s(String(0 === t4.$H ? 24 : t4.$H), "k" === e5 ? 1 : 2, "0");
            case "X":
              return Math.floor(t4.$d.getTime() / 1e3);
            case "x":
              return t4.$d.getTime();
            case "z":
              return "[" + t4.offsetName() + "]";
            case "zzz":
              return "[" + t4.offsetName("long") + "]";
            default:
              return e5;
          }
        });
        return n2.bind(this)(a3);
      };
    };
  });
})(advancedFormat);
var advancedFormatExports = advancedFormat.exports;
const advancedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
defaultDayjs.extend(localizedFormatPlugin);
defaultDayjs.extend(weekOfYearPlugin);
defaultDayjs.extend(isBetweenPlugin);
defaultDayjs.extend(advancedFormatPlugin);
const formatTokenMap = {
  // Year
  YY: "year",
  YYYY: {
    sectionType: "year",
    contentType: "digit",
    maxLength: 4
  },
  // Month
  M: {
    sectionType: "month",
    contentType: "digit",
    maxLength: 2
  },
  MM: "month",
  MMM: {
    sectionType: "month",
    contentType: "letter"
  },
  MMMM: {
    sectionType: "month",
    contentType: "letter"
  },
  // Day of the month
  D: {
    sectionType: "day",
    contentType: "digit",
    maxLength: 2
  },
  DD: "day",
  Do: {
    sectionType: "day",
    contentType: "digit-with-letter"
  },
  // Day of the week
  d: {
    sectionType: "weekDay",
    contentType: "digit",
    maxLength: 2
  },
  dd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  ddd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  dddd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  // Meridiem
  A: "meridiem",
  a: "meridiem",
  // Hours
  H: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  HH: "hours",
  h: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  hh: "hours",
  // Minutes
  m: {
    sectionType: "minutes",
    contentType: "digit",
    maxLength: 2
  },
  mm: "minutes",
  // Seconds
  s: {
    sectionType: "seconds",
    contentType: "digit",
    maxLength: 2
  },
  ss: "seconds"
};
const defaultFormats = {
  year: "YYYY",
  month: "MMMM",
  monthShort: "MMM",
  dayOfMonth: "D",
  dayOfMonthFull: "Do",
  weekday: "dddd",
  weekdayShort: "dd",
  hours24h: "HH",
  hours12h: "hh",
  meridiem: "A",
  minutes: "mm",
  seconds: "ss",
  fullDate: "ll",
  keyboardDate: "L",
  shortDate: "MMM D",
  normalDate: "D MMMM",
  normalDateWithWeekday: "ddd, MMM D",
  fullTime: "LT",
  fullTime12h: "hh:mm A",
  fullTime24h: "HH:mm",
  keyboardDateTime: "L LT",
  keyboardDateTime12h: "L hh:mm A",
  keyboardDateTime24h: "L HH:mm"
};
const MISSING_UTC_PLUGIN = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n");
const MISSING_TIMEZONE_PLUGIN = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");
const withLocale = (dayjs, locale2) => !locale2 ? dayjs : (...args) => dayjs(...args).locale(locale2);
class AdapterDayjs {
  constructor({
    locale: _locale,
    formats
  } = {}) {
    this.isMUIAdapter = true;
    this.isTimezoneCompatible = true;
    this.lib = "dayjs";
    this.dayjs = void 0;
    this.locale = void 0;
    this.formats = void 0;
    this.escapedCharacters = {
      start: "[",
      end: "]"
    };
    this.formatTokenMap = formatTokenMap;
    this.setLocaleToValue = (value) => {
      const expectedLocale = this.getCurrentLocaleCode();
      if (expectedLocale === value.locale()) {
        return value;
      }
      return value.locale(expectedLocale);
    };
    this.hasUTCPlugin = () => typeof defaultDayjs.utc !== "undefined";
    this.hasTimezonePlugin = () => typeof defaultDayjs.tz !== "undefined";
    this.isSame = (value, comparing, comparisonTemplate) => {
      const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
      return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
    };
    this.cleanTimezone = (timezone) => {
      switch (timezone) {
        case "default": {
          return void 0;
        }
        case "system": {
          return defaultDayjs.tz.guess();
        }
        default: {
          return timezone;
        }
      }
    };
    this.createSystemDate = (value) => {
      if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
        const timezone = defaultDayjs.tz.guess();
        if (timezone !== "UTC") {
          return defaultDayjs.tz(value, timezone);
        }
        return defaultDayjs(value);
      }
      return defaultDayjs(value);
    };
    this.createUTCDate = (value) => {
      if (!this.hasUTCPlugin()) {
        throw new Error(MISSING_UTC_PLUGIN);
      }
      return defaultDayjs.utc(value);
    };
    this.createTZDate = (value, timezone) => {
      if (!this.hasUTCPlugin()) {
        throw new Error(MISSING_UTC_PLUGIN);
      }
      if (!this.hasTimezonePlugin()) {
        throw new Error(MISSING_TIMEZONE_PLUGIN);
      }
      const keepLocalTime = value !== void 0 && !value.endsWith("Z");
      return defaultDayjs(value).tz(this.cleanTimezone(timezone), keepLocalTime);
    };
    this.getLocaleFormats = () => {
      const locales = defaultDayjs.Ls;
      const locale2 = this.locale || "en";
      let localeObject = locales[locale2];
      if (localeObject === void 0) {
        localeObject = locales.en;
      }
      return localeObject.formats;
    };
    this.adjustOffset = (value) => {
      if (!this.hasTimezonePlugin()) {
        return value;
      }
      const timezone = this.getTimezone(value);
      if (timezone !== "UTC") {
        const fixedValue = value.tz(this.cleanTimezone(timezone), true);
        if (fixedValue.$offset === (value.$offset ?? 0)) {
          return value;
        }
        value.$offset = fixedValue.$offset;
      }
      return value;
    };
    this.date = (value, timezone = "default") => {
      if (value === null) {
        return null;
      }
      let parsedValue;
      if (timezone === "UTC") {
        parsedValue = this.createUTCDate(value);
      } else if (timezone === "system" || timezone === "default" && !this.hasTimezonePlugin()) {
        parsedValue = this.createSystemDate(value);
      } else {
        parsedValue = this.createTZDate(value, timezone);
      }
      if (this.locale === void 0) {
        return parsedValue;
      }
      return parsedValue.locale(this.locale);
    };
    this.getInvalidDate = () => defaultDayjs(/* @__PURE__ */ new Date("Invalid date"));
    this.getTimezone = (value) => {
      var _a2;
      if (this.hasTimezonePlugin()) {
        const zone = (_a2 = value.$x) == null ? void 0 : _a2.$timezone;
        if (zone) {
          return zone;
        }
      }
      if (this.hasUTCPlugin() && value.isUTC()) {
        return "UTC";
      }
      return "system";
    };
    this.setTimezone = (value, timezone) => {
      if (this.getTimezone(value) === timezone) {
        return value;
      }
      if (timezone === "UTC") {
        if (!this.hasUTCPlugin()) {
          throw new Error(MISSING_UTC_PLUGIN);
        }
        return value.utc();
      }
      if (timezone === "system") {
        return value.local();
      }
      if (!this.hasTimezonePlugin()) {
        if (timezone === "default") {
          return value;
        }
        throw new Error(MISSING_TIMEZONE_PLUGIN);
      }
      return defaultDayjs.tz(value, this.cleanTimezone(timezone));
    };
    this.toJsDate = (value) => {
      return value.toDate();
    };
    this.parse = (value, format2) => {
      if (value === "") {
        return null;
      }
      return this.dayjs(value, format2, this.locale, true);
    };
    this.getCurrentLocaleCode = () => {
      return this.locale || "en";
    };
    this.is12HourCycleInCurrentLocale = () => {
      return /A|a/.test(this.getLocaleFormats().LT || "");
    };
    this.expandFormat = (format2) => {
      const localeFormats = this.getLocaleFormats();
      const t3 = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_, a3, b3) => a3 || b3.slice(1));
      return format2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_, a3, b3) => {
        const B3 = b3 && b3.toUpperCase();
        return a3 || localeFormats[b3] || t3(localeFormats[B3]);
      });
    };
    this.isValid = (value) => {
      if (value == null) {
        return false;
      }
      return value.isValid();
    };
    this.format = (value, formatKey) => {
      return this.formatByString(value, this.formats[formatKey]);
    };
    this.formatByString = (value, formatString) => {
      return this.dayjs(value).format(formatString);
    };
    this.formatNumber = (numberToFormat) => {
      return numberToFormat;
    };
    this.isEqual = (value, comparing) => {
      if (value === null && comparing === null) {
        return true;
      }
      if (value === null || comparing === null) {
        return false;
      }
      return value.toDate().getTime() === comparing.toDate().getTime();
    };
    this.isSameYear = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY");
    };
    this.isSameMonth = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY-MM");
    };
    this.isSameDay = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY-MM-DD");
    };
    this.isSameHour = (value, comparing) => {
      return value.isSame(comparing, "hour");
    };
    this.isAfter = (value, comparing) => {
      return value > comparing;
    };
    this.isAfterYear = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isAfter(comparing, "year");
      }
      return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
    };
    this.isAfterDay = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isAfter(comparing, "day");
      }
      return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
    };
    this.isBefore = (value, comparing) => {
      return value < comparing;
    };
    this.isBeforeYear = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isBefore(comparing, "year");
      }
      return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
    };
    this.isBeforeDay = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isBefore(comparing, "day");
      }
      return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
    };
    this.isWithinRange = (value, [start2, end2]) => {
      return value >= start2 && value <= end2;
    };
    this.startOfYear = (value) => {
      return this.adjustOffset(value.startOf("year"));
    };
    this.startOfMonth = (value) => {
      return this.adjustOffset(value.startOf("month"));
    };
    this.startOfWeek = (value) => {
      return this.adjustOffset(this.setLocaleToValue(value).startOf("week"));
    };
    this.startOfDay = (value) => {
      return this.adjustOffset(value.startOf("day"));
    };
    this.endOfYear = (value) => {
      return this.adjustOffset(value.endOf("year"));
    };
    this.endOfMonth = (value) => {
      return this.adjustOffset(value.endOf("month"));
    };
    this.endOfWeek = (value) => {
      return this.adjustOffset(this.setLocaleToValue(value).endOf("week"));
    };
    this.endOfDay = (value) => {
      return this.adjustOffset(value.endOf("day"));
    };
    this.addYears = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "year") : value.add(amount, "year"));
    };
    this.addMonths = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "month") : value.add(amount, "month"));
    };
    this.addWeeks = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "week") : value.add(amount, "week"));
    };
    this.addDays = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "day") : value.add(amount, "day"));
    };
    this.addHours = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "hour") : value.add(amount, "hour"));
    };
    this.addMinutes = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "minute") : value.add(amount, "minute"));
    };
    this.addSeconds = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "second") : value.add(amount, "second"));
    };
    this.getYear = (value) => {
      return value.year();
    };
    this.getMonth = (value) => {
      return value.month();
    };
    this.getDate = (value) => {
      return value.date();
    };
    this.getHours = (value) => {
      return value.hour();
    };
    this.getMinutes = (value) => {
      return value.minute();
    };
    this.getSeconds = (value) => {
      return value.second();
    };
    this.getMilliseconds = (value) => {
      return value.millisecond();
    };
    this.setYear = (value, year) => {
      return this.adjustOffset(value.set("year", year));
    };
    this.setMonth = (value, month) => {
      return this.adjustOffset(value.set("month", month));
    };
    this.setDate = (value, date) => {
      return this.adjustOffset(value.set("date", date));
    };
    this.setHours = (value, hours) => {
      return this.adjustOffset(value.set("hour", hours));
    };
    this.setMinutes = (value, minutes) => {
      return this.adjustOffset(value.set("minute", minutes));
    };
    this.setSeconds = (value, seconds) => {
      return this.adjustOffset(value.set("second", seconds));
    };
    this.setMilliseconds = (value, milliseconds) => {
      return this.adjustOffset(value.set("millisecond", milliseconds));
    };
    this.getDaysInMonth = (value) => {
      return value.daysInMonth();
    };
    this.getWeekArray = (value) => {
      const start2 = this.startOfWeek(this.startOfMonth(value));
      const end2 = this.endOfWeek(this.endOfMonth(value));
      let count2 = 0;
      let current = start2;
      const nestedWeeks = [];
      while (current < end2) {
        const weekNumber = Math.floor(count2 / 7);
        nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
        nestedWeeks[weekNumber].push(current);
        current = this.addDays(current, 1);
        count2 += 1;
      }
      return nestedWeeks;
    };
    this.getWeekNumber = (value) => {
      return value.week();
    };
    this.getYearRange = ([start2, end2]) => {
      const startDate = this.startOfYear(start2);
      const endDate = this.endOfYear(end2);
      const years = [];
      let current = startDate;
      while (this.isBefore(current, endDate)) {
        years.push(current);
        current = this.addYears(current, 1);
      }
      return years;
    };
    this.dayjs = withLocale(defaultDayjs, _locale);
    this.locale = _locale;
    this.formats = _extends$1({}, defaultFormats, formats);
    defaultDayjs.extend(customParseFormatPlugin);
  }
  getDayOfWeek(value) {
    return value.day() + 1;
  }
}
const MaterialTable = (props) => {
  const { data, columns } = props;
  const table = useMaterialReactTable({
    renderEmptyRowsFallback: () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            height: "20rem"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              style: {
                fontSize: "1.125rem",
                fontWeight: "bold",
                color: "#6B7280"
              },
              children: "No se encontraron registros"
            }
          )
        }
      );
    },
    ...props,
    columns,
    data,
    muiTablePaperProps: {
      style: {
        borderRadius: "1em"
      }
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationProvider, { dateAdapter: AdapterDayjs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MaterialReactTable, { table }) });
};
var Refresh = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(Refresh, "__esModule", {
  value: true
});
var default_1 = Refresh.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
default_1 = Refresh.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z"
}), "Refresh");
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context) {
  return constructFrom(argument, argument);
}
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}
function isEqual(leftDate, rightDate) {
  return +toDate(leftDate) === +toDate(rightDate);
}
const getWeekRange = () => {
  const today = /* @__PURE__ */ new Date();
  const dayOfWeek = today.getDay();
  const dayOfMonth = today.getDate();
  const startOfWeek2 = new Date(today);
  const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  startOfWeek2.setDate(dayOfMonth + diffToMonday);
  const endOfWeek2 = new Date(startOfWeek2);
  endOfWeek2.setDate(startOfWeek2.getDate() + 6);
  return [startOfWeek2, endOfWeek2];
};
const setToMidnight = (date) => {
  const adjustedDate = new Date(date);
  adjustedDate.setHours(0, 0, 0, 0);
  return adjustedDate;
};
const isSameWeek = (week) => {
  if (!week) return false;
  const actualWeek = getWeekRange();
  const actualWeekStart = actualWeek[0];
  const actualWeekEnd = actualWeek[1];
  const weekStart = week[0];
  const weekEnd = week[1];
  const start2 = setToMidnight(weekStart);
  const end2 = setToMidnight(weekEnd);
  return actualWeekStart.toISOString().split("T")[0] === start2.toISOString().split("T")[0] && actualWeekEnd.toISOString().split("T")[0] === end2.toISOString().split("T")[0];
};
const isGOEWeek = (week) => {
  if (!week) return false;
  const actualWeekStart = setToMidnight(getWeekRange()[0]);
  const weekStart = setToMidnight(week[0]);
  return isEqual(weekStart, actualWeekStart) || isAfter(weekStart, actualWeekStart);
};
const collectRegisterToApi = (register) => {
  return {
    week_id: register.weekId,
    client_id: register.clientId,
    [`${register.day}_amount`]: register.mount
  };
};
const collectRegisterToApiFull = (register) => ({
  id: register.id,
  client_id: register.clientId,
  client_name: register.clientName,
  week_id: register.weekId,
  monday_amount: Number(register.monday),
  tuesday_amount: Number(register.tuesday),
  wednesday_amount: Number(register.wednesday),
  thursday_amount: Number(register.thursday),
  friday_amount: Number(register.friday),
  saturday_amount: Number(register.saturday),
  observations: register.observations
});
const collectRegisterToLocal = (data) => ({
  id: Number(data.id),
  clientId: Number(data.client_id),
  clientName: data.client_name,
  weekId: Number(data.week_id),
  monday: data.monday_amount,
  tuesday: data.tuesday_amount,
  wednesday: data.wednesday_amount,
  thursday: data.thursday_amount,
  friday: data.friday_amount,
  saturday: data.saturday_amount,
  observations: data.observations,
  totalConfirmed: data.total_confirmed_amount
});
const collectConfirmationToApi = (confirmation) => ({
  collect_id: confirmation.itemId,
  day_of_week: confirmation.dayOfWeek,
  confirmed: confirmation.confirmed
});
const BASE_URL$4 = "./services/";
class CollectServiceApi {
  /**
   * Obtener los registros de la semana
   * @param weekId ID de la semana
   * @returns Array con los registros de la semana
   */
  static async getCollectRegisterByWeekId(weekId) {
    const url = `${BASE_URL$4}collect/get_collect_registers.php?week_id=${weekId}`;
    try {
      const response = await fetch(url);
      const data = await response.json();
      if (!data.success) {
        throw new Error("Error al obtener los registros");
      }
      return data.data.map(collectRegisterToLocal);
    } catch (error) {
      console.error(error);
      return [];
    }
  }
  /**
   * Crear un nuevo registro de collect
   * @param param0 Objeto con el ID de la semana y el ID del cliente
   * @returns True si se ha creado el registro correctamente
   */
  static async createRegister(newRegister) {
    const body = collectRegisterToApi(newRegister);
    try {
      const response = await fetch(`${BASE_URL$4}collect/create_register.php`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
  /**
   * Actualizar un registro de collect
   * @param register Objeto con los datos del registro a actualizar
   * @returns True si se ha actualizado el registro correctamente
   */
  static async updateRegister(register) {
    const body = collectRegisterToApiFull(register);
    try {
      const response = await fetch(`${BASE_URL$4}collect/update_register.php`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
  static async deleteRegister(registerId) {
    try {
      const response = await fetch(`${BASE_URL$4}collect/delete_register.php?collect_id=${registerId}`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json"
        }
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
  /**
   * Confirmar la recogida de un día
   * @param confirmation Objeto con los datos de la confirmación
   */
  static async confirmCollect(confirmation) {
    const body = collectConfirmationToApi(confirmation);
    try {
      const response = await fetch(`${BASE_URL$4}collect/confirm_collect.php`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
}
const WeekContext = reactExports.createContext({});
const useWeekContext = () => {
  const context = reactExports.useContext(WeekContext);
  return {
    ...context
  };
};
const registersKey = "registers";
const useCollectRegisters = () => {
  const queryClient2 = useQueryClient();
  const { activeWeekId } = useWeekContext();
  const collectRegisterQuery = useQuery({
    queryKey: [registersKey, "weekId", activeWeekId],
    queryFn: () => CollectServiceApi.getCollectRegisterByWeekId(activeWeekId || 0),
    refetchOnWindowFocus: false,
    staleTime: 1e3 * 60 * 5
  });
  const createCollectRegisterMutation = useMutation({
    mutationFn: CollectServiceApi.createRegister,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Registro creado correctamente");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al crear el registro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [registersKey, "weekId", activeWeekId] });
    }
  });
  const updateCollectRegisterMutation = useMutation({
    mutationFn: CollectServiceApi.updateRegister,
    onSuccess: () => {
      Jt.success("Registro actualizado correctamente");
    },
    onError: () => {
      Jt.error("Error al actualizar el registro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [registersKey, "weekId", activeWeekId] });
    }
  });
  const deleteCollectRegisterMutation = useMutation({
    mutationFn: CollectServiceApi.deleteRegister,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Registro eliminado correctamente");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al eliminar el registro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [registersKey, "weekId", activeWeekId] });
    }
  });
  const confirmCollectMutation = useMutation({
    mutationFn: CollectServiceApi.confirmCollect,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Cobro confirmado");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al confirmar el cobro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [registersKey, "weekId", activeWeekId] });
    }
  });
  return {
    collects: collectRegisterQuery.data || [],
    collectRegisterQuery,
    createCollectRegisterMutation,
    updateCollectRegisterMutation,
    deleteCollectRegisterMutation,
    confirmCollectMutation
  };
};
const formatCurrency = (value) => {
  const numericValue = typeof value === "string" ? parseFloat(value) : value;
  if (isNaN(numericValue)) {
    return "";
  }
  return numericValue.toLocaleString("es-MX", {
    style: "currency",
    currency: "MXN",
    minimumFractionDigits: 2,
    // Mostrar siempre 2 decimales
    maximumFractionDigits: 2
    // No más de 2 decimales
  });
};
const TotalFooterItem = ({ total }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        padding: "5px",
        borderTop: "3px solid #ff5733",
        // Color de borde más vibrante
        backgroundColor: "#f0f8ff",
        // Color de fondo claro
        color: "#333",
        // Color del texto
        textAlign: "left",
        // Alineación a la izquierda
        fontSize: "15px",
        // Tamaño de fuente mayor
        fontWeight: "bold"
        // Peso de fuente negrita
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { margin: "0" }, children: [
        "Total: ",
        formatCurrency(total)
      ] })
    }
  );
};
var Remind$2 = {};
var Remind$1 = { exports: {} };
var Remind = {};
var hasRequiredRemind;
function requireRemind() {
  if (hasRequiredRemind) return Remind;
  hasRequiredRemind = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var React2 = _interopRequireWildcard(reactExports);
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;
      var cache2 = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache2;
      };
      return cache2;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache2 = _getRequireWildcardCache();
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function _extends2() {
      _extends2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends2.apply(this, arguments);
    }
    function Remind2(props, svgRef) {
      return /* @__PURE__ */ React2.createElement("svg", _extends2({
        width: "1em",
        height: "1em",
        viewBox: "0 0 14 14",
        fill: "currentColor",
        ref: svgRef
      }, props), /* @__PURE__ */ React2.createElement("path", {
        d: "M8.021 1.101l5.832 10.509a1.168 1.168 0 01-1.021 1.734H1.167a1.167 1.167 0 01-1.02-1.734L5.979 1.101a1.167 1.167 0 012.041 0zM7 12.177a1.167 1.167 0 100-2.334 1.167 1.167 0 000 2.334zm0-9.34c-.645 0-1.167.523-1.167 1.167v3.502a1.167 1.167 0 002.334 0V4.004c0-.645-.523-1.167-1.167-1.167z"
      }));
    }
    var ForwardRef = /* @__PURE__ */ React2.forwardRef(Remind2);
    var _default = ForwardRef;
    exports["default"] = _default;
  })(Remind);
  return Remind;
}
(function(module, exports) {
  var _interopRequireDefault2 = interopRequireDefaultExports;
  exports.__esModule = true;
  exports["default"] = void 0;
  var _createSvgIcon2 = _interopRequireDefault2(requireCreateSvgIcon$1());
  var _Remind = _interopRequireDefault2(requireRemind());
  var Remind2 = (0, _createSvgIcon2["default"])({
    as: _Remind["default"],
    ariaLabel: "remind",
    category: "legacy",
    displayName: "Remind"
  });
  var _default = Remind2;
  exports["default"] = _default;
  module.exports = exports.default;
})(Remind$1, Remind$1.exports);
var RemindExports = Remind$1.exports;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function get2() {
      return _Remind["default"];
    }
  });
  var _Remind = _interopRequireDefault2(RemindExports);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(Remind$2);
const RemindIcon = /* @__PURE__ */ getDefaultExportFromCjs(Remind$2);
const paymentToLocal = (payment) => ({
  id: payment.id,
  monday: payment.monday_amount,
  tuesday: payment.tuesday_amount,
  wednesday: payment.wednesday_amount,
  thursday: payment.thursday_amount,
  friday: payment.friday_amount,
  saturday: payment.saturday_amount,
  providerId: payment.provider_id,
  providerName: payment.provider,
  weekId: payment.week_id,
  observations: payment.observations,
  concept: payment.concept,
  totalConfirmed: payment.total_confirmed_amount
});
const paymentToApi = (payment) => ({
  week_id: payment.weekId,
  provider_id: payment.providerId,
  provider: payment.providerName,
  concept: payment.concept,
  [`${payment.day}_amount`]: payment.amount
});
const paymentToApiFull = (payment) => ({
  id: payment.id,
  monday_amount: payment.monday,
  tuesday_amount: payment.tuesday,
  wednesday_amount: payment.wednesday,
  thursday_amount: payment.thursday,
  friday_amount: payment.friday,
  saturday_amount: payment.saturday,
  provider_id: payment.providerId,
  provider: payment.providerName,
  week_id: payment.weekId,
  observations: payment.observations,
  concept: payment.concept,
  total_confirmed_amount: payment.totalConfirmed
});
const paymentConfirmationToApi = (confirmation) => ({
  payment_id: confirmation.itemId,
  day_of_week: confirmation.dayOfWeek,
  confirmed: confirmation.confirmed
});
const BASE_URL$3 = "./services/";
class PaymentServiceApi {
  /**
   * Obtiene los registros de pago de una semana
   * @param weekId ID de la semana a buscar
   * @returns Array de registros de pago
   */
  static async getRegisterByWeekId(weekId) {
    var _a2;
    const url = `${BASE_URL$3}payment/get_payments.php?week_id=${weekId}`;
    try {
      const response = await fetch(url);
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message || "Error al obtener los registros");
      }
      return ((_a2 = data.payments) == null ? void 0 : _a2.map(paymentToLocal)) || [];
    } catch (error) {
      console.error(error);
      return [];
    }
  }
  /**
   * Crea un registro de pago
   * @param param0 Objeto con la información del registro a crear
   * @returns Booleano indicando si se creó correctamente
   */
  static async createRegister(payment) {
    const body = paymentToApi(payment);
    try {
      const response = await fetch(`${BASE_URL$3}payment/create_payment.php`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
  /**
   * Actualiza un registro de pago
   * @param register Objeto con la información del registro a actualizar
   * @returns Booleano indicando si se actualizó correctamente
   */
  static async updateRegister(register) {
    const body = paymentToApiFull(register);
    try {
      const response = await fetch(`${BASE_URL$3}payment/update_payment.php`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
  static async deleteRegister(id2) {
    try {
      const response = await fetch(`${BASE_URL$3}payment/delete_payment.php?payment_id=${id2}`, {
        method: "DELETE"
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
  /**
  * Confirmar pago de un día
  * @param confirmation Objeto con los datos de la confirmación
  */
  static async confirmPayment(confirmation) {
    const body = paymentConfirmationToApi(confirmation);
    try {
      const response = await fetch(`${BASE_URL$3}payment/confirm_payment.php`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await response.json();
      if (!data.success) {
        throw new Error(data.message);
      }
      return response.ok;
    } catch (error) {
      console.error(error);
      return false;
    }
  }
}
const mainKey$1 = "payments";
const usePayments = () => {
  const queryClient2 = useQueryClient();
  const { activeWeekId } = useWeekContext();
  const paymentsQuery = useQuery({
    queryKey: [mainKey$1, "weekId", activeWeekId],
    queryFn: () => PaymentServiceApi.getRegisterByWeekId(activeWeekId || 6),
    refetchOnWindowFocus: false,
    staleTime: 1e3 * 60 * 5
  });
  const createPaymentMutation = useMutation({
    mutationFn: PaymentServiceApi.createRegister,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Registro creado correctamente");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al crear el registro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [mainKey$1, "weekId", activeWeekId] });
    }
  });
  const updatePaymentMutation = useMutation({
    mutationFn: PaymentServiceApi.updateRegister,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Registro actualizado correctamente");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al actualizar el registro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [mainKey$1, "weekId", activeWeekId] });
    }
  });
  const deletePaymentMutation = useMutation({
    mutationFn: PaymentServiceApi.deleteRegister,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Registro eliminado correctamente");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al eliminar el registro");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [mainKey$1, "weekId", activeWeekId] });
    }
  });
  const confirmPaymentMutation = useMutation({
    mutationFn: PaymentServiceApi.confirmPayment,
    onSuccess: (response) => {
      console.log(response);
      Jt.success("Pago confirmado");
    },
    onError: (err) => {
      console.error(err);
      Jt.error("Error al confirmar el pago");
    },
    onSettled: () => {
      queryClient2.invalidateQueries({ queryKey: [mainKey$1, "weekId", activeWeekId] });
    }
  });
  return {
    paymentsQuery,
    createPaymentMutation,
    updatePaymentMutation,
    deletePaymentMutation,
    confirmPaymentMutation
  };
};
const style = {
  display: "inline-block",
  padding: "4px 8px",
  borderRadius: "4px",
  color: "#333",
  fontSize: "14px",
  fontWeight: "bold",
  textAlign: "right",
  userSelect: "none",
  cursor: "pointer"
};
const CurrencyCell = (props) => {
  const { value, customColor, type, dayOfWeek, itemId } = props;
  const [open, setOpen] = reactExports.useState(false);
  const {
    confirmCollectMutation: { mutate: confirmCollect }
  } = useCollectRegisters();
  const {
    confirmPaymentMutation: { mutate: confirmPayment }
  } = usePayments();
  const handleDoubleClick = (e3) => {
    e3.stopPropagation();
    if (!props.confirmationRequired) return;
    setOpen(true);
  };
  const onConfirm = () => {
    if (!type) return;
    if (!dayOfWeek || !itemId) return;
    if (type === "collect") {
      confirmCollect({
        itemId: props.itemId,
        dayOfWeek: props.dayOfWeek,
        confirmed: true
      });
    } else {
      confirmPayment({
        itemId: props.itemId,
        dayOfWeek: props.dayOfWeek,
        confirmed: true
      });
    }
    setOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        style: {
          ...style,
          backgroundColor: customColor || "#f0f8ff"
        },
        onDoubleClick: handleDoubleClick,
        children: formatCurrency(value || 0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Modal$1,
      {
        role: "alertdialog",
        open,
        onClose: () => setOpen(false),
        size: "300px",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Modal$1.Body, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  RemindIcon,
                  {
                    style: { color: "#ffb300", fontSize: 24, marginRight: "8px" }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "¿Confirmar Pago?" })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal$1.Footer, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: onConfirm, appearance: "primary", children: "Confirmar" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: () => setOpen(false), appearance: "subtle", children: "Cancelar" })
          ] })
        ]
      }
    )
  ] });
};
const getTotalPerDay = (data, day) => {
  return data.reduce((acc, curr) => {
    const value = curr[day].amount;
    return acc + (isNaN(value) ? 0 : value);
  }, 0) || 0;
};
const getProjection = (data) => {
  return data.monday.amount + data.tuesday.amount + data.wednesday.amount + data.thursday.amount + data.friday.amount + data.saturday.amount;
};
const useCollectTableColumns = (data) => {
  const columns = reactExports.useMemo(() => {
    return [
      {
        header: "Cliente",
        accessorFn: (originalRow) => originalRow.clientName,
        id: "client",
        enableEditing: false
      },
      {
        header: "Proyección",
        filterFn: "between",
        enableEditing: false,
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TotalFooterItem,
          {
            total: data.reduce((acc, curr) => acc + getProjection(curr), 0)
          }
        ),
        Cell: ({ row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CurrencyCell, { value: getProjection(row.original) })
      },
      {
        accessorFn: (originalRow) => originalRow.totalConfirmed,
        id: "totalConfirmed",
        filterFn: "between",
        header: "Total Confirmado",
        enableEditing: false,
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TotalFooterItem,
          {
            total: data.reduce((acc, curr) => acc + curr.totalConfirmed, 0)
          }
        ),
        Cell: ({ cell }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CurrencyCell, { value: cell.getValue() || 0 })
      },
      {
        accessorFn: (originalRow) => originalRow.monday.amount,
        filterFn: "between",
        id: "monday",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el lunes"
        },
        header: "Lunes",
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "monday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.monday.confirmed,
            type: "collect",
            itemId: row.original.id,
            dayOfWeek: "monday",
            customColor: row.original.monday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.tuesday.amount,
        id: "tuesday",
        filterFn: "between",
        header: "Martes",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el martes"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "tuesday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.tuesday.confirmed,
            type: "collect",
            itemId: row.original.id,
            dayOfWeek: "tuesday",
            customColor: row.original.tuesday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.wednesday.amount,
        id: "wednesday",
        filterFn: "between",
        header: "Miercoles",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el miercoles"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "wednesday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.wednesday.confirmed,
            type: "collect",
            itemId: row.original.id,
            dayOfWeek: "wednesday",
            customColor: row.original.wednesday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.thursday.amount,
        id: "thursday",
        filterFn: "between",
        header: "Jueves",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el jueves"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "thursday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.thursday.confirmed,
            type: "collect",
            itemId: row.original.id,
            dayOfWeek: "thursday",
            customColor: row.original.thursday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.friday.amount,
        id: "friday",
        filterFn: "between",
        header: "Viernes",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el viernes"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "friday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.friday.confirmed,
            type: "collect",
            itemId: row.original.id,
            dayOfWeek: "friday",
            customColor: row.original.friday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.saturday.amount,
        id: "saturday",
        filterFn: "between",
        header: "Sabado",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el sabado"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "saturday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.saturday.confirmed,
            type: "collect",
            itemId: row.original.id,
            dayOfWeek: "saturday",
            customColor: row.original.saturday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorKey: "observations",
        header: "Observaciones",
        filterVariant: "text"
      }
    ];
  }, [data]);
  return columns;
};
const CollectionTable = (props) => {
  const { createFn } = props;
  const { weekSelected } = useWeekContext();
  const {
    collectRegisterQuery: { data: registers, refetch },
    updateCollectRegisterMutation: { mutate: updateRegister },
    deleteCollectRegisterMutation: { mutate: deleteRegister }
  } = useCollectRegisters();
  const columns = useCollectTableColumns(registers || []);
  const handleSaveRegisters = async ({ values: values2, table, row }) => {
    updateRegister({ ...values2, id: Number(row.id) });
    table.setEditingRow(null);
  };
  const handleDelete = (id2) => {
    deleteRegister(id2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MaterialTable,
    {
      data: registers || [],
      columns,
      initialState: {
        columnPinning: {
          right: ["mrt-row-actions"]
        },
        density: "compact"
        // isLoading: isFetching,
      },
      enableCellActions: true,
      enableRowActions: true,
      enableClickToCopy: "context-menu",
      editDisplayMode: "row",
      enableEditing: true,
      getRowId: (row) => row.id,
      onEditingRowSave: handleSaveRegisters,
      renderRowActions: ({ row, table }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        gap: "5px",
        alignItems: "center",
        padding: "2px 0px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            circle: true,
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$y, {}),
            appearance: "primary",
            size: "xs",
            style: { padding: "5px" },
            onClick: () => table.setEditingRow(row),
            disabled: !isGOEWeek(weekSelected)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            circle: true,
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$z, {}),
            appearance: "primary",
            size: "xs",
            onClick: () => handleDelete(Number(row.original.id)),
            color: "red",
            stye: { padding: "1px" },
            disabled: !isGOEWeek(weekSelected)
          }
        )
      ] }),
      renderTopToolbarCustomActions: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            gap: "1rem"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton$1,
              {
                appearance: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {}),
                style: { padding: "7px" },
                onClick: () => refetch()
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                appearance: "primary",
                onClick: createFn,
                disabled: !isGOEWeek(weekSelected),
                children: "Crear Nuevo Registro"
              }
            )
          ]
        }
      )
    }
  );
};
const Card = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        backgroundColor: "#1F242A",
        borderRadius: "12px",
        padding: "7px 20px",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)",
        flex: "1",
        maxWidth: "250px",
        transition: "transform 0.2s, box-shadow 0.2s"
      },
      onMouseEnter: (e3) => {
        e3.currentTarget.style.transform = "scale(1.05)";
        e3.currentTarget.style.boxShadow = "0 8px 16px rgba(0, 0, 0, 0.3)";
      },
      onMouseLeave: (e3) => {
        e3.currentTarget.style.transform = "scale(1)";
        e3.currentTarget.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.1)";
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            style: {
              margin: "0",
              color: "#CFD8DC",
              fontSize: "1em",
              fontWeight: "bold",
              padding: "0"
            },
            children: props.title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "hr",
          {
            style: {
              border: "none",
              borderTop: "1px solid #37474F",
              margin: "10px 0"
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            style: {
              margin: "10px 0 0 0",
              fontSize: "24px",
              fontWeight: "bold",
              color: "#4CAF50",
              transition: "color 0.3s"
            },
            children: props.content
          }
        )
      ]
    }
  );
};
const weekToApi = (startDate, endDate) => {
  const setToMidnight2 = (date) => {
    const adjustedDate = new Date(date);
    adjustedDate.setHours(0, 0, 0, 0);
    return adjustedDate;
  };
  const start2 = setToMidnight2(startDate);
  const end2 = setToMidnight2(endDate);
  return {
    start_date: start2.toISOString().split("T")[0],
    end_date: end2.toISOString().split("T")[0]
  };
};
const weekToLocal = (week) => ({
  success: week.success,
  message: week.message,
  weekId: week.week_id
});
const BASE_URL$2 = "./services/";
class WeekServiceApi {
  /**
   * Cambiar de semana
   * @param param0 Objeto con el rango de fechas
   * @returns Objeto con el ID de la semana si el cambio es exitoso
   */
  static async changeWeek({
    startDate,
    endDate
  }) {
    const body = weekToApi(startDate, endDate);
    try {
      const response = await fetch(`${BASE_URL$2}week/change_week.php`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      let data;
      try {
        data = await response.json();
      } catch (jsonError) {
        console.error("Error al parsear la respuesta JSON:", jsonError);
        throw new Error("Error al parsear la respuesta JSON");
      }
      if (response.ok) {
        if (data && data.success) {
          if (data.week_id !== void 0) {
            return weekToLocal(data);
          } else {
            throw new Error("Respuesta inesperada: falta el ID de la semana");
          }
        } else {
          throw new Error((data == null ? void 0 : data.message) || "Error desconocido");
        }
      } else {
        throw new Error(
          `Error HTTP ${response.status}: ${response.statusText}`
        );
      }
    } catch (error) {
      console.error("Error al cambiar la semana:", error);
      return void 0;
    }
  }
}
const useWeek = () => {
  const { onChangeWeek } = useWeekContext();
  const changeWeekMutation = useMutation({
    mutationFn: WeekServiceApi.changeWeek,
    onSuccess: (response) => {
      onChangeWeek(response.weekId);
    },
    onError: () => {
      Jt.error("Error al crear la semana");
    }
  });
  return {
    changeWeekMutation
  };
};
const Header = () => {
  const [value, setValue2] = reactExports.useState(null);
  const { onSetWeekSelected } = useWeekContext();
  const {
    collectRegisterQuery: { data: registers, isFetching: loadingCollect }
  } = useCollectRegisters();
  const {
    paymentsQuery: { data: payments, isFetching: loadingPayments }
  } = usePayments();
  const {
    changeWeekMutation: { mutate }
  } = useWeek();
  reactExports.useEffect(() => {
    const [startOfWeek2, endOfWeek2] = getWeekRange();
    setValue2([startOfWeek2, endOfWeek2]);
    onSetWeekSelected([startOfWeek2, endOfWeek2]);
    mutate({
      startDate: startOfWeek2,
      endDate: endOfWeek2
    });
  }, []);
  const onChangeWeek = (week) => {
    if (!week) return;
    setValue2(week);
    onSetWeekSelected(week);
    mutate({
      startDate: week[0],
      endDate: week[1]
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        maxWidth: "100%",
        margin: "0 auto",
        backgroundColor: "#2B303A",
        color: "#fff",
        borderRadius: "10px",
        padding: "10px",
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Card,
          {
            title: "Total Cobrado",
            content: loadingCollect ? "Cargando..." : formatCurrency(
              (registers || []).reduce(
                (acc, curr) => acc + curr.totalConfirmed,
                0
              )
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Card,
          {
            title: "Proyección de Cobro",
            content: loadingCollect ? "Cargando..." : formatCurrency(
              (registers || []).reduce((acc, curr) => acc + getProjection(curr), 0)
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Card,
          {
            title: "Total Pagado",
            content: loadingPayments ? "Cargando..." : formatCurrency(
              (payments || []).reduce(
                (acc, curr) => acc + curr.totalConfirmed,
                0
              )
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Card,
          {
            title: "Proyección de Pago",
            content: loadingCollect ? "Cargando..." : formatCurrency(
              (payments || []).reduce((acc, curr) => acc + getProjection(curr), 0)
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flexShrink: "0", width: "250px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DateRangePicker,
          {
            oneTap: true,
            showOneCalendar: true,
            placeholder: "Selecciona la semana",
            hoverRange: "week",
            showWeekNumbers: true,
            isoWeek: true,
            ranges: [],
            style: {
              width: "100%"
            },
            value,
            onChange: onChangeWeek
          }
        ) })
      ]
    }
  );
};
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
const isObjectType = (value) => typeof value === "object";
var isObject2 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject2(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject2 = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject2(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy2;
  const isArray2 = Array.isArray(data);
  if (data instanceof Date) {
    copy2 = new Date(data);
  } else if (data instanceof Set) {
    copy2 = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray2 || isObject2(data))) {
    copy2 = isArray2 ? [] : {};
    if (!isArray2 && !isPlainObject2(data)) {
      copy2 = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy2[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy2;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (object, path, defaultValue) => {
  if (!path || !isObject2(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set = (object, path, value) => {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length2 = tempPath.length;
  const lastIndex = length2 - 1;
  while (++index < length2) {
    const key = tempPath[index];
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = object[key];
      newValue = isObject2(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    if (key === "__proto__") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const HookFormContext = React.createContext(null);
const useFormContext = () => React.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value) => isObject2(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = React.useRef(props);
  _props.current = props;
  React.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _mounted = React.useRef(true);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: (value) => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value
    }),
    subject: control._subjects.state
  });
  React.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return getProxyFormState(formState, control, _localProxyFormState.current, false);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = React.useState(control._getWatch(name, defaultValue));
  React.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _registerProps = React.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  React.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name2, value2) => {
      const field = get(control._fields, name2);
      if (field && field._f) {
        field._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React.useEffect(() => {
    if (get(control._fields, name)) {
      control._updateDisabledField({
        disabled,
        fields: control._fields,
        name,
        value: get(control._fields, name)._f.value
      });
    }
  }, [disabled, name, control]);
  return {
    field: {
      name,
      value,
      ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
      onChange: React.useCallback((event) => _registerProps.current.onChange({
        target: {
          value: getEventValue(event),
          name
        },
        type: EVENTS.CHANGE
      }), [name]),
      onBlur: React.useCallback(() => _registerProps.current.onBlur({
        target: {
          value: get(control._formValues, name),
          name
        },
        type: EVENTS.BLUR
      }), [name, control]),
      ref: React.useCallback((elm) => {
        const field = get(control._fields, name);
        if (field && elm) {
          field._f.ref = {
            focus: () => elm.focus(),
            select: () => elm.select(),
            setCustomValidity: (message) => elm.setCustomValidity(message),
            reportValidity: () => elm.reportValidity()
          };
        }
      }, [control._fields, name])
    },
    formState,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: true,
        get: () => !!get(formState.errors, name)
      },
      isDirty: {
        enumerable: true,
        get: () => !!get(formState.dirtyFields, name)
      },
      isTouched: {
        enumerable: true,
        get: () => !!get(formState.touchedFields, name)
      },
      isValidating: {
        enumerable: true,
        get: () => !!get(formState.validatingFields, name)
      },
      error: {
        enumerable: true,
        get: () => get(formState.errors, name)
      }
    })
  };
}
const Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message || true
  }
} : {};
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const { _f: _f2, ...currentField } = field;
      if (_f2) {
        if (_f2.refs && _f2.refs[0] && action(_f2.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f2.ref && action(_f2.ref, _f2.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject2(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value) => isString(value);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value) => value instanceof RegExp;
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values2 = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values2, isValid: !!values2.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject2(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabled) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty2 = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty2 || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty2 && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time2) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time2);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty2 && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty2 && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject2(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
function baseGet(object, updatePath) {
  const length2 = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length2) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index = paths.length - 1;
  const key = paths[index];
  if (childObject) {
    delete childObject[key];
  }
  if (index !== 0 && (isObject2(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var createSubject = () => {
  let _observers2 = [];
  const next2 = (value) => {
    for (const observer of _observers2) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers2.push(observer);
    return {
      unsubscribe: () => {
        _observers2 = _observers2.filter((o) => o !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers2 = [];
  };
  return {
    get observers() {
      return _observers2;
    },
    next: next2,
    subscribe,
    unsubscribe
  };
};
var isPrimitive2 = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive2(object1) || isPrimitive2(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject2(val1) && isObject2(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject2(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject2(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject2(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject2(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive2(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
function getFieldValue(_f2) {
  const ref = _f2.ref;
  if (_f2.refs ? _f2.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f2.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f2.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f2.ref.value : ref.value, _f2);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject2(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
const ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => (!fieldReference || !fieldReference.validate) && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject2(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject2(_options.defaultValues) || isObject2(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce2 = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (_proxyFormState.isValid || shouldUpdateValid) {
      const isValid2 = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (_proxyFormState.isValidating || _proxyFormState.validatingFields) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = (name, values2 = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values2),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values2);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    const disabledField = !!(get(_fields, name) && get(_fields, name)._f && get(_fields, name)._f.disabled);
    if (!isBlurEvent || shouldDirty) {
      if (_proxyFormState.isDirty) {
        isPreviousDirty = _formState.isDirty;
        _formState.isDirty = output.isDirty = _getDirty();
        shouldUpdateField = isPreviousDirty !== output.isDirty;
      }
      const isCurrentFieldPristine = disabledField || deepEqual(get(_defaultValues, name), fieldValue);
      isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));
      isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
    }
    if (isBlurEvent) {
      const isPreviousFieldTouched = get(_formState.touchedFields, name);
      if (!isPreviousFieldTouched) {
        set(_formState.touchedFields, name, isBlurEvent);
        output.touchedFields = _formState.touchedFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
      }
    }
    shouldUpdateField && shouldRender && _subjects.state.next(output);
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid2, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid2) && _formState.isValid !== isValid2;
    if (props.delayError && error) {
      delayErrorCallback = debounce2(() => updateErrors(name, error));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f: _f2, ...fieldValue } = field;
        if (_f2) {
          const isFieldArrayRoot = _names.array.has(_f2.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f2.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f2.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f2.name) : set(_formState.errors, _f2.name, fieldError[_f2.name]) : unset(_formState.errors, _f2.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger2(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || !isPrimitive2(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue2 = (name, value, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name : void 0,
      values: { ..._formValues }
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid2;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (props.mode === "onBlur") {
            if (isBlurEvent) {
              _updateValid();
            }
          } else {
            _updateValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid2 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid2 = false;
          } else if (_proxyFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger2(field._f.deps);
        shouldRenderByError(name, isValid2, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger2 = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || _proxyFormState.isValid && isValid2 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid2 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values2 = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values2 : isString(fieldNames) ? get(values2, fieldNames) : fieldNames.map((name) => get(values2, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = ({ disabled, name, field, fields, value }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled) {
      const inputValue = disabled ? void 0 : isUndefined(value) ? getFieldValue(field ? field._f : get(fields, name)._f) : value;
      set(_formValues, name, inputValue);
      updateTouchAndDirty(name, inputValue, false, false, true);
    }
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(props.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
        name,
        value: options.value
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || props.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e3) => {
    let onValidError = void 0;
    if (e3) {
      e3.preventDefault && e3.preventDefault();
      e3.persist && e3.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values: values2 } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values2;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e3);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e3);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue2(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue2(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values2 = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        for (const fieldName of _names.mount) {
          get(_formState.dirtyFields, fieldName) ? set(values2, fieldName, get(_formValues, fieldName)) : setValue2(fieldName, get(values2, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values2);
      _subjects.array.next({
        values: { ...values2 }
      });
      _subjects.values.next({
        values: { ...values2 }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values2) => {
    reset(values2, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger: trigger2,
    register,
    handleSubmit,
    watch,
    setValue: setValue2,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef();
  const _values = React.useRef();
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  React.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  React.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  React.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  React.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
const NumberInput = (props) => {
  const { control, name, label, rules, style: style2 } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Controller,
    {
      control,
      name,
      rules,
      render: ({ field: { name: name2, value, onChange }, fieldState }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form.Group, { controlId: "numberIntput", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Form.ControlLabel, { children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form.Control,
          {
            name: name2,
            accepter: InputNumber,
            style: style2,
            value,
            onChange,
            prefix: "$"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form.ErrorMessage,
          {
            show: fieldState.invalid,
            placement: "bottomStart",
            children: fieldState.error ? fieldState.error.message : null
          }
        )
      ] })
    }
  );
};
const SelectInput = (props) => {
  const { control, name, label, rules, items, style: style2 } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Controller,
    {
      control,
      name,
      rules,
      render: ({ field: { name: name2, value, onChange }, fieldState }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form.Group, { controlId: "selectPicker", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Form.ControlLabel, { children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form.Control,
          {
            name: name2,
            accepter: SelectPicker,
            placeholder: props.placeholder || "Selecciona una opción",
            virtualized: props.virtualized,
            data: items || [],
            style: style2,
            value,
            onChange,
            loading: props.isLoading
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form.ErrorMessage,
          {
            show: fieldState.invalid,
            placement: "bottomStart",
            children: fieldState.error ? fieldState.error.message : null
          }
        )
      ] })
    }
  );
};
const BASE_URL$1 = "./services/";
class ClientsServiceApi {
  /**
   * Obtener todos los clientes
   * @returns Lista de clientes
   */
  static async getAllClients() {
    try {
      const response = await fetch(`${BASE_URL$1}/collect/get_clients.php`);
      if (!response.ok) {
        throw new Error(`Error al obtener clientes: ${response.status}`);
      }
      const data = await response.json();
      return data || [];
    } catch (error) {
      console.error("Error fetching clients:", error);
      throw error;
    }
  }
}
const clientsKey = "clients";
const useClients = () => {
  const clientsQuery = useQuery({
    queryKey: [clientsKey],
    queryFn: ClientsServiceApi.getAllClients,
    refetchOnWindowFocus: false,
    staleTime: 1e3 * 60 * 5
  });
  return {
    clientsQuery
  };
};
const daysSelection$1 = [
  { label: "Lunes", value: "monday" },
  { label: "Martes", value: "tuesday" },
  { label: "Miercoles", value: "wednesday" },
  { label: "Jueves", value: "thursday" },
  { label: "Viernes", value: "friday" },
  { label: "Sabado", value: "saturday" }
];
const initialFormState$1 = {
  clientId: "",
  mount: 0,
  day: ""
};
const NewCollectForm = (props) => {
  const { handleClose } = props;
  const { activeWeekId } = useWeekContext();
  const { control, handleSubmit } = useForm({
    defaultValues: initialFormState$1
  });
  const {
    clientsQuery: { data: clients, isFetching, isError }
  } = useClients();
  const {
    createCollectRegisterMutation: { mutate: createRegister }
  } = useCollectRegisters();
  const onSubmit = (data2) => {
    console.log(data2);
    if (!activeWeekId) {
      Jt.error("No hay una semana activa");
    }
    createRegister({
      weekId: Number(activeWeekId),
      clientId: Number(data2.clientId),
      mount: Number(data2.mount),
      day: data2.day
    });
  };
  const data = reactExports.useMemo(() => {
    if (isFetching || isError) return [];
    return clients == null ? void 0 : clients.map((item) => ({ label: item.nombre, value: item.id }));
  }, [clients, isError, isFetching]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Modal$1,
    {
      open: true,
      onClose: handleClose,
      size: "xs",
      style: {
        padding: "2px",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal$1.Body,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              padding: "0",
              margin: "0"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Nuevo Registro" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Form,
                {
                  style: {
                    margin: "1rem"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SelectInput,
                      {
                        control,
                        controlId: "clientId",
                        name: "clientId",
                        label: "Cliente",
                        items: data || [],
                        style: { width: 300 },
                        rules: { required: "Selecciona un cliente por favor" },
                        isLoading: isFetching,
                        virtualized: true
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SelectInput,
                      {
                        control,
                        controlId: "dayId",
                        name: "day",
                        label: "Día",
                        items: daysSelection$1,
                        style: { width: 300 },
                        rules: { required: "Selecciona un día por favor" }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      NumberInput,
                      {
                        control,
                        name: "mount",
                        label: "Monto",
                        rules: { required: "Ingresa un monto" }
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal$1.Footer, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: handleClose, appearance: "ghost", color: "red", children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              onClick: handleSubmit(onSubmit),
              appearance: "primary",
              children: "Insertar"
            }
          )
        ] })
      ]
    }
  );
};
const CollectReportView = () => {
  const [newRegister, setNewRegister] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          paddingTop: "10px"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionTable, { createFn: () => setNewRegister(true) })
      }
    ),
    newRegister && /* @__PURE__ */ jsxRuntimeExports.jsx(NewCollectForm, { handleClose: () => setNewRegister(false) })
  ] });
};
const TextInput = (props) => {
  const { control, name, label, rules, style: style2 } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Controller,
    {
      control,
      name,
      rules,
      render: ({ field: { name: name2, value, onChange }, fieldState }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Form.Group, { controlId: "numberIntput", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Form.ControlLabel, { children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form.Control,
          {
            name: name2,
            accepter: Input$1,
            style: style2,
            value,
            onChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form.ErrorMessage,
          {
            show: fieldState.invalid,
            placement: "bottomStart",
            children: fieldState.error ? fieldState.error.message : null
          }
        )
      ] })
    }
  );
};
const BASE_URL = "./services/";
class ProviderServiceApi {
  static async getAllProviders() {
    try {
      const response = await fetch(`${BASE_URL}/payment/get_providers.php`);
      if (!response.ok) {
        throw new Error(`Error al obtener clientes: ${response.status}`);
      }
      const data = await response.json();
      return data || [];
    } catch (error) {
      console.error("Error fetching clients:", error);
      throw error;
    }
  }
}
const mainKey = "providers";
const useProviders = () => {
  const providersQuery = useQuery({
    queryKey: [mainKey],
    queryFn: ProviderServiceApi.getAllProviders,
    refetchOnWindowFocus: false,
    staleTime: 1e3 * 60 * 5
  });
  return {
    providersQuery
  };
};
const daysSelection = [
  { label: "Lunes", value: "monday" },
  { label: "Martes", value: "tuesday" },
  { label: "Miercoles", value: "wednesday" },
  { label: "Jueves", value: "thursday" },
  { label: "Viernes", value: "friday" },
  { label: "Sabado", value: "saturday" }
];
const initialFormState = {
  providerId: "",
  concept: "",
  amount: null,
  day: ""
};
const NewPaymentForm = (props) => {
  const { handleClose } = props;
  const { activeWeekId } = useWeekContext();
  const { control, handleSubmit } = useForm({
    defaultValues: initialFormState
  });
  const {
    providersQuery: { data: providers, isFetching, isError }
  } = useProviders();
  const {
    createPaymentMutation: { mutate: createRegister }
  } = usePayments();
  const onSubmit = (data2) => {
    var _a2;
    if (!activeWeekId) {
      Jt.error("No hay una semana activa");
    }
    const newPayment = {
      weekId: Number(activeWeekId),
      providerId: Number(data2.providerId),
      providerName: ((_a2 = providers == null ? void 0 : providers.find((item) => item.id === data2.providerId)) == null ? void 0 : _a2.name) || "",
      concept: data2.concept,
      day: data2.day,
      amount: Number(data2.amount)
    };
    createRegister(newPayment);
  };
  const data = reactExports.useMemo(() => {
    if (isFetching || isError) return [];
    return providers == null ? void 0 : providers.map((item) => ({ label: item.name, value: item.id }));
  }, [providers, isError, isFetching]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Modal$1,
    {
      open: true,
      onClose: handleClose,
      size: "xs",
      style: {
        padding: "2px",
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal$1.Body,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              padding: "0",
              margin: "0"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Nuevo Registro" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Form,
                {
                  style: {
                    margin: "1rem"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SelectInput,
                      {
                        control,
                        controlId: "providerId",
                        name: "providerId",
                        label: "Proveedor",
                        items: data || [],
                        style: { width: 300 },
                        rules: { required: "Selecciona un provedor por favor" },
                        isLoading: isFetching,
                        virtualized: true
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SelectInput,
                      {
                        control,
                        controlId: "day",
                        name: "day",
                        label: "Día",
                        items: daysSelection,
                        style: { width: 300 },
                        rules: { required: "Selecciona un día por favor" }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      NumberInput,
                      {
                        control,
                        label: "Monto",
                        name: "amount",
                        rules: { required: "Ingresa un monto por favor" }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextInput,
                      {
                        control,
                        label: "Concepto",
                        name: "concept",
                        rules: { required: "Ingresa un concepto por favor" }
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Modal$1.Footer, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { onClick: handleClose, appearance: "ghost", color: "red", children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              onClick: handleSubmit(onSubmit),
              appearance: "primary",
              children: "Insertar"
            }
          )
        ] })
      ]
    }
  );
};
const usePaymentTableColumns = (data) => {
  const columns = reactExports.useMemo(() => {
    return [
      {
        header: "Proveedor",
        accessorFn: (originalRow) => originalRow.providerName,
        id: "providerId",
        enableEditing: false
      },
      {
        header: "Concepto",
        accessorFn: (originalRow) => originalRow.concept,
        id: "concept",
        enableEditing: false
      },
      {
        accessorKey: "projection",
        filterFn: "between",
        header: "Proyección",
        enableEditing: false,
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TotalFooterItem,
          {
            total: data.reduce((acc, curr) => acc + getProjection(curr), 0)
          }
        ),
        Cell: ({ row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CurrencyCell, { value: getProjection(row.original) })
      },
      {
        accessorKey: "totalConfirmed",
        filterFn: "between",
        header: "Total Confirmado",
        enableEditing: false,
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TotalFooterItem,
          {
            total: data.reduce((acc, curr) => acc + curr.totalConfirmed, 0)
          }
        ),
        Cell: ({ cell }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CurrencyCell, { value: cell.getValue() || 0 })
      },
      {
        accessorFn: (originalRow) => originalRow.monday.amount,
        id: "monday",
        filterFn: "between",
        header: "Lunes",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el lunes"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "monday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.monday.confirmed,
            type: "payment",
            itemId: row.original.id,
            dayOfWeek: "monday",
            customColor: row.original.monday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.tuesday.amount,
        id: "tuesday",
        filterFn: "between",
        header: "Martes",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el martes"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "tuesday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.tuesday.confirmed,
            type: "payment",
            itemId: row.original.id,
            dayOfWeek: "tuesday",
            customColor: row.original.tuesday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.wednesday.amount,
        id: "wednesday",
        filterFn: "between",
        header: "Miercoles",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el miercoles"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "wednesday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.wednesday.confirmed,
            type: "payment",
            itemId: row.original.id,
            dayOfWeek: "wednesday",
            customColor: row.original.wednesday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.thursday.amount,
        id: "thursday",
        filterFn: "between",
        header: "Jueves",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el jueves"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "thursday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.thursday.confirmed,
            type: "payment",
            itemId: row.original.id,
            dayOfWeek: "thursday",
            customColor: row.original.thursday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.friday.amount,
        id: "friday",
        filterFn: "between",
        header: "Viernes",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el viernes"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "friday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue().amount > 0 && !row.original.friday.confirmed,
            type: "payment",
            itemId: row.original.id,
            dayOfWeek: "friday",
            customColor: row.original.friday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorFn: (originalRow) => originalRow.saturday.amount,
        id: "saturday",
        filterFn: "between",
        header: "Sabado",
        muiEditTextFieldProps: {
          type: "number",
          helperText: "Cobrado el sabado"
        },
        Footer: () => /* @__PURE__ */ jsxRuntimeExports.jsx(TotalFooterItem, { total: getTotalPerDay(data, "saturday") }),
        Cell: ({ cell, row }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CurrencyCell,
          {
            value: cell.getValue() || 0,
            confirmationRequired: cell.getValue() > 0 && !row.original.saturday.confirmed,
            type: "payment",
            itemId: row.original.id,
            dayOfWeek: "saturday",
            customColor: row.original.saturday.confirmed ? "#d4edda" : "#ffcccb"
          }
        )
      },
      {
        accessorKey: "observations",
        header: "Observaciones",
        filterVariant: "text"
      }
    ];
  }, [data]);
  return columns;
};
const PaymentTable = (props) => {
  const { createFn } = props;
  const { weekSelected } = useWeekContext();
  const {
    updatePaymentMutation: { mutate: updateRegister },
    deletePaymentMutation: { mutate: deleteRegister }
  } = usePayments();
  const {
    paymentsQuery: { data: payments, refetch }
  } = usePayments();
  const columns = usePaymentTableColumns(payments || []);
  const handleSaveRegisters = async ({ values: values2, table, row }) => {
    updateRegister({ ...values2, id: Number(row.id) });
    table.setEditingRow(null);
  };
  const handleDelete = (id2) => {
    deleteRegister(id2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MaterialTable,
    {
      data: payments || [],
      columns,
      initialState: {
        columnPinning: {
          right: ["mrt-row-actions"]
        },
        density: "compact"
        // isLoading: isFetching,
      },
      enableCellActions: true,
      enableRowActions: true,
      enableClickToCopy: "context-menu",
      editDisplayMode: "row",
      enableEditing: true,
      getRowId: (row) => row.id,
      onEditingRowSave: handleSaveRegisters,
      renderRowActions: ({ row, table }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        gap: "5px",
        alignItems: "center",
        padding: "2px 0px"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            circle: true,
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$y, {}),
            appearance: "primary",
            size: "xs",
            style: { padding: "5px" },
            onClick: () => table.setEditingRow(row),
            disabled: !isSameWeek(weekSelected)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton$1,
          {
            circle: true,
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$z, {}),
            appearance: "primary",
            size: "xs",
            onClick: () => handleDelete(Number(row.original.id)),
            color: "red",
            stye: { padding: "1px" },
            disabled: !isSameWeek(weekSelected)
          }
        )
      ] }),
      renderTopToolbarCustomActions: () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            gap: "1rem"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton$1,
              {
                appearance: "primary",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, {}),
                style: { padding: "7px" },
                onClick: () => refetch()
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                appearance: "primary",
                onClick: createFn,
                disabled: !isSameWeek(weekSelected),
                children: "Crear Nuevo Registro"
              }
            )
          ]
        }
      )
    }
  );
};
const PaymentReportView = () => {
  const [newRegister, setNewRegister] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          paddingTop: "10px"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentTable, { createFn: () => setNewRegister(true) })
      }
    ),
    newRegister && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NewPaymentForm,
      {
        handleClose: () => setNewRegister(false)
      }
    )
  ] });
};
const BalanceReportPage = () => {
  const [activeKey, setActiveKey] = reactExports.useState("collect");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BaseLayout, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Tabs$1,
    {
      activeKey,
      onSelect: (tab) => setActiveKey(tab),
      style: {
        fontSize: "1.2em",
        fontWeight: "bold"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tabs$1.Tab,
          {
            eventKey: "collect",
            title: "Reporte de Cobro",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollectReportView, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Tabs$1.Tab,
          {
            eventKey: "pay",
            title: "Reporte de cuentas por pagar",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentReportView, {})
          }
        )
      ]
    }
  ) });
};
var ReactQueryDevtools2 = function() {
  return null;
};
const WeekProvider = ({ children }) => {
  const [activeWeekId, setActiveWeekId] = reactExports.useState(null);
  const [weekSelected, setWeekSelected] = reactExports.useState(null);
  const onChangeWeek = (weekId) => {
    setActiveWeekId(weekId);
  };
  const onSetWeekSelected = (week) => {
    setWeekSelected(week);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WeekContext.Provider,
    {
      value: {
        activeWeekId,
        onChangeWeek,
        weekSelected,
        onSetWeekSelected
      },
      children
    }
  );
};
var createRoot;
var m3 = reactDomExports;
{
  createRoot = m3.createRoot;
  m3.hydrateRoot;
}
const queryClient = new QueryClient();
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(QueryClientProvider, { client: queryClient, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CustomProvider, { theme: "light", children: /* @__PURE__ */ jsxRuntimeExports.jsx(WeekProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BalanceReportPage, {}) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ReactQueryDevtools2, { initialIsOpen: false })
  ] }) })
);
